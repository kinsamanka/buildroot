From 5e445654c72c84a95ce9dc129dddf5d6b1d1f547 Mon Sep 17 00:00:00 2001
From: GP Orcullo <kinsamanka@gmail.com>
Date: Mon, 6 Nov 2023 09:34:04 +0000
Subject: [PATCH 3/8] sophgo: add mmc driver

---
 drivers/mmc/host/Kconfig        |  12 +
 drivers/mmc/host/Makefile       |   1 +
 drivers/mmc/host/sdhci-cv180x.c | 637 ++++++++++++++++++++++++++++++++
 drivers/mmc/host/sdhci-cv180x.h |  62 ++++
 4 files changed, 712 insertions(+)
 create mode 100644 drivers/mmc/host/sdhci-cv180x.c
 create mode 100644 drivers/mmc/host/sdhci-cv180x.h

diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 58bd5fe4cd25..206308107667 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -357,6 +357,18 @@ config MMC_SDHCI_PXAV2
 
 	  If unsure, say N.
 
+config MMC_SDHCI_SOPHGO
+	tristate "SOPHGO SDHCI Controller Support"
+	depends on MMC_SDHCI_PLTFM
+	help
+	  This selects the Secure Digital Host Controller Interface (SDHCI)
+	  support present in SOPHGO SOCs. The controller supports
+	  SD/MMC/SDIO devices.
+
+	  If you have a controller with this interface, say Y or M here.
+
+	  If unsure, say N.
+
 config MMC_SDHCI_SPEAR
 	tristate "SDHCI support on ST SPEAr platform"
 	depends on MMC_SDHCI
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index d0be4465f3ec..be362f6bf7e2 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -20,6 +20,7 @@ obj-$(CONFIG_MMC_SDHCI_PXAV2)	+= sdhci-pxav2.o
 obj-$(CONFIG_MMC_SDHCI_S3C)	+= sdhci-s3c.o
 obj-$(CONFIG_MMC_SDHCI_F_SDH30)	+= sdhci_f_sdh30.o
 obj-$(CONFIG_MMC_SDHCI_MILBEAUT)	+= sdhci-milbeaut.o
+obj-$(CONFIG_MMC_SDHCI_SOPHGO)	+= sdhci-cv180x.o
 obj-$(CONFIG_MMC_SDHCI_SPEAR)	+= sdhci-spear.o
 obj-$(CONFIG_MMC_SDHCI_AM654)	+= sdhci_am654.o
 obj-$(CONFIG_MMC_WBSD)		+= wbsd.o
diff --git a/drivers/mmc/host/sdhci-cv180x.c b/drivers/mmc/host/sdhci-cv180x.c
new file mode 100644
index 000000000000..0b9a70fbe035
--- /dev/null
+++ b/drivers/mmc/host/sdhci-cv180x.c
@@ -0,0 +1,637 @@
+/*
+ * drivers/mmc/host/sdhci-cv.c - CVITEK SDHCI Platform driver
+ *
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/reset.h>
+
+#include "sdhci-pltfm.h"
+#include "sdhci-cv180x.h"
+
+#define DRIVER_NAME "cvi"
+#define SDHCI_DUMP(f, x...) \
+	pr_err("%s: " DRIVER_NAME ": " f, mmc_hostname(host->mmc), ## x)
+
+static void sdhci_cv180x_sd_setup_pad(struct sdhci_host *host, bool bunplug)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	/* Name              Offset unplug plug
+	 * PAD_SDIO0_CD      0x18   SDIO0  SDIO0
+	 * PAD_SDIO0_PWR_EN  0x1C   SDIO0  SDIO0
+	 * PAD_SDIO0_CLK     0x00   XGPIO  SDIO0
+	 * PAD_SDIO0_CMD     0x04   XGPIO  SDIO0
+	 * PAD_SDIO0_D0      0x08   XGPIO  SDIO0
+	 * PAD_SDIO0_D1      0x0C   XGPIO  SDIO0
+	 * PAD_SDIO0_D2      0x10   XGPIO  SDIO0
+	 * PAD_SDIO0_D3      0x14   XGPIO  SDIO0
+	 * 0x0: SDIO0 function
+	 * 0x3: XGPIO function
+	 */
+
+	u8 val = (bunplug) ? 0x3 : 0x0;
+
+	writeb(0x3, cvi_host->pinmuxbase + 0x18);
+	writeb(0x0, cvi_host->pinmuxbase + 0x1C);
+	writeb(val, cvi_host->pinmuxbase + 0x00);
+	writeb(val, cvi_host->pinmuxbase + 0x04);
+	writeb(val, cvi_host->pinmuxbase + 0x08);
+	writeb(val, cvi_host->pinmuxbase + 0x0C);
+	writeb(val, cvi_host->pinmuxbase + 0x10);
+	writeb(val, cvi_host->pinmuxbase + 0x14);
+}
+
+static void sdhci_cv180x_sd_setup_io(struct sdhci_host *host, bool reset)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	/*
+	 * Name              Offset reset sd0
+	 * REG_SDIO0_CD      0x900  PU    PU
+	 * REG_SDIO0_PWR_EN  0x904  PD    PD
+	 * REG_SDIO0_CLK     0xA00  PD    PD
+	 * REG_SDIO0_CMD     0xA04  PD    PU
+	 * REG_SDIO0_D0      0xA08  PD    PU
+	 * REG_SDIO0_D1      0xA0C  PD    PU
+	 * REG_SDIO0_D2      0xA10  PD    PU
+	 * REG_SDIO0_D3      0xA14  PD    PU
+	 * BIT(2) : PU   enable(1)/disable(0)
+	 * BIT(3) : PD   enable(1)/disable(0)
+	 */
+
+	u8 raise_bit = (reset) ?  BIT(3) : BIT(2);
+	u8 down_bit  = (reset) ?  BIT(2) : BIT(3);
+
+	writeb(((readb(cvi_host->pinmuxbase + 0x900) | BIT(2)) & ~(BIT(3))),
+		cvi_host->pinmuxbase + 0x900);
+	writeb(((readb(cvi_host->pinmuxbase + 0x904) | BIT(3)) & ~(BIT(2))),
+		cvi_host->pinmuxbase + 0x904);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA00) | BIT(3)) & ~(BIT(2))),
+		cvi_host->pinmuxbase + 0xA00);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA04) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA04);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA08) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA08);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA0C) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA0C);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA10) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA10);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA14) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA14);
+}
+
+static void sdhci_cvi_reset_helper(struct sdhci_host *host, u8 mask)
+{
+	// disable Intr before reset
+	sdhci_writel(host, 0, SDHCI_INT_ENABLE);
+	sdhci_writel(host, 0, SDHCI_SIGNAL_ENABLE);
+
+	sdhci_reset(host, mask);
+
+	sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
+	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
+}
+
+static void reset_after_tuning_pass(struct sdhci_host *host)
+{
+	pr_debug("tuning pass\n");
+
+	/* Clear BUF_RD_READY intr */
+	sdhci_writew(host, sdhci_readw(host, SDHCI_INT_STATUS) & (~(0x1 << 5)),
+		     SDHCI_INT_STATUS);
+
+	/* Set SDHCI_SOFTWARE_RESET.SW_RST_DAT = 1 to clear buffered tuning block */
+	sdhci_writeb(host, sdhci_readb(host, SDHCI_SOFTWARE_RESET) | (0x1 << 2), SDHCI_SOFTWARE_RESET);
+
+	/* Set SDHCI_SOFTWARE_RESET.SW_RST_CMD = 1	*/
+	sdhci_writeb(host, sdhci_readb(host, SDHCI_SOFTWARE_RESET) | (0x1 << 1), SDHCI_SOFTWARE_RESET);
+
+	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & 0x3)
+		;
+}
+
+static inline uint32_t CHECK_MASK_BIT(void *_mask, uint32_t bit)
+{
+	uint32_t w = bit / 8;
+	uint32_t off = bit % 8;
+
+	return ((uint8_t *)_mask)[w] & (1 << off);
+}
+
+static inline void SET_MASK_BIT(void *_mask, uint32_t bit)
+{
+	uint32_t byte = bit / 8;
+	uint32_t offset = bit % 8;
+	((uint8_t *)_mask)[byte] |= (1 << offset);
+}
+
+static void sdhci_cvi_general_set_uhs_signaling(struct sdhci_host *host, unsigned int uhs)
+{
+	struct mmc_host *mmc = host->mmc;
+	u16 ctrl_2;
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	/* Select Bus Speed Mode for host */
+	ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
+	switch (uhs) {
+	case MMC_TIMING_UHS_SDR12:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR12;
+		break;
+	case MMC_TIMING_UHS_SDR25:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR25;
+		break;
+	case MMC_TIMING_UHS_SDR50:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR50;
+		break;
+	case MMC_TIMING_MMC_HS200:
+	case MMC_TIMING_UHS_SDR104:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR104;
+		break;
+	case MMC_TIMING_UHS_DDR50:
+	case MMC_TIMING_MMC_DDR52:
+		ctrl_2 |= SDHCI_CTRL_UHS_DDR50;
+		break;
+	}
+
+	/*
+	 * When clock frequency is less than 100MHz, the feedback clock must be
+	 * provided and DLL must not be used so that tuning can be skipped. To
+	 * provide feedback clock, the mode selection can be any value less
+	 * than 3'b011 in bits [2:0] of HOST CONTROL2 register.
+	 */
+	if (host->clock <= 100000000 &&
+	    (uhs == MMC_TIMING_MMC_HS400 ||
+	     uhs == MMC_TIMING_MMC_HS200 ||
+	     uhs == MMC_TIMING_UHS_SDR104))
+		ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
+
+	dev_dbg(mmc_dev(mmc), "%s: clock=%u uhs=%u ctrl_2=0x%x\n",
+		mmc_hostname(host->mmc), host->clock, uhs, ctrl_2);
+	sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
+}
+
+static unsigned int sdhci_cvi_general_get_max_clock(struct sdhci_host *host)
+{
+	return 375000000;
+}
+
+static void sdhci_cvi_cv180x_set_tap(struct sdhci_host *host, unsigned int tap)
+{
+	pr_debug("%s %d\n", __func__, tap);
+	// Set sd_clk_en(0x2c[2]) to 0
+	sdhci_writew(host, sdhci_readw(host, SDHCI_CLOCK_CONTROL) & (~(0x1 << 2)), SDHCI_CLOCK_CONTROL);
+	sdhci_writel(host,
+		sdhci_readl(host, CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R) & (~(BIT(1))),
+		CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R);
+	sdhci_writel(host, BIT(8) | tap << 16,
+		     CVI_CV180X_SDHCI_PHY_TX_RX_DLY);
+	sdhci_writel(host, 0, CVI_CV180X_SDHCI_PHY_CONFIG);
+	// Set sd_clk_en(0x2c[2]) to 1
+	sdhci_writew(host, sdhci_readw(host, SDHCI_CLOCK_CONTROL) | (0x1 << 2), SDHCI_CLOCK_CONTROL);
+	mdelay(1);
+}
+
+static int sdhci_cv180x_general_execute_tuning(struct sdhci_host *host, u32 opcode)
+{
+	u16 min = 0;
+	u32 k = 0;
+	s32 ret;
+	u32 retry_cnt = 0;
+
+	u32 tuning_result[4] = {0, 0, 0, 0};
+	u32 rx_lead_lag_result[4] = {0, 0, 0, 0};
+	char tuning_graph[TUNE_MAX_PHCODE+1];
+	char rx_lead_lag_graph[TUNE_MAX_PHCODE+1];
+
+	u32 reg = 0;
+	u32 reg_rx_lead_lag = 0;
+	s32 max_lead_lag_idx = -1;
+	s32 max_window_idx = -1;
+	s32 cur_window_idx = -1;
+	u16 max_lead_lag_size = 0;
+	u16 max_window_size = 0;
+	u16 cur_window_size = 0;
+	s32 rx_lead_lag_phase = -1;
+	s32 final_tap = -1;
+	u32 rate = 0;
+
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	reg = sdhci_readw(host, SDHCI_ERR_INT_STATUS);
+	pr_debug("%s : SDHCI_ERR_INT_STATUS 0x%x\n", mmc_hostname(host->mmc),
+		 reg);
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("%s : host ctrl2 0x%x\n", mmc_hostname(host->mmc), reg);
+	/* Set Host_CTRL2_R.SAMPLE_CLK_SEL=0 */
+	sdhci_writew(host,
+			 sdhci_readw(host, SDHCI_HOST_CONTROL2) & (~(0x1 << 7)),
+			 SDHCI_HOST_CONTROL2);
+	sdhci_writew(host,
+			 sdhci_readw(host, SDHCI_HOST_CONTROL2) & (~(0x3 << 4)),
+			 SDHCI_HOST_CONTROL2);
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("%s : host ctrl2 0x%x\n", mmc_hostname(host->mmc), reg);
+
+	while (min < TUNE_MAX_PHCODE) {
+		retry_cnt = 0;
+		sdhci_cvi_cv180x_set_tap(host, min);
+		reg_rx_lead_lag = sdhci_readw(host, CVI_CV180X_SDHCI_PHY_DLY_STS) & BIT(1);
+
+retry_tuning:
+		ret = mmc_send_tuning(host->mmc, opcode, NULL);
+
+		if (!ret && retry_cnt < MAX_TUNING_CMD_RETRY_COUNT) {
+			retry_cnt++;
+			goto retry_tuning;
+		}
+
+		if (ret) {
+			SET_MASK_BIT(tuning_result, min);
+		}
+
+		if (reg_rx_lead_lag) {
+			SET_MASK_BIT(rx_lead_lag_result, min);
+		}
+
+		min++;
+	}
+
+	reset_after_tuning_pass(host);
+
+	pr_debug("tuning result:      0x%08x 0x%08x 0x%08x 0x%08x\n",
+		tuning_result[0], tuning_result[1], tuning_result[2], tuning_result[3]);
+	pr_debug("rx_lead_lag result: 0x%08x 0x%08x 0x%08x 0x%08x\n",
+		rx_lead_lag_result[0], rx_lead_lag_result[1], rx_lead_lag_result[2], rx_lead_lag_result[3]);
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(tuning_result, k) == 0)
+			tuning_graph[k] = '-';
+		else
+			tuning_graph[k] = 'x';
+		if (CHECK_MASK_BIT(rx_lead_lag_result, k) == 0)
+			rx_lead_lag_graph[k] = '0';
+		else
+			rx_lead_lag_graph[k] = '1';
+	}
+	tuning_graph[TUNE_MAX_PHCODE] = '\0';
+	rx_lead_lag_graph[TUNE_MAX_PHCODE] = '\0';
+
+	pr_debug("tuning graph:      %s\n", tuning_graph);
+	pr_debug("rx_lead_lag graph: %s\n", rx_lead_lag_graph);
+
+	// Find a final tap as median of maximum window
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(tuning_result, k) == 0) {
+			if (-1 == cur_window_idx) {
+				cur_window_idx = k;
+			}
+			cur_window_size++;
+
+			if (cur_window_size > max_window_size) {
+				max_window_size = cur_window_size;
+				max_window_idx = cur_window_idx;
+				if (max_window_size >= TAP_WINDOW_THLD)
+					final_tap = cur_window_idx + (max_window_size/2);
+			}
+		} else {
+			cur_window_idx = -1;
+			cur_window_size = 0;
+		}
+	}
+
+	cur_window_idx = -1;
+	cur_window_size = 0;
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(rx_lead_lag_result, k) == 0) {
+			//from 1 to 0 and window_size already computed.
+			if ((rx_lead_lag_phase == 1) && (cur_window_size > 0)) {
+				max_lead_lag_idx = cur_window_idx;
+				max_lead_lag_size = cur_window_size;
+				break;
+			}
+			if (cur_window_idx == -1) {
+				cur_window_idx = k;
+			}
+			cur_window_size++;
+			rx_lead_lag_phase = 0;
+		} else {
+			rx_lead_lag_phase = 1;
+			if ((cur_window_idx != -1) && (cur_window_size > 0)) {
+				cur_window_size++;
+				max_lead_lag_idx = cur_window_idx;
+				max_lead_lag_size = cur_window_size;
+			} else {
+				cur_window_size = 0;
+			}
+		}
+	}
+	rate = max_window_size * 100 / max_lead_lag_size;
+	pr_debug("MaxWindow[Idx, Width]:[%d,%u] Tuning Tap: %d\n", max_window_idx, max_window_size, final_tap);
+	pr_debug("RX_LeadLag[Idx, Width]:[%d,%u] rate = %d\n", max_lead_lag_idx, max_lead_lag_size, rate);
+
+	sdhci_cvi_cv180x_set_tap(host, final_tap);
+	cvi_host->final_tap = final_tap;
+	pr_debug("%s finished tuning, code:%d\n", __func__, final_tap);
+
+	return mmc_send_tuning(host->mmc, opcode, NULL);
+}
+
+static void sdhci_cv180x_sd_reset(struct sdhci_host *host, u8 mask)
+{
+	u16 ctrl_2;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s mask = 0x%x\n", __func__, mask);
+	sdhci_cvi_reset_helper(host, mask);
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctrl_2 &= SDHCI_CTRL_UHS_MASK;
+	if (ctrl_2 == SDHCI_CTRL_UHS_SDR104) {
+		//reg_0x200[1] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R) & ~(BIT(1)),
+			CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV180X_SDHCI_PHY_CONFIG) & ~(BIT(0)),
+			CVI_CV180X_SDHCI_PHY_CONFIG);
+		//reg_0x240[22:16] = tap reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host,
+			(BIT(8) | ((cvi_host->final_tap & 0x7F) << 16)),
+			CVI_CV180X_SDHCI_PHY_TX_RX_DLY);
+	} else {
+		//Reset as DS/HS setting.
+		//reg_0x200[1] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(1),
+			CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV180X_SDHCI_PHY_CONFIG) | BIT(0),
+			CVI_CV180X_SDHCI_PHY_CONFIG);
+		//reg_0x240[25:24] = 1 reg_0x240[22:16] = 0 reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host, 0x1000100, CVI_CV180X_SDHCI_PHY_TX_RX_DLY);
+	}
+}
+
+void sdhci_cv180x_sd_voltage_switch(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s\n", __func__);
+
+	// enable SDIO0_CLK[7:5] to set CLK max strengh
+	writeb((readb(cvi_host->pinmuxbase + 0xA00) | BIT(7) | BIT(6) | BIT(5)),
+		cvi_host->pinmuxbase + 0xA00);
+
+	//Voltage switching flow (1.8v)
+	//reg_pwrsw_auto=1, reg_pwrsw_disc=0, pwrsw_vsel=1(1.8v), reg_en_pwrsw=1
+	writel(0xB | (readl(cvi_host->topbase + OFFSET_SD_PWRSW_CTRL) & 0xFFFFFFF0),
+		cvi_host->topbase + OFFSET_SD_PWRSW_CTRL);
+	pr_debug("sd PWRSW 0x%x\n", readl(cvi_host->topbase + OFFSET_SD_PWRSW_CTRL));
+	cvi_host->sdio0_voltage_1_8_v = 1;
+
+	mdelay(1);
+}
+
+void sdhci_cv180x_sd_voltage_restore(struct sdhci_host *host, bool bunplug)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s\n", __func__);
+
+	if (bunplug) {
+		//Voltage close flow
+		//(reg_pwrsw_auto=1, reg_pwrsw_disc=1, reg_pwrsw_vsel=1(1.8v), reg_en_pwrsw=0)
+		writel(0xE | (readl(cvi_host->topbase + OFFSET_SD_PWRSW_CTRL) & 0xFFFFFFF0),
+			cvi_host->topbase + OFFSET_SD_PWRSW_CTRL);
+		cvi_host->sdio0_voltage_1_8_v = 0;
+	} else {
+		if (!cvi_host->sdio0_voltage_1_8_v) {
+			//Voltage switching flow (3.3)
+			//(reg_pwrsw_auto=1, reg_pwrsw_disc=0, reg_pwrsw_vsel=0(3.0v), reg_en_pwrsw=1)
+			writel(0x9 | (readl(cvi_host->topbase + OFFSET_SD_PWRSW_CTRL) & 0xFFFFFFF0),
+				cvi_host->topbase + OFFSET_SD_PWRSW_CTRL);
+		}
+	}
+
+	//wait 1ms
+	mdelay(1);
+
+	// restore to DS/HS setting
+	sdhci_writel(host,
+		sdhci_readl(host, CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(1) | BIT(8) | BIT(9),
+		CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R);
+	sdhci_writel(host, 0x1000100, CVI_CV180X_SDHCI_PHY_TX_RX_DLY);
+	sdhci_writel(host, 1, CVI_CV180X_SDHCI_PHY_CONFIG);
+
+	mdelay(1);
+}
+
+static void sdhci_cv180x_sd_set_power(struct sdhci_host *host, unsigned char mode,
+				unsigned short vdd)
+{
+	struct mmc_host *mmc = host->mmc;
+
+	pr_debug("%s:mode %u, vdd %u\n", __func__, mode, vdd);
+
+	if (mode == MMC_POWER_ON && mmc->ops->get_cd(mmc)) {
+		sdhci_set_power_noreg(host, mode, vdd);
+		sdhci_cv180x_sd_voltage_restore(host, false);
+		sdhci_cv180x_sd_setup_pad(host, false);
+		sdhci_cv180x_sd_setup_io(host, false);
+		mdelay(5);
+	} else if (mode == MMC_POWER_OFF) {
+		sdhci_cv180x_sd_setup_pad(host, true);
+		sdhci_cv180x_sd_setup_io(host, true);
+		sdhci_cv180x_sd_voltage_restore(host, true);
+		sdhci_set_power_noreg(host, mode, vdd);
+		mdelay(30);
+	}
+}
+
+static const struct sdhci_ops sdhci_cv180x_sd_ops = {
+	.reset = sdhci_cv180x_sd_reset,
+	.set_clock = sdhci_set_clock,
+	.set_power = sdhci_cv180x_sd_set_power,
+	.set_bus_width = sdhci_set_bus_width,
+	.get_max_clock = sdhci_cvi_general_get_max_clock,
+	.voltage_switch = sdhci_cv180x_sd_voltage_switch,
+	.set_uhs_signaling = sdhci_cvi_general_set_uhs_signaling,
+	.platform_execute_tuning = sdhci_cv180x_general_execute_tuning,
+};
+
+static const struct sdhci_pltfm_data sdhci_cv180x_sd_pdata = {
+	.ops = &sdhci_cv180x_sd_ops,
+	.quirks = SDHCI_QUIRK_INVERTED_WRITE_PROTECT | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
+};
+
+static const struct of_device_id sdhci_cvi_dt_match[] = {
+	{.compatible = "sophgo,cv180x-sd", .data = &sdhci_cv180x_sd_pdata},
+};
+
+MODULE_DEVICE_TABLE(of, sdhci_cvi_dt_match);
+
+static int sdhci_cvi_probe(struct platform_device *pdev)
+{
+	struct sdhci_host *host;
+	struct sdhci_pltfm_host *pltfm_host;
+	struct sdhci_cvi_host *cvi_host;
+	const struct of_device_id *match;
+	const struct sdhci_pltfm_data *pdata;
+	int ret;
+
+	pr_info(DRIVER_NAME ":%s\n", __func__);
+
+	match = of_match_device(sdhci_cvi_dt_match, &pdev->dev);
+	if (!match)
+		return -EINVAL;
+
+	pdata = match->data;
+
+	host = sdhci_pltfm_init(pdev, pdata, sizeof(*cvi_host));
+	if (IS_ERR(host))
+		return PTR_ERR(host);
+
+	pltfm_host = sdhci_priv(host);
+	cvi_host = sdhci_pltfm_priv(pltfm_host);
+	cvi_host->host = host;
+	cvi_host->mmc = host->mmc;
+	cvi_host->pdev = pdev;
+	cvi_host->core_mem = host->ioaddr;
+	cvi_host->topbase = ioremap(TOP_BASE, 0x2000);
+	cvi_host->pinmuxbase = ioremap(PINMUX_BASE, 0x1000);
+	cvi_host->clkgenbase = ioremap(CLKGEN_BASE, 0x100);
+
+	sdhci_cv180x_sd_voltage_restore(host, false);
+
+	ret = mmc_of_parse(host->mmc);
+	if (ret)
+		goto pltfm_free;
+
+	sdhci_get_of_property(pdev);
+
+	if (pdata->ops->hw_reset) {
+		cvi_host->reset = devm_reset_control_get(&pdev->dev, "sdio");
+		if (IS_ERR(cvi_host->reset)) {
+			ret = PTR_ERR(cvi_host->reset);
+			goto pltfm_free;
+		}
+	}
+
+	ret = sdhci_add_host(host);
+	if (ret)
+		goto err_add_host;
+
+	platform_set_drvdata(pdev, cvi_host);
+
+	return 0;
+
+err_add_host:
+pltfm_free:
+	sdhci_pltfm_free(pdev);
+	return ret;
+}
+
+static int sdhci_cvi_remove(struct platform_device *pdev)
+{
+	struct sdhci_host *host = platform_get_drvdata(pdev);
+	int dead = (readl_relaxed(host->ioaddr + SDHCI_INT_STATUS) == 0xffffffff);
+
+	sdhci_remove_host(host, dead);
+	sdhci_pltfm_free(pdev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int save_rtc_reg(struct sdhci_cvi_host *cvi_host)
+{
+	return 0;
+}
+static void restore_rtc_reg(struct sdhci_cvi_host *cvi_host) {}
+
+static void save_reg(struct sdhci_host *host, struct sdhci_cvi_host *cvi_host)
+{
+	save_rtc_reg(cvi_host);
+	cvi_host->reg_ctrl2 = sdhci_readl(host, SDHCI_HOST_CONTROL2);
+	cvi_host->reg_clk_ctrl = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
+	cvi_host->reg_host_ctrl = sdhci_readl(host, SDHCI_HOST_CONTROL);
+}
+
+static void restore_reg(struct sdhci_host *host, struct sdhci_cvi_host *cvi_host)
+{
+	restore_rtc_reg(cvi_host);
+	sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
+	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
+	sdhci_writel(host, cvi_host->reg_ctrl2, SDHCI_HOST_CONTROL2);
+	sdhci_writel(host, cvi_host->reg_clk_ctrl, SDHCI_CLOCK_CONTROL);
+	sdhci_writel(host, cvi_host->reg_host_ctrl, SDHCI_HOST_CONTROL);
+}
+
+static int sdhci_cvi_suspend(struct device *dev)
+{
+	struct sdhci_cvi_host *cvi_host = dev_get_drvdata(dev);
+	struct sdhci_host *host = cvi_host->host;
+
+	if (!host)
+		return 0;
+
+	save_reg(host, cvi_host);
+
+	return 0;
+}
+
+static int sdhci_cvi_resume(struct device *dev)
+{
+	struct sdhci_cvi_host *cvi_host = dev_get_drvdata(dev);
+	struct sdhci_host *host = cvi_host->host;
+
+	if (!host)
+		return 0;
+
+	restore_reg(host, cvi_host);
+
+	return 0;
+}
+
+#endif
+
+static const struct dev_pm_ops sdhci_cvi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(sdhci_cvi_suspend, sdhci_cvi_resume)
+};
+
+static struct platform_driver sdhci_cvi_driver = {
+	.probe = sdhci_cvi_probe,
+	.remove = sdhci_cvi_remove,
+	.driver = {
+		.name = DRIVER_NAME,
+		.pm = &sdhci_cvi_pm_ops,
+		.of_match_table = sdhci_cvi_dt_match,
+	},
+};
+
+module_platform_driver(sdhci_cvi_driver);
+
+MODULE_DESCRIPTION("Cvitek Secure Digital Host Controller Interface driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mmc/host/sdhci-cv180x.h b/drivers/mmc/host/sdhci-cv180x.h
new file mode 100644
index 000000000000..0ec2217228a6
--- /dev/null
+++ b/drivers/mmc/host/sdhci-cv180x.h
@@ -0,0 +1,62 @@
+/*
+ * drivers/mmc/host/sdhci-cvi.c - CVITEK SDHCI Platform driver
+ *
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __SDHCI_CV_H
+#define __SDHCI_CV_H
+
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/delay.h>
+#include <linux/mmc/mmc.h>
+#include <linux/slab.h>
+
+
+#define SDHCI_ERR_INT_STATUS			0x32
+
+#define MAX_TUNING_CMD_RETRY_COUNT		50
+#define TUNE_MAX_PHCODE				128
+#define TAP_WINDOW_THLD				20
+
+#define TOP_BASE				0x03000000
+#define OFFSET_SD_PWRSW_CTRL			0x1F4
+
+#define PINMUX_BASE 				0x03001000
+#define CLKGEN_BASE 				0x03002000
+
+#define CVI_CV180X_SDHCI_VENDOR_OFFSET		0x200
+#define CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R	(CVI_CV180X_SDHCI_VENDOR_OFFSET + 0x0)
+#define CVI_CV180X_SDHCI_PHY_TX_RX_DLY		(CVI_CV180X_SDHCI_VENDOR_OFFSET + 0x40)
+#define CVI_CV180X_SDHCI_PHY_DLY_STS		(CVI_CV180X_SDHCI_VENDOR_OFFSET + 0x48)
+#define CVI_CV180X_SDHCI_PHY_CONFIG		(CVI_CV180X_SDHCI_VENDOR_OFFSET + 0x4C)
+
+struct sdhci_cvi_host {
+	struct sdhci_host *host;
+	struct platform_device *pdev;
+	void __iomem *core_mem; /* mmio address */
+	struct mmc_host *mmc;
+	struct reset_control *reset;
+
+	void __iomem *topbase;
+	void __iomem *pinmuxbase;
+	void __iomem *clkgenbase;
+
+	u32 reg_ctrl2;
+	u32 reg_clk_ctrl;
+	u32 reg_host_ctrl;
+	u8 final_tap;
+	u8 sdio0_voltage_1_8_v;
+};
+#endif
-- 
2.39.2

