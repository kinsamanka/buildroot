From 40d6e2825c50a551c62e2aa02e08c055c0fbaf67 Mon Sep 17 00:00:00 2001
From: GP Orcullo <kinsamanka@gmail.com>
Date: Tue, 31 Oct 2023 11:39:39 +0800
Subject: [PATCH 1/2] [linux] port cvitek asic chips

---
 .../bindings/clock/cvitek,cv180x-clk.yaml     |   59 +
 .../bindings/clock/cvitek,cv181x-clk.yaml     |   59 +
 .../devicetree/bindings/soc/cvitek/base.txt   |    6 +
 .../devicetree/bindings/soc/cvitek/bt_pin.txt |    5 +
 .../devicetree/bindings/soc/cvitek/cif.txt    |    8 +
 .../devicetree/bindings/soc/cvitek/fb.txt     |    8 +
 .../devicetree/bindings/soc/cvitek/jpu.txt    |    8 +
 .../bindings/soc/cvitek/mipi_tx.txt           |    7 +
 .../bindings/soc/cvitek/pwm-cvitek.txt        |    9 +
 .../devicetree/bindings/soc/cvitek/rtc.txt    |    8 +
 .../devicetree/bindings/soc/cvitek/saradc.txt |    8 +
 .../bindings/soc/cvitek/sysdma_remap.txt      |   19 +
 .../devicetree/bindings/soc/cvitek/tpu.txt    |    8 +
 .../devicetree/bindings/soc/cvitek/vcodec.txt |   11 +
 .../devicetree/bindings/soc/cvitek/vip.txt    |    8 +
 .../bindings/soc/cvitek/wiegand.txt           |    8 +
 .../bindings/soc/cvitek/wifi_pin.txt          |    6 +
 .../bindings/sound/cvitek,cv182xa.yaml        |   76 +
 .../thermal/cvitek-cv180x-thermal.txt         |    9 +
 .../thermal/cvitek-cv181x-thermal.txt         |    9 +
 .../devicetree/bindings/vendor-prefixes.yaml  |    2 +
 README.md                                     |    1 +
 arch/riscv/Kconfig                            |   12 +-
 arch/riscv/Kconfig.socs                       |   10 +
 arch/riscv/Makefile                           |    7 +
 arch/riscv/boot/dts/Makefile                  |    2 +
 arch/riscv/boot/dts/cvitek/.gitignore         |    3 +
 arch/riscv/boot/dts/cvitek/Makefile           |    5 +
 arch/riscv/boot/dts/cvitek/cv1835_asic.dtsi   | 1143 +++++++
 arch/riscv/boot/dts/thead/Makefile            |    3 +
 arch/riscv/boot/dts/thead/ice.dts             |  399 +++
 arch/riscv/boot/dts/thead/light_mpw.dts       |  259 ++
 arch/riscv/configs/ice_defconfig              |  185 ++
 arch/riscv/configs/vector_0_7_defconfig       |  189 ++
 arch/riscv/include/asm/bug.h                  |    1 +
 arch/riscv/include/asm/cacheflush.h           |    3 +
 arch/riscv/include/asm/compat.h               |  266 ++
 arch/riscv/include/asm/csr.h                  |   37 +
 arch/riscv/include/asm/elf.h                  |   40 +-
 arch/riscv/include/asm/fixmap.h               |    2 -
 arch/riscv/include/asm/kprobes.h              |   40 +
 arch/riscv/include/asm/mmu.h                  |    2 +
 arch/riscv/include/asm/page.h                 |    6 +
 arch/riscv/include/asm/pgtable-64.h           |    2 +-
 arch/riscv/include/asm/pgtable-bits.h         |   12 +-
 arch/riscv/include/asm/pgtable.h              |   66 +-
 arch/riscv/include/asm/probes.h               |   24 +
 arch/riscv/include/asm/processor.h            |   24 +
 arch/riscv/include/asm/ptrace.h               |   35 +
 arch/riscv/include/asm/sbi.h                  |    3 +
 arch/riscv/include/asm/set_memory.h           |    6 +-
 arch/riscv/include/asm/stacktrace.h           |   19 +
 arch/riscv/include/asm/switch_to.h            |   48 +
 arch/riscv/include/asm/syscall.h              |    5 +-
 arch/riscv/include/asm/thread_info.h          |   21 +-
 arch/riscv/include/asm/tlbflush.h             |   21 +-
 arch/riscv/include/asm/uaccess.h              |   25 +
 arch/riscv/include/asm/uprobes.h              |   40 +
 arch/riscv/include/uapi/asm/elf.h             |    2 +
 arch/riscv/include/uapi/asm/hwcap.h           |    1 +
 arch/riscv/include/uapi/asm/ptrace.h          |    9 +
 arch/riscv/include/uapi/asm/sigcontext.h      |    1 +
 arch/riscv/include/uapi/asm/unistd.h          |    2 +-
 arch/riscv/kernel/asm-offsets.c               |  190 ++
 arch/riscv/kernel/cpu.c                       |   23 +
 arch/riscv/kernel/cpu_ops_spinwait.c          |    2 +
 arch/riscv/kernel/cpufeature.c                |   10 +
 arch/riscv/kernel/entry.S                     |   21 +-
 arch/riscv/kernel/ftrace.c                    |   95 +-
 arch/riscv/kernel/head.S                      |   13 +-
 arch/riscv/kernel/mcount-dyn.S                |  342 +-
 arch/riscv/kernel/module.c                    |   89 +-
 arch/riscv/kernel/patch.c                     |    8 +-
 arch/riscv/kernel/perf_callchain.c            |   10 +-
 arch/riscv/kernel/process.c                   |   25 +-
 arch/riscv/kernel/ptrace.c                    |  228 +-
 arch/riscv/kernel/sbi.c                       |   15 +
 arch/riscv/kernel/signal.c                    |   57 +-
 arch/riscv/kernel/stacktrace.c                |   72 +-
 arch/riscv/kernel/syscall_table.c             |    2 +-
 arch/riscv/kernel/traps.c                     |   31 +-
 arch/riscv/kernel/vdso/gen_vdso_offsets.sh    |    5 +
 arch/riscv/kernel/vmlinux.lds.S               |    2 +-
 arch/riscv/mach-cvitek/Kconfig                |   93 +
 arch/riscv/mach-cvitek/Makefile               |    1 +
 arch/riscv/mm/Makefile                        |    2 +
 arch/riscv/mm/asid.c                          |  189 ++
 arch/riscv/mm/cacheflush.c                    |   43 +-
 arch/riscv/mm/dma-mapping.c                   |   69 +
 arch/riscv/mm/fault.c                         |   12 +-
 arch/riscv/mm/init.c                          |   19 +-
 arch/riscv/mm/ioremap.c                       |   20 +
 arch/riscv/mm/tlbflush.c                      |   68 +
 drivers/clk/Kconfig                           |    1 +
 drivers/clk/Makefile                          |    1 +
 drivers/clk/cvitek/Kconfig                    |   12 +
 drivers/clk/cvitek/Makefile                   |    5 +
 drivers/clk/cvitek/clk-cv180x.c               | 2842 ++++++++++++++++
 drivers/clk/cvitek/clk-cv181x.c               | 2848 +++++++++++++++++
 drivers/clk/cvitek/clk-cv182x.c               | 1862 +++++++++++
 drivers/clk/cvitek/clk-cv1835.c               | 1703 ++++++++++
 drivers/dma/Kconfig                           |    2 +
 drivers/dma/Makefile                          |    1 +
 drivers/dma/cvitek/Kconfig                    |    6 +
 drivers/dma/cvitek/Makefile                   |    1 +
 drivers/dma/cvitek/cvitek-dma.c               | 2192 +++++++++++++
 drivers/dma/cvitek/cvitek-dma.h               |  497 +++
 drivers/firmware/efi/libstub/efi-stub.c       |    2 +-
 drivers/i2c/busses/Kconfig                    |    5 +
 drivers/i2c/busses/Makefile                   |    1 +
 drivers/i2c/busses/i2c-designware-core.h      |    1 +
 drivers/i2c/busses/i2c-designware-ice.c       |  746 +++++
 drivers/i2c/busses/i2c-designware-master.c    |   14 +-
 drivers/i2c/i2c-dev.c                         |   25 +
 drivers/irqchip/irq-sifive-plic.c             |    2 +-
 drivers/media/platform/Kconfig                |    2 +
 drivers/media/platform/cvitek/Kconfig         |   19 +
 drivers/mmc/core/card.h                       |    5 +
 drivers/mmc/core/core.c                       |   36 +-
 drivers/mmc/core/host.c                       |    3 +
 drivers/mmc/core/quirks.h                     |    2 +
 drivers/mmc/core/sdio.c                       |   39 +
 drivers/mmc/core/slot-gpio.c                  |    9 -
 drivers/mmc/host/Kconfig                      |   23 +
 drivers/mmc/host/Makefile                     |    2 +
 drivers/mmc/host/cvitek/Makefile              |   10 +
 drivers/mmc/host/cvitek/sdhci-cv180x.c        | 1422 ++++++++
 drivers/mmc/host/cvitek/sdhci-cv180x.h        |  104 +
 drivers/mmc/host/cvitek/sdhci-cv181x.c        | 1434 +++++++++
 drivers/mmc/host/cvitek/sdhci-cv181x.h        |  104 +
 drivers/mmc/host/cvitek/sdhci-cv182x.c        | 1353 ++++++++
 drivers/mmc/host/cvitek/sdhci-cv182x.h        |  103 +
 drivers/mmc/host/cvitek/sdhci-cv183x.c        | 1467 +++++++++
 drivers/mmc/host/cvitek/sdhci-cv183x.h        |   99 +
 drivers/mmc/host/sdhci-of-light-mpw.c         |  558 ++++
 drivers/mmc/host/sdhci-pltfm.c                |    3 +
 drivers/mmc/host/sdhci.c                      |  113 +-
 drivers/mmc/host/sdhci.h                      |   16 +
 drivers/mtd/nand/raw/Kconfig                  |    9 +
 drivers/mtd/nand/raw/Makefile                 |    1 +
 drivers/mtd/nand/raw/cvitek/Makefile          |    2 +
 drivers/mtd/nand/raw/cvitek/cvmc_common.h     |   48 +
 drivers/mtd/nand/raw/cvitek/cvsnfc.c          | 1419 ++++++++
 drivers/mtd/nand/raw/cvitek/cvsnfc.h          |  668 ++++
 drivers/mtd/nand/raw/cvitek/cvsnfc_common.c   |  165 +
 drivers/mtd/nand/raw/cvitek/cvsnfc_common.h   |  159 +
 drivers/mtd/nand/raw/cvitek/cvsnfc_dt.c       |  137 +
 drivers/mtd/nand/raw/cvitek/cvsnfc_spi_ids.c  | 1456 +++++++++
 drivers/mtd/nand/raw/cvitek/cvsnfc_spi_ids.h  |  120 +
 drivers/mtd/nand/raw/cvitek/match_table.c     |   88 +
 drivers/mtd/nand/raw/cvitek/match_table.h     |   49 +
 drivers/mtd/nand/raw/nand_base.c              |    6 +
 drivers/mtd/spi-nor/Makefile                  |    1 +
 drivers/mtd/spi-nor/controllers/Kconfig       |   10 +
 drivers/mtd/spi-nor/controllers/Makefile      |    1 +
 drivers/mtd/spi-nor/controllers/cvi-spif.c    |  849 +++++
 drivers/mtd/spi-nor/core.c                    |  102 +-
 drivers/mtd/spi-nor/core.h                    |    5 +
 drivers/mtd/spi-nor/cvitek_support_list.c     |  182 ++
 drivers/mtd/spi-nor/eon.c                     |    4 +
 drivers/mtd/spi-nor/winbond.c                 |   18 +-
 drivers/mtd/spi-nor/xmc.c                     |   30 +-
 drivers/net/ethernet/stmicro/stmmac/Kconfig   |   10 +
 drivers/net/ethernet/stmicro/stmmac/Makefile  |    3 +-
 .../ethernet/stmicro/stmmac/dwmac-cvitek.c    |  159 +
 .../net/ethernet/stmicro/stmmac/dwmac-thead.c |  606 ++++
 .../ethernet/stmicro/stmmac/stmmac_platform.c |   13 +
 drivers/of/of_reserved_mem.c                  |  105 +-
 drivers/perf/Makefile                         |    2 +
 drivers/perf/thead_c900_pmu.c                 |  754 +++++
 drivers/perf/thead_c900_pmu_v1.c              |  800 +++++
 drivers/pinctrl/Kconfig                       |    1 +
 drivers/pinctrl/Makefile                      |    1 +
 drivers/pinctrl/cvitek/Kconfig                |   10 +
 drivers/pinctrl/cvitek/Makefile               |    1 +
 .../pinctrl/cvitek/cv180x_pinlist_swconfig.h  |  407 +++
 drivers/pinctrl/cvitek/cv180x_reg_fmux_gpio.h |  337 ++
 .../pinctrl/cvitek/cv181x_pinlist_swconfig.h  |  676 ++++
 drivers/pinctrl/cvitek/cv181x_reg_fmux_gpio.h |  482 +++
 .../pinctrl/cvitek/cv1822_pinlist_swconfig.h  |  603 ++++
 drivers/pinctrl/cvitek/cv1822_reg_fmux_gpio.h |  451 +++
 .../pinctrl/cvitek/cv1835_pinlist_swconfig.h  |  504 +++
 drivers/pinctrl/cvitek/cv1835_reg_fmux_gpio.h |  449 +++
 drivers/pinctrl/cvitek/pinctrl-cv180x.c       |  108 +
 drivers/pinctrl/cvitek/pinctrl-cv180x.h       |   34 +
 drivers/pinctrl/cvitek/pinctrl-cv181x.c       |  108 +
 drivers/pinctrl/cvitek/pinctrl-cv181x.h       |   43 +
 drivers/pinctrl/cvitek/pinctrl-cv1822.h       |   47 +
 drivers/pinctrl/cvitek/pinctrl-cv182x.c       |  127 +
 drivers/pinctrl/cvitek/pinctrl-cv1835.h       |   52 +
 drivers/pinctrl/cvitek/pinctrl-cv183x.c       |   20 +
 drivers/pinctrl/cvitek/pinctrl-cv75x1.c       |   20 +
 drivers/pinctrl/cvitek/pinctrl-cv952x.c       |   20 +
 drivers/power/reset/Makefile                  |    1 +
 drivers/power/reset/cvi-reboot.c              |  112 +
 drivers/reset/Makefile                        |    3 +-
 drivers/reset/clk-reset-cvitek.c              |  125 +
 drivers/reset/reset-cvitek.c                  |  128 +
 drivers/soc/Kconfig                           |    1 +
 drivers/soc/Makefile                          |    1 +
 drivers/soc/cvitek/Kconfig                    |   33 +
 drivers/soc/cvitek/Makefile                   |    3 +
 drivers/soc/cvitek/bt_pin/cvi_bt_pin.c        |   77 +
 drivers/soc/cvitek/sysdma/cv1835_dma_remap.c  |  135 +
 drivers/soc/cvitek/wifi_pin/cvi_wifi_pin.c    |   96 +
 drivers/tee/Makefile                          |    1 +
 drivers/tee/optee/core.c                      |    7 +
 drivers/tee/tee_core.c                        |    6 +
 drivers/tee/tee_cv_private.c                  |  629 ++++
 drivers/tee/tee_cv_private.h                  |   87 +
 drivers/thermal/Kconfig                       |   44 +
 drivers/thermal/Makefile                      |    4 +
 drivers/thermal/cv180x_thermal.c              |  486 +++
 drivers/thermal/cv181x_thermal.c              |  483 +++
 drivers/thermal/cv182x_thermal.c              |  453 +++
 drivers/thermal/cv1835_thermal.c              |  426 +++
 drivers/thermal/thermal_core.c                |    9 +-
 drivers/usb/Kconfig                           |   37 +
 drivers/usb/common/Makefile                   |    5 +
 drivers/usb/common/usb-otg.c                  | 1257 ++++++++
 drivers/usb/common/usb-otg.h                  |   78 +
 drivers/usb/core/hcd.c                        |  331 ++
 drivers/usb/dwc2/Kconfig                      |    1 -
 drivers/usb/dwc2/Makefile                     |    5 +-
 drivers/usb/dwc2/core.c                       |  138 +-
 drivers/usb/dwc2/core.h                       |   95 +-
 drivers/usb/dwc2/core_intr.c                  |  110 +-
 drivers/usb/dwc2/debugfs.c                    |    2 +
 drivers/usb/dwc2/gadget.c                     |  252 +-
 drivers/usb/dwc2/hcd.c                        |  638 +++-
 drivers/usb/dwc2/hcd_intr.c                   |   21 +-
 drivers/usb/dwc2/hw.h                         |    1 +
 drivers/usb/dwc2/params.c                     |   53 +-
 drivers/usb/dwc2/pci.c                        |   18 -
 drivers/usb/dwc2/platform.c                   |  646 +++-
 drivers/usb/gadget/Kconfig                    |   11 +
 drivers/usb/gadget/function/f_uac1.c          |   22 +
 drivers/usb/gadget/function/u_audio.c         |   52 +
 drivers/usb/gadget/function/u_uac1.h          |    8 +-
 drivers/usb/gadget/function/uvc_configfs.c    |  351 +-
 drivers/usb/gadget/function/uvc_v4l2.c        |    3 +
 drivers/usb/gadget/function/uvc_video.c       |   79 +-
 drivers/usb/gadget/udc/core.c                 |  123 +
 drivers/usb/host/xhci-plat.c                  |   34 +
 drivers/usb/host/xhci.c                       |    5 +
 drivers/usb/roles/Kconfig                     |    1 +
 drivers/video/fbdev/Kconfig                   |    1 +
 drivers/video/fbdev/Makefile                  |    2 +-
 drivers/video/fbdev/core/fbmem.c              |   44 +-
 drivers/video/fbdev/cvitek/Kconfig            |   13 +
 drivers/video/fbdev/dc8000-fb.c               | 1696 ++++++++++
 drivers/watchdog/Kconfig                      |   14 +
 drivers/watchdog/Makefile                     |    1 +
 drivers/watchdog/ice_wdt.c                    |  193 ++
 include/dt-bindings/clock/cv180x-clock.h      |  175 +
 include/dt-bindings/clock/cv181x-clock.h      |  175 +
 include/dt-bindings/clock/cv182x-clock.h      |  201 ++
 include/dt-bindings/clock/cv1835-clock.h      |  197 ++
 include/dt-bindings/dma/cv180x-dmamap.h       |   48 +
 include/dt-bindings/dma/cv181x-dmamap.h       |   48 +
 include/dt-bindings/dma/cv182x-dmamap.h       |   48 +
 include/dt-bindings/dma/cv1835-dmamap.h       |   48 +
 include/dt-bindings/reset/cv180x-resets.h     |  172 +
 include/dt-bindings/reset/cv181x-resets.h     |  172 +
 include/dt-bindings/reset/cv182x-resets.h     |  172 +
 include/dt-bindings/reset/cv1835-resets.h     |  172 +
 include/dt-bindings/sound/cv1835-audio.h      |    9 +
 include/linux/compat.h                        |    2 -
 include/linux/cpuhotplug.h                    |    1 +
 include/linux/early_time_log.h                |    7 +
 include/linux/i2c.h                           |    3 +
 include/linux/mmc/card.h                      |    1 +
 include/linux/mmc/host.h                      |    3 +-
 include/linux/mmc/slot-gpio.h                 |    9 +
 include/linux/mtd/spi-nor.h                   |    1 +
 include/linux/sched.h                         |    4 +
 include/linux/streamline_annotate.h           |  275 ++
 include/linux/uaccess.h                       |   11 +-
 include/linux/usb/gadget.h                    |   19 +
 include/linux/usb/hcd.h                       |   16 +
 include/linux/usb/otg-fsm.h                   |   29 +-
 include/linux/usb/otg.h                       |  182 ++
 include/linux/usb/phy.h                       |    4 +
 include/sound/cv1835_i2s.h                    |   60 +
 include/trace/events/kmem.h                   |   42 +
 include/uapi/asm-generic/unistd.h             |    4 +-
 include/uapi/linux/elf.h                      |    1 +
 include/uapi/linux/i2c.h                      |    1 +
 include/uapi/linux/media-bus-format.h         |   10 +
 include/uapi/linux/usb/video.h                |   58 +
 include/uapi/linux/videodev2.h                |    4 +
 init/Kconfig                                  |    7 +
 init/main.c                                   |    5 +
 kernel/Kconfig.hz                             |    3 +
 kernel/compat.c                               |   21 -
 kernel/module.c                               |    5 +-
 kernel/reboot.c                               |    2 +-
 kernel/sched/core.c                           |   17 +-
 kernel/sched/cvi_sched.h                      |   49 +
 kernel/time/Makefile                          |    1 +
 kernel/time/early_time_log.c                  |   86 +
 .../dtc/include-prefixes/cvi_board_memmap.h   |    1 +
 scripts/kconfig/Makefile                      |   32 +
 sound/last.c                                  |    2 +-
 sound/soc/Kconfig                             |    1 +
 sound/soc/Makefile                            |    1 +
 sound/soc/codecs/cv181xadac.h                 |  683 ++++
 sound/soc/codecs/cv182xadac.h                 |  578 ++++
 sound/soc/codecs/cv1835adc.h                  |   99 +
 sound/soc/codecs/cv1835dac.h                  |   73 +
 sound/soc/cvitek/Kconfig                      |  192 ++
 sound/soc/cvitek/Makefile                     |   81 +
 sound/soc/cvitek/cv181x_cv181xadc.c           |  289 ++
 sound/soc/cvitek/cv181x_cv181xdac.c           |  246 ++
 sound/soc/cvitek/cv181xadc.c                  |  966 ++++++
 sound/soc/cvitek/cv181xdac.c                  |  738 +++++
 sound/soc/cvitek/cv182x_cv182xadc.c           |  288 ++
 sound/soc/cvitek/cv182x_cv182xdac.c           |  244 ++
 sound/soc/cvitek/cv182x_cv182xpdm.c           |   99 +
 sound/soc/cvitek/cv182xadc.c                  |  937 ++++++
 sound/soc/cvitek/cv182xdac.c                  |  715 +++++
 sound/soc/cvitek/cv1835_adau1372.c            |  209 ++
 sound/soc/cvitek/cv1835_cv1835adc.c           |  197 ++
 sound/soc/cvitek/cv1835_cv1835dac.c           |  186 ++
 sound/soc/cvitek/cv1835_cv1835pdm.c           |  100 +
 sound/soc/cvitek/cv1835_dummy_codec.c         |  160 +
 sound/soc/cvitek/cv1835_i2s.c                 | 1353 ++++++++
 sound/soc/cvitek/cv1835_i2s_subsys.c          |  350 ++
 sound/soc/cvitek/cv1835_i2s_subsys.h          |   77 +
 sound/soc/cvitek/cv1835_ioctl.h               |  125 +
 sound/soc/cvitek/cv1835_lt9611.c              |   99 +
 sound/soc/cvitek/cv1835adc.c                  |  794 +++++
 sound/soc/cvitek/cv1835dac.c                  |  608 ++++
 sound/soc/cvitek/cv1835pdm.c                  |  267 ++
 sound/soc/cvitek/cv1835pdm.h                  |   61 +
 sound/soc/cvitek/dummy_codec.c                |  153 +
 sound/soc/cvitek/local.h                      |  275 ++
 337 files changed, 59981 insertions(+), 824 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/clock/cvitek,cv180x-clk.yaml
 create mode 100644 Documentation/devicetree/bindings/clock/cvitek,cv181x-clk.yaml
 create mode 100644 Documentation/devicetree/bindings/soc/cvitek/base.txt
 create mode 100644 Documentation/devicetree/bindings/soc/cvitek/bt_pin.txt
 create mode 100644 Documentation/devicetree/bindings/soc/cvitek/cif.txt
 create mode 100644 Documentation/devicetree/bindings/soc/cvitek/fb.txt
 create mode 100644 Documentation/devicetree/bindings/soc/cvitek/jpu.txt
 create mode 100644 Documentation/devicetree/bindings/soc/cvitek/mipi_tx.txt
 create mode 100644 Documentation/devicetree/bindings/soc/cvitek/pwm-cvitek.txt
 create mode 100644 Documentation/devicetree/bindings/soc/cvitek/rtc.txt
 create mode 100644 Documentation/devicetree/bindings/soc/cvitek/saradc.txt
 create mode 100644 Documentation/devicetree/bindings/soc/cvitek/sysdma_remap.txt
 create mode 100644 Documentation/devicetree/bindings/soc/cvitek/tpu.txt
 create mode 100644 Documentation/devicetree/bindings/soc/cvitek/vcodec.txt
 create mode 100644 Documentation/devicetree/bindings/soc/cvitek/vip.txt
 create mode 100644 Documentation/devicetree/bindings/soc/cvitek/wiegand.txt
 create mode 100644 Documentation/devicetree/bindings/soc/cvitek/wifi_pin.txt
 create mode 100644 Documentation/devicetree/bindings/sound/cvitek,cv182xa.yaml
 create mode 100644 Documentation/devicetree/bindings/thermal/cvitek-cv180x-thermal.txt
 create mode 100644 Documentation/devicetree/bindings/thermal/cvitek-cv181x-thermal.txt
 create mode 100644 README.md
 create mode 100644 arch/riscv/boot/dts/cvitek/.gitignore
 create mode 100644 arch/riscv/boot/dts/cvitek/Makefile
 create mode 100644 arch/riscv/boot/dts/cvitek/cv1835_asic.dtsi
 create mode 100644 arch/riscv/boot/dts/thead/Makefile
 create mode 100644 arch/riscv/boot/dts/thead/ice.dts
 create mode 100644 arch/riscv/boot/dts/thead/light_mpw.dts
 create mode 100644 arch/riscv/configs/ice_defconfig
 create mode 100644 arch/riscv/configs/vector_0_7_defconfig
 create mode 100644 arch/riscv/include/asm/compat.h
 create mode 100644 arch/riscv/include/asm/probes.h
 create mode 100644 arch/riscv/include/asm/stacktrace.h
 create mode 100644 arch/riscv/include/asm/uprobes.h
 create mode 100755 arch/riscv/kernel/vdso/gen_vdso_offsets.sh
 create mode 100644 arch/riscv/mach-cvitek/Kconfig
 create mode 100644 arch/riscv/mach-cvitek/Makefile
 create mode 100644 arch/riscv/mm/asid.c
 create mode 100644 arch/riscv/mm/dma-mapping.c
 create mode 100644 arch/riscv/mm/ioremap.c
 create mode 100644 drivers/clk/cvitek/Kconfig
 create mode 100644 drivers/clk/cvitek/Makefile
 create mode 100644 drivers/clk/cvitek/clk-cv180x.c
 create mode 100644 drivers/clk/cvitek/clk-cv181x.c
 create mode 100644 drivers/clk/cvitek/clk-cv182x.c
 create mode 100644 drivers/clk/cvitek/clk-cv1835.c
 create mode 100644 drivers/dma/cvitek/Kconfig
 create mode 100644 drivers/dma/cvitek/Makefile
 create mode 100644 drivers/dma/cvitek/cvitek-dma.c
 create mode 100644 drivers/dma/cvitek/cvitek-dma.h
 create mode 100644 drivers/i2c/busses/i2c-designware-ice.c
 create mode 100644 drivers/media/platform/cvitek/Kconfig
 create mode 100644 drivers/mmc/host/cvitek/Makefile
 create mode 100644 drivers/mmc/host/cvitek/sdhci-cv180x.c
 create mode 100644 drivers/mmc/host/cvitek/sdhci-cv180x.h
 create mode 100644 drivers/mmc/host/cvitek/sdhci-cv181x.c
 create mode 100644 drivers/mmc/host/cvitek/sdhci-cv181x.h
 create mode 100644 drivers/mmc/host/cvitek/sdhci-cv182x.c
 create mode 100644 drivers/mmc/host/cvitek/sdhci-cv182x.h
 create mode 100644 drivers/mmc/host/cvitek/sdhci-cv183x.c
 create mode 100644 drivers/mmc/host/cvitek/sdhci-cv183x.h
 create mode 100644 drivers/mmc/host/sdhci-of-light-mpw.c
 create mode 100644 drivers/mtd/nand/raw/cvitek/Makefile
 create mode 100644 drivers/mtd/nand/raw/cvitek/cvmc_common.h
 create mode 100644 drivers/mtd/nand/raw/cvitek/cvsnfc.c
 create mode 100644 drivers/mtd/nand/raw/cvitek/cvsnfc.h
 create mode 100644 drivers/mtd/nand/raw/cvitek/cvsnfc_common.c
 create mode 100644 drivers/mtd/nand/raw/cvitek/cvsnfc_common.h
 create mode 100644 drivers/mtd/nand/raw/cvitek/cvsnfc_dt.c
 create mode 100644 drivers/mtd/nand/raw/cvitek/cvsnfc_spi_ids.c
 create mode 100644 drivers/mtd/nand/raw/cvitek/cvsnfc_spi_ids.h
 create mode 100644 drivers/mtd/nand/raw/cvitek/match_table.c
 create mode 100644 drivers/mtd/nand/raw/cvitek/match_table.h
 create mode 100644 drivers/mtd/spi-nor/controllers/cvi-spif.c
 create mode 100644 drivers/mtd/spi-nor/cvitek_support_list.c
 create mode 100644 drivers/net/ethernet/stmicro/stmmac/dwmac-cvitek.c
 create mode 100644 drivers/net/ethernet/stmicro/stmmac/dwmac-thead.c
 create mode 100644 drivers/perf/thead_c900_pmu.c
 create mode 100644 drivers/perf/thead_c900_pmu_v1.c
 create mode 100644 drivers/pinctrl/cvitek/Kconfig
 create mode 100644 drivers/pinctrl/cvitek/Makefile
 create mode 100644 drivers/pinctrl/cvitek/cv180x_pinlist_swconfig.h
 create mode 100644 drivers/pinctrl/cvitek/cv180x_reg_fmux_gpio.h
 create mode 100644 drivers/pinctrl/cvitek/cv181x_pinlist_swconfig.h
 create mode 100644 drivers/pinctrl/cvitek/cv181x_reg_fmux_gpio.h
 create mode 100644 drivers/pinctrl/cvitek/cv1822_pinlist_swconfig.h
 create mode 100644 drivers/pinctrl/cvitek/cv1822_reg_fmux_gpio.h
 create mode 100644 drivers/pinctrl/cvitek/cv1835_pinlist_swconfig.h
 create mode 100644 drivers/pinctrl/cvitek/cv1835_reg_fmux_gpio.h
 create mode 100644 drivers/pinctrl/cvitek/pinctrl-cv180x.c
 create mode 100644 drivers/pinctrl/cvitek/pinctrl-cv180x.h
 create mode 100644 drivers/pinctrl/cvitek/pinctrl-cv181x.c
 create mode 100644 drivers/pinctrl/cvitek/pinctrl-cv181x.h
 create mode 100644 drivers/pinctrl/cvitek/pinctrl-cv1822.h
 create mode 100644 drivers/pinctrl/cvitek/pinctrl-cv182x.c
 create mode 100644 drivers/pinctrl/cvitek/pinctrl-cv1835.h
 create mode 100644 drivers/pinctrl/cvitek/pinctrl-cv183x.c
 create mode 100644 drivers/pinctrl/cvitek/pinctrl-cv75x1.c
 create mode 100644 drivers/pinctrl/cvitek/pinctrl-cv952x.c
 create mode 100644 drivers/power/reset/cvi-reboot.c
 create mode 100644 drivers/reset/clk-reset-cvitek.c
 create mode 100644 drivers/reset/reset-cvitek.c
 create mode 100644 drivers/soc/cvitek/Kconfig
 create mode 100644 drivers/soc/cvitek/Makefile
 create mode 100644 drivers/soc/cvitek/bt_pin/cvi_bt_pin.c
 create mode 100644 drivers/soc/cvitek/sysdma/cv1835_dma_remap.c
 create mode 100644 drivers/soc/cvitek/wifi_pin/cvi_wifi_pin.c
 create mode 100644 drivers/tee/tee_cv_private.c
 create mode 100644 drivers/tee/tee_cv_private.h
 create mode 100644 drivers/thermal/cv180x_thermal.c
 create mode 100644 drivers/thermal/cv181x_thermal.c
 create mode 100644 drivers/thermal/cv182x_thermal.c
 create mode 100644 drivers/thermal/cv1835_thermal.c
 create mode 100644 drivers/usb/common/usb-otg.c
 create mode 100644 drivers/usb/common/usb-otg.h
 create mode 100644 drivers/video/fbdev/cvitek/Kconfig
 create mode 100644 drivers/video/fbdev/dc8000-fb.c
 create mode 100644 drivers/watchdog/ice_wdt.c
 create mode 100644 include/dt-bindings/clock/cv180x-clock.h
 create mode 100644 include/dt-bindings/clock/cv181x-clock.h
 create mode 100644 include/dt-bindings/clock/cv182x-clock.h
 create mode 100644 include/dt-bindings/clock/cv1835-clock.h
 create mode 100644 include/dt-bindings/dma/cv180x-dmamap.h
 create mode 100644 include/dt-bindings/dma/cv181x-dmamap.h
 create mode 100644 include/dt-bindings/dma/cv182x-dmamap.h
 create mode 100644 include/dt-bindings/dma/cv1835-dmamap.h
 create mode 100644 include/dt-bindings/reset/cv180x-resets.h
 create mode 100644 include/dt-bindings/reset/cv181x-resets.h
 create mode 100644 include/dt-bindings/reset/cv182x-resets.h
 create mode 100644 include/dt-bindings/reset/cv1835-resets.h
 create mode 100644 include/dt-bindings/sound/cv1835-audio.h
 create mode 100644 include/linux/early_time_log.h
 create mode 100644 include/linux/streamline_annotate.h
 create mode 100644 include/sound/cv1835_i2s.h
 create mode 100644 kernel/sched/cvi_sched.h
 create mode 100644 kernel/time/early_time_log.c
 create mode 120000 scripts/dtc/include-prefixes/cvi_board_memmap.h
 create mode 100644 sound/soc/codecs/cv181xadac.h
 create mode 100644 sound/soc/codecs/cv182xadac.h
 create mode 100644 sound/soc/codecs/cv1835adc.h
 create mode 100644 sound/soc/codecs/cv1835dac.h
 create mode 100644 sound/soc/cvitek/Kconfig
 create mode 100644 sound/soc/cvitek/Makefile
 create mode 100644 sound/soc/cvitek/cv181x_cv181xadc.c
 create mode 100644 sound/soc/cvitek/cv181x_cv181xdac.c
 create mode 100644 sound/soc/cvitek/cv181xadc.c
 create mode 100644 sound/soc/cvitek/cv181xdac.c
 create mode 100644 sound/soc/cvitek/cv182x_cv182xadc.c
 create mode 100644 sound/soc/cvitek/cv182x_cv182xdac.c
 create mode 100644 sound/soc/cvitek/cv182x_cv182xpdm.c
 create mode 100644 sound/soc/cvitek/cv182xadc.c
 create mode 100644 sound/soc/cvitek/cv182xdac.c
 create mode 100644 sound/soc/cvitek/cv1835_adau1372.c
 create mode 100644 sound/soc/cvitek/cv1835_cv1835adc.c
 create mode 100644 sound/soc/cvitek/cv1835_cv1835dac.c
 create mode 100644 sound/soc/cvitek/cv1835_cv1835pdm.c
 create mode 100644 sound/soc/cvitek/cv1835_dummy_codec.c
 create mode 100644 sound/soc/cvitek/cv1835_i2s.c
 create mode 100644 sound/soc/cvitek/cv1835_i2s_subsys.c
 create mode 100644 sound/soc/cvitek/cv1835_i2s_subsys.h
 create mode 100644 sound/soc/cvitek/cv1835_ioctl.h
 create mode 100644 sound/soc/cvitek/cv1835_lt9611.c
 create mode 100644 sound/soc/cvitek/cv1835adc.c
 create mode 100644 sound/soc/cvitek/cv1835dac.c
 create mode 100644 sound/soc/cvitek/cv1835pdm.c
 create mode 100644 sound/soc/cvitek/cv1835pdm.h
 create mode 100644 sound/soc/cvitek/dummy_codec.c
 create mode 100644 sound/soc/cvitek/local.h

diff --git a/Documentation/devicetree/bindings/clock/cvitek,cv180x-clk.yaml b/Documentation/devicetree/bindings/clock/cvitek,cv180x-clk.yaml
new file mode 100644
index 000000000000..70a96bcaf0cd
--- /dev/null
+++ b/Documentation/devicetree/bindings/clock/cvitek,cv180x-clk.yaml
@@ -0,0 +1,59 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/clock/cvitek,cv180x-clk.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Cvitek CV180X SoC Clock Controller
+
+maintainers:
+  - Fisher Cheng <fisher.cheng@cvitek.com>
+
+description: |
+  The Cvitek CV180X SoC clock controller generates and supplies clock to
+  various peripherals within the SoC.
+
+  This binding uses common clock bindings
+  [1] Documentation/devicetree/bindings/clock/clock-bindings.txt
+
+properties:
+  compatible:
+    const: cvitek,cv180x-clk
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  '#clock-cells':
+    const: 1
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - '#clock-cells'
+
+additionalProperties: false
+
+examples:
+  # Clock controller node:
+  - |
+    clk: clock-controller {
+      compatible = "cvitek,cv180x-clk";
+      reg = <0x0 0x03002000 0x0 0x1000>;
+      clocks = <&osc>;
+      #clock-cells = <1>;
+    };
+
+  # Example PWM controller node that consumes clock generated by the clock controller:
+  - |
+    pwm0: pwm@3060000 {
+      compatible = "cvitek,cvi-pwm";
+      reg = <0x0 0x3060000 0x0 0x1000>;
+      clocks = <&clk CV180X_CLK_PWM>;
+      #pwm-cells = <1>;
+    };
+
+...
diff --git a/Documentation/devicetree/bindings/clock/cvitek,cv181x-clk.yaml b/Documentation/devicetree/bindings/clock/cvitek,cv181x-clk.yaml
new file mode 100644
index 000000000000..68a98c40b838
--- /dev/null
+++ b/Documentation/devicetree/bindings/clock/cvitek,cv181x-clk.yaml
@@ -0,0 +1,59 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/clock/cvitek,cv181x-clk.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Cvitek CV181X SoC Clock Controller
+
+maintainers:
+  - Fisher Cheng <fisher.cheng@cvitek.com>
+
+description: |
+  The Cvitek CV181X SoC clock controller generates and supplies clock to
+  various peripherals within the SoC.
+
+  This binding uses common clock bindings
+  [1] Documentation/devicetree/bindings/clock/clock-bindings.txt
+
+properties:
+  compatible:
+    const: cvitek,cv181x-clk
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  '#clock-cells':
+    const: 1
+
+required:
+  - compatible
+  - reg
+  - clocks
+  - '#clock-cells'
+
+additionalProperties: false
+
+examples:
+  # Clock controller node:
+  - |
+    clk: clock-controller {
+      compatible = "cvitek,cv181x-clk";
+      reg = <0x0 0x03002000 0x0 0x1000>;
+      clocks = <&osc>;
+      #clock-cells = <1>;
+    };
+
+  # Example PWM controller node that consumes clock generated by the clock controller:
+  - |
+    pwm0: pwm@3060000 {
+      compatible = "cvitek,cvi-pwm";
+      reg = <0x0 0x3060000 0x0 0x1000>;
+      clocks = <&clk CV181X_CLK_PWM>;
+      #pwm-cells = <1>;
+    };
+
+...
diff --git a/Documentation/devicetree/bindings/soc/cvitek/base.txt b/Documentation/devicetree/bindings/soc/cvitek/base.txt
new file mode 100644
index 000000000000..01ac2304bd43
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/cvitek/base.txt
@@ -0,0 +1,6 @@
+Cvitek base driver
+
+This document describes the binding for the Cvitek base.
+
+Required properties:
+- compatible: "cvitek,base"
diff --git a/Documentation/devicetree/bindings/soc/cvitek/bt_pin.txt b/Documentation/devicetree/bindings/soc/cvitek/bt_pin.txt
new file mode 100644
index 000000000000..5e1a5eb4805e
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/cvitek/bt_pin.txt
@@ -0,0 +1,5 @@
+Cvitek bluetooth pin driver
+
+Required properties:
+- compatible: "cvitek,bt-pin"
+- power-gpio: bluetooth chip power on gpio
\ No newline at end of file
diff --git a/Documentation/devicetree/bindings/soc/cvitek/cif.txt b/Documentation/devicetree/bindings/soc/cvitek/cif.txt
new file mode 100644
index 000000000000..6ce8a7d09cc7
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/cvitek/cif.txt
@@ -0,0 +1,8 @@
+Cvitek cif driver
+
+This document describes the binding for the Cvitek cif.
+
+Required properties:
+- compatible: "cvitek,cif"
+- reg: cif register regions
+- interrupts: cif interrupt number
diff --git a/Documentation/devicetree/bindings/soc/cvitek/fb.txt b/Documentation/devicetree/bindings/soc/cvitek/fb.txt
new file mode 100644
index 000000000000..f953cba80ced
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/cvitek/fb.txt
@@ -0,0 +1,8 @@
+Cvitek fb driver
+
+This document describes the binding for the Cvitek fb.
+
+Required properties:
+- compatible: "cvitek,fb"
+- reg: fb register regions
+- interrupts: display interrupt number
diff --git a/Documentation/devicetree/bindings/soc/cvitek/jpu.txt b/Documentation/devicetree/bindings/soc/cvitek/jpu.txt
new file mode 100644
index 000000000000..1f63e2f2c977
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/cvitek/jpu.txt
@@ -0,0 +1,8 @@
+Cvitek JPEG Driver
+
+This document describes the binding for Cvitek JPEG.
+
+Required properties:
+- compatible: "cvitek,jpeg"
+- reg: jpu register regions
+- interrupts: jpu interrupt number
diff --git a/Documentation/devicetree/bindings/soc/cvitek/mipi_tx.txt b/Documentation/devicetree/bindings/soc/cvitek/mipi_tx.txt
new file mode 100644
index 000000000000..f6e63cdbeccb
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/cvitek/mipi_tx.txt
@@ -0,0 +1,7 @@
+Cvitek mipi_tx driver
+
+This document describes the binding for the Cvitek vip.
+
+Required properties:
+- compatible: "cvitek,mipi_tx"
+- reg: mipi_tx register regions
diff --git a/Documentation/devicetree/bindings/soc/cvitek/pwm-cvitek.txt b/Documentation/devicetree/bindings/soc/cvitek/pwm-cvitek.txt
new file mode 100644
index 000000000000..84e40e80cdda
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/cvitek/pwm-cvitek.txt
@@ -0,0 +1,9 @@
+Cvitek PWM controller
+
+Required properties:
+- compatible: should be "cvitek,cvi-pwm"
+- reg: physical base address and length of the controller's registers
+- clocks: lable to the input clock
+- #pwm-cells: should be 1. See pwm.txt in this directory for a description of
+
+
diff --git a/Documentation/devicetree/bindings/soc/cvitek/rtc.txt b/Documentation/devicetree/bindings/soc/cvitek/rtc.txt
new file mode 100644
index 000000000000..3d25b3ebe98e
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/cvitek/rtc.txt
@@ -0,0 +1,8 @@
+Cvitek rtc driver
+
+This document describes the binding for the Cvitek rtc.
+
+Required properties:
+- compatible: "cvitek,rtc"
+- reg: rtc register regions
+- interrupts: rtc interrupt number
diff --git a/Documentation/devicetree/bindings/soc/cvitek/saradc.txt b/Documentation/devicetree/bindings/soc/cvitek/saradc.txt
new file mode 100644
index 000000000000..9f27a47035d7
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/cvitek/saradc.txt
@@ -0,0 +1,8 @@
+Cvitek saradc driver
+
+This document describes the binding for the Cvitek saradc.
+
+Required properties:
+- compatible: "cvitek,saradc"
+- reg: saradc register regions
+- interrupts: saradc interrupt number
diff --git a/Documentation/devicetree/bindings/soc/cvitek/sysdma_remap.txt b/Documentation/devicetree/bindings/soc/cvitek/sysdma_remap.txt
new file mode 100644
index 000000000000..0a46f3a70e2f
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/cvitek/sysdma_remap.txt
@@ -0,0 +1,19 @@
+Cvitek sysDMA remap driver
+
+This document describes the binding for Cvitek sysDMA remap register.
+
+Required properties:
+- compatible: "cvitek,sysdma_remap"
+- reg: sysDMA remap register regions
+- ch-remap: assign device for each sysDMA remap channel.
+  There are maximum 16 channels can be assigned to remap register.
+  But be noted that sysDMA can only support 8 channels at one time.
+
+
+Example:
+	sysdma_remap {
+		compatible = "cvitek,sysdma_remap";
+		reg = <0x0 0x03000154 0x0 0x10>;
+		ch-remap = <CVI_I2S0_RX CVI_I2S0_TX CVI_I2S1_RX CVI_I2S1_TX
+					CVI_SPI_NAND CVI_SPI_NAND CVI_I2S3_RX CVI_I2S3_TX>;
+	};
\ No newline at end of file
diff --git a/Documentation/devicetree/bindings/soc/cvitek/tpu.txt b/Documentation/devicetree/bindings/soc/cvitek/tpu.txt
new file mode 100644
index 000000000000..b646dc769aa2
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/cvitek/tpu.txt
@@ -0,0 +1,8 @@
+Bitmain TPU driver
+
+Required properties:
+- compatible: "cvitek,tpu"
+- reg: TDMA and TIU engine's register regions
+- interrupts: TDMA interrupt number
+- resets: reset handles for TIU and TDMA
+- reset-names: should be "tiu" and "tdma"
diff --git a/Documentation/devicetree/bindings/soc/cvitek/vcodec.txt b/Documentation/devicetree/bindings/soc/cvitek/vcodec.txt
new file mode 100644
index 000000000000..4ef7466e5a5c
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/cvitek/vcodec.txt
@@ -0,0 +1,11 @@
+Cvitek Video Codec Driver
+
+This document describes the binding for Cvitek Video Codec.
+
+Required properties:
+- compatible: should be one of the following
+  - "cvitek,vcodec"
+  - "cvitek,cv1822-fpga-vcodec"
+  - "cvitek,cv1822-fpga-jpeg"
+- reg: vcodec register regions
+- interrupts: vcodec interrupt number
diff --git a/Documentation/devicetree/bindings/soc/cvitek/vip.txt b/Documentation/devicetree/bindings/soc/cvitek/vip.txt
new file mode 100644
index 000000000000..32b7c3d279ed
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/cvitek/vip.txt
@@ -0,0 +1,8 @@
+Cvitek vip driver
+
+This document describes the binding for the Cvitek vip.
+
+Required properties:
+- compatible: "cvitek,vip"
+- reg: vip register regions
+- interrupts: vip interrupt number
diff --git a/Documentation/devicetree/bindings/soc/cvitek/wiegand.txt b/Documentation/devicetree/bindings/soc/cvitek/wiegand.txt
new file mode 100644
index 000000000000..1095a5e00393
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/cvitek/wiegand.txt
@@ -0,0 +1,8 @@
+Cvitek wiegand driver
+
+This document describes the binding for the Cvitek vip.
+
+Required properties:
+- compatible: "cvitek,wiegand"
+- reg: wiegand register regions
+- interrupts: wiegand interrupt number
diff --git a/Documentation/devicetree/bindings/soc/cvitek/wifi_pin.txt b/Documentation/devicetree/bindings/soc/cvitek/wifi_pin.txt
new file mode 100644
index 000000000000..0213a3855a56
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/cvitek/wifi_pin.txt
@@ -0,0 +1,6 @@
+sCvitek wifi pin driver
+
+Required properties:
+- compatible: "cvitek,wifi-pin"
+- power-gpio: Wifi chip power on gpio
+- wakeup-gpio: Wifi chip wakeup gpio
\ No newline at end of file
diff --git a/Documentation/devicetree/bindings/sound/cvitek,cv182xa.yaml b/Documentation/devicetree/bindings/sound/cvitek,cv182xa.yaml
new file mode 100644
index 000000000000..91601c3608d0
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/cvitek,cv182xa.yaml
@@ -0,0 +1,76 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/sound/cvitek,cv182xa.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Cvitek CV181X cv182xa codec driver
+
+maintainers:
+  - Ethan Chen <ethan.chen@cvitek.com>
+
+description: |
+  The Cvitek CV181X cv182xa internal audio codec driver.
+
+properties:
+  compatible:
+    const: cvitek,cv182xa-adc
+    const: cvitek,cv182xa-dac
+    const: cvitek,cv182xaadc
+    const: cvitek,cv182xadac
+
+  reg:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  cvi,model:
+    maxItems: 1
+
+  clock-names:
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - clocks
+	- clock-names
+	- cvi,model
+additionalProperties: false
+
+examples:
+  # adc codec node:
+  - |
+	adc: adc@0300A100 {
+		compatible = "cvitek,cv182xaadc";
+		reg = <0x0 0x0300A100 0x0 0x100>;
+		clocks = <&i2s_mclk 0>;
+		clock-names = "i2sclk";
+		clk_source = <0x04130000>;
+	};
+
+  # dac codec node:
+  - |
+	dac: dac@0300A000 {
+		compatible = "cvitek,cv182xadac";
+		reg = <0x0 0x0300A000 0x0 0x100>;
+		clocks = <&i2s_mclk 0>;
+		clock-names = "i2sclk";
+	};
+
+  # sound_adc node:
+  - |
+	sound_adc {
+		compatible = "cvitek,cv182xa-adc";
+		cvi,model = "CV182XA";
+		cvi,card_name = "cv182xa_adc";
+	};
+
+  # sound_dac node:
+  - |
+	sound_dac {
+		compatible = "cvitek,cv182xa-dac";
+		cvi,model = "CV182XA";
+		cvi,card_name = "cv182xa_dac";
+	};
\ No newline at end of file
diff --git a/Documentation/devicetree/bindings/thermal/cvitek-cv180x-thermal.txt b/Documentation/devicetree/bindings/thermal/cvitek-cv180x-thermal.txt
new file mode 100644
index 000000000000..4d79a34aaa4e
--- /dev/null
+++ b/Documentation/devicetree/bindings/thermal/cvitek-cv180x-thermal.txt
@@ -0,0 +1,9 @@
+* CVITEK CV180X Thermal Driver
+
+** Required properties:
+- compatible : "cvitek,cv180x-thermal"
+- reg : Address range of the thermal registers.
+- interrupts : Should contain interrupt for thermal system.
+- clocks : The clocks for thermal(tempsen).
+- clock-names : Should be "clk_tempsen".
+- #thermal-sensor-cells : Should be <1>.
diff --git a/Documentation/devicetree/bindings/thermal/cvitek-cv181x-thermal.txt b/Documentation/devicetree/bindings/thermal/cvitek-cv181x-thermal.txt
new file mode 100644
index 000000000000..a80e6f3c28d8
--- /dev/null
+++ b/Documentation/devicetree/bindings/thermal/cvitek-cv181x-thermal.txt
@@ -0,0 +1,9 @@
+* CVITEK CV181X Thermal Driver
+
+** Required properties:
+- compatible : "cvitek,cv181x-thermal"
+- reg : Address range of the thermal registers.
+- interrupts : Should contain interrupt for thermal system.
+- clocks : The clocks for thermal(tempsen).
+- clock-names : Should be "clk_tempsen".
+- #thermal-sensor-cells : Should be <1>.
diff --git a/Documentation/devicetree/bindings/vendor-prefixes.yaml b/Documentation/devicetree/bindings/vendor-prefixes.yaml
index 2735be1a8470..daf1473df07e 100644
--- a/Documentation/devicetree/bindings/vendor-prefixes.yaml
+++ b/Documentation/devicetree/bindings/vendor-prefixes.yaml
@@ -249,6 +249,8 @@ patternProperties:
     description: Shenzen Chuangsiqi Technology Co.,Ltd.
   "^cubietech,.*":
     description: Cubietech, Ltd.
+  "^cvitek,.*":
+    description:  Cvitek Co., Ltd.
   "^cypress,.*":
     description: Cypress Semiconductor Corporation
   "^cznic,.*":
diff --git a/README.md b/README.md
new file mode 100644
index 000000000000..55571bed6438
--- /dev/null
+++ b/README.md
@@ -0,0 +1 @@
+Please follow buildroot tips to startup T-HEAD C9xx CPU's boards: [T-HEAD buildroot](https://github.com/T-head-Semi/buildroot)
diff --git a/arch/riscv/Kconfig b/arch/riscv/Kconfig
index b28fabfc91bf..c5349c31382a 100644
--- a/arch/riscv/Kconfig
+++ b/arch/riscv/Kconfig
@@ -27,6 +27,11 @@ config RISCV
 	select ARCH_HAS_SET_DIRECT_MAP
 	select ARCH_HAS_SET_MEMORY
 	select ARCH_HAS_STRICT_KERNEL_RWX if MMU
+	select ARCH_HAS_DMA_PREP_COHERENT if ARCH_CVITEK
+	select ARCH_HAS_SYNC_DMA_FOR_CPU if ARCH_CVITEK
+	select ARCH_HAS_SYNC_DMA_FOR_DEVICE if ARCH_CVITEK
+	select ARCH_HAS_DMA_WRITE_COMBINE if ARCH_CVITEK
+	select ARCH_HAS_DMA_MMAP_PGPROT if ARCH_CVITEK
 	select ARCH_OPTIONAL_KERNEL_RWX if ARCH_HAS_STRICT_KERNEL_RWX
 	select ARCH_OPTIONAL_KERNEL_RWX_DEFAULT
 	select ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT if MMU
@@ -36,6 +41,8 @@ config RISCV
 	select CLINT_TIMER if !MMU
 	select COMMON_CLK
 	select EDAC_SUPPORT
+	select DMA_DIRECT_REMAP if ARCH_CVITEK
+	select GENERIC_ALLOCATOR if ARCH_CVITEK
 	select GENERIC_ARCH_TOPOLOGY
 	select GENERIC_ATOMIC64 if !64BIT
 	select GENERIC_CLOCKEVENTS
@@ -73,6 +80,7 @@ config RISCV
 	select HAVE_PERF_EVENTS
 	select HAVE_PERF_REGS
 	select HAVE_PERF_USER_STACK_DUMP
+	select HAVE_REGS_AND_STACK_ACCESS_API if ARCH_CVITEK
 	select HAVE_STACKPROTECTOR
 	select HAVE_SYSCALL_TRACEPOINTS
 	select IRQ_DOMAIN
@@ -144,7 +152,6 @@ config KASAN_SHADOW_OFFSET
 	depends on KASAN_GENERIC
 	default 0xdfffffc800000000 if 64BIT
 	default 0xffffffff if 32BIT
-
 config ARCH_FLATMEM_ENABLE
 	def_bool y
 
@@ -324,7 +331,7 @@ menu "supported PMU type"
 
 config RISCV_BASE_PMU
 	bool "Base Performance Monitoring Unit"
-	def_bool y
+	def_bool n
 	help
 	  A base PMU that serves as a reference implementation and has limited
 	  feature of perf.  It can run on any RISC-V machines so serves as the
@@ -459,3 +466,4 @@ source "kernel/power/Kconfig"
 endmenu
 
 source "drivers/firmware/Kconfig"
+source "arch/riscv/mach-cvitek/Kconfig"
diff --git a/arch/riscv/Kconfig.socs b/arch/riscv/Kconfig.socs
index 8a55f6156661..e80c5ba2789f 100644
--- a/arch/riscv/Kconfig.socs
+++ b/arch/riscv/Kconfig.socs
@@ -48,4 +48,14 @@ config SOC_KENDRYTE_K210_DTB_BUILTIN
 	  This option should be selected if no bootloader is being used.
 	  If unsure, say Y.
 
+config ARCH_CVITEK
+	bool "CVITEK SoCs"
+	help
+	  This enables support for cvitek SoC platform hardware.
+
+config SOC_THEAD
+	bool "T-HEAD SoCs"
+	help
+	  This enables support for T-HEAD SoC platform hardware.
+
 endmenu
diff --git a/arch/riscv/Makefile b/arch/riscv/Makefile
index daa679440000..734f0d606622 100644
--- a/arch/riscv/Makefile
+++ b/arch/riscv/Makefile
@@ -26,6 +26,11 @@ ifeq ($(CONFIG_ARCH_RV64I),y)
 	KBUILD_CFLAGS += -mabi=lp64
 	KBUILD_AFLAGS += -mabi=lp64
 
+# workaround for C906 ldd performance issue
+ifeq ($(CONFIG_ARCH_CVITEK),y)
+	KBUILD_CFLAGS += -mno-ldd
+endif
+
 	KBUILD_LDFLAGS += -melf64lriscv
 else
 	BITS := 32
@@ -66,6 +71,8 @@ KBUILD_AFLAGS += -march=$(riscv-march-y)
 KBUILD_CFLAGS += -mno-save-restore
 KBUILD_CFLAGS += -DCONFIG_PAGE_OFFSET=$(CONFIG_PAGE_OFFSET)
 
+machine-$(CONFIG_ARCH_CVITEK)       += cvitek
+
 ifeq ($(CONFIG_CMODEL_MEDLOW),y)
 	KBUILD_CFLAGS += -mcmodel=medlow
 endif
diff --git a/arch/riscv/boot/dts/Makefile b/arch/riscv/boot/dts/Makefile
index ca1f8cbd78c0..9cf67bf345da 100644
--- a/arch/riscv/boot/dts/Makefile
+++ b/arch/riscv/boot/dts/Makefile
@@ -1,5 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 subdir-y += sifive
 subdir-y += kendryte
+subdir-y += thead
+subdir-y += cvitek
 
 obj-$(CONFIG_BUILTIN_DTB) := $(addsuffix /, $(subdir-y))
diff --git a/arch/riscv/boot/dts/cvitek/.gitignore b/arch/riscv/boot/dts/cvitek/.gitignore
new file mode 100644
index 000000000000..6ddb7382c247
--- /dev/null
+++ b/arch/riscv/boot/dts/cvitek/.gitignore
@@ -0,0 +1,3 @@
+*.dts
+*.dtsi
+!cv1835_asic.dtsi
\ No newline at end of file
diff --git a/arch/riscv/boot/dts/cvitek/Makefile b/arch/riscv/boot/dts/cvitek/Makefile
new file mode 100644
index 000000000000..18256fc93ad0
--- /dev/null
+++ b/arch/riscv/boot/dts/cvitek/Makefile
@@ -0,0 +1,5 @@
+dtb-$(CONFIG_ARCH_CVITEK) += $(foreach dts,$(patsubst %.dts,%.dtb,$(wildcard ${srctree}/${src}/*.dts)),$(notdir ${dts}))
+
+always          := $(dtb-y)
+subdir-y        := $(dts-dirs)
+clean-files     := *.dtb
diff --git a/arch/riscv/boot/dts/cvitek/cv1835_asic.dtsi b/arch/riscv/boot/dts/cvitek/cv1835_asic.dtsi
new file mode 100644
index 000000000000..ed794efb4cec
--- /dev/null
+++ b/arch/riscv/boot/dts/cvitek/cv1835_asic.dtsi
@@ -0,0 +1,1143 @@
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/reset/cv1835-resets.h>
+#include <dt-bindings/clock/cv1835-clock.h>
+#include <dt-bindings/dma/cv1835-dmamap.h>
+#include <dt-bindings/thermal/thermal.h>
+
+/dts-v1/;
+/memreserve/	0x0000000100000000 0x0000000000080000; // ATF (BL31 + BL32) 512KB
+/memreserve/	0x000000010FE00000 0x0000000000200000; // bootlogo (1024x768,yuv)
+
+/ {
+	compatible = "linux,dummy-virt";
+	#size-cells = <0x2>;
+	#address-cells = <0x2>;
+	interrupt-parent = <&gic>;
+
+	top_misc:top_misc_ctrl@3000000 {
+		compatible = "syscon";
+		reg = <0x0 0x03000000 0x0 0x8000>;
+	};
+
+	clk_rst: clk-reset-controller {
+		#reset-cells = <1>;
+		compatible = "cvitek,clk-reset";
+		reg = <0x0 0x03002000 0x0 0x8>;
+	};
+
+	osc: oscillator {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <25000000>;
+		clock-output-names = "osc";
+	};
+
+	clk: clock-controller {
+		compatible = "cvitek,cv1835-clk";
+		reg = <0x0 0x03002000 0x0 0x1000>;
+		clocks = <&osc>;
+		#clock-cells = <1>;
+	};
+
+
+
+	rst: reset-controller {
+		#reset-cells = <1>;
+		compatible = "cvitek,reset";
+		reg = <0x0 0x03003000 0x0 0x10>;
+	};
+
+	gic: interrupt-controller {
+		compatible = "arm,cortex-a15-gic";
+		ranges;
+		#size-cells = <0x2>;
+		#address-cells = <0x2>;
+		interrupt-controller;
+		#interrupt-cells = <0x3>;
+		reg = <0x0 0x01F01000 0x0 0x1000>,
+		      <0x0 0x01F02000 0x0 0x2000>;
+	};
+
+	pmu_a53 {
+		compatible = "arm,cortex-a53-pmu";
+		interrupts = <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&A53_0>,
+				     <&A53_1>;
+	};
+
+	psci {
+		migrate = <0xc4000005>;
+		cpu_on = <0xc4000003>;
+		cpu_off = <0x84000002>;
+		cpu_suspend = <0xc4000001>;
+		sys_poweroff = <0x84000008>;
+		sys_reset = <0x84000009>;
+		method = "smc";
+		compatible = "arm,psci-0.2", "arm,psci";
+	};
+
+	cpus {
+		#size-cells = <0x0>;
+		#address-cells = <0x1>;
+
+		A53_0: cpu@0 {
+			reg = <0x0>;
+			enable-method = "psci";
+			compatible = "arm,cortex-a53";
+			device_type = "cpu";
+			next-level-cache = <&CA53_L2>;
+		};
+
+		A53_1: cpu@1 {
+			reg = <0x1>;
+			enable-method = "psci";
+			compatible = "arm,cortex-a53";
+			device_type = "cpu";
+			next-level-cache = <&CA53_L2>;
+		};
+
+		CA53_L2: l2-cache0 {
+			compatible = "cache";
+		};
+	};
+
+	tpu {
+		compatible = "cvitek,tpu";
+		reg-names = "tdma", "tiu";
+		reg = <0x0 0x0C100000 0x0 0x1000>,
+			  <0x0 0x0C101000 0x0 0x1000>;
+		clocks = <&clk CV1835_CLK_TPU_AXI>, <&clk CV1835_CLK_TPU_FAB>;
+		clock-names = "clk_tpu_axi", "clk_tpu_fab";
+		interrupts = <GIC_SPI 79 IRQ_TYPE_EDGE_RISING>,
+			     <GIC_SPI 80 IRQ_TYPE_EDGE_RISING>;
+		resets = <&rst RST_TDMA>, <&rst RST_TPU>, <&rst RST_TPUSYS>;
+		reset-names = "res_tdma", "res_tpu", "res_tpusys";
+	};
+
+	wiegand1 {
+		compatible = "cvitek,wiegand";
+		reg-names = "wiegand";
+		reg = <0x0 0x03031000 0x0 0x1000>;
+		clocks = <&clk CV1835_CLK_WGN>, <&clk CV1835_CLK_WGN1>;
+		clock-names = "clk_wgn", "clk_wgn1";
+		interrupts = <GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>;
+		resets = <&rst RST_WGN1>;
+		reset-names = "res_wgn";
+	};
+
+	wiegand2 {
+		compatible = "cvitek,wiegand";
+		reg-names = "wiegand";
+		reg = <0x0 0x03032000 0x0 0x1000>;
+		clocks = <&clk CV1835_CLK_WGN>, <&clk CV1835_CLK_WGN2>;
+		clock-names = "clk_wgn", "clk_wgn1";
+		interrupts = <GIC_SPI 137 IRQ_TYPE_LEVEL_HIGH>;
+		resets = <&rst RST_WGN2>;
+		reset-names = "res_wgn";
+	};
+
+	saradc {
+		compatible = "cvitek,saradc";
+		reg-names = "saradc";
+		reg = <0x0 0x030F0000 0x0 0x1000>;
+		clocks = <&clk CV1835_CLK_SARADC>;
+		clock-names = "clk_saradc";
+		interrupts = <GIC_SPI 165 IRQ_TYPE_EDGE_RISING>;
+		resets = <&rst RST_SARADC>;
+		reset-names = "res_saradc";
+	};
+
+	rtc {
+		compatible = "cvitek,rtc";
+		reg = <0x0 0x03005000 0x0 0x1000>,<0x0 0x03004000 0x0 0x1000>;
+		interrupts = <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&clk CV1835_CLK_RTC_25M>;
+		clock-names = "clk_rtc";
+	};
+
+	cvitek-ion {
+		compatible = "cvitek,cvitek-ion";
+
+		heap_carveout@0 {
+			compatible = "cvitek,carveout";
+			memory-region = <&ion_reserved>;
+		};
+	};
+
+	timer {
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			<GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			<GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>,
+			<GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(2) | IRQ_TYPE_LEVEL_LOW)>;
+		always-on;
+		clock-frequency = <25000000>;
+		compatible = "arm,armv8-timer";
+	};
+
+	dmac: dma@0x4330000 {
+		compatible = "snps,dmac-bm";
+		reg = <0x0 0x04330000 0x0 0x1000>;
+		interrupts = <GIC_SPI 0 IRQ_TYPE_LEVEL_HIGH>;
+		clock-names = "clk_sdma_axi";
+		clocks = <&clk CV1835_CLK_SDMA_AXI>;
+
+		dma-channels = /bits/ 8 <8>;
+		#dma-cells = <3>;
+		dma-requests = /bits/ 8 <16>;
+		chan_allocation_order = /bits/ 8 <0>;
+		chan_priority = /bits/ 8 <1>;
+		block_size = <1024>;
+		dma-masters = /bits/ 8 <2>;
+		data-width = <4 4>; /* bytes */
+		axi_tr_width = <4>; /* bytes */
+		block-ts = <15>;
+	};
+
+	watchdog0: cv-wd@0x3010000 {
+		compatible = "snps,dw-wdt";
+		reg = <0x0 0x03010000 0x0 0x1000>;
+		interrupts = <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>;
+		resets = <&rst RST_WDT>;
+		clocks = <&pclk>;
+	};
+
+	pwm0: pwm@3060000 {
+		compatible = "cvitek,cvi-pwm";
+		reg = <0x0 0x3060000 0x0 0x1000>;
+		clocks = <&clk CV1835_CLK_APB_PWM>;
+		#pwm-cells = <1>;
+	};
+
+	pwm1: pwm@3061000 {
+		compatible = "cvitek,cvi-pwm";
+		reg = <0x0 0x3061000 0x0 0x1000>;
+		clocks = <&clk CV1835_CLK_APB_PWM>;
+		#pwm-cells = <2>;
+	};
+
+	pwm2: pwm@3062000 {
+		compatible = "cvitek,cvi-pwm";
+		reg = <0x0 0x3062000 0x0 0x1000>;
+		clocks = <&clk CV1835_CLK_APB_PWM>;
+		#pwm-cells = <3>;
+	};
+
+	pwm3: pwm@3063000 {
+		compatible = "cvitek,cvi-pwm";
+		reg = <0x0 0x3063000 0x0 0x1000>;
+		clocks = <&clk CV1835_CLK_APB_PWM>;
+		#pwm-cells = <4>;
+	};
+
+	pclk: pclk {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <25000000>;
+	};
+
+	spi0:spi0@04180000 {
+		compatible = "snps,dw-apb-ssi";
+		reg = <0x0 0x04180000 0x0 0x10000>;
+		interrupts = <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&clk CV1835_CLK_SPI>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		num-cs = <1>;
+	};
+
+	spi1:spi1@04190000 {
+		compatible = "snps,dw-apb-ssi";
+		reg = <0x0 0x04190000 0x0 0x10000>;
+		interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&clk CV1835_CLK_SPI>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		num-cs = <1>;
+	};
+
+	spi2:spi2@041A0000 {
+		compatible = "snps,dw-apb-ssi";
+		reg = <0x0 0x041A0000 0x0 0x10000>;
+		interrupts = <GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&clk CV1835_CLK_SPI>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		num-cs = <1>;
+	};
+
+	spi3:spi3@041B0000 {
+		compatible = "snps,dw-apb-ssi";
+		reg = <0x0 0x041B0000 0x0 0x10000>;
+		interrupts = <GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&clk CV1835_CLK_SPI>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		num-cs = <1>;
+	};
+
+	uart0: serial@04140000 {
+		compatible = "snps,dw-apb-uart";
+		reg = <0x0 0x04140000 0x0 0x1000>;
+		clock-frequency = <25000000>;
+		interrupts = <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		status = "okay";
+	};
+
+	uart1: serial@04150000 {
+		compatible = "snps,dw-apb-uart";
+		reg = <0x0 0x04150000 0x0 0x1000>;
+		clock-frequency = <25000000>;
+		interrupts = <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>;
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		status = "disabled";
+	};
+
+	uart2: serial@04160000 {
+		compatible = "snps,dw-apb-uart";
+		reg = <0x0 0x04160000 0x0 0x1000>;
+		clock-frequency = <25000000>;
+		interrupts = <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>;
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		status = "disabled";
+	};
+
+	uart3: serial@04170000 {
+		compatible = "snps,dw-apb-uart";
+		reg = <0x0 0x04170000 0x0 0x1000>;
+		clock-frequency = <25000000>;
+		interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>;
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		status = "disabled";
+	};
+
+	uart4: serial@041C0000 {
+		compatible = "snps,dw-apb-uart";
+		reg = <0x0 0x041C0000 0x0 0x1000>;
+		clock-frequency = <25000000>;
+		interrupts = <GIC_SPI 93 IRQ_TYPE_LEVEL_HIGH>;
+		reg-shift = <2>;
+		reg-io-width = <4>;
+		status = "disabled";
+	};
+
+	gpio0: gpio@03020000 {
+		compatible = "snps,dw-apb-gpio";
+		reg = <0x0 0x03020000 0x0 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		porta: gpio-controller@0 {
+			compatible = "snps,dw-apb-gpio-port";
+			bank-name = "porta";
+			gpio-controller;
+			#gpio-cells = <2>;
+			snps,nr-gpios = <32>;
+			reg = <0>;
+			interrupt-controller;
+			interrupts = <GIC_SPI 68 IRQ_TYPE_LEVEL_HIGH>;
+		};
+	};
+
+	gpio1: gpio@03021000 {
+		compatible = "snps,dw-apb-gpio";
+		reg = <0x0 0x03021000 0x0 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		portb: gpio-controller@1 {
+			compatible = "snps,dw-apb-gpio-port";
+			bank-name = "portb";
+			gpio-controller;
+			#gpio-cells = <2>;
+			snps,nr-gpios = <32>;
+			reg = <0>;
+			interrupt-controller;
+			interrupts = <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>;
+		};
+	};
+
+	gpio2: gpio@03022000 {
+		compatible = "snps,dw-apb-gpio";
+		reg = <0x0 0x03022000 0x0 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		portc: gpio-controller@2 {
+			compatible = "snps,dw-apb-gpio-port";
+			bank-name = "portc";
+			gpio-controller;
+			#gpio-cells = <2>;
+			snps,nr-gpios = <32>;
+			reg = <0>;
+			interrupt-controller;
+			interrupts = <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>;
+		};
+	};
+
+	gpio3: gpio@03023000 {
+		compatible = "snps,dw-apb-gpio";
+		reg = <0x0 0x03023000 0x0 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		portd: gpio-controller@3 {
+			compatible = "snps,dw-apb-gpio-port";
+			bank-name = "portd";
+			gpio-controller;
+			#gpio-cells = <2>;
+			snps,nr-gpios = <12>;
+			reg = <0>;
+			interrupt-controller;
+			interrupts = <GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>;
+		};
+	};
+
+	i2c0: i2c@04000000 {
+		compatible = "snps,designware-i2c";
+		clocks = <&clk CV1835_CLK_I2C>;
+		reg = <0x0 0x04000000 0x0 0x1000>;
+		interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
+		clock-frequency = <400000>;
+
+		#size-cells = <0x0>;
+		#address-cells = <0x1>;
+		resets = <&rst RST_I2C0>;
+		reset-names = "i2c0";
+	};
+
+	i2c1: i2c@04010000 {
+		compatible = "snps,designware-i2c";
+		clocks = <&clk CV1835_CLK_I2C>;
+		reg = <0x0 0x04010000 0x0 0x1000>;
+		interrupts = <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>;
+		clock-frequency = <100000>;
+
+		#size-cells = <0x0>;
+		#address-cells = <0x1>;
+		resets = <&rst RST_I2C1>;
+		reset-names = "i2c1";
+	};
+
+	i2c2: i2c@04020000 {
+		compatible = "snps,designware-i2c";
+		clocks = <&clk CV1835_CLK_I2C>;
+		reg = <0x0 0x04020000 0x0 0x1000>;
+		interrupts = <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>;
+		clock-frequency = <100000>;
+		resets = <&rst RST_I2C2>;
+		reset-names = "i2c2";
+	};
+
+	i2c3: i2c@04030000 {
+		compatible = "snps,designware-i2c";
+		clocks = <&clk CV1835_CLK_I2C>;
+		reg = <0x0 0x04030000 0x0 0x1000>;
+		interrupts = <GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>;
+		clock-frequency = <400000>;
+		resets = <&rst RST_I2C3>;
+		reset-names = "i2c3";
+	};
+
+	i2c4: i2c@04040000 {
+		compatible = "snps,designware-i2c";
+		clocks = <&clk CV1835_CLK_I2C>;
+		reg = <0x0 0x04040000 0x0 0x1000>;
+		interrupts = <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>;
+		clock-frequency = <100000>;
+		resets = <&rst RST_I2C4>;
+		reset-names = "i2c4";
+	};
+
+	eth_csrclk: eth_csrclk {
+		clock-output-names = "eth_csrclk";
+		clock-frequency = <250000000>;
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+	};
+
+	eth_ptpclk: eth_ptpclk {
+		clock-output-names = "eth_ptpclk";
+		clock-frequency = <50000000>;
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+	};
+
+	stmmac_axi_setup: stmmac-axi-config {
+		snps,wr_osr_lmt = <1>;
+		snps,rd_osr_lmt = <2>;
+		snps,blen = <4 8 16 0 0 0 0>;
+	};
+
+	mtl_rx_setup: rx-queues-config {
+		snps,rx-queues-to-use = <4>;
+		queue0 {};
+		queue1 {};
+		queue2 {};
+		queue3 {};
+	};
+
+	mtl_tx_setup: tx-queues-config {
+		snps,tx-queues-to-use = <4>;
+		queue0 {};
+		queue1 {};
+		queue2 {};
+		queue3 {};
+	};
+
+	ethernet0: ethernet@4510000 {
+		compatible = "cvitek,ethernet";
+		reg = <0x0 0x04510000 0x0 0x10000>;
+		interrupt-names = "macirq";
+		interrupts = <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>;
+		clock-names = "stmmaceth", "ptp_ref", "clk_500m_eth", "clk_axi4_eth";
+		clocks = <&eth_csrclk>, <&eth_ptpclk>, <&clk CV1835_CLK_500M_ETH0>, <&clk CV1835_CLK_AXI4_ETH0>;
+		//phy-reset-gpios = <&portb 20 0>;
+		ephy_ctl_reg = <0x3009000>;
+
+		/* no hash filter and perfect filter support */
+		snps,multicast-filter-bins = <0>;
+		snps,perfect-filter-entries = <1>;
+
+		snps,txpbl = <16>;
+		snps,rxpbl = <16>;
+		snps,aal;
+
+		snps,axi-config = <&stmmac_axi_setup>;
+		snps,mtl-rx-config = <&mtl_rx_setup>;
+		snps,mtl-tx-config = <&mtl_tx_setup>;
+	};
+
+	ethernet1: ethernet@04520000 {
+		compatible = "cvitek,ethernet";
+		reg = <0x0 0x04520000 0x0 0x10000>;
+		interrupts = <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "macirq";
+		clock-names = "stmmaceth", "ptp_ref", "clk_500m_eth", "clk_axi4_eth";
+		clocks = <&eth_csrclk>, <&eth_ptpclk>, <&clk CV1835_CLK_500M_ETH1>, <&clk CV1835_CLK_AXI4_ETH1>;
+		phy-reset-gpios = <&portb 20 0>;
+
+		/* no hash filter and perfect filter support */
+		snps,multicast-filter-bins = <0>;
+		snps,perfect-filter-entries = <1>;
+
+		snps,txpbl = <16>;
+		snps,rxpbl = <16>;
+		snps,aal;
+
+		snps,axi-config = <&stmmac_axi_setup>;
+		snps,mtl-rx-config = <&mtl_rx_setup>;
+		snps,mtl-tx-config = <&mtl_tx_setup>;
+
+	};
+
+	spinand:cv-spinf@4060000 {
+		compatible = "cvitek,cv1835-spinf";
+		reg = <0x0 0x4060000 0x0 0x1000>;
+		reg-names = "core_mem";
+		interrupts = <GIC_SPI 181 IRQ_TYPE_LEVEL_HIGH>;
+		bus-width = <4>;
+		dmas = <&dmac 4 1 1
+			&dmac 5 1 1>;
+		dma-names = "rx","tx";
+	};
+
+	emmc:cv-emmc@4300000 {
+		compatible = "cvitek,cv1835-emmc";
+		reg = <0x0 0x4300000 0x0 0x1000>;
+		reg-names = "core_mem";
+		interrupts = <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
+		bus-width = <4>;
+		non-removable;
+		max-frequency = <200000000>;
+		no-sdio;
+		no-sd;
+	};
+
+
+	sd:cv-sd@4310000 {
+		compatible = "cvitek,cv1835-sd";
+		reg = <0x0 0x4310000 0x0 0x1000>;
+		reg-names = "core_mem";
+		interrupts = <GIC_SPI 59 IRQ_TYPE_LEVEL_HIGH>;
+		bus-width = <4>;
+		cap-sd-highspeed;
+		cap-mmc-highspeed;
+		sd-uhs-sdr12;
+		sd-uhs-sdr25;
+		sd-uhs-sdr50;
+		sd-uhs-sdr104;
+		max-frequency = <200000000>;
+		no-sdio;
+		no-mmc;
+	};
+
+	spif:cvi-spif@10000000 {
+		compatible = "cvitek,cvi-spif";
+		reg = <0x0 0x10000000 0x0 0x2000000>;
+		reg-names = "spif";
+		interrupts = <GIC_SPI 64 IRQ_TYPE_LEVEL_HIGH>;
+		sck-div = <3>;
+		flash {
+			compatible = "jedec,spi-nor";
+			spi-rx-bus-width = <1>;
+			spi-tx-bus-width = <1>;
+		};
+	};
+
+	wifisd:wifi-sd@4320000 {
+		compatible = "cvitek,cv1835-sdio";
+		reg = <0x0 0x4320000 0x0 0x1000>;
+		reg-names = "core_mem";
+		interrupts = <GIC_SPI 23 IRQ_TYPE_LEVEL_HIGH>;
+		bus-width = <4>;
+		max-frequency = <50000000>;
+		no-mmc;
+		no-sd;
+	};
+
+	i2s_mclk: i2s_mclk {
+		clock-output-names = "i2s_mclk";
+		clock-frequency = <24576000>;
+		#clock-cells = <0x0>;
+		compatible = "fixed-clock";
+	};
+
+	i2s_subsys {
+		compatible = "cvitek,i2s_tdm_subsys";
+		reg = <0x0 0x04108000 0x0 0x100>;
+		clocks = <&i2s_mclk>, <&clk CV1835_CLK_A0PLL>,
+			<&clk CV1835_CLK_SDMA_AUD0>, <&clk CV1835_CLK_SDMA_AUD1>,
+			<&clk CV1835_CLK_SDMA_AUD2>, <&clk CV1835_CLK_SDMA_AUD3>;
+		clock-names = "i2sclk", "clk_a0pll",
+			"clk_sdma_aud0", "clk_sdma_aud1",
+			"clk_sdma_aud2", "clk_sdma_aud3";
+		master_base = <0x04110000>; /* I2S1 is master, only useful while using multi I2S IPs work on same IO */
+	};
+
+	sysdma_remap {
+		compatible = "cvitek,sysdma_remap";
+		reg = <0x0 0x03000154 0x0 0x10>;
+		ch-remap = <CVI_I2S0_RX CVI_I2S2_TX CVI_I2S1_RX CVI_I2S1_TX
+					CVI_SPI_NAND CVI_SPI_NAND CVI_I2S2_RX CVI_I2S3_TX>;
+	};
+
+	mipi_rx: cif {
+		compatible = "cvitek,cif";
+		reg = <0x0 0x0a0c2000 0x0 0x2000>, <0x0 0x0300b000 0x0 0x1000>,
+			<0x0 0x0a0c4000 0x0 0x2000>, <0x0 0x0300d000 0x0 0x1000>;
+		reg-names = "csi_mac0", "csi_wrap0", "csi_mac1", "csi_wrap1";
+		interrupts = <GIC_SPI 155 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "csi0", "csi1";
+		snsr-reset = <&portd 7 GPIO_ACTIVE_LOW>, <&portd 7 GPIO_ACTIVE_LOW>;
+		resets = <&rst RST_CSIPHY0>, <&rst RST_CSIPHY1>,
+			<&rst RST_CSIPHY0RST_APB>, <&rst RST_CSIPHY1RST_APB>;
+		reset-names = "phy0", "phy1", "phy-apb0", "phy-apb1";
+		clocks = <&clk CV1835_CLK_CAM0>, <&clk CV1835_CLK_CAM1>, <&clk CV1835_CLK_SRC_VIP_SYS_2>,
+			<&clk CV1835_CLK_DIV_0_SRC_VIP_SYS_2>, <&clk CV1835_CLK_DIV_1_SRC_VIP_SYS_2>;
+		clock-names = "clk_cam0", "clk_cam1", "clk_sys_2", "clk_div_0_src_vip_sys_2",
+				"clk_div_1_src_vip_sys_2";
+	};
+
+	mipi_tx {
+		compatible = "cvitek,mipi_tx";
+		clocks = <&clk CV1835_CLK_DSI_MAC_VIP>, <&clk CV1835_CLK_DISP_VIP>;
+		clock-names = "clk_dsi", "clk_disp";
+		reset-gpio = <&portb 5 GPIO_ACTIVE_LOW>;
+		pwm-gpio = <&portb 3 GPIO_ACTIVE_HIGH>;
+		power-ct-gpio = <&portb 4 GPIO_ACTIVE_HIGH>;
+		interrupts = <GIC_SPI 174 IRQ_TYPE_LEVEL_HIGH>;
+	};
+
+	base {
+		compatible = "cvitek,base";
+	};
+
+	vip {
+		compatible = "cvitek,vip";
+		memory-region = <&vip_reserved>;
+		reg = <0x0 0x0a080000 0x0 0x10000>,<0x0 0x0a0a0000 0x0 0x2000>,
+		      <0x0 0x0a0c8000 0x0 0xa0>,<0x0 0x0a000000 0x0 0x80000>,
+		      <0x0 0x0300c000 0x0 0x100>;
+		reg-names = "sc","dwa","vip_sys","isp","dphy";
+		interrupts = <GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 157 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "sc","dwa","isp";
+		cvitek,cif-modules = <&mipi_rx>;
+		clocks = <&clk CV1835_CLK_AXI_VIP>, <&clk CV1835_CLK_SRC_VIP_SYS_0>,
+			<&clk CV1835_CLK_SRC_VIP_SYS_1>, <&clk CV1835_CLK_SRC_VIP_SYS_2>,
+			<&clk CV1835_CLK_ISP_TOP_VIP>, <&clk CV1835_CLK_IMG_D_VIP>,
+			<&clk CV1835_CLK_IMG_V_VIP>, <&clk CV1835_CLK_SC_TOP_VIP>,
+			<&clk CV1835_CLK_SC_D_VIP>, <&clk CV1835_CLK_SC_V1_VIP>,
+			<&clk CV1835_CLK_SC_V2_VIP>, <&clk CV1835_CLK_SC_V3_VIP>,
+			<&clk CV1835_CLK_DWA_VIP>, <&clk CV1835_CLK_BT_VIP>,
+			<&clk CV1835_CLK_DISP_VIP>, <&clk CV1835_CLK_DSI_MAC_VIP>,
+			<&clk CV1835_CLK_CSI_MAC0_VIP>, <&clk CV1835_CLK_CSI_MAC1_VIP>;
+		clock-names = "clk_axi", "clk_sys_0",
+			"clk_sys_1", "clk_sys_2",
+			"clk_isp_top", "clk_img_d",
+			"clk_img_v", "clk_sc_top",
+			"clk_sc_d", "clk_sc_v1",
+			"clk_sc_v2", "clk_sc_v3",
+			"clk_dwa", "clk_bt",
+			"clk_disp", "clk_dsi",
+			"clk_csi_mac0", "clk_csi_mac1";
+		clock-freq-vip-sys1 = <300000000>;
+	};
+
+	cvifb {
+		compatible = "cvitek,fb";
+		reg = <0x0 0x0a088000 0x0 0x1000>;
+		reg-names = "disp";
+		interrupts = <GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "sc";
+	};
+
+	vcodec {
+		compatible = "cvitek,vcodec";
+		memory-region = <&vcodec_reserved>;
+		reg = <0x0 0xb020000 0x0 0x10000>,<0x0 0xb010000 0x0 0x10000>;
+		reg-names = "h265", "h264";
+		clocks = <&clk CV1835_CLK_AXI_VIDEO_CODEC>,
+			<&clk CV1835_CLK_H264C>, <&clk CV1835_CLK_APB_H264C>,
+			<&clk CV1835_CLK_H265C>, <&clk CV1835_CLK_APB_H265C>,
+			<&clk CV1835_CLK_VC_SRC0>, <&clk CV1835_CLK_VC_SRC1>,
+			<&clk CV1835_CLK_VC_SRC2>, <&clk CV1835_CLK_CFG_REG_VC>;
+		clock-names = "clk_axi_video_codec",
+			"clk_h264c", "clk_apb_h264c",
+			"clk_h265c", "clk_apb_h265c",
+			"clk_vc_src0", "clk_vc_src1",
+			"clk_vc_src2", "clk_cfg_reg_vc";
+		interrupts = <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>,
+					 <GIC_SPI 76 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "h265","h264";
+	};
+
+	jpu {
+		compatible = "cvitek,jpeg";
+		reg = <0x0 0x0B000000 0x0 0x300>;
+		reg-names = "jpu";
+		clocks = <&clk CV1835_CLK_AXI_VIDEO_CODEC>,
+			<&clk CV1835_CLK_JPEG>, <&clk CV1835_CLK_APB_JPEG>,
+			<&clk CV1835_CLK_VC_SRC0>, <&clk CV1835_CLK_VC_SRC1>,
+			<&clk CV1835_CLK_VC_SRC2>, <&clk CV1835_CLK_CFG_REG_VC>;
+		clock-names = "clk_axi_video_codec",
+			"clk_jpeg", "clk_apb_jpeg",
+			"clk_vc_src0", "clk_vc_src1",
+			"clk_vc_src2", "clk_cfg_reg_vc";
+		interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "jpu";
+		resets = <&rst RST_JPEG>;
+		reset-names = "jpeg";
+	};
+
+	i2s0: i2s@04100000 {
+		compatible = "cvitek,cv1835-i2s";
+		reg = <0x0 0x04100000 0x0 0x2000>;
+		interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&i2s_mclk 0>;
+		clock-names = "i2sclk";
+		dev-id = <0>;
+		#sound-dai-cells = <0>;
+		dmas = <&dmac 0 1 1>; /* read channel */
+		dma-names = "rx";
+		capability = "rx"; /* I2S0 connect to internal ADC as RX */
+		mclk_out = "false";
+	};
+
+	i2s1: i2s@04110000 {
+		compatible = "cvitek,cv1835-i2s";
+		reg = <0x0 0x04110000 0x0 0x2000>;
+		interrupts = <GIC_SPI 8 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&i2s_mclk 0>;
+		clock-names = "i2sclk";
+		dev-id = <1>;
+		#sound-dai-cells = <0>;
+		dmas = <&dmac 2 1 1 /* read channel */
+			&dmac 3 1 1>; /* write channel */
+		dma-names = "rx", "tx";
+		capability = "txrx";
+		mclk_out = "false";
+	};
+
+	i2s2: i2s@04120000 {
+		compatible = "cvitek,cv1835-i2s";
+		reg = <0x0 0x04120000 0x0 0x2000>;
+		interrupts = <GIC_SPI 128 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&i2s_mclk 0>;
+		clock-names = "i2sclk";
+		dev-id = <2>;
+		#sound-dai-cells = <0>;
+		dmas = <&dmac 6 1 1 /* read channel */
+			&dmac 1 1 1>; /* write channel */
+		dma-names = "rx", "tx";
+		capability = "txrx";
+		mclk_out = "false";
+
+	};
+
+	i2s3: i2s@04130000 {
+		compatible = "cvitek,cv1835-i2s";
+		reg = <0x0 0x04130000 0x0 0x2000>;
+		interrupts = <GIC_SPI 132 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&i2s_mclk 0>;
+		clock-names = "i2sclk";
+		dev-id = <3>;
+		#sound-dai-cells = <0>;
+		dmas = <&dmac 7 1 1>; /* write channel */
+		dma-names = "tx";
+		capability = "tx"; /* I2S3 connect to internal DAC as TX */
+		mclk_out = "false";
+	};
+
+	adc: adc@0300A000 {
+		compatible = "cvitek,cv1835adc";
+		reg = <0x0 0x0300A000 0x0 0x100>;
+		clocks = <&i2s_mclk 0>;
+		clock-names = "i2sclk";
+	};
+
+	dac: dac@0300A400 {
+		compatible = "cvitek,cv1835dac";
+		reg = <0x0 0x0300A400 0x0 0x100>;
+		clocks = <&i2s_mclk 0>;
+		clock-names = "i2sclk";
+	};
+
+	pdm: pdm@0x041D0C00 {
+		compatible = "cvitek,cv1835pdm";
+		reg = <0x0 0x041D0C00 0x0 0x100>;
+		clocks = <&i2s_mclk 0>;
+		clock-names = "i2sclk";
+	};
+
+	sound_adc {
+		compatible = "cvitek,cv1835-adc";
+		cvi,model = "CV1835";
+		cvi,card_name = "cvi_adc";
+	};
+
+	sound_dac {
+		compatible = "cvitek,cv1835-dac";
+		cvi,model = "CV1835";
+		cvi,card_name = "cvi_dac";
+	};
+
+	/* sound_PDM use PDM to transfer DMIC signal to I2S signal as audio input */
+	sound_PDM {
+		compatible = "cvitek,cv1835-pdm";
+		cvi,model = "CV1835";
+		cvi,card_name = "cv1835_internal_PDM";
+	};
+
+	sound_ext1 {
+		compatible = "cvitek,cv1835-adau1372";
+		cvi,model = "CV1835";
+		cvi,mode = "I2S";
+		cvi,fmt = "IBNF";
+		cvi,card_name = "cvi_sound_card_0";
+		cvi,slot_no=<2>;
+
+		dai@0 {
+			cvi,dai_name = "cv1835-i2s-1";
+			cvi,stream_name = "adau1372-aif";
+			cvi,cpu_dai_name = "4110000.i2s";
+			cvi,codec_dai_name = "adau1372-aif";
+			cvi,platform_name = "4110000.i2s";
+			cvi,codec_name = "adau1372.1-003c";
+			cvi,role = "master";
+		};
+		dai@1 {
+			cvi,dai_name = "cv1835-i2s-2";
+			cvi,stream_name = "adau1372-aif";
+			cvi,cpu_dai_name = "4120000.i2s";
+			cvi,codec_dai_name = "adau1372-aif";
+			cvi,platform_name = "4120000.i2s";
+			cvi,codec_name = "adau1372.1-003c";
+			cvi,role = "slave";
+		};
+	};
+
+	/* sound_ext2 use external codec */
+	sound_ext2 {
+		compatible = "cvitek,cv1835-adau1372";
+		cvi,model = "CV1835";
+		cvi,mode = "I2S";
+		cvi,fmt = "IBNF";
+		cvi,card_name = "cv1835_external_card";
+		cvi,slot_no=<2>;
+
+		dai@0 {
+			cvi,dai_name = "cv1835-i2s-2";
+			cvi,stream_name = "adau1372-aif";
+			cvi,cpu_dai_name = "4120000.i2s";
+			cvi,codec_dai_name = "adau1372-aif";
+			cvi,platform_name = "4120000.i2s";
+			cvi,codec_name = "adau1372.0-003c";
+			cvi,role = "master";
+		};
+		dai@1 {
+			cvi,dai_name = "cv1835-i2s-3";
+			cvi,stream_name = "adau1372-aif";
+			cvi,cpu_dai_name = "4130000.i2s";
+			cvi,codec_dai_name = "adau1372-aif";
+			cvi,platform_name = "4130000.i2s";
+			cvi,codec_name = "adau1372.0-003c";
+			cvi,role = "slave";
+		};
+	};
+
+	otg0:cvi-usb-otg@040C0000 {
+		compatible = "cvitek,usb-otg";
+		reg = <0x0 0x040C0000 0x0 0x10000>,
+			<0x0 0x03000064 0x0 0x04>,//ddr_addr_mode
+			<0x0 0x03000038 0x0 0x08>,//USB Control and Status Register 0
+			<0x0 0x03000048 0x0 0x08>;//USB PHY Control and Status Register
+		interrupts = <GIC_SPI 82 IRQ_TYPE_EDGE_RISING>;
+		clock-frequency = <25000000>;
+		clocks = <&clk CV1835_CLK_AXI4_USB>,
+				<&clk CV1835_CLK_APB_USB>,
+				<&clk CV1835_CLK_125M_USB>,
+				<&clk CV1835_CLK_33K_USB>,
+				<&clk CV1835_CLK_12M_USB>;
+		clock-names = "clk_axi", "clk_apb", "clk_125m", "clk_33k", "clk_12m";
+		//dr_mode		= "peripheral";
+		dr_mode		= "otg";
+		dis_ss = "true";
+		resets = <&rst RST_USB>;
+		reset-names = "usb";
+		vbus-gpio = <&portb 25 0>;
+		otg_bypass = "true";
+		status = "okay";
+	};
+
+	host0:cvi-usb-host@040D0000 {
+		compatible = "cvitek,xhci-platform";
+		reg = <0x0 0x040D0000 0x0 0x10000>;
+		interrupts = <GIC_SPI 85 IRQ_TYPE_EDGE_RISING>;
+		otg-controller = <&otg0>;
+		clock-frequency = <25000000>;
+		status = "okay";
+	};
+
+	usb0:cvi-usb-dev@040E0000 {
+		compatible = "cvitek,usb-dev";
+		reg = <0x0 0x040E0000 0x0 0x1000>;
+		interrupts = <GIC_SPI 83 IRQ_TYPE_EDGE_RISING>,
+			     <GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH>;
+		clock-frequency = <25000000>;
+		otg-controller = <&otg0>;
+		dma_mode = "new";
+		status = "okay";
+	};
+
+	thermal:thermal@030E0000 {
+		compatible = "cvitek,cv1835-thermal";
+		reg = <0x0 0x030E0000 0x0 0x10000>;
+		interrupts = <GIC_SPI 164 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "tempsen";
+		clocks = <&clk CV1835_CLK_TEMPSEN>;
+		clock-names = "clk_tempsen";
+		resets = <&rst RST_TEMPSEN>;
+		reset-names = "tempsen";
+		#thermal-sensor-cells = <1>;
+	};
+
+	cv1835_cooling:cv1835_cooling {
+		clocks = <&clk CV1835_CLK_A53>, <&clk CV1835_CLK_TPU_AXI>;
+		clock-names = "clk_a53", "clk_tpu_axi";
+		dev-freqs = <1000000000 650000000>,
+			<500000000 375000000>,
+			<500000000 100000000>;
+		compatible = "cvitek,cv1835-cooling";
+		#cooling-cells = <2>;
+	};
+
+	thermal-zones {
+		soc_thermal_0: soc_thermal_0 {
+			polling-delay-passive = <1000>; /* milliseconds */
+			polling-delay = <1000>; /* milliseconds */
+			thermal-sensors = <&thermal 0>;
+
+			trips {
+				soc_thermal_trip_0: soc_thermal_trip_0 {
+					temperature = <90000>; /* millicelsius */
+					hysteresis = <5000>; /* millicelsius */
+					type = "passive";
+				};
+
+				soc_thermal_trip_1: soc_thermal_trip_1 {
+					temperature = <100000>; /* millicelsius */
+					hysteresis = <5000>; /* millicelsius */
+					type = "passive";
+				};
+
+				soc_thermal_crtical_0: soc_thermal_crtical_0 {
+					temperature = <120000>; /* millicelsius */
+					hysteresis = <0>; /* millicelsius */
+					type = "critical";
+				};
+			};
+		};
+
+		soc_thermal_1: soc_thermal_1 {
+			polling-delay-passive = <1000>; /* milliseconds */
+			polling-delay = <1000>; /* milliseconds */
+			thermal-sensors = <&thermal 1>;
+		};
+	};
+
+	cvipctrl: pinctrl@3001000 {
+		compatible = "cvitek,pinctrl-cv1835";
+		reg = <0 0x03001000 0 0x1000>;
+		pinctrl-names = "nop", "nop";
+		pinctrl-0 = <>;
+		pinctrl-1 = <>;
+
+		nand_acquire: nand_acquire {
+			mux {
+				groups = "nand_grp";
+				function = "nand_a";
+			};
+		};
+		nand_release: nand_release{
+			mux {
+				groups = "null_grp";
+				function = "nand_r";
+			};
+		};
+		spi_acquire: spi_acquire {
+			mux {
+				groups = "spi_grp";
+				function = "spi_a";
+			};
+		};
+		spi_release: spi_release{
+			mux {
+				groups = "null_grp";
+				function = "spi_r";
+			};
+		};
+		emmc_acquire: emmc_acquire {
+			mux {
+				groups = "emmc_grp";
+				function = "emmc_a";
+			};
+		};
+		emmc_release: emmc_release{
+			mux {
+				groups = "null_grp";
+				function = "emmc_r";
+			};
+		};
+		uart0_acquire: uart0_acquire {
+			mux {
+				groups = "uart0_grp";
+				function = "uart0_a";
+			};
+		};
+		uart0_release: uart0_release{
+			mux {
+				groups = "null_grp";
+				function = "uart0_r";
+			};
+		};
+		pwm0_acquire: pwm0_acquire {
+			mux {
+				groups = "pwm0_grp";
+				function = "pwm0_a";
+			};
+		};
+		pwm0_release: pwm0_release{
+			mux {
+				groups = "null_grp";
+				function = "pwm0_r";
+			};
+		};
+		i2c0_acquire: i2c0_acquire {
+			mux {
+				groups = "i2c0_grp";
+				function = "i2c0_a";
+			};
+		};
+		i2c0_release: i2c0_release{
+			mux {
+				groups = "null_grp";
+				function = "i2c0_r";
+			};
+		};
+		eth1_acquire: eth1_acquire {
+			mux {
+				groups = "eth1_grp";
+				function = "eth1_a";
+			};
+		};
+		eth1_release: eth1_release{
+			mux {
+				groups = "null_grp";
+				function = "eth1_r";
+			};
+		};
+		i2s1_acquire: i2s1_acquire {
+			mux {
+				groups = "i2s1_grp";
+				function = "i2s1_a";
+			};
+		};
+		i2s1_release: i2s1_release{
+			mux {
+				groups = "null_grp";
+				function = "i2s1_r";
+			};
+		};
+		spi0_acquire: spi0_acquire {
+			mux {
+				groups = "spi0_grp";
+				function = "spi0_a";
+			};
+		};
+		spi0_release: spi0_release{
+			mux {
+				groups = "null_grp";
+				function = "spi0_r";
+			};
+		};
+	};
+
+	aliases {
+		serial0 = &uart0;
+		serial1 = &uart1;
+		serial2 = &uart2;
+		serial3 = &uart3;
+		serial4 = &uart4;
+		ethernet0 = &ethernet0;
+		ethernet1 = &ethernet1;
+	};
+
+	chosen {
+		stdout-path = "serial0"; // "serial0:115200n8", no arguments means no re-initialization
+	};
+
+	firmware {
+		optee {
+			compatible = "linaro,optee-tz";
+			method = "smc";
+		};
+	};
+	ramoops@0xE000000 {
+		compatible = "ramoops";
+		reg = <0 0xE000000 0 0xF000>;
+		ecc-size = <16>;
+		record-size = <0x4000>;
+		console-size = <0x4000>;
+		pmsg-size = <0x4000>;
+	};
+};
+
diff --git a/arch/riscv/boot/dts/thead/Makefile b/arch/riscv/boot/dts/thead/Makefile
new file mode 100644
index 000000000000..5cb939a097c9
--- /dev/null
+++ b/arch/riscv/boot/dts/thead/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0
+dtb-$(CONFIG_SOC_THEAD) += ice.dtb
+dtb-$(CONFIG_SOC_THEAD) += light_mpw.dtb
diff --git a/arch/riscv/boot/dts/thead/ice.dts b/arch/riscv/boot/dts/thead/ice.dts
new file mode 100644
index 000000000000..9c6e6e2e5313
--- /dev/null
+++ b/arch/riscv/boot/dts/thead/ice.dts
@@ -0,0 +1,399 @@
+/dts-v1/;
+/ {
+	model = "T-HEAD c910 ice";
+	compatible = "thead,c910_ice";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	memory@0 {
+		device_type = "memory";
+		/*
+		 * Total memory size: 4GB (0x00000000 0x100000000)
+		 * 0x00200000 - 0x0e0000000: 3407MB for Linux system
+		 * 0xe0000000 - 0x100000000:  512MB for GPU
+		 */
+		reg = <0x0 0x200000 0x0 0xdfe00000>;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		timebase-frequency = <3000000>;
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64imafdcsu";
+			mmu-type = "riscv,sv39";
+			cpu-freq = "1.2Ghz";
+			cpu-icache = "64KB";
+			cpu-dcache = "64KB";
+			cpu-l2cache = "2MB";
+			cpu-tlb = "1024 4-ways";
+			cpu-cacheline = "64Bytes";
+			cpu-vector = "0.7.1";
+			cpu0_intc: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+		cpu@1 {
+			device_type = "cpu";
+			reg = <1>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64imafdcsu";
+			mmu-type = "riscv,sv39";
+			cpu-freq = "1.2Ghz";
+			cpu-icache = "64KB";
+			cpu-dcache = "64KB";
+			cpu-l2cache = "2MB";
+			cpu-tlb = "1024 4-ways";
+			cpu-cacheline = "64Bytes";
+			cpu-vector = "0.7.1";
+			cpu1_intc: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+	};
+
+	soc {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		compatible = "simple-bus";
+		ranges;
+
+		reset: reset-sample {
+			compatible = "thead,reset-sample";
+			plic-delegate = <0x3 0xf01ffffc>;
+			using-csr-reset;
+			csr-copy = <
+				0x7c0 0x7c1 0x7c2 0x7c3 0x7c5 0x7cc
+				0x3b0 0x3b1 0x3b2 0x3b3
+				0x3b4 0x3b5 0x3b6 0x3b7
+				0x3a0
+				>;
+		};
+
+		clint0: clint@3f4000000 {
+			compatible = "riscv,clint0";
+			interrupts-extended = <
+				&cpu0_intc  3 &cpu0_intc  7
+				&cpu1_intc  3 &cpu1_intc  7
+				>;
+			reg = <0x3 0xf4000000 0x0 0x04000000>;
+			clint,has-no-64bit-mmio;
+		};
+
+		intc: interrupt-controller@3f0000000 {
+			#interrupt-cells = <1>;
+			compatible = "riscv,plic0";
+			interrupt-controller;
+			interrupts-extended = <
+				&cpu0_intc  0xffffffff &cpu0_intc  9
+				&cpu1_intc  0xffffffff &cpu1_intc  9
+				>;
+			reg = <0x3 0xf0000000 0x0 0x04000000>;
+			reg-names = "control";
+			riscv,max-priority = <7>;
+			riscv,ndev = <80>;
+		};
+
+		dummy_apb: apb-clock {
+			compatible = "fixed-clock";
+			clock-frequency = <62500000>;
+			clock-output-names = "dummy_apb";
+			#clock-cells = <0>;
+		};
+
+		dummy_ahb: ahb-clock {
+			compatible = "fixed-clock";
+			clock-frequency = <250000000>;
+			clock-output-names = "dummy_ahb";
+			#clock-cells = <0>;
+		};
+
+		dummy_axi: axi-clock {
+			compatible = "fixed-clock";
+			clock-frequency = <500000000>;
+			clock-output-names = "dummy_axi";
+			#clock-cells = <0>;
+		};
+
+		dummy_gmac: gmac-clock {
+			compatible = "fixed-clock";
+			clock-frequency = <1000000000>;
+			clock-output-names = "dummy_gmac";
+			#clock-cells = <0>;
+		};
+
+		dummy_clk_sdio: dummy-clk-sdio {
+			compatible = "fixed-clock";
+			clock-frequency = <150000000>;
+			clock-output-names = "dummy_clk_sdio";
+			#clock-cells = <0>;
+		};
+
+		usb: dwc3@3fff10000 {
+			compatible = "snps,dwc3";
+			reg = <0x3 0xfff10000 0x0 0x10000>;
+			interrupt-parent = <&intc>;
+			interrupts = <44>;
+			clocks = <&dummy_ahb>, <&dummy_ahb>, <&dummy_ahb>;
+			clock-names = "ref", "bus_early", "suspend";
+			maximum-speed = "super-speed";
+			dr_mode = "peripheral";
+			snps,usb3_lpm_capable;
+			snps,dis_u3_susphy_quirk;
+		};
+
+		gpio0: gpio@3fff71000 {
+			compatible = "snps,dw-apb-gpio";
+			reg = <0x3 0xfff71000 0x0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			/* GPIO0[0-31] */
+			gpio0_porta: gpio0-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <0>;
+
+				interrupt-controller;
+				#interrupt-cells = <2>;
+				interrupt-parent = <&intc>;
+				interrupts = <27>;
+			};
+
+			/* GPIO0[32-63] */
+			gpio0_portb: gpio0-controller@1 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <1>;
+			};
+		};
+
+		gpio1: gpio@3fff72000 {
+			compatible = "snps,dw-apb-gpio";
+			reg = <0x3 0xfff72000 0x0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			/* GPIO1[0-31] */
+			gpio1_porta: gpio1-controller@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <0>;
+			};
+
+			/* GPIO1[32-63] */
+			gpio1_portb: gpio1-controller@1 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <1>;
+			};
+
+			/* GPIO1[64-95] */
+			gpio1_portc: gpio1-controller@2 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				snps,nr-gpios = <32>;
+				reg = <2>;
+			};
+		};
+
+		gpio-leds {
+			compatible = "gpio-leds";
+
+			led0 { /* GPIO0[11] - UART2_TXD */
+				label = "led0";
+				gpios = <&gpio0_porta 11 1>;
+				default-state = "off";
+			};
+		};
+
+		gpio-keys {
+			compatible = "gpio-keys";
+			/* autorepeat; */
+
+			key_0 { /* GPIO0[10] - UART2_RXD */
+				gpios = <&gpio0_porta 10 1>;
+				linux,code = <59>;
+				label = "key_0";
+			};
+		};
+
+		i2c@3fff74000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "snps,designware-i2c-ice";
+			reg = <0x3 0xfff74000 0x0 0x1000>;
+			interrupts = <21>;
+			interrupt-parent = <&intc>;
+			clocks = <&dummy_apb>;
+			clock-frequency = <400000>;
+
+			eeprom@50 {
+				compatible = "atmel,24c64";
+				reg = <0x50>;
+				pagesize = <32>;
+			};
+
+			goodix_ts@14 {
+				#gpio-cells = <2>;
+				compatible = "goodix,gt917s";
+				reg = <0x14>;
+				interrupt-parent = <&gpio0_porta>;
+				interrupts = <31 0>;
+				irq-gpios = <&gpio0_porta 31 0>;
+				reset-gpios = <&gpio0_porta 30 0>;
+				touchscreen-size-x = <720>;
+				touchscreen-size-y = <1280>;
+			};
+		};
+
+		serial@3fff73000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x3 0xfff73000 0x0 0x400>;
+			interrupt-parent = <&intc>;
+			interrupts = <23>;
+			clocks = <&dummy_apb>;
+			clock-names = "baudclk";
+			reg-shift = <2>;
+			reg-io-width = <4>;
+		};
+
+		pmu: pmu {
+			interrupt-parent = <&cpu0_intc>;
+			interrupts = <17>;
+			compatible = "riscv,c910_pmu";
+		};
+
+		dmac0: dmac@3fffd0000 {
+			compatible = "snps,axi-dma-1.01a";
+			reg = <0x3 0xfffd0000 0x0 0x1000>;
+			interrupt-parent = <&intc>;
+			interrupts = <65>;
+			clocks = <&dummy_axi>, <&dummy_ahb>;
+			clock-names = "core-clk", "cfgr-clk";
+
+			dma-channels = <8>;
+			snps,block-size = <65536 65536 65536 65536 65536 65536 65536 65536>;
+			snps,priority = <0 1 2 3 4 5 6 7>;
+			snps,dma-masters = <1>;
+			snps,data-width = <4>;
+			snps,axi-max-burst-len = <16>;
+
+			status = "disabled";
+		};
+
+		sdhc0: sdhc0@3fffb0000 {
+			compatible = "snps,dw-mshc";
+			reg = <0x3 0xfffb0000 0x0 0x1000>;
+			interrupt-parent = <&intc>;
+			interrupts = <37>;
+			clocks = <&dummy_clk_sdio>, <&dummy_clk_sdio>;
+			clock-names = "ciu", "biu";
+			num-slots = <1>;
+			card-detect-delay = <200>;
+			cap-mmc-highspeed;
+			cap-cmd23;
+			non-removable;
+			bus-width = <8>;
+		};
+
+		sdhc1: sdhc1@3fffa0000 {
+			compatible = "snps,dw-mshc";
+			reg = <0x3 0xfffa0000 0x0 0x1000>;
+			interrupt-parent = <&intc>;
+			interrupts = <38>;
+			clocks = <&dummy_clk_sdio>, <&dummy_clk_sdio>;
+			clock-names = "ciu", "biu";
+			num-slots = <1>;
+			card-detect-delay = <200>;
+			cap-sd-highspeed;
+			bus-width = <4>;
+		};
+
+		stmmac_axi_setup: stmmac-axi-config {
+			snps,wr_osr_lmt = <3>;
+			snps,rd_osr_lmt = <3>;
+			snps,blen = <16 8 4 0 0 0 0>;
+		};
+
+		gmac: ethernet@3fffc0000 {
+			compatible = "thead,dwmac";
+			reg = < 0x3 0xfffc0000 0x0 0x2000
+				0x3 0xfe83025c 0x0 0x4
+				0x3 0xfe83031c 0x0 0x4
+				0x3 0xfff770c0 0x0 0x1c>;
+			reg-names = "gmac", "phy_if_reg", "txclk_dir_reg", "clk_mgr_reg";
+			interrupt-parent = <&intc>;
+			interrupts = <40>;
+			interrupt-names = "macirq";
+			clocks = <&dummy_ahb>, <&dummy_gmac>;
+			clock-names = "stmmaceth", "gmac_pll_clk";
+			snps,pbl = <32>;
+			snps,fixed-burst;
+			snps,axi-config = <&stmmac_axi_setup>;
+
+			phy-mode = "rgmii-id";
+			rx-clk-delay = <0x1f>; /* for RGMII */
+			tx-clk-delay = <0x1f>; /* for RGMII */
+
+			phy-handle = <&eth_phy_0>;
+			mdio0 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "snps,dwmac-mdio";
+
+				eth_phy_0: ethernet-phy@0 {
+					reg = <0>;
+				};
+			};
+		};
+
+		gpu: gpu@3fff27000 {
+			compatible = "verisilicon,gc8000ul";
+			reg = <0x3 0xfff27000 0x0 0x1000>;
+			interrupt-parent = <&intc>;
+			interrupts = <63>;
+			contiguous-base = <0x0 0xe0000000>;
+			contiguous-size = <0x0 0x20000000>;
+		};
+
+		watchdog: watchdog@3fffe3000 {
+			compatible = "ice,ice-wdt";
+			reg = <0x3 0xfffe3000 0x0 0x1000>;
+			interrupts = <20>;
+		};
+
+		dpu: dpu@3fff28000 {
+			compatible = "verisilicon,dc8000-fb";
+			reg = <0x3 0xfff28000 0x0 0x8000>;
+			interrupt-parent = <&intc>;
+			interrupts = <64>;
+		};
+	};
+
+	chosen {
+		/* bootargs = "console=ttyS0,115200 crashkernel=256M-:128M c910_mmu_v1"; */
+		/* linux,initrd-start = <0x2000000>; */
+		/* linux,initrd-end = <0x17000000>; */
+		bootargs = "console=ttyS0,115200 rdinit=/sbin/init root=/dev/mmcblk0p4 rw rootfstype=ext4 blkdevparts=mmcblk0:2M(table),2M(dtb),60M(kernel),-(rootfs) clk_ignore_unused loglevel=7 rootwait crashkernel=256M-:128M c910_mmu_v1";
+		stdout-path = "serial0@3fff73000:115200";
+	};
+};
diff --git a/arch/riscv/boot/dts/thead/light_mpw.dts b/arch/riscv/boot/dts/thead/light_mpw.dts
new file mode 100644
index 000000000000..9ded4be25d13
--- /dev/null
+++ b/arch/riscv/boot/dts/thead/light_mpw.dts
@@ -0,0 +1,259 @@
+/dts-v1/;
+/ {
+	model = "T-HEAD c910 light mpw";
+	compatible = "thead,c910_light_mpw";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x00200000 0x0 0xf0000000>;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		timebase-frequency = <0x2dc6c0>;
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64imafdcvsu";
+			mmu-type = "riscv,sv39";
+			cpu-freq = "1.5Ghz";
+			cpu-icache = "64KB";
+			cpu-dcache = "64KB";
+			cpu-l2cache = "2MB";
+			cpu-tlb = "1024 4-ways";
+			cpu-cacheline = "64Bytes";
+			cpu-vector = "0.7.1";
+			cpu0_intc: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+		cpu@1 {
+			device_type = "cpu";
+			reg = <1>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64imafdcvsu";
+			mmu-type = "riscv,sv39";
+			cpu-freq = "1.5Ghz";
+			cpu-icache = "64KB";
+			cpu-dcache = "64KB";
+			cpu-l2cache = "2MB";
+			cpu-tlb = "1024 4-ways";
+			cpu-cacheline = "64Bytes";
+			cpu-vector = "0.7.1";
+			cpu1_intc: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+		cpu@2 {
+			device_type = "cpu";
+			reg = <2>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64imafdcvsu";
+			mmu-type = "riscv,sv39";
+			cpu-freq = "1.5Ghz";
+			cpu-icache = "64KB";
+			cpu-dcache = "64KB";
+			cpu-l2cache = "2MB";
+			cpu-tlb = "1024 4-ways";
+			cpu-cacheline = "64Bytes";
+			cpu-vector = "0.7.1";
+			cpu2_intc: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+		cpu@3 {
+			device_type = "cpu";
+			reg = <3>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64imafdcvsu";
+			mmu-type = "riscv,sv39";
+			cpu-freq = "1.5Ghz";
+			cpu-icache = "64KB";
+			cpu-dcache = "64KB";
+			cpu-l2cache = "2MB";
+			cpu-tlb = "1024 4-ways";
+			cpu-cacheline = "64Bytes";
+			cpu-vector = "0.7.1";
+			cpu3_intc: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+	};
+
+	soc {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		compatible = "simple-bus";
+		ranges;
+
+		reset: reset-sample {
+			compatible = "thead,reset-sample";
+			plic-delegate = <0xff 0xd81ffffc>;
+			using-csr-reset;
+			csr-copy = <
+				0x7c0 0x7c1 0x7c2 0x7c3 0x7c5 0x7cc
+				0x3b0 0x3b1 0x3b2 0x3b3
+				0x3b4 0x3b5 0x3b6 0x3b7
+				0x3a0
+				>;
+		};
+
+		clint0: clint@ffdc000000 {
+			compatible = "riscv,clint0";
+			interrupts-extended = <
+				&cpu0_intc  3 &cpu0_intc  7
+				&cpu1_intc  3 &cpu1_intc  7
+				&cpu2_intc  3 &cpu2_intc  7
+				&cpu3_intc  3 &cpu3_intc  7
+				>;
+			reg = <0xff 0xdc000000 0x0 0x04000000>;
+			clint,has-no-64bit-mmio;
+		};
+
+		intc: interrupt-controller@ffd8000000 {
+			#interrupt-cells = <1>;
+			compatible = "riscv,plic0";
+			interrupt-controller;
+			interrupts-extended = <
+				&cpu0_intc  0xffffffff &cpu0_intc  9
+				&cpu1_intc  0xffffffff &cpu1_intc  9
+				&cpu2_intc  0xffffffff &cpu2_intc  9
+				&cpu3_intc  0xffffffff &cpu3_intc  9
+				>;
+			reg = <0xff 0xd8000000 0x0 0x08000000>;
+			reg-names = "control";
+			riscv,max-priority = <7>;
+			riscv,ndev = <80>;
+		};
+
+                clocks {
+			compatible = "simple-bus";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			dummy_apb: apb-clock {
+				compatible = "fixed-clock";
+				clock-frequency = <62500000>;
+				clock-output-names = "dummy_apb";
+				#clock-cells = <0>;
+			};
+
+			dummy_clock_sdhci: sdhci-clock {
+				compatible = "fixed-clock";
+				reg = <4>;	/* Not address, just for index */
+				clock-frequency = <198000000>;
+				clock-output-names = "dummy_clock_sdhci";
+				#clock-cells = <0>;
+			};
+
+			dummy_clock_gmac: gmac-clock {
+				compatible = "fixed-clock";
+				clock-frequency = <1000000000>;
+				clock-output-names = "dummy_clock_gmac";
+				#clock-cells = <0>;
+			};
+		};
+
+		serial@ffe7014000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0xff 0xe7014000 0x0 0x4000>;
+			interrupt-parent = <&intc>;
+			interrupts = <36>;
+			clocks = <&dummy_apb>;
+			clock-names = "baudclk";
+			reg-shift = <2>;
+			reg-io-width = <4>;
+		};
+
+		stmmac_axi_setup: stmmac-axi-config {
+			snps,wr_osr_lmt = <3>;
+			snps,rd_osr_lmt = <3>;
+			snps,blen = <16 8 4 0 0 0 0>;
+		};
+
+		gmac: ethernet@ffe7070000 {
+			compatible = "snps,dwmac";
+			reg = <0xff 0xe7070000 0x0 0x2000>;
+			interrupt-parent = <&intc>;
+			interrupts = <66>;
+			interrupt-names = "macirq";
+			clocks = <&dummy_clock_gmac>;
+			clock-names = "stmmaceth";
+			snps,pbl = <32>;
+			snps,fixed-burst;
+			snps,axi-config = <&stmmac_axi_setup>;
+
+			phy-mode = "rgmii-txid";
+			phy-handle = <&phy_88E1111>;
+			mdio0 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "snps,dwmac-mdio";
+
+				phy_88E1111: ethernet-phy@0 {
+					reg = <0x1>;
+				};
+			};
+		};
+
+		emmc: sdhci@ffe7080000 {
+			compatible = "snps,dwcmshc-sdhci-light-mpw";
+			reg = <0xff 0xe7080000 0x0 0x10000
+			       0xff 0xEF014060 0x0 0x4>;
+			interrupt-parent = <&intc>;
+			interrupts = <62>;
+			interrupt-names = "sdhciirq";
+			clocks = <&dummy_clock_sdhci>;
+			clock-names = "core";
+			max-frequency = <198000000>;
+			non-removable;
+			is_emmc;
+			no-sdio;
+			no-sd;
+			no-1-8-v;
+			bus-width = <8>;
+			status = "okay";
+		};
+
+		sdcard: sd@ffe7090000 {
+			compatible = "snps,dwcmshc-sdhci-light-mpw";
+			reg = <0xff 0xe7090000 0x0 0x10000
+                   	       0xff 0xEF014064 0x0 0x4>;
+			interrupt-parent = <&intc>;
+			interrupts = <64>;
+			interrupt-names = "sdhci0irq";
+			clocks = <&dummy_clock_sdhci>;
+			clock-names = "core";
+			max-frequency = <198000000>;
+			bus-width = <4>;
+			status = "okay";
+		};
+
+		pmu: pmu {
+			interrupt-parent = <&cpu0_intc>;
+			interrupts = <17>;
+			compatible = "riscv,c910_pmu";
+		};
+	};
+
+	chosen {
+		bootargs = "console=ttyS0,115200 root=PARTUUID=80a5a8e9-c744-491a-93c1-4f4194fd690b rootfstype=ext4 rdinit=/sbin/init rootwait rw earlyprintk clk_ignore_unused loglevel=7 eth=00:a0:a0:a0:a0:a1";
+		stdout-path = "/soc/serial@ffe7014000:115200";
+	};
+};
diff --git a/arch/riscv/configs/ice_defconfig b/arch/riscv/configs/ice_defconfig
new file mode 100644
index 000000000000..24f809f56361
--- /dev/null
+++ b/arch/riscv/configs/ice_defconfig
@@ -0,0 +1,185 @@
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_CGROUP_BPF=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EXPERT=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_PERF_EVENTS=y
+CONFIG_SOC_THEAD=y
+CONFIG_SMP=y
+CONFIG_VECTOR=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_ACORN_PARTITION=y
+CONFIG_ACORN_PARTITION_CUMANA=y
+CONFIG_ACORN_PARTITION_EESOX=y
+CONFIG_ACORN_PARTITION_ICS=y
+CONFIG_ACORN_PARTITION_ADFS=y
+CONFIG_ACORN_PARTITION_POWERTEC=y
+CONFIG_ACORN_PARTITION_RISCIX=y
+CONFIG_AIX_PARTITION=y
+CONFIG_OSF_PARTITION=y
+CONFIG_AMIGA_PARTITION=y
+CONFIG_ATARI_PARTITION=y
+CONFIG_MAC_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_LDM_PARTITION=y
+CONFIG_LDM_DEBUG=y
+CONFIG_SGI_PARTITION=y
+CONFIG_ULTRIX_PARTITION=y
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_SYSV68_PARTITION=y
+CONFIG_CMDLINE_PARTITION=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NETLINK_DIAG=y
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+CONFIG_NET_9P_DEBUG=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_SPI_NAND=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_VIRTIO_BLK=y
+CONFIG_EEPROM_AT24=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_NETDEVICES=y
+CONFIG_VIRTIO_NET=y
+CONFIG_MACB=y
+CONFIG_STMMAC_ETH=y
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_MARVELL_PHY=y
+# CONFIG_WLAN is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_MOUSE_PS2 is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_GOODIX=y
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=5
+CONFIG_SERIAL_8250_RUNTIME_UARTS=5
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_SERIAL_EARLYCON_RISCV_SBI=y
+CONFIG_HVC_RISCV_SBI=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_VIRTIO=y
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+CONFIG_I2C_DESIGNWARE_ICE=y
+CONFIG_SPI=y
+CONFIG_SPI_DESIGNWARE=y
+CONFIG_SPI_DW_MMIO=y
+# CONFIG_PTP_1588_CLOCK is not set
+CONFIG_GPIOLIB=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_DWAPB=y
+CONFIG_POWER_RESET=y
+CONFIG_POWER_SUPPLY=y
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_FB=y
+CONFIG_FB_VIRTUAL=m
+CONFIG_FB_SIMPLE=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_USB_DWC3=y
+# CONFIG_USB_DWC3_OF_SIMPLE is not set
+CONFIG_USB_GADGET=y
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+CONFIG_USB_ROLE_SWITCH=y
+CONFIG_MMC=y
+CONFIG_MMC_DEBUG=y
+CONFIG_MMC_DW=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_DMADEVICES=y
+CONFIG_DW_AXI_DMAC=y
+CONFIG_DMATEST=y
+CONFIG_SYNC_FILE=y
+CONFIG_VIRTIO_BALLOON=y
+CONFIG_VIRTIO_MMIO=y
+CONFIG_SIFIVE_PLIC=y
+CONFIG_GENERIC_PHY=y
+CONFIG_RAS=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_UTF8=y
+CONFIG_EXFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HFS_FS=y
+CONFIG_HFSPLUS_FS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_ROOT_NFS=y
+CONFIG_9P_FS=y
+CONFIG_9P_FS_POSIX_ACL=y
+CONFIG_9P_FS_SECURITY=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_1250=y
+CONFIG_NLS_CODEPAGE_1251=y
+CONFIG_LSM="lockdown,yama,loadpin,safesetid,integrity"
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_CRYPTO_DEV_VIRTIO=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_FS=y
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=60
+CONFIG_DEBUG_ATOMIC_SLEEP=y
+# CONFIG_RCU_TRACE is not set
diff --git a/arch/riscv/configs/vector_0_7_defconfig b/arch/riscv/configs/vector_0_7_defconfig
new file mode 100644
index 000000000000..fb84600fc796
--- /dev/null
+++ b/arch/riscv/configs/vector_0_7_defconfig
@@ -0,0 +1,189 @@
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_CGROUP_BPF=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EXPERT=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_PERF_EVENTS=y
+CONFIG_SOC_THEAD=y
+CONFIG_SMP=y
+CONFIG_VECTOR_0_7=y
+CONFIG_VECTOR=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_ACORN_PARTITION=y
+CONFIG_ACORN_PARTITION_CUMANA=y
+CONFIG_ACORN_PARTITION_EESOX=y
+CONFIG_ACORN_PARTITION_ICS=y
+CONFIG_ACORN_PARTITION_ADFS=y
+CONFIG_ACORN_PARTITION_POWERTEC=y
+CONFIG_ACORN_PARTITION_RISCIX=y
+CONFIG_AIX_PARTITION=y
+CONFIG_OSF_PARTITION=y
+CONFIG_AMIGA_PARTITION=y
+CONFIG_ATARI_PARTITION=y
+CONFIG_MAC_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_LDM_PARTITION=y
+CONFIG_LDM_DEBUG=y
+CONFIG_SGI_PARTITION=y
+CONFIG_ULTRIX_PARTITION=y
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_SYSV68_PARTITION=y
+CONFIG_CMDLINE_PARTITION=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NETLINK_DIAG=y
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+CONFIG_NET_9P_DEBUG=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_SPI_NAND=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_VIRTIO_BLK=y
+CONFIG_EEPROM_AT24=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_NETDEVICES=y
+CONFIG_VIRTIO_NET=y
+CONFIG_MACB=y
+CONFIG_STMMAC_ETH=y
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_MARVELL_PHY=y
+# CONFIG_WLAN is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_MOUSE_PS2 is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_GOODIX=y
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=5
+CONFIG_SERIAL_8250_RUNTIME_UARTS=5
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_SERIAL_EARLYCON_RISCV_SBI=y
+CONFIG_HVC_RISCV_SBI=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_VIRTIO=y
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+CONFIG_I2C_DESIGNWARE_ICE=y
+CONFIG_SPI=y
+CONFIG_SPI_DESIGNWARE=y
+CONFIG_SPI_DW_MMIO=y
+# CONFIG_PTP_1588_CLOCK is not set
+CONFIG_GPIOLIB=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_DWAPB=y
+CONFIG_POWER_RESET=y
+CONFIG_POWER_SUPPLY=y
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_FB=y
+CONFIG_FB_VIRTUAL=m
+CONFIG_FB_SIMPLE=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_USB_DWC3=y
+# CONFIG_USB_DWC3_OF_SIMPLE is not set
+CONFIG_USB_GADGET=y
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+CONFIG_USB_ROLE_SWITCH=y
+CONFIG_MMC=y
+CONFIG_MMC_DEBUG=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_OF_LIGHT_MPW=y
+CONFIG_MMC_DW=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_DMADEVICES=y
+CONFIG_DW_AXI_DMAC=y
+CONFIG_DMATEST=y
+CONFIG_SYNC_FILE=y
+CONFIG_VIRTIO_BALLOON=y
+CONFIG_VIRTIO_MMIO=y
+CONFIG_SIFIVE_PLIC=y
+CONFIG_GENERIC_PHY=y
+CONFIG_RAS=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_UTF8=y
+CONFIG_EXFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HFS_FS=y
+CONFIG_HFSPLUS_FS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_ROOT_NFS=y
+CONFIG_9P_FS=y
+CONFIG_9P_FS_POSIX_ACL=y
+CONFIG_9P_FS_SECURITY=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_1250=y
+CONFIG_NLS_CODEPAGE_1251=y
+CONFIG_LSM="lockdown,yama,loadpin,safesetid,integrity"
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_CRYPTO_DEV_VIRTIO=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_FS=y
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=60
+CONFIG_DEBUG_ATOMIC_SLEEP=y
+# CONFIG_RCU_TRACE is not set
diff --git a/arch/riscv/include/asm/bug.h b/arch/riscv/include/asm/bug.h
index d6f1ec08d97b..d3804a2f9aad 100644
--- a/arch/riscv/include/asm/bug.h
+++ b/arch/riscv/include/asm/bug.h
@@ -85,6 +85,7 @@ do {								\
 struct pt_regs;
 struct task_struct;
 
+void __show_regs(struct pt_regs *regs);
 void die(struct pt_regs *regs, const char *str);
 void do_trap(struct pt_regs *regs, int signo, int code, unsigned long addr);
 
diff --git a/arch/riscv/include/asm/cacheflush.h b/arch/riscv/include/asm/cacheflush.h
index 23ff70350992..a4d3ce5b91a6 100644
--- a/arch/riscv/include/asm/cacheflush.h
+++ b/arch/riscv/include/asm/cacheflush.h
@@ -42,6 +42,9 @@ void flush_icache_mm(struct mm_struct *mm, bool local);
 
 #endif /* CONFIG_SMP */
 
+void dma_wbinv_range(unsigned long start, unsigned long end);
+void dma_wb_range(unsigned long start, unsigned long end);
+
 /*
  * Bits in sys_riscv_flush_icache()'s flags argument.
  */
diff --git a/arch/riscv/include/asm/compat.h b/arch/riscv/include/asm/compat.h
new file mode 100644
index 000000000000..11f7c5b7e811
--- /dev/null
+++ b/arch/riscv/include/asm/compat.h
@@ -0,0 +1,266 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+#ifndef __ASM_COMPAT_H
+#define __ASM_COMPAT_H
+
+#define compat_mode_t	compat_mode_t
+typedef u16		compat_mode_t;
+
+/*
+ * Architecture specific compatibility types
+ */
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/sched/task_stack.h>
+#include <asm-generic/compat.h>
+
+#define COMPAT_USER_HZ		100
+#define COMPAT_UTS_MACHINE	"riscv\0\0"
+
+#define _COMPAT_NSIG		_NSIG
+#define _COMPAT_NSIG_BPW	32
+
+typedef compat_uint_t	__compat_uid_t;
+typedef compat_uint_t	__compat_gid_t;
+typedef compat_uint_t	__compat_uid32_t;
+typedef compat_uint_t	__compat_gid32_t;
+typedef compat_uint_t	compat_dev_t;
+typedef compat_int_t	compat_ipc_pid_t;
+
+typedef u32             compat_sigset_word;
+typedef u32		compat_caddr_t;
+struct compat_stat {
+	compat_ulong_t	st_dev;
+	compat_ulong_t	st_ino;
+	compat_uint_t	st_mode;
+	compat_uint_t	st_nlink;
+	compat_uint_t	st_uid;
+	compat_uint_t	st_gid;
+	compat_ulong_t	st_rdev;
+	compat_ulong_t	__pad1;
+	compat_long_t	st_size;
+	compat_int_t	st_blksize;
+	compat_int_t	__pad2;
+	compat_long_t	st_blocks;
+	compat_long_t	st_atime;
+	compat_ulong_t	st_atime_nsec;
+	compat_long_t	st_mtime;
+	compat_ulong_t	st_mtime_nsec;
+	compat_long_t	st_ctime;
+	compat_ulong_t	st_ctime_nsec;
+	compat_uint_t	__unused4;
+	compat_uint_t	__unused5;
+};
+
+struct compat_flock {
+	compat_short_t	l_type;
+	compat_short_t	l_whence;
+	compat_off_t	l_start;
+	compat_off_t	l_len;
+	compat_pid_t	l_pid;
+	/* No __ARCH_FLOCK_PAD in riscv */
+};
+
+#define F_GETLK64	12
+#define F_SETLK64	13
+#define F_SETLKW64	14
+
+struct compat_flock64 {
+	compat_short_t	l_type;
+	compat_short_t	l_whence;
+	compat_loff_t	l_start;
+	compat_loff_t	l_len;
+	compat_pid_t	l_pid;
+	/* No __ARCH_FLOCK64_PAD in riscv */
+};
+
+struct compat_statfs {
+	compat_uint_t	f_type;
+	compat_uint_t	f_bsize;
+	compat_uint_t	f_blocks;
+	compat_uint_t	f_bfree;
+	compat_uint_t	f_bavail;
+	compat_uint_t	f_files;
+	compat_uint_t	f_ffree;
+	__kernel_fsid_t	f_fsid;
+	compat_uint_t	f_namelen;
+	compat_uint_t	f_frsize;
+	compat_uint_t	f_flags;
+	compat_uint_t	f_spare[4];
+};
+
+#define COMPAT_RLIM_INFINITY	0x7fffffff
+#define COMPAT_OFF_T_MAX	COMPAT_RLIM_INFINITY
+
+struct compat_ipc64_perm {
+	compat_key_t key;
+	__compat_uid32_t uid;
+	__compat_gid32_t gid;
+	__compat_uid32_t cuid;
+	__compat_gid32_t cgid;
+	compat_mode_t	mode;
+	unsigned char	__pad1[4 - sizeof(compat_mode_t)];
+	compat_ushort_t	seq;
+	compat_ushort_t	__pad2;
+	compat_ulong_t	unused1;
+	compat_ulong_t	unused2;
+};
+
+struct compat_semid64_ds {
+	struct compat_ipc64_perm sem_perm;
+	compat_ulong_t sem_otime;
+	compat_ulong_t sem_otime_high;
+	compat_ulong_t sem_ctime;
+	compat_ulong_t sem_ctime_high;
+	compat_ulong_t sem_nsems;
+	compat_ulong_t __unused3;
+	compat_ulong_t __unused4;
+};
+
+struct compat_msqid64_ds {
+	struct compat_ipc64_perm msg_perm;
+	compat_ulong_t msg_stime;
+	compat_ulong_t msg_stime_high;
+	compat_ulong_t msg_rtime;
+	compat_ulong_t msg_rtime_high;
+	compat_ulong_t msg_ctime;
+	compat_ulong_t msg_ctime_high;
+	compat_ulong_t msg_cbytes;
+	compat_ulong_t msg_qnum;
+	compat_ulong_t msg_qbytes;
+	compat_pid_t   msg_lspid;
+	compat_pid_t   msg_lrpid;
+	compat_ulong_t __unused4;
+	compat_ulong_t __unused5;
+};
+
+struct compat_shmid64_ds {
+	struct compat_ipc64_perm shm_perm;
+	compat_size_t  shm_segsz;
+	compat_ulong_t shm_atime;
+	compat_ulong_t shm_atime_high;
+	compat_ulong_t shm_dtime;
+	compat_ulong_t shm_dtime_high;
+	compat_ulong_t shm_ctime;
+	compat_ulong_t shm_ctime_high;
+	compat_pid_t   shm_cpid;
+	compat_pid_t   shm_lpid;
+	compat_ulong_t shm_nattch;
+	compat_ulong_t __unused4;
+	compat_ulong_t __unused5;
+};
+
+static inline int is_compat_task(void)
+{
+	return test_thread_flag(TIF_32BIT);
+}
+
+struct compat_user_regs_struct {
+	compat_ulong_t pc;
+	compat_ulong_t ra;
+	compat_ulong_t sp;
+	compat_ulong_t gp;
+	compat_ulong_t tp;
+	compat_ulong_t t0;
+	compat_ulong_t t1;
+	compat_ulong_t t2;
+	compat_ulong_t s0;
+	compat_ulong_t s1;
+	compat_ulong_t a0;
+	compat_ulong_t a1;
+	compat_ulong_t a2;
+	compat_ulong_t a3;
+	compat_ulong_t a4;
+	compat_ulong_t a5;
+	compat_ulong_t a6;
+	compat_ulong_t a7;
+	compat_ulong_t s2;
+	compat_ulong_t s3;
+	compat_ulong_t s4;
+	compat_ulong_t s5;
+	compat_ulong_t s6;
+	compat_ulong_t s7;
+	compat_ulong_t s8;
+	compat_ulong_t s9;
+	compat_ulong_t s10;
+	compat_ulong_t s11;
+	compat_ulong_t t3;
+	compat_ulong_t t4;
+	compat_ulong_t t5;
+	compat_ulong_t t6;
+};
+
+static inline void regs_to_cregs(struct compat_user_regs_struct *cregs,
+				 struct pt_regs *regs)
+{
+	cregs->pc = (compat_ulong_t) regs->epc;
+	cregs->ra = (compat_ulong_t) regs->ra;
+	cregs->sp = (compat_ulong_t) regs->sp;
+	cregs->gp = (compat_ulong_t) regs->gp;
+	cregs->tp = (compat_ulong_t) regs->tp;
+	cregs->t0 = (compat_ulong_t) regs->t0;
+	cregs->t1 = (compat_ulong_t) regs->t1;
+	cregs->t2 = (compat_ulong_t) regs->t2;
+	cregs->s0 = (compat_ulong_t) regs->s0;
+	cregs->s1 = (compat_ulong_t) regs->s1;
+	cregs->a0 = (compat_ulong_t) regs->a0;
+	cregs->a1 = (compat_ulong_t) regs->a1;
+	cregs->a2 = (compat_ulong_t) regs->a2;
+	cregs->a3 = (compat_ulong_t) regs->a3;
+	cregs->a4 = (compat_ulong_t) regs->a4;
+	cregs->a5 = (compat_ulong_t) regs->a5;
+	cregs->a6 = (compat_ulong_t) regs->a6;
+	cregs->a7 = (compat_ulong_t) regs->a7;
+	cregs->s2 = (compat_ulong_t) regs->s2;
+	cregs->s3 = (compat_ulong_t) regs->s3;
+	cregs->s4 = (compat_ulong_t) regs->s4;
+	cregs->s5 = (compat_ulong_t) regs->s5;
+	cregs->s6 = (compat_ulong_t) regs->s6;
+	cregs->s7 = (compat_ulong_t) regs->s7;
+	cregs->s8 = (compat_ulong_t) regs->s8;
+	cregs->s9 = (compat_ulong_t) regs->s9;
+	cregs->s10 = (compat_ulong_t) regs->s10;
+	cregs->s11 = (compat_ulong_t) regs->s11;
+	cregs->t3 = (compat_ulong_t) regs->t3;
+	cregs->t4 = (compat_ulong_t) regs->t4;
+	cregs->t5 = (compat_ulong_t) regs->t5;
+	cregs->t6 = (compat_ulong_t) regs->t6;
+};
+
+static inline void cregs_to_regs(struct compat_user_regs_struct *cregs,
+				 struct pt_regs *regs)
+{
+	regs->epc = (unsigned long) cregs->pc;
+	regs->ra = (unsigned long) cregs->ra;
+	regs->sp = (unsigned long) cregs->sp;
+	regs->gp = (unsigned long) cregs->gp;
+	regs->tp = (unsigned long) cregs->tp;
+	regs->t0 = (unsigned long) cregs->t0;
+	regs->t1 = (unsigned long) cregs->t1;
+	regs->t2 = (unsigned long) cregs->t2;
+	regs->s0 = (unsigned long) cregs->s0;
+	regs->s1 = (unsigned long) cregs->s1;
+	regs->a0 = (unsigned long) cregs->a0;
+	regs->a1 = (unsigned long) cregs->a1;
+	regs->a2 = (unsigned long) cregs->a2;
+	regs->a3 = (unsigned long) cregs->a3;
+	regs->a4 = (unsigned long) cregs->a4;
+	regs->a5 = (unsigned long) cregs->a5;
+	regs->a6 = (unsigned long) cregs->a6;
+	regs->a7 = (unsigned long) cregs->a7;
+	regs->s2 = (unsigned long) cregs->s2;
+	regs->s3 = (unsigned long) cregs->s3;
+	regs->s4 = (unsigned long) cregs->s4;
+	regs->s5 = (unsigned long) cregs->s5;
+	regs->s6 = (unsigned long) cregs->s6;
+	regs->s7 = (unsigned long) cregs->s7;
+	regs->s8 = (unsigned long) cregs->s8;
+	regs->s9 = (unsigned long) cregs->s9;
+	regs->s10 = (unsigned long) cregs->s10;
+	regs->s11 = (unsigned long) cregs->s11;
+	regs->t3 = (unsigned long) cregs->t3;
+	regs->t4 = (unsigned long) cregs->t4;
+	regs->t5 = (unsigned long) cregs->t5;
+	regs->t6 = (unsigned long) cregs->t6;
+};
+
+#endif /* __ASM_COMPAT_H */
diff --git a/arch/riscv/include/asm/csr.h b/arch/riscv/include/asm/csr.h
index cec462e198ce..06a90ba24d9e 100644
--- a/arch/riscv/include/asm/csr.h
+++ b/arch/riscv/include/asm/csr.h
@@ -24,6 +24,21 @@
 #define SR_FS_CLEAN	_AC(0x00004000, UL)
 #define SR_FS_DIRTY	_AC(0x00006000, UL)
 
+#define SR_VS_OFF	_AC(0x00000000, UL)
+
+#if (defined(CONFIG_VECTOR_1_0) && defined(__THEAD_VERSION__))
+#define SR_VS		_AC(0x00000600, UL) /* Vector Status */
+#define SR_VS_INITIAL	_AC(0x00000200, UL)
+#define SR_VS_CLEAN	_AC(0x00000400, UL)
+#define SR_VS_DIRTY	_AC(0x00000600, UL)
+#else
+#define SR_VS		_AC(0x01800000, UL) /* Vector Status */
+#define SR_VS_INITIAL	_AC(0x00800000, UL)
+#define SR_VS_CLEAN	_AC(0x01000000, UL)
+#define SR_VS_DIRTY	_AC(0x01800000, UL)
+
+#endif
+
 #define SR_XS		_AC(0x00018000, UL) /* Extension Status */
 #define SR_XS_OFF	_AC(0x00000000, UL)
 #define SR_XS_INITIAL	_AC(0x00008000, UL)
@@ -36,6 +51,13 @@
 #define SR_SD		_AC(0x8000000000000000, UL) /* FS/XS dirty */
 #endif
 
+#ifdef CONFIG_COMPAT
+#define SR_UXL		_AC(0x300000000, UL) /* XLEN mask for U-mode */
+#define SR_UXL_32	_AC(0x100000000, UL) /* XLEN = 32 for U-mode */
+#define SR_UXL_64	_AC(0x200000000, UL) /* XLEN = 64 for U-mode */
+#define SR_UXL_SHIFT	32
+#endif
+
 /* SATP flags */
 #ifndef CONFIG_64BIT
 #define SATP_PPN	_AC(0x003FFFFF, UL)
@@ -45,6 +67,9 @@
 #define SATP_PPN	_AC(0x00000FFFFFFFFFFF, UL)
 #define SATP_MODE_39	_AC(0x8000000000000000, UL)
 #define SATP_MODE	SATP_MODE_39
+#define SATP_ASID_BITS	16
+#define SATP_ASID_SHIFT	44
+#define SATP_ASID_MASK	_AC(0xFFFF, UL)
 #endif
 
 /* Exception cause high bit - is an interrupt if set */
@@ -111,6 +136,18 @@
 #define CSR_PMPADDR0		0x3b0
 #define CSR_MHARTID		0xf14
 
+#define CSR_VSTART		0x8
+#define CSR_VXSAT		0x9
+#define CSR_VXRM		0xa
+#define CSR_VL			0xc20
+#define CSR_VTYPE		0xc21
+#define CSR_VLENB		0xc22
+
+#define CSR_SMIR		0x9c0
+#define CSR_SMEL		0x9c1
+#define CSR_SMEH		0x9c2
+#define CSR_SMCIR		0x9c3
+
 #ifdef CONFIG_RISCV_M_MODE
 # define CSR_STATUS	CSR_MSTATUS
 # define CSR_IE		CSR_MIE
diff --git a/arch/riscv/include/asm/elf.h b/arch/riscv/include/asm/elf.h
index 5c725e1df58b..3d109f285a4a 100644
--- a/arch/riscv/include/asm/elf.h
+++ b/arch/riscv/include/asm/elf.h
@@ -8,6 +8,8 @@
 #ifndef _ASM_RISCV_ELF_H
 #define _ASM_RISCV_ELF_H
 
+#include <uapi/linux/elf.h>
+#include <linux/compat.h>
 #include <uapi/asm/elf.h>
 #include <asm/auxvec.h>
 #include <asm/byteorder.h>
@@ -18,11 +20,13 @@
  */
 #define ELF_ARCH	EM_RISCV
 
+#ifndef ELF_CLASS
 #ifdef CONFIG_64BIT
 #define ELF_CLASS	ELFCLASS64
 #else
 #define ELF_CLASS	ELFCLASS32
 #endif
+#endif
 
 #define ELF_DATA	ELFDATA2LSB
 
@@ -31,6 +35,8 @@
  */
 #define elf_check_arch(x) ((x)->e_machine == EM_RISCV)
 
+#define compat_elf_check_arch(x) ((x)->e_machine == EM_RISCV)
+
 #define CORE_DUMP_USE_REGSET
 #define ELF_EXEC_PAGESIZE	(PAGE_SIZE)
 
@@ -57,11 +63,19 @@ extern unsigned long elf_hwcap;
  */
 #define ELF_PLATFORM	(NULL)
 
+#define COMPAT_ELF_PLATFORM	(NULL)
+
 #ifdef CONFIG_MMU
 #define ARCH_DLINFO						\
 do {								\
+	/*							\
+	 * Note that we add ulong after elf_addr_t because	\
+	 * casting current->mm->context.vdso triggers a cast	\
+	 * warning of cast from pointer to integer for		\
+	 * COMPAT ELFCLASS32.					\
+	 */							\
 	NEW_AUX_ENT(AT_SYSINFO_EHDR,				\
-		(elf_addr_t)current->mm->context.vdso);		\
+		(elf_addr_t)(ulong)current->mm->context.vdso);	\
 	NEW_AUX_ENT(AT_L1I_CACHESIZE,				\
 		get_cache_size(1, CACHE_TYPE_INST));		\
 	NEW_AUX_ENT(AT_L1I_CACHEGEOMETRY,			\
@@ -81,4 +95,28 @@ extern int arch_setup_additional_pages(struct linux_binprm *bprm,
 	int uses_interp);
 #endif /* CONFIG_MMU */
 
+#ifdef CONFIG_COMPAT
+
+#define SET_PERSONALITY(ex)					\
+do {    if ((ex).e_ident[EI_CLASS] == ELFCLASS32)		\
+		set_thread_flag(TIF_32BIT);			\
+	else							\
+		clear_thread_flag(TIF_32BIT);			\
+	if (personality(current->personality) != PER_LINUX32)	\
+		set_personality(PER_LINUX |			\
+			(current->personality & (~PER_MASK)));	\
+} while (0)
+
+#define COMPAT_ELF_ET_DYN_BASE		((TASK_SIZE_32 / 3) * 2)
+
+/* rv32 registers */
+typedef compat_ulong_t			compat_elf_greg_t;
+typedef compat_elf_greg_t		compat_elf_gregset_t[ELF_NGREG];
+
+extern int compat_arch_setup_additional_pages(struct linux_binprm *bprm,
+					      int uses_interp);
+#define compat_arch_setup_additional_pages \
+				compat_arch_setup_additional_pages
+
+#endif /* CONFIG_COMPAT */
 #endif /* _ASM_RISCV_ELF_H */
diff --git a/arch/riscv/include/asm/fixmap.h b/arch/riscv/include/asm/fixmap.h
index 54cbf07fb4e9..899b59bdb9eb 100644
--- a/arch/riscv/include/asm/fixmap.h
+++ b/arch/riscv/include/asm/fixmap.h
@@ -43,8 +43,6 @@ enum fixed_addresses {
 	__end_of_fixed_addresses
 };
 
-#define FIXMAP_PAGE_IO		PAGE_KERNEL
-
 #define __early_set_fixmap	__set_fixmap
 
 #define __late_set_fixmap	__set_fixmap
diff --git a/arch/riscv/include/asm/kprobes.h b/arch/riscv/include/asm/kprobes.h
index 56a98ea30731..4647d38018f6 100644
--- a/arch/riscv/include/asm/kprobes.h
+++ b/arch/riscv/include/asm/kprobes.h
@@ -11,4 +11,44 @@
 
 #include <asm-generic/kprobes.h>
 
+#ifdef CONFIG_KPROBES
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/percpu.h>
+
+#define __ARCH_WANT_KPROBES_INSN_SLOT
+#define MAX_INSN_SIZE			2
+
+#define flush_insn_slot(p)		do { } while (0)
+#define kretprobe_blacklist_size	0
+
+#include <asm/probes.h>
+
+struct prev_kprobe {
+	struct kprobe *kp;
+	unsigned int status;
+};
+
+/* Single step context for kprobe */
+struct kprobe_step_ctx {
+	unsigned long ss_pending;
+	unsigned long match_addr;
+};
+
+/* per-cpu kprobe control block */
+struct kprobe_ctlblk {
+	unsigned int kprobe_status;
+	unsigned long saved_status;
+	struct prev_kprobe prev_kprobe;
+	struct kprobe_step_ctx ss_ctx;
+};
+
+void arch_remove_kprobe(struct kprobe *p);
+int kprobe_fault_handler(struct pt_regs *regs, unsigned int trapnr);
+bool kprobe_breakpoint_handler(struct pt_regs *regs);
+bool kprobe_single_step_handler(struct pt_regs *regs);
+void kretprobe_trampoline(void);
+void __kprobes *trampoline_probe_handler(struct pt_regs *regs);
+
+#endif /* CONFIG_KPROBES */
 #endif /* _ASM_RISCV_KPROBES_H */
diff --git a/arch/riscv/include/asm/mmu.h b/arch/riscv/include/asm/mmu.h
index dabcf2cfb3dc..ac35dfe5e5f6 100644
--- a/arch/riscv/include/asm/mmu.h
+++ b/arch/riscv/include/asm/mmu.h
@@ -14,6 +14,8 @@ typedef struct {
 	unsigned long	end_brk;
 #endif
 	void *vdso;
+	atomic64_t asid;
+	void *vdso_info;
 #ifdef CONFIG_SMP
 	/* A local icache flush is needed before user execution can resume. */
 	cpumask_t icache_stale_mask;
diff --git a/arch/riscv/include/asm/page.h b/arch/riscv/include/asm/page.h
index 64a675c5c30a..21ce39641963 100644
--- a/arch/riscv/include/asm/page.h
+++ b/arch/riscv/include/asm/page.h
@@ -16,6 +16,12 @@
 #define PAGE_SIZE	(_AC(1, UL) << PAGE_SHIFT)
 #define PAGE_MASK	(~(PAGE_SIZE - 1))
 
+#if __riscv_xlen == 64
+#define LOAD_OFFSET	0x200000
+#else
+#define LOAD_OFFSET	0x400000
+#endif
+
 #ifdef CONFIG_64BIT
 #define HUGE_MAX_HSTATE		2
 #else
diff --git a/arch/riscv/include/asm/pgtable-64.h b/arch/riscv/include/asm/pgtable-64.h
index 0e863f3f7187..182bf96177c6 100644
--- a/arch/riscv/include/asm/pgtable-64.h
+++ b/arch/riscv/include/asm/pgtable-64.h
@@ -62,7 +62,7 @@ static inline void pud_clear(pud_t *pudp)
 
 static inline pmd_t *pud_pgtable(pud_t pud)
 {
-	return (pmd_t *)pfn_to_virt(pud_val(pud) >> _PAGE_PFN_SHIFT);
+	return (pmd_t *)pfn_to_virt((pud_val(pud) & _PAGE_CHG_MASK) >> _PAGE_PFN_SHIFT);
 }
 
 static inline struct page *pud_page(pud_t pud)
diff --git a/arch/riscv/include/asm/pgtable-bits.h b/arch/riscv/include/asm/pgtable-bits.h
index bbaeb5d35842..906420370444 100644
--- a/arch/riscv/include/asm/pgtable-bits.h
+++ b/arch/riscv/include/asm/pgtable-bits.h
@@ -24,6 +24,13 @@
 #define _PAGE_DIRTY     (1 << 7)    /* Set by hardware on any write */
 #define _PAGE_SOFT      (1 << 8)    /* Reserved for software */
 
+/* T-HEAD C9xx extend */
+#define _PAGE_SEC	(1UL << 59)   /* Security */
+#define _PAGE_SHARE	(1UL << 60)   /* Shareable */
+#define _PAGE_BUF	(1UL << 61)   /* Bufferable */
+#define _PAGE_CACHE	(1UL << 62)   /* Cacheable */
+#define _PAGE_SO	(1UL << 63)   /* Strong Order */
+
 #define _PAGE_SPECIAL   _PAGE_SOFT
 #define _PAGE_TABLE     _PAGE_PRESENT
 
@@ -38,6 +45,9 @@
 /* Set of bits to preserve across pte_modify() */
 #define _PAGE_CHG_MASK  (~(unsigned long)(_PAGE_PRESENT | _PAGE_READ |	\
 					  _PAGE_WRITE | _PAGE_EXEC |	\
-					  _PAGE_USER | _PAGE_GLOBAL))
+					  _PAGE_USER | _PAGE_GLOBAL |	\
+					  _PAGE_SEC | _PAGE_SHARE |	\
+					  _PAGE_BUF | _PAGE_CACHE |	\
+					  _PAGE_SO ))
 
 #endif /* _ASM_RISCV_PGTABLE_BITS_H */
diff --git a/arch/riscv/include/asm/pgtable.h b/arch/riscv/include/asm/pgtable.h
index b16304fdf448..83e62674cd73 100644
--- a/arch/riscv/include/asm/pgtable.h
+++ b/arch/riscv/include/asm/pgtable.h
@@ -76,9 +76,11 @@
 #define USER_PTRS_PER_PGD   (TASK_SIZE / PGDIR_SIZE)
 
 /* Page protection bits */
-#define _PAGE_BASE	(_PAGE_PRESENT | _PAGE_ACCESSED | _PAGE_USER)
+#define _PAGE_BASE	(_PAGE_PRESENT | _PAGE_ACCESSED | _PAGE_USER | \
+			 _PAGE_SHARE | _PAGE_CACHE | _PAGE_BUF)
 
-#define PAGE_NONE		__pgprot(_PAGE_PROT_NONE)
+#define PAGE_NONE		__pgprot(_PAGE_PROT_NONE | _PAGE_CACHE | \
+					 _PAGE_BUF | _PAGE_SHARE | _PAGE_SHARE)
 #define PAGE_READ		__pgprot(_PAGE_BASE | _PAGE_READ)
 #define PAGE_WRITE		__pgprot(_PAGE_BASE | _PAGE_READ | _PAGE_WRITE)
 #define PAGE_EXEC		__pgprot(_PAGE_BASE | _PAGE_EXEC)
@@ -95,8 +97,12 @@
 #define _PAGE_KERNEL		(_PAGE_READ \
 				| _PAGE_WRITE \
 				| _PAGE_PRESENT \
+				| _PAGE_GLOBAL \
 				| _PAGE_ACCESSED \
-				| _PAGE_DIRTY)
+				| _PAGE_DIRTY \
+				| _PAGE_CACHE \
+				| _PAGE_SHARE \
+				| _PAGE_BUF)
 
 #define PAGE_KERNEL		__pgprot(_PAGE_KERNEL)
 #define PAGE_KERNEL_READ	__pgprot(_PAGE_KERNEL & ~_PAGE_WRITE)
@@ -110,7 +116,16 @@
  * The RISC-V ISA doesn't yet specify how to query or modify PMAs, so we can't
  * change the properties of memory regions.
  */
-#define _PAGE_IOREMAP _PAGE_KERNEL
+#define _PAGE_IOREMAP		(_PAGE_READ \
+				| _PAGE_WRITE \
+				| _PAGE_PRESENT \
+				| _PAGE_GLOBAL \
+				| _PAGE_ACCESSED \
+				| _PAGE_DIRTY \
+				| _PAGE_SHARE \
+				| _PAGE_SO)
+
+#define PAGE_KERNEL_IO		__pgprot(_PAGE_IOREMAP)
 
 extern pgd_t swapper_pg_dir[];
 
@@ -178,18 +193,18 @@ static inline unsigned long _pgd_pfn(pgd_t pgd)
 
 static inline struct page *pmd_page(pmd_t pmd)
 {
-	return pfn_to_page(pmd_val(pmd) >> _PAGE_PFN_SHIFT);
+	return pfn_to_page((pmd_val(pmd) & _PAGE_CHG_MASK) >> _PAGE_PFN_SHIFT);
 }
 
 static inline unsigned long pmd_page_vaddr(pmd_t pmd)
 {
-	return (unsigned long)pfn_to_virt(pmd_val(pmd) >> _PAGE_PFN_SHIFT);
+	return (unsigned long)pfn_to_virt((pmd_val(pmd) & _PAGE_CHG_MASK) >> _PAGE_PFN_SHIFT);
 }
 
 /* Yields the page frame number (PFN) of a page table entry */
 static inline unsigned long pte_pfn(pte_t pte)
 {
-	return (pte_val(pte) >> _PAGE_PFN_SHIFT);
+	return ((pte_val(pte) & _PAGE_CHG_MASK) >> _PAGE_PFN_SHIFT);
 }
 
 #define pte_page(x)     pfn_to_page(pte_pfn(x))
@@ -406,6 +421,32 @@ static inline int ptep_clear_flush_young(struct vm_area_struct *vma,
 	return ptep_test_and_clear_young(vma, address, ptep);
 }
 
+#define __HAVE_PHYS_MEM_ACCESS_PROT
+struct file;
+extern pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
+				     unsigned long size, pgprot_t vma_prot);
+
+#define pgprot_noncached pgprot_noncached
+static inline pgprot_t pgprot_noncached(pgprot_t _prot)
+{
+	unsigned long prot = pgprot_val(_prot);
+
+	prot &= ~(_PAGE_CACHE | _PAGE_BUF);
+	prot |= _PAGE_SO;
+
+	return __pgprot(prot);
+}
+
+#define pgprot_writecombine pgprot_writecombine
+static inline pgprot_t pgprot_writecombine(pgprot_t _prot)
+{
+	unsigned long prot = pgprot_val(_prot);
+
+	prot &= ~(_PAGE_CACHE | _PAGE_BUF);
+
+	return __pgprot(prot);
+}
+
 /*
  * Encode and decode a swap entry
  *
@@ -446,7 +487,16 @@ static inline int ptep_clear_flush_young(struct vm_area_struct *vma,
  * Note that PGDIR_SIZE must evenly divide TASK_SIZE.
  */
 #ifdef CONFIG_64BIT
-#define TASK_SIZE (PGDIR_SIZE * PTRS_PER_PGD / 2)
+#define TASK_SIZE_64	(PGDIR_SIZE * PTRS_PER_PGD / 2)
+
+#ifdef CONFIG_COMPAT
+#define TASK_SIZE_32	(_AC(0x80000000, UL) - PAGE_SIZE)
+#define TASK_SIZE	(test_thread_flag(TIF_32BIT) ? \
+			 TASK_SIZE_32 : TASK_SIZE_64)
+#else
+#define TASK_SIZE	TASK_SIZE_64
+#endif
+
 #else
 #define TASK_SIZE FIXADDR_START
 #endif
diff --git a/arch/riscv/include/asm/probes.h b/arch/riscv/include/asm/probes.h
new file mode 100644
index 000000000000..a787e6d537b9
--- /dev/null
+++ b/arch/riscv/include/asm/probes.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef _ASM_RISCV_PROBES_H
+#define _ASM_RISCV_PROBES_H
+
+typedef u32 probe_opcode_t;
+typedef bool (probes_handler_t) (u32 opcode, unsigned long addr, struct pt_regs *);
+
+/* architecture specific copy of original instruction */
+struct arch_probe_insn {
+	probe_opcode_t *insn;
+	probes_handler_t *handler;
+	/* restore address after simulation */
+	unsigned long restore;
+};
+
+#ifdef CONFIG_KPROBES
+typedef u32 kprobe_opcode_t;
+struct arch_specific_insn {
+	struct arch_probe_insn api;
+};
+#endif
+
+#endif /* _ASM_RISCV_PROBES_H */
diff --git a/arch/riscv/include/asm/processor.h b/arch/riscv/include/asm/processor.h
index bdddcd5c1b71..770a11a51ec5 100644
--- a/arch/riscv/include/asm/processor.h
+++ b/arch/riscv/include/asm/processor.h
@@ -19,7 +19,11 @@
 #define TASK_UNMAPPED_BASE	PAGE_ALIGN(TASK_SIZE / 3)
 
 #define STACK_TOP		TASK_SIZE
+#ifdef CONFIG_64BIT
+#define STACK_TOP_MAX		TASK_SIZE_64
+#else
 #define STACK_TOP_MAX		STACK_TOP
+#endif
 #define STACK_ALIGN		16
 
 #ifndef __ASSEMBLY__
@@ -27,6 +31,15 @@
 struct task_struct;
 struct pt_regs;
 
+#ifdef CONFIG_VECTOR_EMU
+struct vsetvl_info {
+	unsigned long last_vector_pc;
+	unsigned long regid;
+	unsigned long vl;
+	unsigned long vtype;
+};
+#endif
+
 /* CPU-specific state of a task */
 struct thread_struct {
 	/* Callee-saved registers */
@@ -34,6 +47,11 @@ struct thread_struct {
 	unsigned long sp;	/* Kernel mode stack */
 	unsigned long s[12];	/* s[0]: frame pointer */
 	struct __riscv_d_ext_state fstate;
+	unsigned long bad_cause;
+	struct __riscv_v_state vstate;
+#ifdef CONFIG_VECTOR_EMU
+	struct vsetvl_info vsetvl_state;
+#endif
 };
 
 #define INIT_THREAD {					\
@@ -52,6 +70,12 @@ struct thread_struct {
 extern void start_thread(struct pt_regs *regs,
 			unsigned long pc, unsigned long sp);
 
+#ifdef CONFIG_COMPAT
+#define DEFAULT_MAP_WINDOW_64 TASK_SIZE_64
+#else
+#define DEFAULT_MAP_WINDOW_64 TASK_SIZE
+#endif
+
 /* Free all resources held by a thread. */
 static inline void release_thread(struct task_struct *dead_task)
 {
diff --git a/arch/riscv/include/asm/ptrace.h b/arch/riscv/include/asm/ptrace.h
index ee49f80c9533..cb4abb639e8d 100644
--- a/arch/riscv/include/asm/ptrace.h
+++ b/arch/riscv/include/asm/ptrace.h
@@ -8,6 +8,7 @@
 
 #include <uapi/asm/ptrace.h>
 #include <asm/csr.h>
+#include <linux/compiler.h>
 
 #ifndef __ASSEMBLY__
 
@@ -60,6 +61,7 @@ struct pt_regs {
 
 #define user_mode(regs) (((regs)->status & SR_PP) == 0)
 
+#define MAX_REG_OFFSET offsetof(struct pt_regs, orig_a0)
 
 /* Helpers for working with the instruction pointer */
 static inline unsigned long instruction_pointer(struct pt_regs *regs)
@@ -85,6 +87,12 @@ static inline void user_stack_pointer_set(struct pt_regs *regs,
 	regs->sp =  val;
 }
 
+/* Valid only for Kernel mode traps. */
+static inline unsigned long kernel_stack_pointer(struct pt_regs *regs)
+{
+	return regs->sp;
+}
+
 /* Helpers for working with the frame pointer */
 static inline unsigned long frame_pointer(struct pt_regs *regs)
 {
@@ -101,6 +109,33 @@ static inline unsigned long regs_return_value(struct pt_regs *regs)
 	return regs->a0;
 }
 
+static inline void regs_set_return_value(struct pt_regs *regs,
+					 unsigned long val)
+{
+	regs->a0 = val;
+}
+
+extern int regs_query_register_offset(const char *name);
+extern unsigned long regs_get_kernel_stack_nth(struct pt_regs *regs,
+					       unsigned int n);
+
+/**
+ * regs_get_register() - get register value from its offset
+ * @regs:	pt_regs from which register value is gotten
+ * @offset:	offset of the register.
+ *
+ * regs_get_register returns the value of a register whose offset from @regs.
+ * The @offset is the offset of the register in struct pt_regs.
+ * If @offset is bigger than MAX_REG_OFFSET, this returns 0.
+ */
+static inline unsigned long regs_get_register(struct pt_regs *regs,
+					      unsigned int offset)
+{
+	if (unlikely(offset > MAX_REG_OFFSET))
+		return 0;
+
+	return *(unsigned long *)((unsigned long)regs + offset);
+}
 #endif /* __ASSEMBLY__ */
 
 #endif /* _ASM_RISCV_PTRACE_H */
diff --git a/arch/riscv/include/asm/sbi.h b/arch/riscv/include/asm/sbi.h
index c0fdb05ffa0b..072c91f65da8 100644
--- a/arch/riscv/include/asm/sbi.h
+++ b/arch/riscv/include/asm/sbi.h
@@ -97,6 +97,9 @@ struct sbiret sbi_ecall(int ext, int fid, unsigned long arg0,
 
 void sbi_console_putchar(int ch);
 int sbi_console_getchar(void);
+long sbi_get_mvendorid(void);
+long sbi_get_marchid(void);
+long sbi_get_mimpid(void);
 void sbi_set_timer(uint64_t stime_value);
 void sbi_shutdown(void);
 void sbi_clear_ipi(void);
diff --git a/arch/riscv/include/asm/set_memory.h b/arch/riscv/include/asm/set_memory.h
index 4c5bae7ca01c..172e63d942b0 100644
--- a/arch/riscv/include/asm/set_memory.h
+++ b/arch/riscv/include/asm/set_memory.h
@@ -27,14 +27,14 @@ int set_direct_map_default_noflush(struct page *page);
 
 #endif /* __ASSEMBLY__ */
 
-#ifdef CONFIG_ARCH_HAS_STRICT_KERNEL_RWX
+#ifdef CONFIG_STRICT_KERNEL_RWX
 #ifdef CONFIG_64BIT
 #define SECTION_ALIGN (1 << 21)
 #else
 #define SECTION_ALIGN (1 << 22)
 #endif
-#else /* !CONFIG_ARCH_HAS_STRICT_KERNEL_RWX */
+#else /* !CONFIG_STRICT_KERNEL_RWX */
 #define SECTION_ALIGN L1_CACHE_BYTES
-#endif /* CONFIG_ARCH_HAS_STRICT_KERNEL_RWX */
+#endif /* CONFIG_STRICT_KERNEL_RWX */
 
 #endif /* _ASM_RISCV_SET_MEMORY_H */
diff --git a/arch/riscv/include/asm/stacktrace.h b/arch/riscv/include/asm/stacktrace.h
new file mode 100644
index 000000000000..3450c1912afd
--- /dev/null
+++ b/arch/riscv/include/asm/stacktrace.h
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef _ASM_RISCV_STACKTRACE_H
+#define _ASM_RISCV_STACKTRACE_H
+
+#include <linux/sched.h>
+#include <asm/ptrace.h>
+
+struct stackframe {
+	unsigned long fp;
+	unsigned long ra;
+};
+
+extern void notrace walk_stackframe(struct task_struct *task, struct pt_regs *regs,
+				    bool (*fn)(void *, unsigned long), void *arg);
+extern void dump_backtrace(struct pt_regs *regs, struct task_struct *task,
+			   const char *loglvl);
+
+#endif /* _ASM_RISCV_STACKTRACE_H */
diff --git a/arch/riscv/include/asm/switch_to.h b/arch/riscv/include/asm/switch_to.h
index 407bcc96a710..465275f89ed3 100644
--- a/arch/riscv/include/asm/switch_to.h
+++ b/arch/riscv/include/asm/switch_to.h
@@ -63,6 +63,52 @@ extern bool has_fpu;
 #define __switch_to_aux(__prev, __next) do { } while (0)
 #endif
 
+#ifdef CONFIG_VECTOR
+extern void __vstate_save(struct task_struct *save_to);
+extern void __vstate_restore(struct task_struct *restore_from);
+
+static inline void __vstate_clean(struct pt_regs *regs)
+{
+	regs->status |= (regs->status & ~(SR_VS)) | SR_VS_CLEAN;
+}
+
+static inline void vstate_save(struct task_struct *task,
+			       struct pt_regs *regs)
+{
+	if ((regs->status & SR_VS) == SR_VS_DIRTY) {
+		__vstate_save(task);
+		__vstate_clean(regs);
+	}
+}
+
+static inline void vstate_restore(struct task_struct *task,
+				  struct pt_regs *regs)
+{
+	if ((regs->status & SR_VS) != SR_VS_OFF) {
+		__vstate_restore(task);
+		__vstate_clean(regs);
+	}
+}
+
+static inline void __switch_to_vector(struct task_struct *prev,
+				   struct task_struct *next)
+{
+	struct pt_regs *regs;
+
+	regs = task_pt_regs(prev);
+	if (unlikely(regs->status & SR_SD))
+		vstate_save(prev, regs);
+	vstate_restore(next, task_pt_regs(next));
+}
+
+extern bool has_vector;
+#else
+#define has_vector false
+#define vstate_save(task, regs) do { } while (0)
+#define vstate_restore(task, regs) do { } while (0)
+#define __switch_to_vector(__prev, __next) do { } while (0)
+#endif
+
 extern struct task_struct *__switch_to(struct task_struct *,
 				       struct task_struct *);
 
@@ -72,6 +118,8 @@ do {							\
 	struct task_struct *__next = (next);		\
 	if (has_fpu)					\
 		__switch_to_aux(__prev, __next);	\
+	if (has_vector)					\
+		__switch_to_vector(__prev, __next);	\
 	((last) = __switch_to(__prev, __next));		\
 } while (0)
 
diff --git a/arch/riscv/include/asm/syscall.h b/arch/riscv/include/asm/syscall.h
index 49350c8bd7b0..6d34f858f843 100644
--- a/arch/riscv/include/asm/syscall.h
+++ b/arch/riscv/include/asm/syscall.h
@@ -15,7 +15,10 @@
 #include <linux/err.h>
 
 /* The array of function pointers for syscalls. */
-extern void *sys_call_table[];
+extern const void *sys_call_table[];
+#ifdef CONFIG_COMPAT
+extern const void *compat_sys_call_table[];
+#endif
 
 /*
  * Only the low 32 bits of orig_r0 are meaningful, so we return int.
diff --git a/arch/riscv/include/asm/thread_info.h b/arch/riscv/include/asm/thread_info.h
index c55e0a1f07a0..77d899b866f9 100644
--- a/arch/riscv/include/asm/thread_info.h
+++ b/arch/riscv/include/asm/thread_info.h
@@ -30,6 +30,10 @@
 #include <asm/processor.h>
 #include <asm/csr.h>
 
+#ifdef CONFIG_SET_FS
+typedef unsigned long mm_segment_t;
+#endif
+
 /*
  * low level task data that entry.S needs immediate access to
  * - this struct should fit entirely inside of one cache line
@@ -40,6 +44,9 @@
  */
 struct thread_info {
 	unsigned long		flags;		/* low level flags */
+#ifdef CONFIG_SET_FS
+	mm_segment_t            addr_limit;     /* address limit */
+#endif
 	int                     preempt_count;  /* 0=>preemptible, <0=>BUG */
 	/*
 	 * These stack pointers are overwritten on every system call or
@@ -56,11 +63,20 @@ struct thread_info {
  *
  * preempt_count needs to be 1 initially, until the scheduler is functional.
  */
+#ifdef CONFIG_SET_FS /* CONFIG_SET_FS */
+#define INIT_THREAD_INFO(tsk)			\
+{						\
+	.flags		= 0,			\
+	.preempt_count	= INIT_PREEMPT_COUNT,	\
+	.addr_limit	= KERNEL_DS,		\
+}
+#else /* CONFIG_SET_FS */
 #define INIT_THREAD_INFO(tsk)			\
 {						\
 	.flags		= 0,			\
 	.preempt_count	= INIT_PREEMPT_COUNT,	\
 }
+#endif /* CONFIG_SET_FS */
 
 #endif /* !__ASSEMBLY__ */
 
@@ -81,6 +97,8 @@ struct thread_info {
 #define TIF_SYSCALL_AUDIT	7	/* syscall auditing */
 #define TIF_SECCOMP		8	/* syscall secure computing */
 #define TIF_NOTIFY_SIGNAL	9	/* signal notifications exist */
+#define TIF_UPROBE		10	/* uprobe breakpoint or singlestep */
+#define TIF_32BIT		11	/* 32bit process */
 
 #define _TIF_SYSCALL_TRACE	(1 << TIF_SYSCALL_TRACE)
 #define _TIF_NOTIFY_RESUME	(1 << TIF_NOTIFY_RESUME)
@@ -90,10 +108,11 @@ struct thread_info {
 #define _TIF_SYSCALL_AUDIT	(1 << TIF_SYSCALL_AUDIT)
 #define _TIF_SECCOMP		(1 << TIF_SECCOMP)
 #define _TIF_NOTIFY_SIGNAL	(1 << TIF_NOTIFY_SIGNAL)
+#define _TIF_UPROBE		(1 << TIF_UPROBE)
 
 #define _TIF_WORK_MASK \
 	(_TIF_NOTIFY_RESUME | _TIF_SIGPENDING | _TIF_NEED_RESCHED | \
-	 _TIF_NOTIFY_SIGNAL)
+	 _TIF_NOTIFY_SIGNAL | _TIF_UPROBE)
 
 #define _TIF_SYSCALL_WORK \
 	(_TIF_SYSCALL_TRACE | _TIF_SYSCALL_TRACEPOINT | _TIF_SYSCALL_AUDIT | \
diff --git a/arch/riscv/include/asm/tlbflush.h b/arch/riscv/include/asm/tlbflush.h
index 394cfbccdcd9..d76ef8cd4a8c 100644
--- a/arch/riscv/include/asm/tlbflush.h
+++ b/arch/riscv/include/asm/tlbflush.h
@@ -13,13 +13,21 @@
 #ifdef CONFIG_MMU
 static inline void local_flush_tlb_all(void)
 {
+#ifdef CONFIG_NO_SFENCE_VMA
+	csr_write(CSR_SMCIR, 1 << 26);
+#else
 	__asm__ __volatile__ ("sfence.vma" : : : "memory");
+#endif
 }
 
 /* Flush one page from local TLB */
 static inline void local_flush_tlb_page(unsigned long addr)
 {
+#ifdef CONFIG_NO_SFENCE_VMA
+	csr_write(CSR_SMCIR, 1 << 26);
+#else
 	__asm__ __volatile__ ("sfence.vma %0" : : "r" (addr) : "memory");
+#endif
 }
 #else /* CONFIG_MMU */
 #define local_flush_tlb_all()			do { } while (0)
@@ -50,7 +58,18 @@ static inline void flush_tlb_range(struct vm_area_struct *vma,
 static inline void flush_tlb_kernel_range(unsigned long start,
 	unsigned long end)
 {
-	flush_tlb_all();
+#ifdef CONFIG_NO_SFENCE_VMA
+	csr_write(CSR_SMCIR, 1 << 26);
+#else
+	start &= PAGE_MASK;
+	end   += PAGE_SIZE - 1;
+	end   &= PAGE_MASK;
+
+	while (start < end) {
+		__asm__ __volatile__ ("sfence.vma %0" : : "r" (start) : "memory");
+		start += PAGE_SIZE;
+	}
+#endif
 }
 
 #endif /* _ASM_RISCV_TLBFLUSH_H */
diff --git a/arch/riscv/include/asm/uaccess.h b/arch/riscv/include/asm/uaccess.h
index 66af6abfe8af..7ef80183f45f 100644
--- a/arch/riscv/include/asm/uaccess.h
+++ b/arch/riscv/include/asm/uaccess.h
@@ -10,6 +10,31 @@
 
 #include <asm/pgtable.h>		/* for TASK_SIZE */
 
+#ifdef CONFIG_SET_FS
+/*
+ * The fs value determines whether argument validity checking should be
+ * performed or not.  If get_fs() == USER_DS, checking is performed, with
+ * get_fs() == KERNEL_DS, checking is bypassed.
+ *
+ * For historical reasons, these macros are grossly misnamed.
+ */
+#define KERNEL_DS      (~0UL)
+#define USER_DS                (TASK_SIZE)
+
+#define get_ds()       (KERNEL_DS)
+#define get_fs()       (current_thread_info()->addr_limit)
+
+static inline void set_fs(mm_segment_t fs)
+{
+	current_thread_info()->addr_limit = fs;
+}
+
+#define segment_eq(a, b) ((a) == (b))
+
+#define user_addr_max()        (get_fs())
+#define uaccess_kernel() segment_eq(get_fs(), KERNEL_DS)
+#endif /* CONFIG_SET_FS */
+
 /*
  * User space memory access functions
  */
diff --git a/arch/riscv/include/asm/uprobes.h b/arch/riscv/include/asm/uprobes.h
new file mode 100644
index 000000000000..f2183e00fdd2
--- /dev/null
+++ b/arch/riscv/include/asm/uprobes.h
@@ -0,0 +1,40 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+
+#ifndef _ASM_RISCV_UPROBES_H
+#define _ASM_RISCV_UPROBES_H
+
+#include <asm/probes.h>
+#include <asm/patch.h>
+#include <asm/bug.h>
+
+#define MAX_UINSN_BYTES		8
+
+#ifdef CONFIG_RISCV_ISA_C
+#define UPROBE_SWBP_INSN	__BUG_INSN_16
+#define UPROBE_SWBP_INSN_SIZE	2
+#else
+#define UPROBE_SWBP_INSN	__BUG_INSN_32
+#define UPROBE_SWBP_INSN_SIZE	4
+#endif
+#define UPROBE_XOL_SLOT_BYTES	MAX_UINSN_BYTES
+
+typedef u32 uprobe_opcode_t;
+
+struct arch_uprobe_task {
+	unsigned long   saved_cause;
+};
+
+struct arch_uprobe {
+	union {
+		u8 insn[MAX_UINSN_BYTES];
+		u8 ixol[MAX_UINSN_BYTES];
+	};
+	struct arch_probe_insn api;
+	unsigned long insn_size;
+	bool simulate;
+};
+
+bool uprobe_breakpoint_handler(struct pt_regs *regs);
+bool uprobe_single_step_handler(struct pt_regs *regs);
+
+#endif /* _ASM_RISCV_UPROBES_H */
diff --git a/arch/riscv/include/uapi/asm/elf.h b/arch/riscv/include/uapi/asm/elf.h
index d696d6610231..1a36fe6fee06 100644
--- a/arch/riscv/include/uapi/asm/elf.h
+++ b/arch/riscv/include/uapi/asm/elf.h
@@ -24,6 +24,8 @@ typedef __u64 elf_fpreg_t;
 typedef union __riscv_fp_state elf_fpregset_t;
 #define ELF_NFPREG (sizeof(struct __riscv_d_ext_state) / sizeof(elf_fpreg_t))
 
+#define ELF_NVREG  (sizeof(struct __riscv_v_state) / sizeof(elf_greg_t))
+
 #if __riscv_xlen == 64
 #define ELF_RISCV_R_SYM(r_info)		ELF64_R_SYM(r_info)
 #define ELF_RISCV_R_TYPE(r_info)	ELF64_R_TYPE(r_info)
diff --git a/arch/riscv/include/uapi/asm/hwcap.h b/arch/riscv/include/uapi/asm/hwcap.h
index 46dc3f5ee99f..c52bb7bbbabe 100644
--- a/arch/riscv/include/uapi/asm/hwcap.h
+++ b/arch/riscv/include/uapi/asm/hwcap.h
@@ -21,5 +21,6 @@
 #define COMPAT_HWCAP_ISA_F	(1 << ('F' - 'A'))
 #define COMPAT_HWCAP_ISA_D	(1 << ('D' - 'A'))
 #define COMPAT_HWCAP_ISA_C	(1 << ('C' - 'A'))
+#define COMPAT_HWCAP_ISA_V	(1 << ('V' - 'A'))
 
 #endif /* _UAPI_ASM_RISCV_HWCAP_H */
diff --git a/arch/riscv/include/uapi/asm/ptrace.h b/arch/riscv/include/uapi/asm/ptrace.h
index 882547f6bd5c..857a93910499 100644
--- a/arch/riscv/include/uapi/asm/ptrace.h
+++ b/arch/riscv/include/uapi/asm/ptrace.h
@@ -77,6 +77,15 @@ union __riscv_fp_state {
 	struct __riscv_q_ext_state q;
 };
 
+struct __riscv_v_state {
+	__uint128_t v[32];
+	unsigned long vstart;
+	unsigned long vxsat;
+	unsigned long vxrm;
+	unsigned long vl;
+	unsigned long vtype;
+};
+
 #endif /* __ASSEMBLY__ */
 
 #endif /* _UAPI_ASM_RISCV_PTRACE_H */
diff --git a/arch/riscv/include/uapi/asm/sigcontext.h b/arch/riscv/include/uapi/asm/sigcontext.h
index 84f2dfcfdbce..f74b3c814423 100644
--- a/arch/riscv/include/uapi/asm/sigcontext.h
+++ b/arch/riscv/include/uapi/asm/sigcontext.h
@@ -17,6 +17,7 @@
 struct sigcontext {
 	struct user_regs_struct sc_regs;
 	union __riscv_fp_state sc_fpregs;
+	struct __riscv_v_state sc_vregs;
 };
 
 #endif /* _UAPI_ASM_RISCV_SIGCONTEXT_H */
diff --git a/arch/riscv/include/uapi/asm/unistd.h b/arch/riscv/include/uapi/asm/unistd.h
index 8062996c2dfd..c9e50eed14aa 100644
--- a/arch/riscv/include/uapi/asm/unistd.h
+++ b/arch/riscv/include/uapi/asm/unistd.h
@@ -15,7 +15,7 @@
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  */
 
-#ifdef __LP64__
+#if defined(__LP64__) && !defined(__SYSCALL_COMPAT)
 #define __ARCH_WANT_NEW_STAT
 #define __ARCH_WANT_SET_GET_RLIMIT
 #endif /* __LP64__ */
diff --git a/arch/riscv/kernel/asm-offsets.c b/arch/riscv/kernel/asm-offsets.c
index db203442c08f..6069af41cb99 100644
--- a/arch/riscv/kernel/asm-offsets.c
+++ b/arch/riscv/kernel/asm-offsets.c
@@ -67,6 +67,45 @@ void asm_offsets(void)
 	OFFSET(TASK_THREAD_F31, task_struct, thread.fstate.f[31]);
 	OFFSET(TASK_THREAD_FCSR, task_struct, thread.fstate.fcsr);
 
+	OFFSET(TASK_THREAD_V0,  task_struct, thread.vstate.v[0]);
+	OFFSET(TASK_THREAD_V1,  task_struct, thread.vstate.v[1]);
+	OFFSET(TASK_THREAD_V2,  task_struct, thread.vstate.v[2]);
+	OFFSET(TASK_THREAD_V3,  task_struct, thread.vstate.v[3]);
+	OFFSET(TASK_THREAD_V4,  task_struct, thread.vstate.v[4]);
+	OFFSET(TASK_THREAD_V5,  task_struct, thread.vstate.v[5]);
+	OFFSET(TASK_THREAD_V6,  task_struct, thread.vstate.v[6]);
+	OFFSET(TASK_THREAD_V7,  task_struct, thread.vstate.v[7]);
+	OFFSET(TASK_THREAD_V8,  task_struct, thread.vstate.v[8]);
+	OFFSET(TASK_THREAD_V9,  task_struct, thread.vstate.v[9]);
+	OFFSET(TASK_THREAD_V10, task_struct, thread.vstate.v[10]);
+	OFFSET(TASK_THREAD_V11, task_struct, thread.vstate.v[11]);
+	OFFSET(TASK_THREAD_V12, task_struct, thread.vstate.v[12]);
+	OFFSET(TASK_THREAD_V13, task_struct, thread.vstate.v[13]);
+	OFFSET(TASK_THREAD_V14, task_struct, thread.vstate.v[14]);
+	OFFSET(TASK_THREAD_V15, task_struct, thread.vstate.v[15]);
+	OFFSET(TASK_THREAD_V16, task_struct, thread.vstate.v[16]);
+	OFFSET(TASK_THREAD_V17, task_struct, thread.vstate.v[17]);
+	OFFSET(TASK_THREAD_V18, task_struct, thread.vstate.v[18]);
+	OFFSET(TASK_THREAD_V19, task_struct, thread.vstate.v[19]);
+	OFFSET(TASK_THREAD_V20, task_struct, thread.vstate.v[20]);
+	OFFSET(TASK_THREAD_V21, task_struct, thread.vstate.v[21]);
+	OFFSET(TASK_THREAD_V22, task_struct, thread.vstate.v[22]);
+	OFFSET(TASK_THREAD_V23, task_struct, thread.vstate.v[23]);
+	OFFSET(TASK_THREAD_V24, task_struct, thread.vstate.v[24]);
+	OFFSET(TASK_THREAD_V25, task_struct, thread.vstate.v[25]);
+	OFFSET(TASK_THREAD_V26, task_struct, thread.vstate.v[26]);
+	OFFSET(TASK_THREAD_V27, task_struct, thread.vstate.v[27]);
+	OFFSET(TASK_THREAD_V28, task_struct, thread.vstate.v[28]);
+	OFFSET(TASK_THREAD_V29, task_struct, thread.vstate.v[29]);
+	OFFSET(TASK_THREAD_V30, task_struct, thread.vstate.v[30]);
+	OFFSET(TASK_THREAD_V31, task_struct, thread.vstate.v[31]);
+	OFFSET(TASK_THREAD_VSTART, task_struct, thread.vstate.vstart);
+	OFFSET(TASK_THREAD_VXSAT, task_struct, thread.vstate.vxsat);
+	OFFSET(TASK_THREAD_VXRM, task_struct, thread.vstate.vxrm);
+	OFFSET(TASK_THREAD_VL, task_struct, thread.vstate.vl);
+	OFFSET(TASK_THREAD_VTYPE, task_struct, thread.vstate.vtype);
+	DEFINE(RISCV_VECTOR_VLENB, sizeof(__uint128_t));
+
 	DEFINE(PT_SIZE, sizeof(struct pt_regs));
 	OFFSET(PT_EPC, pt_regs, epc);
 	OFFSET(PT_RA, pt_regs, ra);
@@ -168,6 +207,7 @@ void asm_offsets(void)
 		- offsetof(struct task_struct, thread.ra)
 	);
 
+	/* Float Point */
 	DEFINE(TASK_THREAD_F0_F0,
 		  offsetof(struct task_struct, thread.fstate.f[0])
 		- offsetof(struct task_struct, thread.fstate.f[0])
@@ -301,6 +341,156 @@ void asm_offsets(void)
 		- offsetof(struct task_struct, thread.fstate.f[0])
 	);
 
+	/* Vector */
+	DEFINE(TASK_THREAD_V0_V0,
+		  offsetof(struct task_struct, thread.vstate.v[0])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V1_V0,
+		  offsetof(struct task_struct, thread.vstate.v[1])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V2_V0,
+		  offsetof(struct task_struct, thread.vstate.v[2])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V3_V0,
+		  offsetof(struct task_struct, thread.vstate.v[3])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V4_V0,
+		  offsetof(struct task_struct, thread.vstate.v[4])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V5_V0,
+		  offsetof(struct task_struct, thread.vstate.v[5])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V6_V0,
+		  offsetof(struct task_struct, thread.vstate.v[6])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V7_V0,
+		  offsetof(struct task_struct, thread.vstate.v[7])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V8_V0,
+		  offsetof(struct task_struct, thread.vstate.v[8])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V9_V0,
+		  offsetof(struct task_struct, thread.vstate.v[9])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V10_V0,
+		  offsetof(struct task_struct, thread.vstate.v[10])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V11_V0,
+		  offsetof(struct task_struct, thread.vstate.v[11])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V12_V0,
+		  offsetof(struct task_struct, thread.vstate.v[12])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V13_V0,
+		  offsetof(struct task_struct, thread.vstate.v[13])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V14_V0,
+		  offsetof(struct task_struct, thread.vstate.v[14])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V15_V0,
+		  offsetof(struct task_struct, thread.vstate.v[15])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V16_V0,
+		  offsetof(struct task_struct, thread.vstate.v[16])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V17_V0,
+		  offsetof(struct task_struct, thread.vstate.v[17])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V18_V0,
+		  offsetof(struct task_struct, thread.vstate.v[18])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V19_V0,
+		  offsetof(struct task_struct, thread.vstate.v[19])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V20_V0,
+		  offsetof(struct task_struct, thread.vstate.v[20])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V21_V0,
+		  offsetof(struct task_struct, thread.vstate.v[21])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V22_V0,
+		  offsetof(struct task_struct, thread.vstate.v[22])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V23_V0,
+		  offsetof(struct task_struct, thread.vstate.v[23])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V24_V0,
+		  offsetof(struct task_struct, thread.vstate.v[24])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V25_V0,
+		  offsetof(struct task_struct, thread.vstate.v[25])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V26_V0,
+		  offsetof(struct task_struct, thread.vstate.v[26])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V27_V0,
+		  offsetof(struct task_struct, thread.vstate.v[27])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V28_V0,
+		  offsetof(struct task_struct, thread.vstate.v[28])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V29_V0,
+		  offsetof(struct task_struct, thread.vstate.v[29])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V30_V0,
+		  offsetof(struct task_struct, thread.vstate.v[30])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_V31_V0,
+		  offsetof(struct task_struct, thread.vstate.v[31])
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_VSTART_V0,
+		  offsetof(struct task_struct, thread.vstate.vstart)
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_VXSAT_V0,
+		  offsetof(struct task_struct, thread.vstate.vxsat)
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_VXRM_V0,
+		  offsetof(struct task_struct, thread.vstate.vxrm)
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_VL_V0,
+		  offsetof(struct task_struct, thread.vstate.vl)
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+	DEFINE(TASK_THREAD_VTYPE_V0,
+		  offsetof(struct task_struct, thread.vstate.vtype)
+		- offsetof(struct task_struct, thread.vstate.v[0])
+	);
+
 	/*
 	 * We allocate a pt_regs on the stack when entering the kernel.  This
 	 * ensures the alignment is sane.
diff --git a/arch/riscv/kernel/cpu.c b/arch/riscv/kernel/cpu.c
index 6d59e6906fdd..58972bbc444a 100644
--- a/arch/riscv/kernel/cpu.c
+++ b/arch/riscv/kernel/cpu.c
@@ -107,6 +107,7 @@ static int c_show(struct seq_file *m, void *v)
 	unsigned long cpu_id = (unsigned long)v - 1;
 	struct device_node *node = of_get_cpu_node(cpu_id, NULL);
 	const char *compat, *isa, *mmu;
+	const char  *freq, *icache, *dcache, *l2cache, *tlb, *cacheline, *vecver;
 
 	seq_printf(m, "processor\t: %lu\n", cpu_id);
 	seq_printf(m, "hart\t\t: %lu\n", cpuid_to_hartid_map(cpu_id));
@@ -117,6 +118,28 @@ static int c_show(struct seq_file *m, void *v)
 	if (!of_property_read_string(node, "compatible", &compat)
 	    && strcmp(compat, "riscv"))
 		seq_printf(m, "uarch\t\t: %s\n", compat);
+
+	if (!of_property_read_string(node, "cpu-freq", &freq))
+		seq_printf(m, "cpu-freq\t: %s\n", freq);
+
+	if (!of_property_read_string(node, "cpu-icache", &icache))
+		seq_printf(m, "cpu-icache\t: %s\n", icache);
+
+	if (!of_property_read_string(node, "cpu-dcache", &dcache))
+		seq_printf(m, "cpu-dcache\t: %s\n", dcache);
+
+	if (!of_property_read_string(node, "cpu-l2cache", &l2cache))
+		seq_printf(m, "cpu-l2cache\t: %s\n", l2cache);
+
+	if (!of_property_read_string(node, "cpu-tlb", &tlb))
+		seq_printf(m, "cpu-tlb\t\t: %s\n", tlb);
+
+	if (!of_property_read_string(node, "cpu-cacheline", &cacheline))
+		seq_printf(m, "cpu-cacheline\t: %s\n", cacheline);
+
+	if (!of_property_read_string(node, "cpu-vector", &vecver))
+		seq_printf(m, "cpu-vector\t: %s\n", vecver);
+
 	seq_puts(m, "\n");
 	of_node_put(node);
 
diff --git a/arch/riscv/kernel/cpu_ops_spinwait.c b/arch/riscv/kernel/cpu_ops_spinwait.c
index b2c957bb68c1..4d980d8bdaea 100644
--- a/arch/riscv/kernel/cpu_ops_spinwait.c
+++ b/arch/riscv/kernel/cpu_ops_spinwait.c
@@ -33,6 +33,8 @@ static int spinwait_cpu_start(unsigned int cpuid, struct task_struct *tidle)
 	 */
 	cpu_update_secondary_bootdata(cpuid, tidle);
 
+	sbi_ecall(0x09000003, 0, cpuid_to_hartid_map(cpuid), 0, 0, 0, 0, 0);
+
 	return 0;
 }
 
diff --git a/arch/riscv/kernel/cpufeature.c b/arch/riscv/kernel/cpufeature.c
index ac202f44a670..0905ea573a41 100644
--- a/arch/riscv/kernel/cpufeature.c
+++ b/arch/riscv/kernel/cpufeature.c
@@ -59,6 +59,10 @@ bool __riscv_isa_extension_available(const unsigned long *isa_bitmap, int bit)
 }
 EXPORT_SYMBOL_GPL(__riscv_isa_extension_available);
 
+#ifdef CONFIG_VECTOR
+bool has_vector __read_mostly;
+#endif
+
 void riscv_fill_hwcap(void)
 {
 	struct device_node *node;
@@ -73,6 +77,7 @@ void riscv_fill_hwcap(void)
 	isa2hwcap['f'] = isa2hwcap['F'] = COMPAT_HWCAP_ISA_F;
 	isa2hwcap['d'] = isa2hwcap['D'] = COMPAT_HWCAP_ISA_D;
 	isa2hwcap['c'] = isa2hwcap['C'] = COMPAT_HWCAP_ISA_C;
+	isa2hwcap['v'] = isa2hwcap['V'] = COMPAT_HWCAP_ISA_V;
 
 	elf_hwcap = 0;
 
@@ -148,4 +153,9 @@ void riscv_fill_hwcap(void)
 	if (elf_hwcap & (COMPAT_HWCAP_ISA_F | COMPAT_HWCAP_ISA_D))
 		has_fpu = true;
 #endif
+
+#ifdef CONFIG_VECTOR
+	if (elf_hwcap & COMPAT_HWCAP_ISA_V)
+		has_vector = true;
+#endif
 }
diff --git a/arch/riscv/kernel/entry.S b/arch/riscv/kernel/entry.S
index 5214c578a602..b7436b182c6c 100644
--- a/arch/riscv/kernel/entry.S
+++ b/arch/riscv/kernel/entry.S
@@ -70,7 +70,7 @@ _save_context:
 	 * Disable the FPU to detect illegal usage of floating point in kernel
 	 * space.
 	 */
-	li t0, SR_SUM | SR_FS
+	li t0, SR_SUM | SR_FS | SR_VS
 
 	REG_L s0, TASK_TI_USER_SP(tp)
 	csrrc s1, CSR_STATUS, t0
@@ -132,13 +132,29 @@ skip_context_tracking:
 	beqz t0, 1f
 #ifdef CONFIG_TRACE_IRQFLAGS
 	call __trace_hardirqs_on
+
+	REG_L s1, PT_STATUS(sp)
 #endif
 	csrs CSR_STATUS, SR_IE
 
 1:
+#ifdef CONFIG_TRACE_IRQFLAGS
+	REG_L a0, PT_A0(sp)
+	REG_L a1, PT_A1(sp)
+	REG_L a2, PT_A2(sp)
+	REG_L a3, PT_A3(sp)
+	REG_L a4, PT_A4(sp)
+	REG_L a5, PT_A5(sp)
+	REG_L a6, PT_A6(sp)
+	REG_L a7, PT_A7(sp)
+#endif
 	la ra, ret_from_exception
 	/* Handle syscalls */
 	li t0, EXC_SYSCALL
+
+#ifdef CONFIG_TRACE_IRQFLAGS
+	REG_L s4, PT_CAUSE(sp)
+#endif
 	beq s4, t0, handle_syscall
 
 	/* Handle other exceptions */
@@ -181,6 +197,9 @@ handle_syscall:
 	 * Advance SEPC to avoid executing the original
 	 * scall instruction on sret
 	 */
+#ifdef CONFIG_TRACE_IRQFLAGS
+	REG_L s2, PT_EPC(sp)
+#endif
 	addi s2, s2, 0x4
 	REG_S s2, PT_EPC(sp)
 	/* Trace syscalls, but only if requested by the user. */
diff --git a/arch/riscv/kernel/ftrace.c b/arch/riscv/kernel/ftrace.c
index 8693dfcffb02..72e269c369d7 100644
--- a/arch/riscv/kernel/ftrace.c
+++ b/arch/riscv/kernel/ftrace.c
@@ -82,29 +82,56 @@ static int __ftrace_modify_call(unsigned long hook_pos, unsigned long target,
 	return 0;
 }
 
+/*
+ * Put 5 instructions with 16 bytes at the front of function within
+ * patchable function entry nops' area.
+ *
+ * 0: REG_S  ra, -SZREG(sp)
+ * 1: auipc  ra, 0x?
+ * 2: jalr   -?(ra)
+ * 3: REG_L  ra, -SZREG(sp)
+ *
+ * So the opcodes is:
+ * 0: 0xfe113c23 (sd)/0xfe112e23 (sw)
+ * 1: 0x???????? -> auipc
+ * 2: 0x???????? -> jalr
+ * 3: 0xff813083 (ld)/0xffc12083 (lw)
+ */
+#if __riscv_xlen == 64
+#define INSN0	0xfe113c23
+#define INSN3	0xff813083
+#elif __riscv_xlen == 32
+#define INSN0	0xfe112e23
+#define INSN3	0xffc12083
+#endif
+
+#define FUNC_ENTRY_SIZE	16
+#define FUNC_ENTRY_JMP	4
+
 int ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)
 {
-	int ret = ftrace_check_current_call(rec->ip, NULL);
+	unsigned int call[4] = {INSN0, 0, 0, INSN3};
+	unsigned long target = addr;
+	unsigned long caller = rec->ip + FUNC_ENTRY_JMP;
 
-	if (ret)
-		return ret;
+	call[1] = to_auipc_insn((unsigned int)(target - caller));
+	call[2] = to_jalr_insn((unsigned int)(target - caller));
 
-	return __ftrace_modify_call(rec->ip, addr, true);
+	if (patch_text_nosync((void *)rec->ip, call, FUNC_ENTRY_SIZE))
+		return -EPERM;
+
+	return 0;
 }
 
 int ftrace_make_nop(struct module *mod, struct dyn_ftrace *rec,
 		    unsigned long addr)
 {
-	unsigned int call[2];
-	int ret;
+	unsigned int nops[4] = {NOP4, NOP4, NOP4, NOP4};
 
-	make_call(rec->ip, addr, call);
-	ret = ftrace_check_current_call(rec->ip, call);
-
-	if (ret)
-		return ret;
+	if (patch_text_nosync((void *)rec->ip, nops, FUNC_ENTRY_SIZE))
+		return -EPERM;
 
-	return __ftrace_modify_call(rec->ip, addr, false);
+	return 0;
 }
 
 
@@ -149,15 +176,16 @@ int ftrace_modify_call(struct dyn_ftrace *rec, unsigned long old_addr,
 		       unsigned long addr)
 {
 	unsigned int call[2];
+	unsigned long caller = rec->ip + FUNC_ENTRY_JMP;
 	int ret;
 
-	make_call(rec->ip, old_addr, call);
-	ret = ftrace_check_current_call(rec->ip, call);
+	make_call(caller, old_addr, call);
+	ret = ftrace_check_current_call(caller, call);
 
 	if (ret)
 		return ret;
 
-	return __ftrace_modify_call(rec->ip, addr, true);
+	return __ftrace_modify_call(caller, addr, true);
 }
 #endif
 
@@ -186,53 +214,30 @@ void prepare_ftrace_return(unsigned long *parent, unsigned long self_addr,
 
 #ifdef CONFIG_DYNAMIC_FTRACE
 extern void ftrace_graph_call(void);
+extern void ftrace_graph_regs_call(void);
 int ftrace_enable_ftrace_graph_caller(void)
 {
-	unsigned int call[2];
-	static int init_graph = 1;
 	int ret;
 
-	make_call(&ftrace_graph_call, &ftrace_stub, call);
-
-	/*
-	 * When enabling graph tracer for the first time, ftrace_graph_call
-	 * should contains a call to ftrace_stub.  Once it has been disabled,
-	 * the 8-bytes at the position becomes NOPs.
-	 */
-	if (init_graph) {
-		ret = ftrace_check_current_call((unsigned long)&ftrace_graph_call,
-						call);
-		init_graph = 0;
-	} else {
-		ret = ftrace_check_current_call((unsigned long)&ftrace_graph_call,
-						NULL);
-	}
-
+	ret = __ftrace_modify_call((unsigned long)&ftrace_graph_call,
+				    (unsigned long)&prepare_ftrace_return, true);
 	if (ret)
 		return ret;
 
-	return __ftrace_modify_call((unsigned long)&ftrace_graph_call,
+	return __ftrace_modify_call((unsigned long)&ftrace_graph_regs_call,
 				    (unsigned long)&prepare_ftrace_return, true);
 }
 
 int ftrace_disable_ftrace_graph_caller(void)
 {
-	unsigned int call[2];
 	int ret;
 
-	make_call(&ftrace_graph_call, &prepare_ftrace_return, call);
-
-	/*
-	 * This is to make sure that ftrace_enable_ftrace_graph_caller
-	 * did the right thing.
-	 */
-	ret = ftrace_check_current_call((unsigned long)&ftrace_graph_call,
-					call);
-
+	ret = __ftrace_modify_call((unsigned long)&ftrace_graph_call,
+				    (unsigned long)&prepare_ftrace_return, false);
 	if (ret)
 		return ret;
 
-	return __ftrace_modify_call((unsigned long)&ftrace_graph_call,
+	return __ftrace_modify_call((unsigned long)&ftrace_graph_regs_call,
 				    (unsigned long)&prepare_ftrace_return, false);
 }
 #endif /* CONFIG_DYNAMIC_FTRACE */
diff --git a/arch/riscv/kernel/head.S b/arch/riscv/kernel/head.S
index 47d1411db0a9..f471b5ad2824 100644
--- a/arch/riscv/kernel/head.S
+++ b/arch/riscv/kernel/head.S
@@ -39,13 +39,7 @@ ENTRY(_start)
 	/* Image load offset (0MB) from start of RAM for M-mode */
 	.dword 0
 #else
-#if __riscv_xlen == 64
-	/* Image load offset(2MB) from start of RAM */
-	.dword 0x200000
-#else
-	/* Image load offset(4MB) from start of RAM */
-	.dword 0x400000
-#endif
+	.dword LOAD_OFFSET
 #endif
 	/* Effective size of kernel image */
 	.dword _end - _start
@@ -69,7 +63,7 @@ pe_head_start:
 #ifdef CONFIG_MMU
 relocate:
 	/* Relocate return address */
-	li a1, PAGE_OFFSET
+	li a1, PAGE_OFFSET + LOAD_OFFSET
 	la a2, _start
 	sub a1, a1, a2
 	add ra, ra, a1
@@ -183,7 +177,6 @@ setup_trap_vector:
 
 END(_start)
 
-	__INIT
 ENTRY(_start_kernel)
 	/* Mask all interrupts */
 	csrw CSR_IE, zero
@@ -228,7 +221,7 @@ pmp_done:
 	 * Disable FPU to detect illegal usage of
 	 * floating point in kernel space
 	 */
-	li t0, SR_FS
+	li t0, SR_FS | SR_VS
 	csrc CSR_STATUS, t0
 
 #ifdef CONFIG_SMP
diff --git a/arch/riscv/kernel/mcount-dyn.S b/arch/riscv/kernel/mcount-dyn.S
index 35a6ed76cb8b..d171eca623b6 100644
--- a/arch/riscv/kernel/mcount-dyn.S
+++ b/arch/riscv/kernel/mcount-dyn.S
@@ -13,224 +13,186 @@
 
 	.text
 
-	.macro SAVE_ABI_STATE
-#ifdef CONFIG_FUNCTION_GRAPH_TRACER
-	addi    sp, sp, -48
-	sd      s0, 32(sp)
-	sd      ra, 40(sp)
-	addi    s0, sp, 48
-	sd      t0, 24(sp)
-	sd      t1, 16(sp)
-#ifdef HAVE_FUNCTION_GRAPH_FP_TEST
-	sd      t2, 8(sp)
-#endif
-#else
-	addi	sp, sp, -16
-	sd	s0, 0(sp)
-	sd	ra, 8(sp)
-	addi	s0, sp, 16
-#endif
+#define FENTRY_RA_OFFSET	12
+#define ABI_SIZE_ON_STACK	72
+#define ABI_A0			0
+#define ABI_A1			8
+#define ABI_A2			16
+#define ABI_A3			24
+#define ABI_A4			32
+#define ABI_A5			40
+#define ABI_A6			48
+#define ABI_A7			56
+#define ABI_RA			64
+
+	.macro SAVE_ABI
+	addi	sp, sp, -SZREG
+	addi	sp, sp, -ABI_SIZE_ON_STACK
+
+	REG_S	a0, ABI_A0(sp)
+	REG_S	a1, ABI_A1(sp)
+	REG_S	a2, ABI_A2(sp)
+	REG_S	a3, ABI_A3(sp)
+	REG_S	a4, ABI_A4(sp)
+	REG_S	a5, ABI_A5(sp)
+	REG_S	a6, ABI_A6(sp)
+	REG_S	a7, ABI_A7(sp)
+	REG_S	ra, ABI_RA(sp)
 	.endm
 
-	.macro RESTORE_ABI_STATE
-#ifdef CONFIG_FUNCTION_GRAPH_TRACER
-	ld	s0, 32(sp)
-	ld	ra, 40(sp)
-	addi	sp, sp, 48
-#else
-	ld	ra, 8(sp)
-	ld	s0, 0(sp)
-	addi	sp, sp, 16
-#endif
+	.macro RESTORE_ABI
+	REG_L	a0, ABI_A0(sp)
+	REG_L	a1, ABI_A1(sp)
+	REG_L	a2, ABI_A2(sp)
+	REG_L	a3, ABI_A3(sp)
+	REG_L	a4, ABI_A4(sp)
+	REG_L	a5, ABI_A5(sp)
+	REG_L	a6, ABI_A6(sp)
+	REG_L	a7, ABI_A7(sp)
+	REG_L	ra, ABI_RA(sp)
+
+	addi	sp, sp, ABI_SIZE_ON_STACK
+	addi	sp, sp, SZREG
 	.endm
 
-	.macro RESTORE_GRAPH_ARGS
-	ld	a0, 24(sp)
-	ld	a1, 16(sp)
-#ifdef HAVE_FUNCTION_GRAPH_FP_TEST
-	ld	a2, 8(sp)
-#endif
+#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS
+	.macro SAVE_ALL
+	addi	sp, sp, -SZREG
+	addi	sp, sp, -PT_SIZE_ON_STACK
+
+	REG_S x1,  PT_EPC(sp)
+	addi	sp, sp, PT_SIZE_ON_STACK
+	REG_L x1,  (sp)
+	addi	sp, sp, -PT_SIZE_ON_STACK
+	REG_S x1,  PT_RA(sp)
+	REG_L x1,  PT_EPC(sp)
+
+	REG_S x2,  PT_SP(sp)
+	REG_S x3,  PT_GP(sp)
+	REG_S x4,  PT_TP(sp)
+	REG_S x5,  PT_T0(sp)
+	REG_S x6,  PT_T1(sp)
+	REG_S x7,  PT_T2(sp)
+	REG_S x8,  PT_S0(sp)
+	REG_S x9,  PT_S1(sp)
+	REG_S x10, PT_A0(sp)
+	REG_S x11, PT_A1(sp)
+	REG_S x12, PT_A2(sp)
+	REG_S x13, PT_A3(sp)
+	REG_S x14, PT_A4(sp)
+	REG_S x15, PT_A5(sp)
+	REG_S x16, PT_A6(sp)
+	REG_S x17, PT_A7(sp)
+	REG_S x18, PT_S2(sp)
+	REG_S x19, PT_S3(sp)
+	REG_S x20, PT_S4(sp)
+	REG_S x21, PT_S5(sp)
+	REG_S x22, PT_S6(sp)
+	REG_S x23, PT_S7(sp)
+	REG_S x24, PT_S8(sp)
+	REG_S x25, PT_S9(sp)
+	REG_S x26, PT_S10(sp)
+	REG_S x27, PT_S11(sp)
+	REG_S x28, PT_T3(sp)
+	REG_S x29, PT_T4(sp)
+	REG_S x30, PT_T5(sp)
+	REG_S x31, PT_T6(sp)
 	.endm
 
-ENTRY(ftrace_graph_caller)
-	addi	sp, sp, -16
-	sd	s0, 0(sp)
-	sd	ra, 8(sp)
-	addi	s0, sp, 16
-ftrace_graph_call:
-	.global ftrace_graph_call
-	/*
-	 * Calling ftrace_enable/disable_ftrace_graph_caller would overwrite the
-	 * call below.  Check ftrace_modify_all_code for details.
-	 */
-	call	ftrace_stub
-	ld	ra, 8(sp)
-	ld	s0, 0(sp)
-	addi	sp, sp, 16
-	ret
-ENDPROC(ftrace_graph_caller)
+	.macro RESTORE_ALL
+	REG_L x1,  PT_RA(sp)
+	addi	sp, sp, PT_SIZE_ON_STACK
+	REG_S x1,  (sp)
+	addi	sp, sp, -PT_SIZE_ON_STACK
+	REG_L x1,  PT_EPC(sp)
+	REG_L x2,  PT_SP(sp)
+	REG_L x3,  PT_GP(sp)
+	REG_L x4,  PT_TP(sp)
+	REG_L x5,  PT_T0(sp)
+	REG_L x6,  PT_T1(sp)
+	REG_L x7,  PT_T2(sp)
+	REG_L x8,  PT_S0(sp)
+	REG_L x9,  PT_S1(sp)
+	REG_L x10, PT_A0(sp)
+	REG_L x11, PT_A1(sp)
+	REG_L x12, PT_A2(sp)
+	REG_L x13, PT_A3(sp)
+	REG_L x14, PT_A4(sp)
+	REG_L x15, PT_A5(sp)
+	REG_L x16, PT_A6(sp)
+	REG_L x17, PT_A7(sp)
+	REG_L x18, PT_S2(sp)
+	REG_L x19, PT_S3(sp)
+	REG_L x20, PT_S4(sp)
+	REG_L x21, PT_S5(sp)
+	REG_L x22, PT_S6(sp)
+	REG_L x23, PT_S7(sp)
+	REG_L x24, PT_S8(sp)
+	REG_L x25, PT_S9(sp)
+	REG_L x26, PT_S10(sp)
+	REG_L x27, PT_S11(sp)
+	REG_L x28, PT_T3(sp)
+	REG_L x29, PT_T4(sp)
+	REG_L x30, PT_T5(sp)
+	REG_L x31, PT_T6(sp)
+
+	addi	sp, sp, PT_SIZE_ON_STACK
+	addi	sp, sp, SZREG
+	.endm
+#endif /* CONFIG_DYNAMIC_FTRACE_WITH_REGS */
 
 ENTRY(ftrace_caller)
-	/*
-	 * a0: the address in the caller when calling ftrace_caller
-	 * a1: the caller's return address
-	 * a2: the address of global variable function_trace_op
-	 */
-	ld	a1, -8(s0)
-	addi	a0, ra, -MCOUNT_INSN_SIZE
-	la	t5, function_trace_op
-	ld	a2, 0(t5)
+	SAVE_ABI
 
-#ifdef CONFIG_FUNCTION_GRAPH_TRACER
-	/*
-	 * the graph tracer (specifically, prepare_ftrace_return) needs these
-	 * arguments but for now the function tracer occupies the regs, so we
-	 * save them in temporary regs to recover later.
-	 */
-	addi	t0, s0, -8
-	mv	t1, a0
-#ifdef HAVE_FUNCTION_GRAPH_FP_TEST
-	ld	t2, -16(s0)
-#endif
-#endif
+	addi	a0, ra, -FENTRY_RA_OFFSET
+	la	a1, function_trace_op
+	REG_L	a2, 0(a1)
+	REG_L	a1, ABI_SIZE_ON_STACK(sp)
+	mv	a3, sp
 
-	SAVE_ABI_STATE
 ftrace_call:
 	.global ftrace_call
-	/*
-	 * For the dynamic ftrace to work, here we should reserve at least
-	 * 8 bytes for a functional auipc-jalr pair.  The following call
-	 * serves this purpose.
-	 *
-	 * Calling ftrace_update_ftrace_func would overwrite the nops below.
-	 * Check ftrace_modify_all_code for details.
-	 */
 	call	ftrace_stub
 
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
-	RESTORE_GRAPH_ARGS
-	call	ftrace_graph_caller
+	addi	a0, sp, ABI_SIZE_ON_STACK
+	REG_L	a1, ABI_RA(sp)
+	addi	a1, a1, -FENTRY_RA_OFFSET
+#ifdef HAVE_FUNCTION_GRAPH_FP_TEST
+	mv	a2, s0
 #endif
-
-	RESTORE_ABI_STATE
+ftrace_graph_call:
+	.global ftrace_graph_call
+	call	ftrace_stub
+#endif
+	RESTORE_ABI
 	ret
 ENDPROC(ftrace_caller)
 
 #ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS
-	.macro SAVE_ALL
-	addi	sp, sp, -(PT_SIZE_ON_STACK+16)
-	sd	s0, (PT_SIZE_ON_STACK)(sp)
-	sd	ra, (PT_SIZE_ON_STACK+8)(sp)
-	addi	s0, sp, (PT_SIZE_ON_STACK+16)
-
-	sd x1,  PT_RA(sp)
-	sd x2,  PT_SP(sp)
-	sd x3,  PT_GP(sp)
-	sd x4,  PT_TP(sp)
-	sd x5,  PT_T0(sp)
-	sd x6,  PT_T1(sp)
-	sd x7,  PT_T2(sp)
-	sd x8,  PT_S0(sp)
-	sd x9,  PT_S1(sp)
-	sd x10, PT_A0(sp)
-	sd x11, PT_A1(sp)
-	sd x12, PT_A2(sp)
-	sd x13, PT_A3(sp)
-	sd x14, PT_A4(sp)
-	sd x15, PT_A5(sp)
-	sd x16, PT_A6(sp)
-	sd x17, PT_A7(sp)
-	sd x18, PT_S2(sp)
-	sd x19, PT_S3(sp)
-	sd x20, PT_S4(sp)
-	sd x21, PT_S5(sp)
-	sd x22, PT_S6(sp)
-	sd x23, PT_S7(sp)
-	sd x24, PT_S8(sp)
-	sd x25, PT_S9(sp)
-	sd x26, PT_S10(sp)
-	sd x27, PT_S11(sp)
-	sd x28, PT_T3(sp)
-	sd x29, PT_T4(sp)
-	sd x30, PT_T5(sp)
-	sd x31, PT_T6(sp)
-	.endm
-
-	.macro RESTORE_ALL
-	ld x1,  PT_RA(sp)
-	ld x2,  PT_SP(sp)
-	ld x3,  PT_GP(sp)
-	ld x4,  PT_TP(sp)
-	ld x5,  PT_T0(sp)
-	ld x6,  PT_T1(sp)
-	ld x7,  PT_T2(sp)
-	ld x8,  PT_S0(sp)
-	ld x9,  PT_S1(sp)
-	ld x10, PT_A0(sp)
-	ld x11, PT_A1(sp)
-	ld x12, PT_A2(sp)
-	ld x13, PT_A3(sp)
-	ld x14, PT_A4(sp)
-	ld x15, PT_A5(sp)
-	ld x16, PT_A6(sp)
-	ld x17, PT_A7(sp)
-	ld x18, PT_S2(sp)
-	ld x19, PT_S3(sp)
-	ld x20, PT_S4(sp)
-	ld x21, PT_S5(sp)
-	ld x22, PT_S6(sp)
-	ld x23, PT_S7(sp)
-	ld x24, PT_S8(sp)
-	ld x25, PT_S9(sp)
-	ld x26, PT_S10(sp)
-	ld x27, PT_S11(sp)
-	ld x28, PT_T3(sp)
-	ld x29, PT_T4(sp)
-	ld x30, PT_T5(sp)
-	ld x31, PT_T6(sp)
-
-	ld	s0, (PT_SIZE_ON_STACK)(sp)
-	ld	ra, (PT_SIZE_ON_STACK+8)(sp)
-	addi	sp, sp, (PT_SIZE_ON_STACK+16)
-	.endm
-
-	.macro RESTORE_GRAPH_REG_ARGS
-	ld	a0, PT_T0(sp)
-	ld	a1, PT_T1(sp)
-#ifdef HAVE_FUNCTION_GRAPH_FP_TEST
-	ld	a2, PT_T2(sp)
-#endif
-	.endm
-
-/*
- * Most of the contents are the same as ftrace_caller.
- */
 ENTRY(ftrace_regs_caller)
-	/*
-	 * a3: the address of all registers in the stack
-	 */
-	ld	a1, -8(s0)
-	addi	a0, ra, -MCOUNT_INSN_SIZE
-	la	t5, function_trace_op
-	ld	a2, 0(t5)
-	addi	a3, sp, -(PT_SIZE_ON_STACK+16)
-
-#ifdef CONFIG_FUNCTION_GRAPH_TRACER
-	addi	t0, s0, -8
-	mv	t1, a0
-#ifdef HAVE_FUNCTION_GRAPH_FP_TEST
-	ld	t2, -16(s0)
-#endif
-#endif
 	SAVE_ALL
 
+	addi	a0, ra, -FENTRY_RA_OFFSET
+	la	a1, function_trace_op
+	REG_L	a2, 0(a1)
+	REG_L	a1, PT_SIZE_ON_STACK(sp)
+	mv	a3, sp
+
 ftrace_regs_call:
 	.global ftrace_regs_call
 	call	ftrace_stub
 
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
-	RESTORE_GRAPH_REG_ARGS
-	call	ftrace_graph_caller
+	addi	a0, sp, PT_RA
+	REG_L	a1, PT_EPC(sp)
+	addi	a1, a1, -FENTRY_RA_OFFSET
+#ifdef HAVE_FUNCTION_GRAPH_FP_TEST
+	mv	a2, s0
+#endif
+ftrace_graph_regs_call:
+	.global ftrace_graph_regs_call
+	call	ftrace_stub
 #endif
 
 	RESTORE_ALL
diff --git a/arch/riscv/kernel/module.c b/arch/riscv/kernel/module.c
index c3310a68ac46..9c6dc93d3213 100644
--- a/arch/riscv/kernel/module.c
+++ b/arch/riscv/kernel/module.c
@@ -264,7 +264,7 @@ static int apply_r_riscv_align_rela(struct module *me, u32 *location,
 	pr_err(
 	  "%s: The unexpected relocation type 'R_RISCV_ALIGN' from PC = %p\n",
 	  me->name, location);
-	return -EINVAL;
+	return 0; /* Do not return -EINVAL when relocation type is R_RISCV_ALIGN */
 }
 
 static int apply_r_riscv_add32_rela(struct module *me, u32 *location,
@@ -320,6 +320,45 @@ static int (*reloc_handlers_rela[]) (struct module *me, u32 *location,
 	[R_RISCV_SUB64]			= apply_r_riscv_sub64_rela,
 };
 
+static inline int apply_calc_pcrel_lo12(Elf_Shdr *sechdrs, Elf_Rela *rel,
+			   Elf_Sym *sym, unsigned int relidx,
+		       unsigned int symindex, unsigned int relsec,
+		       struct module *me, Elf_Addr *v) {
+	unsigned long hi20_loc =
+		sechdrs[sechdrs[relsec].sh_info].sh_addr
+		+ rel[relidx].r_offset;
+	u32 hi20_type = ELF_RISCV_R_TYPE(rel[relidx].r_info);
+	int ret = 0;
+
+	/* Find the corresponding HI20 relocation entry */
+	if (hi20_loc == sym->st_value
+		&& (hi20_type == R_RISCV_PCREL_HI20
+		|| hi20_type == R_RISCV_GOT_HI20)) {
+		s32 hi20, lo12;
+		Elf_Sym *hi20_sym =
+			(Elf_Sym *)sechdrs[symindex].sh_addr
+			+ ELF_RISCV_R_SYM(rel[relidx].r_info);
+		unsigned long hi20_sym_val =
+			hi20_sym->st_value
+			+ rel[relidx].r_addend;
+
+		/* Calculate lo12 */
+		size_t offset = hi20_sym_val - hi20_loc;
+
+		if (IS_ENABLED(CONFIG_MODULE_SECTIONS)
+			&& hi20_type == R_RISCV_GOT_HI20) {
+			offset = module_emit_got_entry(
+				me, hi20_sym_val);
+			offset = offset - hi20_loc;
+		}
+		hi20 = (offset + 0x800) & 0xfffff000;
+		lo12 = offset - hi20;
+		*v = lo12;
+		ret = 1;
+	}
+	return ret;
+}
+
 int apply_relocate_add(Elf_Shdr *sechdrs, const char *strtab,
 		       unsigned int symindex, unsigned int relsec,
 		       struct module *me)
@@ -368,38 +407,26 @@ int apply_relocate_add(Elf_Shdr *sechdrs, const char *strtab,
 
 		if (type == R_RISCV_PCREL_LO12_I || type == R_RISCV_PCREL_LO12_S) {
 			unsigned int j;
+			unsigned int found = 0;
+
+			/* in some module, the hi20 type is before the lo12 type,
+			 * so we search the i-1 first to reduice the search time.
+			 */
+			if (i > 0) {
+				j = i - 1;
+				found = apply_calc_pcrel_lo12(sechdrs, rel, sym, j, symindex,
+					relsec, me, &v);
+			}
 
-			for (j = 0; j < sechdrs[relsec].sh_size / sizeof(*rel); j++) {
-				unsigned long hi20_loc =
-					sechdrs[sechdrs[relsec].sh_info].sh_addr
-					+ rel[j].r_offset;
-				u32 hi20_type = ELF_RISCV_R_TYPE(rel[j].r_info);
-
-				/* Find the corresponding HI20 relocation entry */
-				if (hi20_loc == sym->st_value
-				    && (hi20_type == R_RISCV_PCREL_HI20
-					|| hi20_type == R_RISCV_GOT_HI20)) {
-					s32 hi20, lo12;
-					Elf_Sym *hi20_sym =
-						(Elf_Sym *)sechdrs[symindex].sh_addr
-						+ ELF_RISCV_R_SYM(rel[j].r_info);
-					unsigned long hi20_sym_val =
-						hi20_sym->st_value
-						+ rel[j].r_addend;
-
-					/* Calculate lo12 */
-					size_t offset = hi20_sym_val - hi20_loc;
-					if (IS_ENABLED(CONFIG_MODULE_SECTIONS)
-					    && hi20_type == R_RISCV_GOT_HI20) {
-						offset = module_emit_got_entry(
-							 me, hi20_sym_val);
-						offset = offset - hi20_loc;
+			if (found == 0) {
+				for (j = 0; j < sechdrs[relsec].sh_size / sizeof(*rel); j++) {
+					if (j != i-1) {
+						found = apply_calc_pcrel_lo12(sechdrs, rel, sym, j,
+							symindex, relsec, me, &v);
+					}
+					if (found) {
+						break;
 					}
-					hi20 = (offset + 0x800) & 0xfffff000;
-					lo12 = offset - hi20;
-					v = lo12;
-
-					break;
 				}
 			}
 			if (j == sechdrs[relsec].sh_size / sizeof(*rel)) {
diff --git a/arch/riscv/kernel/patch.c b/arch/riscv/kernel/patch.c
index c3fced410e74..e099961453cc 100644
--- a/arch/riscv/kernel/patch.c
+++ b/arch/riscv/kernel/patch.c
@@ -23,7 +23,12 @@ struct patch_insn {
 int riscv_patch_in_stop_machine = false;
 
 #ifdef CONFIG_MMU
-static void *patch_map(void *addr, int fixmap)
+/*
+ * The fix_to_virt(, idx) needs a const value (not a dynamic variable of
+ * reg-a0) or BUILD_BUG_ON failed with "idx >= __end_of_fixed_addresses".
+ * So use '__always_inline' and 'const unsigned int fixmap' here.
+ */
+static __always_inline void *patch_map(void *addr, const unsigned int fixmap)
 {
 	uintptr_t uintaddr = (uintptr_t) addr;
 	struct page *page;
@@ -40,7 +45,6 @@ static void *patch_map(void *addr, int fixmap)
 	return (void *)set_fixmap_offset(fixmap, page_to_phys(page) +
 					 (uintaddr & ~PAGE_MASK));
 }
-NOKPROBE_SYMBOL(patch_map);
 
 static void patch_unmap(int fixmap)
 {
diff --git a/arch/riscv/kernel/perf_callchain.c b/arch/riscv/kernel/perf_callchain.c
index fb02811df714..357f985041cb 100644
--- a/arch/riscv/kernel/perf_callchain.c
+++ b/arch/riscv/kernel/perf_callchain.c
@@ -4,11 +4,7 @@
 #include <linux/perf_event.h>
 #include <linux/uaccess.h>
 
-/* Kernel callchain */
-struct stackframe {
-	unsigned long fp;
-	unsigned long ra;
-};
+#include <asm/stacktrace.h>
 
 /*
  * Get the return address for a single stackframe and return a pointer to the
@@ -75,13 +71,11 @@ void perf_callchain_user(struct perf_callchain_entry_ctx *entry,
 		fp = user_backtrace(entry, fp, 0);
 }
 
-bool fill_callchain(unsigned long pc, void *entry)
+static bool fill_callchain(void *entry, unsigned long pc)
 {
 	return perf_callchain_store(entry, pc) == 0;
 }
 
-void notrace walk_stackframe(struct task_struct *task,
-	struct pt_regs *regs, bool (*fn)(unsigned long, void *), void *arg);
 void perf_callchain_kernel(struct perf_callchain_entry_ctx *entry,
 			   struct pt_regs *regs)
 {
diff --git a/arch/riscv/kernel/process.c b/arch/riscv/kernel/process.c
index 7868050ff426..0fed86eb3167 100644
--- a/arch/riscv/kernel/process.c
+++ b/arch/riscv/kernel/process.c
@@ -14,10 +14,13 @@
 #include <linux/tick.h>
 #include <linux/ptrace.h>
 #include <linux/uaccess.h>
+#include <uapi/linux/elf.h>
 
 #include <asm/unistd.h>
 #include <asm/processor.h>
+#include <asm/compat.h>
 #include <asm/csr.h>
+#include <asm/stacktrace.h>
 #include <asm/string.h>
 #include <asm/switch_to.h>
 #include <asm/thread_info.h>
@@ -39,7 +42,7 @@ void arch_cpu_idle(void)
 	raw_local_irq_enable();
 }
 
-void show_regs(struct pt_regs *regs)
+void __show_regs(struct pt_regs *regs)
 {
 	show_regs_print_info(KERN_DEFAULT);
 
@@ -69,6 +72,12 @@ void show_regs(struct pt_regs *regs)
 	pr_cont("status: " REG_FMT " badaddr: " REG_FMT " cause: " REG_FMT "\n",
 		regs->status, regs->badaddr, regs->cause);
 }
+void show_regs(struct pt_regs *regs)
+{
+	__show_regs(regs);
+	if (!user_mode(regs))
+		dump_backtrace(regs, NULL, KERN_DEFAULT);
+}
 
 void start_thread(struct pt_regs *regs, unsigned long pc,
 	unsigned long sp)
@@ -82,8 +91,22 @@ void start_thread(struct pt_regs *regs, unsigned long pc,
 		 */
 		fstate_restore(current, regs);
 	}
+
+	if (has_vector) {
+		regs->status |= SR_VS_INITIAL;
+		vstate_restore(current, regs);
+	}
+
 	regs->epc = pc;
 	regs->sp = sp;
+
+#ifdef CONFIG_COMPAT
+	regs->status &= ~SR_UXL;
+	if (is_compat_task())
+		regs->status |= SR_UXL_32;
+	else
+		regs->status |= SR_UXL_64;
+#endif
 }
 
 void flush_thread(void)
diff --git a/arch/riscv/kernel/ptrace.c b/arch/riscv/kernel/ptrace.c
index 69678ab6457d..85c81d65f694 100644
--- a/arch/riscv/kernel/ptrace.c
+++ b/arch/riscv/kernel/ptrace.c
@@ -12,6 +12,7 @@
 #include <asm/thread_info.h>
 #include <asm/switch_to.h>
 #include <linux/audit.h>
+#include <linux/compat.h>
 #include <linux/ptrace.h>
 #include <linux/elf.h>
 #include <linux/regset.h>
@@ -27,6 +28,9 @@ enum riscv_regset {
 #ifdef CONFIG_FPU
 	REGSET_F,
 #endif
+#ifdef CONFIG_VECTOR
+	REGSET_V,
+#endif
 };
 
 static int riscv_gpr_get(struct task_struct *target,
@@ -85,6 +89,31 @@ static int riscv_fpr_set(struct task_struct *target,
 }
 #endif
 
+#ifdef CONFIG_VECTOR
+static int riscv_vr_get(struct task_struct *target,
+			 const struct user_regset *regset,
+			 struct membuf to)
+{
+	struct __riscv_v_state *vstate = &target->thread.vstate;
+
+	membuf_write(&to, vstate, offsetof(struct __riscv_v_state, vtype));
+	return membuf_zero(&to, 4);	// explicitly pad
+}
+
+static int riscv_vr_set(struct task_struct *target,
+			 const struct user_regset *regset,
+			 unsigned int pos, unsigned int count,
+			 const void *kbuf, const void __user *ubuf)
+{
+	int ret;
+	struct __riscv_v_state *vstate = &target->thread.vstate;
+
+	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, vstate, 0,
+				 offsetof(struct __riscv_v_state, vtype));
+	return ret;
+}
+#endif
+
 static const struct user_regset riscv_user_regset[] = {
 	[REGSET_X] = {
 		.core_note_type = NT_PRSTATUS,
@@ -104,6 +133,16 @@ static const struct user_regset riscv_user_regset[] = {
 		.set = riscv_fpr_set,
 	},
 #endif
+#ifdef CONFIG_VECTOR
+	[REGSET_V] = {
+		.core_note_type = NT_RISCV_VECTOR,
+		.n = ELF_NVREG,
+		.size = sizeof(elf_greg_t),
+		.align = sizeof(elf_greg_t),
+		.regset_get = riscv_vr_get,
+		.set = riscv_vr_set,
+	},
+#endif
 };
 
 static const struct user_regset_view riscv_user_native_view = {
@@ -113,9 +152,103 @@ static const struct user_regset_view riscv_user_native_view = {
 	.n = ARRAY_SIZE(riscv_user_regset),
 };
 
-const struct user_regset_view *task_user_regset_view(struct task_struct *task)
+struct pt_regs_offset {
+	const char *name;
+	int offset;
+};
+
+#define REG_OFFSET_NAME(r) {.name = #r, .offset = offsetof(struct pt_regs, r)}
+#define REG_OFFSET_END {.name = NULL, .offset = 0}
+
+static const struct pt_regs_offset regoffset_table[] = {
+	REG_OFFSET_NAME(epc),
+	REG_OFFSET_NAME(ra),
+	REG_OFFSET_NAME(sp),
+	REG_OFFSET_NAME(gp),
+	REG_OFFSET_NAME(tp),
+	REG_OFFSET_NAME(t0),
+	REG_OFFSET_NAME(t1),
+	REG_OFFSET_NAME(t2),
+	REG_OFFSET_NAME(s0),
+	REG_OFFSET_NAME(s1),
+	REG_OFFSET_NAME(a0),
+	REG_OFFSET_NAME(a1),
+	REG_OFFSET_NAME(a2),
+	REG_OFFSET_NAME(a3),
+	REG_OFFSET_NAME(a4),
+	REG_OFFSET_NAME(a5),
+	REG_OFFSET_NAME(a6),
+	REG_OFFSET_NAME(a7),
+	REG_OFFSET_NAME(s2),
+	REG_OFFSET_NAME(s3),
+	REG_OFFSET_NAME(s4),
+	REG_OFFSET_NAME(s5),
+	REG_OFFSET_NAME(s6),
+	REG_OFFSET_NAME(s7),
+	REG_OFFSET_NAME(s8),
+	REG_OFFSET_NAME(s9),
+	REG_OFFSET_NAME(s10),
+	REG_OFFSET_NAME(s11),
+	REG_OFFSET_NAME(t3),
+	REG_OFFSET_NAME(t4),
+	REG_OFFSET_NAME(t5),
+	REG_OFFSET_NAME(t6),
+	REG_OFFSET_NAME(status),
+	REG_OFFSET_NAME(badaddr),
+	REG_OFFSET_NAME(cause),
+	REG_OFFSET_NAME(orig_a0),
+	REG_OFFSET_END,
+};
+
+/**
+ * regs_query_register_offset() - query register offset from its name
+ * @name:	the name of a register
+ *
+ * regs_query_register_offset() returns the offset of a register in struct
+ * pt_regs from its name. If the name is invalid, this returns -EINVAL;
+ */
+int regs_query_register_offset(const char *name)
+{
+	const struct pt_regs_offset *roff;
+
+	for (roff = regoffset_table; roff->name != NULL; roff++)
+		if (!strcmp(roff->name, name))
+			return roff->offset;
+	return -EINVAL;
+}
+
+/**
+ * regs_within_kernel_stack() - check the address in the stack
+ * @regs:      pt_regs which contains kernel stack pointer.
+ * @addr:      address which is checked.
+ *
+ * regs_within_kernel_stack() checks @addr is within the kernel stack page(s).
+ * If @addr is within the kernel stack, it returns true. If not, returns false.
+ */
+static bool regs_within_kernel_stack(struct pt_regs *regs, unsigned long addr)
 {
-	return &riscv_user_native_view;
+	return (addr & ~(THREAD_SIZE - 1))  ==
+		(kernel_stack_pointer(regs) & ~(THREAD_SIZE - 1));
+}
+
+/**
+ * regs_get_kernel_stack_nth() - get Nth entry of the stack
+ * @regs:	pt_regs which contains kernel stack pointer.
+ * @n:		stack entry number.
+ *
+ * regs_get_kernel_stack_nth() returns @n th entry of the kernel stack which
+ * is specified by @regs. If the @n th entry is NOT in the kernel stack,
+ * this returns 0.
+ */
+unsigned long regs_get_kernel_stack_nth(struct pt_regs *regs, unsigned int n)
+{
+	unsigned long *addr = (unsigned long *)kernel_stack_pointer(regs);
+
+	addr += n;
+	if (regs_within_kernel_stack(regs, (unsigned long)addr))
+		return *addr;
+	else
+		return 0;
 }
 
 void ptrace_disable(struct task_struct *child)
@@ -176,3 +309,94 @@ __visible void do_syscall_trace_exit(struct pt_regs *regs)
 		trace_sys_exit(regs, regs_return_value(regs));
 #endif
 }
+
+#ifdef CONFIG_COMPAT
+static int compat_riscv_gpr_get(struct task_struct *target,
+				const struct user_regset *regset,
+				struct membuf to)
+{
+	struct compat_user_regs_struct cregs;
+
+	regs_to_cregs(&cregs, task_pt_regs(target));
+
+	return membuf_write(&to, &cregs,
+			    sizeof(struct compat_user_regs_struct));
+}
+
+static int compat_riscv_gpr_set(struct task_struct *target,
+				const struct user_regset *regset,
+				unsigned int pos, unsigned int count,
+				const void *kbuf, const void __user *ubuf)
+{
+	int ret;
+	struct compat_user_regs_struct cregs;
+
+	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &cregs, 0, -1);
+
+	cregs_to_regs(&cregs, task_pt_regs(target));
+
+	return ret;
+}
+
+static const struct user_regset compat_riscv_user_regset[] = {
+	[REGSET_X] = {
+		.core_note_type = NT_PRSTATUS,
+		.n = ELF_NGREG,
+		.size = sizeof(compat_elf_greg_t),
+		.align = sizeof(compat_elf_greg_t),
+		.regset_get = compat_riscv_gpr_get,
+		.set = compat_riscv_gpr_set,
+	},
+#ifdef CONFIG_FPU
+	[REGSET_F] = {
+		.core_note_type = NT_PRFPREG,
+		.n = ELF_NFPREG,
+		.size = sizeof(elf_fpreg_t),
+		.align = sizeof(elf_fpreg_t),
+		.regset_get = riscv_fpr_get,
+		.set = riscv_fpr_set,
+	},
+#endif
+#ifdef CONFIG_VECTOR
+	[REGSET_V] = {
+		.core_note_type = NT_RISCV_VECTOR,
+		.n = ELF_NVREG,
+		.size = sizeof(elf_greg_t),
+		.align = sizeof(elf_greg_t),
+		.regset_get = riscv_vr_get,
+		.set = riscv_vr_set,
+	},
+#endif
+};
+
+static const struct user_regset_view compat_riscv_user_native_view = {
+	.name = "riscv",
+	.e_machine = EM_RISCV,
+	.regsets = compat_riscv_user_regset,
+	.n = ARRAY_SIZE(compat_riscv_user_regset),
+};
+
+long compat_arch_ptrace(struct task_struct *child, compat_long_t request,
+			compat_ulong_t caddr, compat_ulong_t cdata)
+{
+	long ret = -EIO;
+
+	switch (request) {
+	default:
+		ret = compat_ptrace_request(child, request, caddr, cdata);
+		break;
+	}
+
+	return ret;
+}
+#endif /* CONFIG_COMPAT */
+
+const struct user_regset_view *task_user_regset_view(struct task_struct *task)
+{
+#ifdef CONFIG_COMPAT
+	if (test_tsk_thread_flag(task, TIF_32BIT))
+		return &compat_riscv_user_native_view;
+	else
+#endif
+		return &riscv_user_native_view;
+}
diff --git a/arch/riscv/kernel/sbi.c b/arch/riscv/kernel/sbi.c
index 226ccce0f9e0..51a4e5f23989 100644
--- a/arch/riscv/kernel/sbi.c
+++ b/arch/riscv/kernel/sbi.c
@@ -547,6 +547,21 @@ static inline long sbi_get_firmware_version(void)
 	return __sbi_base_ecall(SBI_EXT_BASE_GET_IMP_VERSION);
 }
 
+long sbi_get_mvendorid(void)
+{
+	return __sbi_base_ecall(SBI_EXT_BASE_GET_MVENDORID);
+}
+
+long sbi_get_marchid(void)
+{
+	return __sbi_base_ecall(SBI_EXT_BASE_GET_MARCHID);
+}
+
+long sbi_get_mimpid(void)
+{
+	return __sbi_base_ecall(SBI_EXT_BASE_GET_MIMPID);
+}
+
 static void sbi_send_cpumask_ipi(const struct cpumask *target)
 {
 	struct cpumask hartid_mask;
diff --git a/arch/riscv/kernel/signal.c b/arch/riscv/kernel/signal.c
index dd63407e8294..dd2d54d0c35e 100644
--- a/arch/riscv/kernel/signal.c
+++ b/arch/riscv/kernel/signal.c
@@ -6,6 +6,7 @@
  * Copyright (C) 2012 Regents of the University of California
  */
 
+#include <linux/compat.h>
 #include <linux/signal.h>
 #include <linux/uaccess.h>
 #include <linux/syscalls.h>
@@ -84,6 +85,41 @@ static long save_fp_state(struct pt_regs *regs,
 #define restore_fp_state(task, regs) (0)
 #endif
 
+#ifdef CONFIG_VECTOR
+static long restore_v_state(struct pt_regs *regs,
+			    struct __riscv_v_state *sc_vregs)
+{
+	long err;
+	struct __riscv_v_state __user *state = sc_vregs;
+
+	err = __copy_from_user(&current->thread.vstate, state, sizeof(*state));
+	if (unlikely(err))
+		return err;
+
+	vstate_restore(current, regs);
+
+	return err;
+}
+
+static long save_v_state(struct pt_regs *regs,
+			 struct __riscv_v_state *sc_vregs)
+{
+	long err;
+	struct __riscv_v_state __user *state = sc_vregs;
+
+	vstate_save(current, regs);
+	err = __copy_to_user(state, &current->thread.vstate, sizeof(*state));
+	if (unlikely(err))
+		return err;
+
+	return err;
+}
+#else
+#define save_v_state(task, regs) (0)
+#define restore_v_state(task, regs) (0)
+#endif
+
+
 static long restore_sigcontext(struct pt_regs *regs,
 	struct sigcontext __user *sc)
 {
@@ -93,6 +129,9 @@ static long restore_sigcontext(struct pt_regs *regs,
 	/* Restore the floating-point state. */
 	if (has_fpu)
 		err |= restore_fp_state(regs, &sc->sc_fpregs);
+	/* Restore the vector state. */
+	if (has_vector)
+		err |= restore_v_state(regs, &sc->sc_vregs);
 	return err;
 }
 
@@ -148,6 +187,9 @@ static long setup_sigcontext(struct rt_sigframe __user *frame,
 	/* Save the floating-point state. */
 	if (has_fpu)
 		err |= save_fp_state(regs, &sc->sc_fpregs);
+	/* Save the vector state. */
+	if (has_vector)
+		err |= save_v_state(regs, &sc->sc_vregs);
 	return err;
 }
 
@@ -238,6 +280,11 @@ static int setup_rt_frame(struct ksignal *ksig, sigset_t *set,
 	return 0;
 }
 
+#ifdef CONFIG_COMPAT
+extern int compat_setup_rt_frame(struct ksignal *ksig, sigset_t *set,
+				 struct pt_regs *regs);
+#endif
+
 static void handle_signal(struct ksignal *ksig, struct pt_regs *regs)
 {
 	sigset_t *oldset = sigmask_to_save();
@@ -267,8 +314,13 @@ static void handle_signal(struct ksignal *ksig, struct pt_regs *regs)
 		}
 	}
 
+#ifdef CONFIG_COMPAT
 	/* Set up the stack frame */
-	ret = setup_rt_frame(ksig, oldset, regs);
+	if (is_compat_task())
+		ret = compat_setup_rt_frame(ksig, oldset, regs);
+	else
+#endif
+		ret = setup_rt_frame(ksig, oldset, regs);
 
 	signal_setup_done(ret, ksig, 0);
 }
@@ -318,6 +370,9 @@ static void do_signal(struct pt_regs *regs)
 asmlinkage __visible void do_notify_resume(struct pt_regs *regs,
 					   unsigned long thread_info_flags)
 {
+	if (thread_info_flags & _TIF_UPROBE)
+		uprobe_notify_resume(regs);
+
 	/* Handle pending signal delivery */
 	if (thread_info_flags & (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))
 		do_signal(regs);
diff --git a/arch/riscv/kernel/stacktrace.c b/arch/riscv/kernel/stacktrace.c
index 9c34735c1e77..0165620c6e1f 100644
--- a/arch/riscv/kernel/stacktrace.c
+++ b/arch/riscv/kernel/stacktrace.c
@@ -12,17 +12,14 @@
 #include <linux/stacktrace.h>
 #include <linux/ftrace.h>
 
+#include <asm/stacktrace.h>
+
 register unsigned long sp_in_global __asm__("sp");
 
 #ifdef CONFIG_FRAME_POINTER
 
-struct stackframe {
-	unsigned long fp;
-	unsigned long ra;
-};
-
 void notrace walk_stackframe(struct task_struct *task, struct pt_regs *regs,
-			     bool (*fn)(unsigned long, void *), void *arg)
+			     bool (*fn)(void *, unsigned long), void *arg)
 {
 	unsigned long fp, sp, pc;
 
@@ -46,7 +43,7 @@ void notrace walk_stackframe(struct task_struct *task, struct pt_regs *regs,
 		unsigned long low, high;
 		struct stackframe *frame;
 
-		if (unlikely(!__kernel_text_address(pc) || fn(pc, arg)))
+		if (unlikely(!__kernel_text_address(pc) || !fn(arg, pc)))
 			break;
 
 		/* Validate frame pointer */
@@ -72,7 +69,7 @@ void notrace walk_stackframe(struct task_struct *task, struct pt_regs *regs,
 #else /* !CONFIG_FRAME_POINTER */
 
 void notrace walk_stackframe(struct task_struct *task,
-	struct pt_regs *regs, bool (*fn)(unsigned long, void *), void *arg)
+	struct pt_regs *regs, bool (*fn)(void *, unsigned long), void *arg)
 {
 	unsigned long sp, pc;
 	unsigned long *ksp;
@@ -94,7 +91,7 @@ void notrace walk_stackframe(struct task_struct *task,
 
 	ksp = (unsigned long *)sp;
 	while (!kstack_end(ksp)) {
-		if (__kernel_text_address(pc) && unlikely(fn(pc, arg)))
+		if (__kernel_text_address(pc) && unlikely(!fn(arg, pc)))
 			break;
 		pc = READ_ONCE_NOCHECK(*ksp++) - 0x4;
 	}
@@ -102,29 +99,34 @@ void notrace walk_stackframe(struct task_struct *task,
 
 #endif /* CONFIG_FRAME_POINTER */
 
-
-static bool print_trace_address(unsigned long pc, void *arg)
+static bool print_trace_address(void *arg, unsigned long pc)
 {
 	const char *loglvl = arg;
 
 	print_ip_sym(loglvl, pc);
-	return false;
+	return true;
+}
+
+void dump_backtrace(struct pt_regs *regs, struct task_struct *task,
+		    const char *loglvl)
+{
+	pr_cont("%sCall Trace:\n", loglvl);
+	walk_stackframe(task, regs, print_trace_address, (void *)loglvl);
 }
 
 void show_stack(struct task_struct *task, unsigned long *sp, const char *loglvl)
 {
-	pr_cont("Call Trace:\n");
-	walk_stackframe(task, NULL, print_trace_address, (void *)loglvl);
+	dump_backtrace(NULL, task, loglvl);
 }
 
-static bool save_wchan(unsigned long pc, void *arg)
+static bool save_wchan(void *arg, unsigned long pc)
 {
 	if (!in_sched_functions(pc)) {
 		unsigned long *p = arg;
 		*p = pc;
-		return true;
+		return false;
 	}
-	return false;
+	return true;
 }
 
 unsigned long get_wchan(struct task_struct *task)
@@ -136,42 +138,12 @@ unsigned long get_wchan(struct task_struct *task)
 	return pc;
 }
 
-
 #ifdef CONFIG_STACKTRACE
 
-static bool __save_trace(unsigned long pc, void *arg, bool nosched)
-{
-	struct stack_trace *trace = arg;
-
-	if (unlikely(nosched && in_sched_functions(pc)))
-		return false;
-	if (unlikely(trace->skip > 0)) {
-		trace->skip--;
-		return false;
-	}
-
-	trace->entries[trace->nr_entries++] = pc;
-	return (trace->nr_entries >= trace->max_entries);
-}
-
-static bool save_trace(unsigned long pc, void *arg)
-{
-	return __save_trace(pc, arg, false);
-}
-
-/*
- * Save stack-backtrace addresses into a stack_trace buffer.
- */
-void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
-{
-	walk_stackframe(tsk, NULL, save_trace, trace);
-}
-EXPORT_SYMBOL_GPL(save_stack_trace_tsk);
-
-void save_stack_trace(struct stack_trace *trace)
+void arch_stack_walk(stack_trace_consume_fn consume_entry, void *cookie,
+		     struct task_struct *task, struct pt_regs *regs)
 {
-	save_stack_trace_tsk(NULL, trace);
+	walk_stackframe(task, regs, consume_entry, cookie);
 }
-EXPORT_SYMBOL_GPL(save_stack_trace);
 
 #endif /* CONFIG_STACKTRACE */
diff --git a/arch/riscv/kernel/syscall_table.c b/arch/riscv/kernel/syscall_table.c
index f1ead9df96ca..f5415280c46a 100644
--- a/arch/riscv/kernel/syscall_table.c
+++ b/arch/riscv/kernel/syscall_table.c
@@ -13,7 +13,7 @@
 #undef __SYSCALL
 #define __SYSCALL(nr, call)	[nr] = (call),
 
-void *sys_call_table[__NR_syscalls] = {
+const void *sys_call_table[__NR_syscalls] = {
 	[0 ... __NR_syscalls - 1] = sys_ni_syscall,
 #include <asm/unistd.h>
 };
diff --git a/arch/riscv/kernel/traps.c b/arch/riscv/kernel/traps.c
index 227253fde33c..8489c2992ffa 100644
--- a/arch/riscv/kernel/traps.c
+++ b/arch/riscv/kernel/traps.c
@@ -12,11 +12,13 @@
 #include <linux/signal.h>
 #include <linux/kdebug.h>
 #include <linux/uaccess.h>
+#include <linux/kprobes.h>
 #include <linux/mm.h>
 #include <linux/module.h>
 #include <linux/irq.h>
 #include <linux/kexec.h>
 
+#include <asm/bug.h>
 #include <asm/processor.h>
 #include <asm/ptrace.h>
 #include <asm/csr.h>
@@ -64,17 +66,26 @@ void die(struct pt_regs *regs, const char *str)
 		make_task_dead(SIGSEGV);
 }
 
+#ifdef CONFIG_VECTOR_EMU
+extern bool decode_exec_insn(struct pt_regs *regs, uint64_t insn);
+#endif
 void do_trap(struct pt_regs *regs, int signo, int code, unsigned long addr)
 {
 	struct task_struct *tsk = current;
 
+#ifdef CONFIG_VECTOR_EMU
+	if (signo == SIGILL)
+		if (decode_exec_insn(regs, regs->badaddr))
+			return;
+#endif
+
 	if (show_unhandled_signals && unhandled_signal(tsk, signo)
 	    && printk_ratelimit()) {
 		pr_info("%s[%d]: unhandled signal %d code 0x%x at 0x" REG_FMT,
 			tsk->comm, task_pid_nr(tsk), signo, code, addr);
 		print_vma_addr(KERN_CONT " in ", instruction_pointer(regs));
 		pr_cont("\n");
-		show_regs(regs);
+		__show_regs(regs);
 	}
 
 	force_sig_fault(signo, code, (void __user *)addr);
@@ -83,6 +94,8 @@ void do_trap(struct pt_regs *regs, int signo, int code, unsigned long addr)
 static void do_trap_error(struct pt_regs *regs, int signo, int code,
 	unsigned long addr, const char *str)
 {
+	current->thread.bad_cause = regs->cause;
+
 	if (user_mode(regs)) {
 		do_trap(regs, signo, code, addr);
 	} else {
@@ -153,6 +166,22 @@ static inline unsigned long get_break_insn_length(unsigned long pc)
 
 asmlinkage __visible void do_trap_break(struct pt_regs *regs)
 {
+#ifdef CONFIG_KPROBES
+	if (kprobe_single_step_handler(regs))
+		return;
+
+	if (kprobe_breakpoint_handler(regs))
+		return;
+#endif
+#ifdef CONFIG_UPROBES
+	if (uprobe_single_step_handler(regs))
+		return;
+
+	if (uprobe_breakpoint_handler(regs))
+		return;
+#endif
+	current->thread.bad_cause = regs->cause;
+
 	if (user_mode(regs))
 		force_sig_fault(SIGTRAP, TRAP_BRKPT, (void __user *)regs->epc);
 #ifdef CONFIG_KGDB
diff --git a/arch/riscv/kernel/vdso/gen_vdso_offsets.sh b/arch/riscv/kernel/vdso/gen_vdso_offsets.sh
new file mode 100755
index 000000000000..c2e5613f3495
--- /dev/null
+++ b/arch/riscv/kernel/vdso/gen_vdso_offsets.sh
@@ -0,0 +1,5 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0
+
+LC_ALL=C
+sed -n -e 's/^[0]\+\(0[0-9a-fA-F]*\) . \(__vdso_[a-zA-Z0-9_]*\)$/\#define \2_offset\t0x\1/p'
diff --git a/arch/riscv/kernel/vmlinux.lds.S b/arch/riscv/kernel/vmlinux.lds.S
index 3ffbd6cbdb86..9b2c352a697e 100644
--- a/arch/riscv/kernel/vmlinux.lds.S
+++ b/arch/riscv/kernel/vmlinux.lds.S
@@ -24,7 +24,7 @@ PECOFF_FILE_ALIGNMENT = 0x200;
 SECTIONS
 {
 	/* Beginning of code and text segment */
-	. = LOAD_OFFSET;
+	. = PAGE_OFFSET + LOAD_OFFSET;
 	_start = .;
 	HEAD_TEXT_SECTION
 	. = ALIGN(PAGE_SIZE);
diff --git a/arch/riscv/mach-cvitek/Kconfig b/arch/riscv/mach-cvitek/Kconfig
new file mode 100644
index 000000000000..3defd9645305
--- /dev/null
+++ b/arch/riscv/mach-cvitek/Kconfig
@@ -0,0 +1,93 @@
+config ARCH_CVITEK
+    bool "Cvitek SoC Family"
+	select ION_CVITEK
+	select SCHED_CVITEK
+	help
+      This enables support for Cvitek SoC family.
+
+if ARCH_CVITEK
+choice
+	prompt "Select the chip of SoC"
+	default ARCH_CV181X
+	help
+	  Select the chip for SoC
+
+config ARCH_CV181X
+	bool "Cvitek CV181X SoC"
+	help
+	  This enables support for Cvitek's CV181X
+
+config ARCH_CV180X
+	bool "Cvitek CV180X SoC"
+	help
+	  This enables support for Cvitek's CV180X
+
+endchoice
+
+if ARCH_CV181X
+config ARCH_CVITEK_CHIP
+	string "cv181x"
+	help
+	  This enables support for Cvitek CV181X series
+
+choice
+	prompt "Select the platform of SoC"
+	default ARCH_CV181X_FPGA
+	help
+	  Select the platform of SoC
+	    FPGA
+	    PALLADIUM
+	    ASIC
+
+config ARCH_CV181X_PALLADIUM
+	bool "Cvitek CV181X SoC - Palladium"
+	help
+	  This enables support for Cvitek's CV181X SoC on Palladium platform
+
+config ARCH_CV181X_FPGA
+	bool "Cvitek CV181X SoC - FPGA"
+	help
+	  This enables support for Cvitek's CV181X SoC on FPGA platform
+
+config ARCH_CV181X_ASIC
+	bool "Cvitek CV181X SoC- ASIC"
+	help
+	  This enables support for Cvitek's CV181X SoC ASIC
+
+endchoice
+endif # end ARCH_CV181X
+
+if ARCH_CV180X
+config ARCH_CVITEK_CHIP
+	string "cv180x"
+	help
+	  This enables support for Cvitek CV180X series
+
+choice
+	prompt "Select the platform of SoC"
+	default ARCH_CV180X_FPGA
+	help
+	  Select the platform of SoC
+	    FPGA
+	    PALLADIUM
+	    ASIC
+
+config ARCH_CV180X_PALLADIUM
+	bool "Cvitek CV180X SoC - Palladium"
+	help
+	  This enables support for Cvitek's CV180X SoC on Palladium platform
+
+config ARCH_CV180X_FPGA
+	bool "Cvitek CV180X SoC - FPGA"
+	help
+	  This enables support for Cvitek's CV180X SoC on FPGA platform
+
+config ARCH_CV180X_ASIC
+	bool "Cvitek CV180X SoC- ASIC"
+	help
+	  This enables support for Cvitek's CV180X SoC ASIC
+
+endchoice
+endif # end ARCH_CV181X
+
+endif # end ARCH_CVITEK
diff --git a/arch/riscv/mach-cvitek/Makefile b/arch/riscv/mach-cvitek/Makefile
new file mode 100644
index 000000000000..c52d393fbd1e
--- /dev/null
+++ b/arch/riscv/mach-cvitek/Makefile
@@ -0,0 +1 @@
+obj-y := cvitek.o
diff --git a/arch/riscv/mm/Makefile b/arch/riscv/mm/Makefile
index ac7a25298a04..5d50cc108513 100644
--- a/arch/riscv/mm/Makefile
+++ b/arch/riscv/mm/Makefile
@@ -13,6 +13,8 @@ obj-y += extable.o
 obj-$(CONFIG_MMU) += fault.o pageattr.o
 obj-y += cacheflush.o
 obj-y += context.o
+obj-y += dma-mapping.o
+obj-y += ioremap.o
 
 ifeq ($(CONFIG_MMU),y)
 obj-$(CONFIG_SMP) += tlbflush.o
diff --git a/arch/riscv/mm/asid.c b/arch/riscv/mm/asid.c
new file mode 100644
index 000000000000..b2e914745c1d
--- /dev/null
+++ b/arch/riscv/mm/asid.c
@@ -0,0 +1,189 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Generic ASID allocator.
+ *
+ * Based on arch/arm/mm/context.c
+ *
+ * Copyright (C) 2002-2003 Deep Blue Solutions Ltd, all rights reserved.
+ * Copyright (C) 2012 ARM Ltd.
+ */
+
+#include <linux/slab.h>
+#include <linux/mm_types.h>
+
+#include <asm/asid.h>
+
+#define reserved_asid(info, cpu) *per_cpu_ptr((info)->reserved, cpu)
+
+#define ASID_MASK(info)			(~GENMASK((info)->bits - 1, 0))
+#define ASID_FIRST_VERSION(info)	(1UL << ((info)->bits))
+
+#define asid2idx(info, asid)		(((asid) & ~ASID_MASK(info)) >> (info)->ctxt_shift)
+#define idx2asid(info, idx)		(((idx) << (info)->ctxt_shift) & ~ASID_MASK(info))
+
+static void flush_context(struct asid_info *info)
+{
+	int i;
+	u64 asid;
+
+	/* Update the list of reserved ASIDs and the ASID bitmap. */
+	bitmap_clear(info->map, 0, NUM_CTXT_ASIDS(info));
+
+	for_each_possible_cpu(i) {
+		asid = atomic64_xchg_relaxed(&active_asid(info, i), 0);
+		/*
+		 * If this CPU has already been through a
+		 * rollover, but hasn't run another task in
+		 * the meantime, we must preserve its reserved
+		 * ASID, as this is the only trace we have of
+		 * the process it is still running.
+		 */
+		if (asid == 0)
+			asid = reserved_asid(info, i);
+		__set_bit(asid2idx(info, asid), info->map);
+		reserved_asid(info, i) = asid;
+	}
+
+	/*
+	 * Queue a TLB invalidation for each CPU to perform on next
+	 * context-switch
+	 */
+	cpumask_setall(&info->flush_pending);
+}
+
+static bool check_update_reserved_asid(struct asid_info *info, u64 asid,
+				       u64 newasid)
+{
+	int cpu;
+	bool hit = false;
+
+	/*
+	 * Iterate over the set of reserved ASIDs looking for a match.
+	 * If we find one, then we can update our mm to use newasid
+	 * (i.e. the same ASID in the current generation) but we can't
+	 * exit the loop early, since we need to ensure that all copies
+	 * of the old ASID are updated to reflect the mm. Failure to do
+	 * so could result in us missing the reserved ASID in a future
+	 * generation.
+	 */
+	for_each_possible_cpu(cpu) {
+		if (reserved_asid(info, cpu) == asid) {
+			hit = true;
+			reserved_asid(info, cpu) = newasid;
+		}
+	}
+
+	return hit;
+}
+
+static u64 new_context(struct asid_info *info, atomic64_t *pasid,
+		       struct mm_struct *mm)
+{
+	static u32 cur_idx = 1;
+	u64 asid = atomic64_read(pasid);
+	u64 generation = atomic64_read(&info->generation);
+
+	if (asid != 0) {
+		u64 newasid = generation | (asid & ~ASID_MASK(info));
+
+		/*
+		 * If our current ASID was active during a rollover, we
+		 * can continue to use it and this was just a false alarm.
+		 */
+		if (check_update_reserved_asid(info, asid, newasid))
+			return newasid;
+
+		/*
+		 * We had a valid ASID in a previous life, so try to re-use
+		 * it if possible.
+		 */
+		if (!__test_and_set_bit(asid2idx(info, asid), info->map))
+			return newasid;
+	}
+
+	/*
+	 * Allocate a free ASID. If we can't find one, take a note of the
+	 * currently active ASIDs and mark the TLBs as requiring flushes.  We
+	 * always count from ASID #2 (index 1), as we use ASID #0 when setting
+	 * a reserved TTBR0 for the init_mm and we allocate ASIDs in even/odd
+	 * pairs.
+	 */
+	asid = find_next_zero_bit(info->map, NUM_CTXT_ASIDS(info), cur_idx);
+	if (asid != NUM_CTXT_ASIDS(info))
+		goto set_asid;
+
+	/* We're out of ASIDs, so increment the global generation count */
+	generation = atomic64_add_return_relaxed(ASID_FIRST_VERSION(info),
+						 &info->generation);
+	flush_context(info);
+
+	/* We have more ASIDs than CPUs, so this will always succeed */
+	asid = find_next_zero_bit(info->map, NUM_CTXT_ASIDS(info), 1);
+
+set_asid:
+	__set_bit(asid, info->map);
+	cur_idx = asid;
+	cpumask_clear(mm_cpumask(mm));
+	return idx2asid(info, asid) | generation;
+}
+
+/*
+ * Generate a new ASID for the context.
+ *
+ * @pasid: Pointer to the current ASID batch allocated. It will be updated
+ * with the new ASID batch.
+ * @cpu: current CPU ID. Must have been acquired through get_cpu()
+ */
+void asid_new_context(struct asid_info *info, atomic64_t *pasid,
+		      unsigned int cpu, struct mm_struct *mm)
+{
+	unsigned long flags;
+	u64 asid;
+
+	raw_spin_lock_irqsave(&info->lock, flags);
+	/* Check that our ASID belongs to the current generation. */
+	asid = atomic64_read(pasid);
+	if ((asid ^ atomic64_read(&info->generation)) >> info->bits) {
+		asid = new_context(info, pasid, mm);
+		atomic64_set(pasid, asid);
+	}
+
+	if (cpumask_test_and_clear_cpu(cpu, &info->flush_pending))
+		info->flush_cpu_ctxt_cb();
+
+	atomic64_set(&active_asid(info, cpu), asid);
+	cpumask_set_cpu(cpu, mm_cpumask(mm));
+	raw_spin_unlock_irqrestore(&info->lock, flags);
+}
+
+/*
+ * Initialize the ASID allocator
+ *
+ * @info: Pointer to the asid allocator structure
+ * @bits: Number of ASIDs available
+ * @asid_per_ctxt: Number of ASIDs to allocate per-context. ASIDs are
+ * allocated contiguously for a given context. This value should be a power of
+ * 2.
+ */
+int asid_allocator_init(struct asid_info *info,
+			u32 bits, unsigned int asid_per_ctxt,
+			void (*flush_cpu_ctxt_cb)(void))
+{
+	info->bits = bits;
+	info->ctxt_shift = ilog2(asid_per_ctxt);
+	info->flush_cpu_ctxt_cb = flush_cpu_ctxt_cb;
+	/*
+	 * Expect allocation after rollover to fail if we don't have at least
+	 * one more ASID than CPUs. ASID #0 is always reserved.
+	 */
+	WARN_ON(NUM_CTXT_ASIDS(info) - 1 <= num_possible_cpus());
+	atomic64_set(&info->generation, ASID_FIRST_VERSION(info));
+	info->map = kcalloc(BITS_TO_LONGS(NUM_CTXT_ASIDS(info)),
+			    sizeof(*info->map), GFP_KERNEL);
+	if (!info->map)
+		return -ENOMEM;
+
+	raw_spin_lock_init(&info->lock);
+
+	return 0;
+}
diff --git a/arch/riscv/mm/cacheflush.c b/arch/riscv/mm/cacheflush.c
index 2ae1201cff88..da71cd285dfc 100644
--- a/arch/riscv/mm/cacheflush.c
+++ b/arch/riscv/mm/cacheflush.c
@@ -4,11 +4,10 @@
  */
 
 #include <asm/cacheflush.h>
+#include <asm/sbi.h>
 
 #ifdef CONFIG_SMP
 
-#include <asm/sbi.h>
-
 static void ipi_remote_fence_i(void *info)
 {
 	return local_flush_icache_all();
@@ -91,3 +90,43 @@ void flush_icache_pte(pte_t pte)
 	}
 }
 #endif /* CONFIG_MMU */
+
+static bool thead_dma_init_flag = false;
+
+#define sync_is()	asm volatile (".long 0x01b0000b")
+void dma_wbinv_range(unsigned long start, unsigned long end)
+{
+	register unsigned long i asm("a0") = start & ~(L1_CACHE_BYTES - 1);
+
+	if (!thead_dma_init_flag)
+		return;
+
+	for (; i < end; i += L1_CACHE_BYTES)
+		asm volatile (".long 0x02b5000b"); /* dcache.cipa a0 */
+
+	sync_is();
+}
+
+void dma_wb_range(unsigned long start, unsigned long end)
+{
+	register unsigned long i asm("a0") = start & ~(L1_CACHE_BYTES - 1);
+
+	if (!thead_dma_init_flag)
+		return;
+
+	for (; i < end; i += L1_CACHE_BYTES)
+		asm volatile (".long 0x0295000b"); /* dcache.cpa a0 */
+
+	sync_is();
+}
+
+#define THEAD_VENDOR_ID       0x5b7
+
+static int __init thead_dma_init(void)
+{
+	if (sbi_get_mvendorid() == THEAD_VENDOR_ID)
+		thead_dma_init_flag = true;
+
+	return 0;
+}
+arch_initcall(thead_dma_init);
diff --git a/arch/riscv/mm/dma-mapping.c b/arch/riscv/mm/dma-mapping.c
new file mode 100644
index 000000000000..af44b9522fd9
--- /dev/null
+++ b/arch/riscv/mm/dma-mapping.c
@@ -0,0 +1,69 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/cache.h>
+#include <linux/dma-map-ops.h>
+#include <linux/genalloc.h>
+#include <linux/highmem.h>
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <linux/scatterlist.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <asm/cache.h>
+
+void arch_dma_prep_coherent(struct page *page, size_t size)
+{
+	void *ptr = page_address(page);
+
+	memset(ptr, 0, size);
+	dma_wbinv_range(page_to_phys(page), page_to_phys(page) + size);
+}
+
+static inline void cache_op(phys_addr_t paddr, size_t size,
+			    void (*fn)(unsigned long start, unsigned long end))
+{
+	unsigned long start = (unsigned long)paddr;
+
+	fn(start, start + size);
+}
+
+void arch_sync_dma_for_device(phys_addr_t paddr, size_t size,
+			      enum dma_data_direction dir)
+{
+	switch (dir) {
+	case DMA_TO_DEVICE:
+		cache_op(paddr, size, dma_wb_range);
+		break;
+	case DMA_FROM_DEVICE:
+	case DMA_BIDIRECTIONAL:
+		cache_op(paddr, size, dma_wbinv_range);
+		break;
+	default:
+		BUG();
+	}
+}
+EXPORT_SYMBOL_GPL(arch_sync_dma_for_device);
+
+void arch_sync_dma_for_cpu(phys_addr_t paddr, size_t size,
+			   enum dma_data_direction dir)
+{
+	switch (dir) {
+	case DMA_TO_DEVICE:
+		return;
+	case DMA_FROM_DEVICE:
+	case DMA_BIDIRECTIONAL:
+		cache_op(paddr, size, dma_wbinv_range);
+		break;
+	default:
+		BUG();
+	}
+}
+EXPORT_SYMBOL_GPL(arch_sync_dma_for_cpu);
+
+pgprot_t arch_dma_mmap_pgprot(struct device *dev, pgprot_t prot,
+		unsigned long attrs)
+{
+	if (attrs & DMA_ATTR_WRITE_COMBINE)
+		return pgprot_writecombine(prot);
+	return pgprot_noncached(prot);
+}
diff --git a/arch/riscv/mm/fault.c b/arch/riscv/mm/fault.c
index 54b12943cc7b..d5dd988efc45 100644
--- a/arch/riscv/mm/fault.c
+++ b/arch/riscv/mm/fault.c
@@ -13,6 +13,7 @@
 #include <linux/perf_event.h>
 #include <linux/signal.h>
 #include <linux/uaccess.h>
+#include <linux/kprobes.h>
 
 #include <asm/ptrace.h>
 #include <asm/tlbflush.h>
@@ -203,6 +204,9 @@ asmlinkage void do_page_fault(struct pt_regs *regs)
 	tsk = current;
 	mm = tsk->mm;
 
+	if (kprobe_page_fault(regs, cause))
+		return;
+
 	/*
 	 * Fault-in kernel-space virtual memory on-demand.
 	 * The 'reference' page table is init_mm.pgd.
@@ -218,7 +222,7 @@ asmlinkage void do_page_fault(struct pt_regs *regs)
 	}
 
 	/* Enable interrupts if they were enabled in the parent context. */
-	if (likely(regs->status & SR_PIE))
+	if (likely(regs->status & SR_PIE) || user_mode(regs))
 		local_irq_enable();
 
 	/*
@@ -226,6 +230,7 @@ asmlinkage void do_page_fault(struct pt_regs *regs)
 	 * in an atomic region, then we must not take the fault.
 	 */
 	if (unlikely(faulthandler_disabled() || !mm)) {
+		tsk->thread.bad_cause = cause;
 		no_context(regs, addr);
 		return;
 	}
@@ -243,16 +248,19 @@ asmlinkage void do_page_fault(struct pt_regs *regs)
 	mmap_read_lock(mm);
 	vma = find_vma(mm, addr);
 	if (unlikely(!vma)) {
+		tsk->thread.bad_cause = cause;
 		bad_area(regs, mm, code, addr);
 		return;
 	}
 	if (likely(vma->vm_start <= addr))
 		goto good_area;
 	if (unlikely(!(vma->vm_flags & VM_GROWSDOWN))) {
+		tsk->thread.bad_cause = cause;
 		bad_area(regs, mm, code, addr);
 		return;
 	}
 	if (unlikely(expand_stack(vma, addr))) {
+		tsk->thread.bad_cause = cause;
 		bad_area(regs, mm, code, addr);
 		return;
 	}
@@ -265,6 +273,7 @@ asmlinkage void do_page_fault(struct pt_regs *regs)
 	code = SEGV_ACCERR;
 
 	if (unlikely(access_error(cause, vma))) {
+		tsk->thread.bad_cause = cause;
 		bad_area(regs, mm, code, addr);
 		return;
 	}
@@ -298,6 +307,7 @@ asmlinkage void do_page_fault(struct pt_regs *regs)
 	mmap_read_unlock(mm);
 
 	if (unlikely(fault & VM_FAULT_ERROR)) {
+		tsk->thread.bad_cause = cause;
 		mm_fault_error(regs, addr, fault);
 		return;
 	}
diff --git a/arch/riscv/mm/init.c b/arch/riscv/mm/init.c
index 6c2f38aac544..f4ca215ad96d 100644
--- a/arch/riscv/mm/init.c
+++ b/arch/riscv/mm/init.c
@@ -154,6 +154,14 @@ static void __init setup_initrd(void)
 }
 #endif /* CONFIG_BLK_DEV_INITRD */
 
+static phys_addr_t firmware_size __initdata;
+static int __init early_get_firmware_size(char *arg)
+{
+	firmware_size = memparse(arg, &arg);
+	return 0;
+}
+early_param("riscv.fwsz", early_get_firmware_size);
+
 void __init setup_bootmem(void)
 {
 	phys_addr_t mem_start = 0;
@@ -208,6 +216,11 @@ void __init setup_bootmem(void)
 	 */
 	memblock_reserve(dtb_early_pa, fdt_totalsize(dtb_early_va));
 
+	if (firmware_size > PAGE_SIZE && firmware_size < LOAD_OFFSET)
+		memblock_reserve(__pa(PAGE_OFFSET), firmware_size);
+	else
+		memblock_reserve(__pa(PAGE_OFFSET), LOAD_OFFSET);
+
 	dma_contiguous_reserve(dma32_phys_limit);
 	memblock_allow_resize();
 	memblock_dump_all();
@@ -439,7 +452,7 @@ static uintptr_t __init best_map_size(phys_addr_t base, phys_addr_t size)
 asmlinkage void __init setup_vm(uintptr_t dtb_pa)
 {
 	uintptr_t va, pa, end_va;
-	uintptr_t load_pa = (uintptr_t)(&_start);
+	uintptr_t load_pa = (uintptr_t)(&_start) - LOAD_OFFSET;
 	uintptr_t load_sz = (uintptr_t)(&_end) - load_pa;
 	uintptr_t map_size;
 #ifndef __PAGETABLE_PMD_FOLDED
@@ -476,8 +489,8 @@ asmlinkage void __init setup_vm(uintptr_t dtb_pa)
 	/* Setup trampoline PGD and PMD */
 	create_pgd_mapping(trampoline_pg_dir, PAGE_OFFSET,
 			   (uintptr_t)trampoline_pmd, PGDIR_SIZE, PAGE_TABLE);
-	create_pmd_mapping(trampoline_pmd, PAGE_OFFSET,
-			   load_pa, PMD_SIZE, PAGE_KERNEL_EXEC);
+	create_pmd_mapping(trampoline_pmd, PAGE_OFFSET + LOAD_OFFSET,
+			   load_pa + LOAD_OFFSET, PMD_SIZE, PAGE_KERNEL_EXEC);
 #else
 	/* Setup trampoline PGD */
 	create_pgd_mapping(trampoline_pg_dir, PAGE_OFFSET,
diff --git a/arch/riscv/mm/ioremap.c b/arch/riscv/mm/ioremap.c
new file mode 100644
index 000000000000..c56f0ca33135
--- /dev/null
+++ b/arch/riscv/mm/ioremap.c
@@ -0,0 +1,20 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include <linux/export.h>
+#include <linux/mm.h>
+#include <linux/io.h>
+
+#include <asm/pgtable.h>
+
+pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
+			      unsigned long size, pgprot_t vma_prot)
+{
+	if (!pfn_valid(pfn)) {
+		return pgprot_noncached(vma_prot);
+	} else if (file->f_flags & O_SYNC) {
+		return pgprot_writecombine(vma_prot);
+	}
+
+	return vma_prot;
+}
+EXPORT_SYMBOL(phys_mem_access_prot);
diff --git a/arch/riscv/mm/tlbflush.c b/arch/riscv/mm/tlbflush.c
index 720b443c4528..fadfde9df7a0 100644
--- a/arch/riscv/mm/tlbflush.c
+++ b/arch/riscv/mm/tlbflush.c
@@ -3,6 +3,73 @@
 #include <linux/mm.h>
 #include <linux/smp.h>
 #include <linux/sched.h>
+
+#define XUANTIE
+#ifdef  XUANTIE
+#include <asm/mmu_context.h>
+
+void flush_tlb_all(void)
+{
+#ifdef CONFIG_NO_SFENCE_VMA
+	csr_write(CSR_SMCIR, 1 << 26);
+#else
+	__asm__ __volatile__ ("sfence.vma" : : : "memory");
+#endif
+}
+
+void flush_tlb_mm(struct mm_struct *mm)
+{
+	int newpid = cpu_asid(mm);
+
+#ifdef CONFIG_NO_SFENCE_VMA
+	csr_write(CSR_SMCIR, (1 << 27) | newpid);
+#else
+	__asm__ __volatile__ ("sfence.vma zero, %0"
+				:
+				: "r"(newpid)
+				: "memory");
+#endif
+}
+
+void flush_tlb_page(struct vm_area_struct *vma, unsigned long addr)
+{
+	int newpid = cpu_asid(vma->vm_mm);
+
+#ifdef CONFIG_NO_SFENCE_VMA
+	csr_write(CSR_SMCIR, (1 << 27) | newpid);
+#else
+	addr &= PAGE_MASK;
+
+	__asm__ __volatile__ ("sfence.vma %0, %1"
+				:
+				: "r"(addr), "r"(newpid)
+				: "memory");
+#endif
+}
+
+void flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
+			unsigned long end)
+{
+	unsigned long newpid = cpu_asid(vma->vm_mm);
+
+#ifdef CONFIG_NO_SFENCE_VMA
+	csr_write(CSR_SMCIR, (1 << 27) | newpid);
+#else
+	start &= PAGE_MASK;
+	end   += PAGE_SIZE - 1;
+	end   &= PAGE_MASK;
+
+	while (start < end) {
+		__asm__ __volatile__ ("sfence.vma %0, %1"
+					:
+					: "r"(start), "r"(newpid)
+					: "memory");
+		start += PAGE_SIZE;
+	}
+#endif
+}
+#else
+
 #include <asm/sbi.h>
 
 void flush_tlb_all(void)
@@ -54,3 +121,4 @@ void flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
 {
 	__sbi_tlb_flush_range(mm_cpumask(vma->vm_mm), start, end - start);
 }
+#endif
diff --git a/drivers/clk/Kconfig b/drivers/clk/Kconfig
index df739665f206..de2a584b7f25 100644
--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -385,5 +385,6 @@ source "drivers/clk/ti/Kconfig"
 source "drivers/clk/uniphier/Kconfig"
 source "drivers/clk/x86/Kconfig"
 source "drivers/clk/zynqmp/Kconfig"
+source "drivers/clk/cvitek/Kconfig"
 
 endif
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index da8fcf147eb1..a4458e6145bc 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -124,3 +124,4 @@ endif
 obj-$(CONFIG_ARCH_ZX)			+= zte/
 obj-$(CONFIG_ARCH_ZYNQ)			+= zynq/
 obj-$(CONFIG_COMMON_CLK_ZYNQMP)         += zynqmp/
+obj-$(CONFIG_COMMON_CLK_CVITEK)     += cvitek/
diff --git a/drivers/clk/cvitek/Kconfig b/drivers/clk/cvitek/Kconfig
new file mode 100644
index 000000000000..37e5cf0ead8a
--- /dev/null
+++ b/drivers/clk/cvitek/Kconfig
@@ -0,0 +1,12 @@
+config COMMON_CLK_CVITEK
+    bool "Clock driver for CVITEK SoC Family"
+    depends on ARCH_CVITEK || COMPILE_TEST
+    default ARCH_CVITEK
+    help
+       Support the clocks on CVITEK SoC Family.
+
+config COMMON_CLK_CV1832_TPU_500M
+	bool "Set TPU clock to 500MHz for CV1832"
+	depends on COMMON_CLK_CVITEK
+	help
+	  Set TPU clock to 500MHz for CV1832.
diff --git a/drivers/clk/cvitek/Makefile b/drivers/clk/cvitek/Makefile
new file mode 100644
index 000000000000..094699c06742
--- /dev/null
+++ b/drivers/clk/cvitek/Makefile
@@ -0,0 +1,5 @@
+obj-$(CONFIG_ARCH_CV183X)	+= clk-cv1835.o
+obj-$(CONFIG_ARCH_CV952X)	+= clk-cv1835.o
+obj-$(CONFIG_ARCH_CV182X)	+= clk-cv182x.o
+obj-$(CONFIG_ARCH_CV181X)		+= clk-cv181x.o
+obj-$(CONFIG_ARCH_CV180X)		+= clk-cv180x.o
diff --git a/drivers/clk/cvitek/clk-cv180x.c b/drivers/clk/cvitek/clk-cv180x.c
new file mode 100644
index 000000000000..24c82de94aae
--- /dev/null
+++ b/drivers/clk/cvitek/clk-cv180x.c
@@ -0,0 +1,2842 @@
+/*
+ * Copyright (c) 2021 CVITEK
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include <linux/syscore_ops.h>
+
+#include <dt-bindings/clock/cv180x-clock.h>
+
+#define CV180X_CLK_FLAGS_ALL	(CLK_GET_RATE_NOCACHE)
+// #define CV180X_CLK_FLAGS_ALL	(CLK_GET_RATE_NOCACHE | CLK_IS_CRITICAL)
+// #define CV180X_CLK_FLAGS_ALL	(CLK_GET_RATE_NOCACHE | CLK_IGNORE_UNUSED)
+#define CV180X_CLK_FLAGS_MUX	(CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT)
+
+/* top_pll_g2 */
+#define REG_PLL_G2_CTRL			0x800
+#define REG_PLL_G2_STATUS		0x804
+#define REG_MIPIMPLL_CSR		0x808
+#define REG_APLL0_CSR			0x80C
+#define REG_DISPPLL_CSR			0x810
+#define REG_CAM0PLL_CSR			0x814
+#define REG_CAM1PLL_CSR			0x818
+#define REG_PLL_G2_SSC_SYN_CTRL		0x840
+#define REG_APLL_SSC_SYN_CTRL		0x850
+#define REG_APLL_SSC_SYN_SET		0x854
+#define REG_APLL_SSC_SYN_SPAN		0x858
+#define REG_APLL_SSC_SYN_STEP		0x85C
+#define REG_DISPPLL_SSC_SYN_CTRL	0x860
+#define REG_DISPPLL_SSC_SYN_SET		0x864
+#define REG_DISPPLL_SSC_SYN_SPAN	0x868
+#define REG_DISPPLL_SSC_SYN_STEP	0x86C
+#define REG_CAM0PLL_SSC_SYN_CTRL	0x870
+#define REG_CAM0PLL_SSC_SYN_SET		0x874
+#define REG_CAM0PLL_SSC_SYN_SPAN	0x878
+#define REG_CAM0PLL_SSC_SYN_STEP	0x87C
+#define REG_CAM1PLL_SSC_SYN_CTRL	0x880
+#define REG_CAM1PLL_SSC_SYN_SET		0x884
+#define REG_CAM1PLL_SSC_SYN_SPAN	0x888
+#define REG_CAM1PLL_SSC_SYN_STEP	0x88C
+#define REG_APLL_FRAC_DIV_CTRL		0x890
+#define REG_APLL_FRAC_DIV_M		0x894
+#define REG_APLL_FRAC_DIV_N		0x898
+#define REG_MIPIMPLL_CLK_CSR		0x8A0
+#define REG_A0PLL_CLK_CSR		0x8A4
+#define REG_DISPPLL_CLK_CSR		0x8A8
+#define REG_CAM0PLL_CLK_CSR		0x8AC
+#define REG_CAM1PLL_CLK_CSR		0x8B0
+#define REG_CLK_CAM0_SRC_DIV		0x8C0
+#define REG_CLK_CAM1_SRC_DIV		0x8C4
+
+/* top_pll_g6 */
+#define REG_PLL_G6_CTRL			0x900
+#define REG_PLL_G6_STATUS		0x904
+#define REG_MPLL_CSR			0x908
+#define REG_TPLL_CSR			0x90C
+#define REG_FPLL_CSR			0x910
+#define REG_PLL_G6_SSC_SYN_CTRL		0x940
+#define REG_DPLL_SSC_SYN_CTRL		0x950
+#define REG_DPLL_SSC_SYN_SET		0x954
+#define REG_DPLL_SSC_SYN_SPAN		0x958
+#define REG_DPLL_SSC_SYN_STEP		0x95C
+#define REG_MPLL_SSC_SYN_CTRL		0x960
+#define REG_MPLL_SSC_SYN_SET		0x964
+#define REG_MPLL_SSC_SYN_SPAN		0x968
+#define REG_MPLL_SSC_SYN_STEP		0x96C
+#define REG_TPLL_SSC_SYN_CTRL		0x970
+#define REG_TPLL_SSC_SYN_SET		0x974
+#define REG_TPLL_SSC_SYN_SPAN		0x978
+#define REG_TPLL_SSC_SYN_STEP		0x97C
+
+/* clkgen */
+#define REG_CLK_EN_0			0x000
+#define REG_CLK_EN_1			0x004
+#define REG_CLK_EN_2			0x008
+#define REG_CLK_EN_3			0x00C
+#define REG_CLK_EN_4			0x010
+#define REG_CLK_SEL_0			0x020
+#define REG_CLK_BYP_0			0x030
+#define REG_CLK_BYP_1			0x034
+
+#define REG_DIV_CLK_A53_0		0x040
+#define REG_DIV_CLK_A53_1		0x044
+#define REG_DIV_CLK_CPU_AXI0		0x048
+#define REG_DIV_CLK_CPU_GIC		0x050
+#define REG_DIV_CLK_TPU			0x054
+#define REG_DIV_CLK_EMMC		0x064
+#define REG_DIV_CLK_100K_EMMC		0x06C
+#define REG_DIV_CLK_SD0			0x070
+#define REG_DIV_CLK_100K_SD0		0x078
+#define REG_DIV_CLK_SD1			0x07C
+#define REG_DIV_CLK_100K_SD1		0x084
+#define REG_DIV_CLK_SPI_NAND		0x088
+#define REG_DIV_CLK_500M_ETH0		0x08C
+#define REG_DIV_CLK_500M_ETH1		0x090
+#define REG_DIV_CLK_GPIO_DB		0x094
+#define REG_DIV_CLK_SDMA_AUD0		0x098
+#define REG_DIV_CLK_SDMA_AUD1		0x09C
+#define REG_DIV_CLK_SDMA_AUD2		0x0A0
+#define REG_DIV_CLK_SDMA_AUD3		0x0A4
+#define REG_DIV_CLK_CAM0_200		0x0A8
+#define REG_DIV_CLK_AXI4		0x0B8
+#define REG_DIV_CLK_AXI6		0x0BC
+#define REG_DIV_CLK_DSI_ESC		0x0C4
+#define REG_DIV_CLK_AXI_VIP		0x0C8
+#define REG_DIV_CLK_SRC_VIP_SYS_0	0x0D0
+#define REG_DIV_CLK_SRC_VIP_SYS_1	0x0D8
+#define REG_DIV_CLK_DISP_SRC_VIP	0x0E0
+#define REG_DIV_CLK_AXI_VIDEO_CODEC	0x0E4
+#define REG_DIV_CLK_VC_SRC0		0x0EC
+#define REG_DIV_CLK_1M			0x0FC
+#define REG_DIV_CLK_SPI			0x100
+#define REG_DIV_CLK_I2C			0x104
+#define REG_DIV_CLK_SRC_VIP_SYS_2	0x110
+#define REG_DIV_CLK_AUDSRC		0x118
+#define REG_DIV_CLK_PWM_SRC_0		0x120
+#define REG_DIV_CLK_AP_DEBUG		0x128
+#define REG_DIV_CLK_RTCSYS_SRC_0	0x12C
+#define REG_DIV_CLK_C906_0_0		0x130
+#define REG_DIV_CLK_C906_0_1		0x134
+#define REG_DIV_CLK_C906_1_0		0x138
+#define REG_DIV_CLK_C906_1_1		0x13C
+#define REG_DIV_CLK_SRC_VIP_SYS_3	0x140
+#define REG_DIV_CLK_SRC_VIP_SYS_4	0x144
+
+#define REG_PLL_G2_CSR_NUM		(REG_CAM1PLL_CSR / 4 - REG_MIPIMPLL_CSR / 4 + 1)
+#define REG_PLL_G2_CSR_START		REG_MIPIMPLL_CSR
+
+#define REG_PLL_G6_CSR_NUM		(REG_FPLL_CSR / 4 - REG_MPLL_CSR / 4 + 1)
+#define REG_PLL_G6_CSR_START		REG_MPLL_CSR
+
+#define REG_CLK_EN_NUM			(REG_CLK_EN_4 / 4 - REG_CLK_EN_0 / 4 + 1)
+#define REG_CLK_EN_START		REG_CLK_EN_0
+
+#define REG_CLK_SEL_NUM			(REG_CLK_SEL_0 / 4  - REG_CLK_SEL_0 / 4 + 1)
+#define REG_CLK_SEL_START		REG_CLK_SEL_0
+
+#define REG_CLK_BYP_NUM			(REG_CLK_BYP_1 / 4 - REG_CLK_BYP_0 / 4 + 1)
+#define REG_CLK_BYP_START		REG_CLK_BYP_0
+
+#define REG_CLK_DIV_NUM			(REG_DIV_CLK_SRC_VIP_SYS_4 / 4 - REG_DIV_CLK_A53_0 / 4 + 1)
+#define REG_CLK_DIV_START		REG_DIV_CLK_A53_0
+
+#define REG_CLK_G2_DIV_NUM		(REG_CLK_CAM1_SRC_DIV / 4 - REG_CLK_CAM0_SRC_DIV / 4 + 1)
+#define REG_CLK_G2_DIV_START		REG_CLK_CAM0_SRC_DIV
+
+#define CV180X_PLL_LOCK_TIMEOUT_MS	200
+
+/* PLL status register offset */
+#define PLL_STATUS_MASK			0xFF
+#define PLL_STATUS_OFFSET		0x04
+
+/* G2 Synthesizer register offset */
+#define G2_SSC_CTRL_MASK		0xFF
+#define G2_SSC_CTRL_OFFSET		0x40
+#define SSC_SYN_SET_MASK		0x0F
+#define SSC_SYN_SET_OFFSET		0x04
+
+#define to_cv180x_pll_clk(_hw) container_of(_hw, struct cv180x_pll_hw_clock, hw)
+#define to_cv180x_clk(_hw) container_of(_hw, struct cv180x_hw_clock, hw)
+
+#define div_mask(width) ((1 << (width)) - 1)
+
+static DEFINE_SPINLOCK(cv180x_clk_lock);
+
+struct cv180x_clock_data {
+	void __iomem *base;
+	spinlock_t *lock;
+	struct clk_hw_onecell_data hw_data;
+#ifdef CONFIG_PM_SLEEP
+	uint32_t clken_saved_regs[REG_CLK_EN_NUM];
+	uint32_t clksel_saved_regs[REG_CLK_SEL_NUM];
+	uint32_t clkbyp_saved_regs[REG_CLK_BYP_NUM];
+	uint32_t clkdiv_saved_regs[REG_CLK_DIV_NUM];
+	uint32_t g2_clkdiv_saved_regs[REG_CLK_G2_DIV_NUM];
+	uint32_t pll_g2_csr_saved_regs[REG_PLL_G2_CSR_NUM];
+	uint32_t a0pll_ssc_syn_set_saved_reg;
+	uint32_t disppll_ssc_syn_set_saved_reg;
+	uint32_t cam0pll_ssc_syn_set_saved_reg;
+	uint32_t cam1pll_ssc_syn_set_saved_reg;
+	uint32_t pll_g6_csr_saved_regs[REG_PLL_G6_CSR_NUM];
+#endif /* CONFIG_PM_SLEEP */
+};
+
+struct cv180x_gate {
+	u32		reg;
+	s8		shift;
+	unsigned long	flags;
+};
+
+struct cv180x_div {
+	u32		reg;
+	s8		shift;
+	s8		width;
+	s16		initval;
+	unsigned long	flags;
+};
+
+struct cv180x_mux {
+	u32		reg;
+	s8		shift;
+	s8		width;
+	unsigned long	flags;
+};
+
+struct cv180x_hw_clock {
+	unsigned int id;
+	const char *name;
+	struct clk_hw hw;
+	void __iomem *base;
+	spinlock_t *lock;
+
+	struct cv180x_gate gate;
+	struct cv180x_div div[2]; /* 0: DIV_IN0, 1: DIV_IN1 */
+	struct cv180x_mux mux[3]; /* 0: bypass, 1: CLK_SEL, 2: CLK_SRC(DIV_IN0_SRC_MUX) */
+};
+
+struct cv180x_pll_clock {
+	unsigned int	id;
+	const char	*name;
+	u32		reg_csr;
+	u32		reg_ssc;
+	s16		post_div_sel; /* -1: postdiv*/
+	unsigned long	flags;
+};
+
+struct cv180x_pll_hw_clock {
+	struct cv180x_pll_clock pll;
+	void __iomem *base;
+	spinlock_t *lock;
+	struct clk_hw hw;
+};
+
+static const struct clk_ops cv180x_g6_pll_ops;
+static const struct clk_ops cv180x_g2_pll_ops;
+static const struct clk_ops cv180x_g2d_pll_ops;
+static const struct clk_ops cv180x_clk_ops;
+
+static struct cv180x_clock_data *clk_data;
+
+static unsigned long cvi_clk_flags;
+
+#define CV180X_CLK(_id, _name, _parents, _gate_reg, _gate_shift,		\
+			_div_0_reg, _div_0_shift,			\
+			_div_0_width, _div_0_initval,			\
+			_div_1_reg, _div_1_shift,			\
+			_div_1_width, _div_1_initval,			\
+			_mux_0_reg, _mux_0_shift,			\
+			_mux_1_reg, _mux_1_shift,			\
+			_mux_2_reg, _mux_2_shift, _flags) {		\
+		.id = _id,						\
+		.name = _name,						\
+		.gate.reg = _gate_reg,					\
+		.gate.shift = _gate_shift,				\
+		.div[0].reg = _div_0_reg,				\
+		.div[0].shift = _div_0_shift,				\
+		.div[0].width = _div_0_width,				\
+		.div[0].initval = _div_0_initval,			\
+		.div[1].reg = _div_1_reg,				\
+		.div[1].shift = _div_1_shift,				\
+		.div[1].width = _div_1_width,				\
+		.div[1].initval = _div_1_initval,			\
+		.mux[0].reg = _mux_0_reg,				\
+		.mux[0].shift = _mux_0_shift,				\
+		.mux[0].width = 1,					\
+		.mux[1].reg = _mux_1_reg,				\
+		.mux[1].shift = _mux_1_shift,				\
+		.mux[1].width = 1,					\
+		.mux[2].reg = _mux_2_reg,				\
+		.mux[2].shift = _mux_2_shift,				\
+		.mux[2].width = 2,					\
+		.hw.init = CLK_HW_INIT_PARENTS(				\
+				_name, _parents,			\
+				&cv180x_clk_ops,				\
+				_flags | CV180X_CLK_FLAGS_ALL),		\
+	}
+
+
+#define CLK_G6_PLL(_id, _name, _parent, _reg_csr, _flags) {		\
+		.pll.id = _id,						\
+		.pll.name = _name,					\
+		.pll.reg_csr = _reg_csr,				\
+		.pll.reg_ssc = 0,					\
+		.pll.post_div_sel = -1,					\
+		.hw.init = CLK_HW_INIT_PARENTS(_name, _parent,		\
+					       &cv180x_g6_pll_ops,	\
+					       _flags |			\
+					       CV180X_CLK_FLAGS_ALL),	\
+	}
+
+#define CLK_G2_PLL(_id, _name, _parent, _reg_csr, _reg_ssc, _flags) {	\
+		.pll.id = _id,						\
+		.pll.name = _name,					\
+		.pll.reg_csr = _reg_csr,				\
+		.pll.reg_ssc = _reg_ssc,				\
+		.pll.post_div_sel = -1,					\
+		.hw.init = CLK_HW_INIT_PARENTS(_name, _parent,		\
+					       &cv180x_g2_pll_ops,	\
+					       _flags |			\
+					       CV180X_CLK_FLAGS_ALL),	\
+	}
+
+#define CLK_G2D_PLL(_id, _name, _parent, _reg_csr, _reg_ssc,		\
+			_post_div_sel, _flags) {			\
+		.pll.id = _id,						\
+		.pll.name = _name,					\
+		.pll.reg_csr = _reg_csr,				\
+		.pll.reg_ssc = _reg_ssc,				\
+		.pll.post_div_sel = _post_div_sel,			\
+		.hw.init = CLK_HW_INIT_PARENTS(_name, _parent,		\
+					       &cv180x_g2d_pll_ops,	\
+					       _flags |			\
+					       CV180X_CLK_FLAGS_ALL),	\
+	}
+
+const char *const cv180x_pll_parent[] = {"osc"};
+const char *const cv180x_frac_pll_parent[] = {"clk_mipimpll"};
+
+/*
+ * All PLL clocks are marked as CRITICAL, hence they are very crucial
+ * for the functioning of the SoC
+ */
+static struct cv180x_pll_hw_clock cv180x_pll_clks[] = {
+	CLK_G6_PLL(CV180X_CLK_MPLL, "clk_mpll", cv180x_pll_parent, REG_MPLL_CSR,
+		   0),
+	CLK_G6_PLL(CV180X_CLK_TPLL, "clk_tpll", cv180x_pll_parent, REG_TPLL_CSR,
+		   0),
+	CLK_G6_PLL(CV180X_CLK_FPLL, "clk_fpll", cv180x_pll_parent, REG_FPLL_CSR,
+		   0),
+	CLK_G2_PLL(CV180X_CLK_MIPIMPLL, "clk_mipimpll", cv180x_pll_parent,
+		   REG_MIPIMPLL_CSR, 0, 0),
+	CLK_G2_PLL(CV180X_CLK_A0PLL, "clk_a0pll", cv180x_frac_pll_parent,
+		   REG_APLL0_CSR, REG_APLL_SSC_SYN_CTRL, 0),
+	CLK_G2_PLL(CV180X_CLK_DISPPLL, "clk_disppll", cv180x_frac_pll_parent,
+		   REG_DISPPLL_CSR, REG_DISPPLL_SSC_SYN_CTRL, 0),
+	CLK_G2_PLL(CV180X_CLK_CAM0PLL, "clk_cam0pll", cv180x_frac_pll_parent,
+	REG_CAM0PLL_CSR, REG_CAM0PLL_SSC_SYN_CTRL,
+		CLK_IGNORE_UNUSED),
+	CLK_G2_PLL(CV180X_CLK_CAM1PLL, "clk_cam1pll", cv180x_frac_pll_parent,
+		   REG_CAM1PLL_CSR, REG_CAM1PLL_SSC_SYN_CTRL, 0),
+	CLK_G2D_PLL(CV180X_CLK_MIPIMPLL_D3, "clk_mipimpll_d3", cv180x_pll_parent, REG_MIPIMPLL_CSR,
+		0, 3, CLK_IGNORE_UNUSED),
+	CLK_G2D_PLL(CV180X_CLK_CAM0PLL_D2, "clk_cam0pll_d2", cv180x_frac_pll_parent, REG_CAM0PLL_CSR,
+		REG_CAM0PLL_SSC_SYN_CTRL, 2, CLK_IGNORE_UNUSED),
+	CLK_G2D_PLL(CV180X_CLK_CAM0PLL_D3, "clk_cam0pll_d3", cv180x_frac_pll_parent, REG_CAM0PLL_CSR,
+		REG_CAM0PLL_SSC_SYN_CTRL, 3, CLK_IGNORE_UNUSED),
+};
+
+/*
+ * Clocks marked as CRITICAL are needed for the proper functioning
+ * of the SoC.
+ */
+static struct cv180x_hw_clock cv180x_clks[] = {
+	CV180X_CLK(CV180X_CLK_A53, "clk_a53",
+		((const char *[]) {"osc", "clk_fpll", "clk_tpll", "clk_a0pll", "clk_mipimpll", "clk_mpll"}),
+		REG_CLK_EN_0, 0,
+		REG_DIV_CLK_A53_0, 16, 4, 1,
+		REG_DIV_CLK_A53_1, 16, 4, 2,
+		REG_CLK_BYP_0, 0,
+		REG_CLK_SEL_0, 0,
+		REG_DIV_CLK_A53_0, 8,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_CPU_AXI0, "clk_cpu_axi0",
+		((const char *[]) {"osc", "clk_fpll", "clk_disppll"}),
+		REG_CLK_EN_0, 1,
+		REG_DIV_CLK_CPU_AXI0, 16, 4, 3,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 1,
+		0, -1,
+		REG_DIV_CLK_CPU_AXI0, 8,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_CPU_GIC, "clk_cpu_gic",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_0, 2,
+		REG_DIV_CLK_CPU_GIC, 16, 4, 5,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 2,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_XTAL_A53, "clk_xtal_a53",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_0, 3,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_TPU, "clk_tpu",
+		((const char *[]) {"osc", "clk_tpll", "clk_a0pll", "clk_mipimpll", "clk_fpll"}),
+		REG_CLK_EN_0, 4,
+		REG_DIV_CLK_TPU, 16, 4, 3,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 3,
+		0, -1,
+		REG_DIV_CLK_TPU, 8,
+		0),
+	CV180X_CLK(CV180X_CLK_TPU_FAB, "clk_tpu_fab",
+		((const char *[]) {"clk_mipimpll"}),
+		REG_CLK_EN_0, 5,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_AHB_ROM, "clk_ahb_rom",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_0, 6,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_DDR_AXI_REG, "clk_ddr_axi_reg",
+		((const char *[]) {"clk_axi6"}),
+		REG_CLK_EN_0, 7,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_RTC_25M, "clk_rtc_25m",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_0, 8,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_TEMPSEN, "clk_tempsen",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_0, 9,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_SARADC, "clk_saradc",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_0, 10,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_EFUSE, "clk_efuse",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_0, 11,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_APB_EFUSE, "clk_apb_efuse",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_0, 12,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_DEBUG, "clk_debug",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_0, 13,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_XTAL_MISC, "clk_xtal_misc",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_0, 14,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_AXI4_EMMC, "clk_axi4_emmc",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_0, 15,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_EMMC, "clk_emmc",
+		((const char *[]) {"osc", "clk_fpll", "clk_disppll"}),
+		REG_CLK_EN_0, 16,
+		REG_DIV_CLK_EMMC, 16, 5, 15,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 5,
+		0, -1,
+		REG_DIV_CLK_EMMC, 8,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_100K_EMMC, "clk_100k_emmc",
+		((const char *[]) {"clk_1m"}),
+		REG_CLK_EN_0, 17,
+		REG_DIV_CLK_100K_EMMC, 16, 8, 10,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_AXI4_SD0, "clk_axi4_sd0",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_0, 18,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_SD0, "clk_sd0",
+		((const char *[]) {"osc", "clk_fpll", "clk_disppll"}),
+		REG_CLK_EN_0, 19,
+		REG_DIV_CLK_SD0, 16, 5, 15,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 6,
+		0, -1,
+		REG_DIV_CLK_SD0, 8,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_100K_SD0, "clk_100k_sd0",
+		((const char *[]) {"clk_1m"}),
+		REG_CLK_EN_0, 20,
+		REG_DIV_CLK_100K_SD0, 16, 8, 10,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_AXI4_SD1, "clk_axi4_sd1",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_0, 21,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_SD1, "clk_sd1",
+		((const char *[]) {"osc", "clk_fpll", "clk_disppll"}),
+		REG_CLK_EN_0, 22,
+		REG_DIV_CLK_SD1, 16, 5, 15,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 7,
+		0, -1,
+		REG_DIV_CLK_SD1, 8,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_100K_SD1, "clk_100k_sd1",
+		((const char *[]) {"clk_1m"}),
+		REG_CLK_EN_0, 23,
+		REG_DIV_CLK_100K_SD1, 16, 8, 10,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_SPI_NAND, "clk_spi_nand",
+		((const char *[]) {"osc", "clk_fpll", "clk_disppll"}),
+		REG_CLK_EN_0, 24,
+		REG_DIV_CLK_SPI_NAND, 16, 5, 8,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 8,
+		0, -1,
+		REG_DIV_CLK_SPI_NAND, 8,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_500M_ETH0, "clk_500m_eth0",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_0, 25,
+		REG_DIV_CLK_500M_ETH0, 16, 4, 3,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 9,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_AXI4_ETH0, "clk_axi4_eth0",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_0, 26,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_500M_ETH1, "clk_500m_eth1",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_0, 27,
+		REG_DIV_CLK_500M_ETH1, 16, 4, 3,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 10,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_AXI4_ETH1, "clk_axi4_eth1",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_0, 28,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_GPIO, "clk_apb_gpio",
+		((const char *[]) {"clk_axi6"}),
+		REG_CLK_EN_0, 29,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_GPIO_INTR, "clk_apb_gpio_intr",
+		((const char *[]) {"clk_axi6"}),
+		REG_CLK_EN_0, 30,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_GPIO_DB, "clk_gpio_db",
+		((const char *[]) {"clk_1m"}),
+		REG_CLK_EN_0, 31,
+		REG_DIV_CLK_GPIO_DB, 16, 16, 10,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_AHB_SF, "clk_ahb_sf",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 0,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_SDMA_AXI, "clk_sdma_axi",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 1,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_SDMA_AUD0, "clk_sdma_aud0",
+		((const char *[]) {"osc", "clk_a0pll", "a24k_clk"}),
+		REG_CLK_EN_1, 2,
+		REG_DIV_CLK_SDMA_AUD0, 16, 8, 18,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 11,
+		0, -1,
+		REG_DIV_CLK_SDMA_AUD0, 8,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_SDMA_AUD1, "clk_sdma_aud1",
+		((const char *[]) {"osc", "clk_a0pll", "a24k_clk"}),
+		REG_CLK_EN_1, 3,
+		REG_DIV_CLK_SDMA_AUD1, 16, 8, 18,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 12,
+		0, -1,
+		REG_DIV_CLK_SDMA_AUD1, 8,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_SDMA_AUD2, "clk_sdma_aud2",
+		((const char *[]) {"osc", "clk_a0pll", "a24k_clk"}),
+		REG_CLK_EN_1, 4,
+		REG_DIV_CLK_SDMA_AUD2, 16, 8, 18,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 13,
+		0, -1,
+		REG_DIV_CLK_SDMA_AUD2, 8,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_SDMA_AUD3, "clk_sdma_aud3",
+		((const char *[]) {"osc", "clk_a0pll", "a24k_clk"}),
+		REG_CLK_EN_1, 5,
+		REG_DIV_CLK_SDMA_AUD3, 16, 8, 18,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 14,
+		0, -1,
+		REG_DIV_CLK_SDMA_AUD3, 8,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_I2C, "clk_apb_i2c",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 6,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_WDT, "clk_apb_wdt",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_1, 7,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_PWM, "clk_pwm",
+		((const char *[]) {"clk_pwm_src"}),
+		REG_CLK_EN_1, 8,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_SPI0, "clk_apb_spi0",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 9,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_SPI1, "clk_apb_spi1",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 10,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_SPI2, "clk_apb_spi2",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 11,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_SPI3, "clk_apb_spi3",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 12,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_CAM0_200, "clk_cam0_200",
+		((const char *[]) {"osc", "osc", "clk_disppll"}),
+		REG_CLK_EN_1, 13,
+		REG_DIV_CLK_CAM0_200, 16, 4, 1,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 16,
+		0, -1,
+		REG_DIV_CLK_CAM0_200, 8,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_UART0, "clk_uart0",
+		((const char *[]) {"clk_cam0_200"}),
+		REG_CLK_EN_1, 14,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_UART0, "clk_apb_uart0",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 15,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_UART1, "clk_uart1",
+		((const char *[]) {"clk_cam0_200"}),
+		REG_CLK_EN_1, 16,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_UART1, "clk_apb_uart1",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 17,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_UART2, "clk_uart2",
+		((const char *[]) {"clk_cam0_200"}),
+		REG_CLK_EN_1, 18,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_UART2, "clk_apb_uart2",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 19,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_UART3, "clk_uart3",
+		((const char *[]) {"clk_cam0_200"}),
+		REG_CLK_EN_1, 20,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_UART3, "clk_apb_uart3",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 21,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_UART4, "clk_uart4",
+		((const char *[]) {"clk_cam0_200"}),
+		REG_CLK_EN_1, 22,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_UART4, "clk_apb_uart4",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 23,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_I2S0, "clk_apb_i2s0",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 24,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_I2S1, "clk_apb_i2s1",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 25,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_I2S2, "clk_apb_i2s2",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 26,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_I2S3, "clk_apb_i2s3",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 27,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_AXI4_USB, "clk_axi4_usb",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 28,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_APB_USB, "clk_apb_usb",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 29,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_125M_USB, "clk_125m_usb",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_1, 30,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 17,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_33K_USB, "clk_33k_usb",
+		((const char *[]) {"clk_1m"}),
+		REG_CLK_EN_1, 31,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_12M_USB, "clk_12m_usb",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_2, 0,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 18,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_AXI4, "clk_axi4",
+		((const char *[]) {"osc", "clk_fpll", "clk_disppll"}),
+		REG_CLK_EN_2, 1,
+		REG_DIV_CLK_AXI4, 16, 4, 5,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 19,
+		0, -1,
+		REG_DIV_CLK_AXI4, 8,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_AXI6, "clk_axi6",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_2, 2,
+		REG_DIV_CLK_AXI6, 16, 4, 15,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 20,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_DSI_ESC, "clk_dsi_esc",
+		((const char *[]) {"osc", "clk_axi6"}),
+		REG_CLK_EN_2, 3,
+		REG_DIV_CLK_DSI_ESC, 16, 4, 5,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 21,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_AXI_VIP, "clk_axi_vip",
+		((const char *[]) {"osc", "clk_mipimpll", "clk_cam0pll", "clk_disppll", "clk_fpll"}),
+		REG_CLK_EN_2, 4,
+		REG_DIV_CLK_AXI_VIP, 16, 4, 3,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 22,
+		0, -1,
+		REG_DIV_CLK_AXI_VIP, 8,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_SRC_VIP_SYS_0, "clk_src_vip_sys_0",
+		((const char *[]) {"osc", "clk_mipimpll", "clk_cam0pll", "clk_disppll", "clk_fpll"}),
+		REG_CLK_EN_2, 5,
+		REG_DIV_CLK_SRC_VIP_SYS_0, 16, 4, 6,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 23,
+		0, -1,
+		REG_DIV_CLK_SRC_VIP_SYS_0, 8,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_SRC_VIP_SYS_1, "clk_src_vip_sys_1",
+		((const char *[]) {"osc", "clk_mipimpll", "clk_cam0pll", "clk_disppll", "clk_fpll"}),
+		REG_CLK_EN_2, 6,
+		REG_DIV_CLK_SRC_VIP_SYS_1, 16, 4, 5,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 24,
+		0, -1,
+		REG_DIV_CLK_SRC_VIP_SYS_1, 8,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_DISP_SRC_VIP, "clk_disp_src_vip",
+		((const char *[]) {"osc", "clk_disppll"}),
+		REG_CLK_EN_2, 7,
+		REG_DIV_CLK_DISP_SRC_VIP, 16, 4, 8,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 25,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_AXI_VIDEO_CODEC, "clk_axi_video_codec",
+		((const char *[]) {"osc", "clk_a0pll", "clk_mipimpll", "clk_cam1pll", "clk_fpll"}),
+		REG_CLK_EN_2, 8,
+		REG_DIV_CLK_AXI_VIDEO_CODEC, 16, 4, 2,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 26,
+		0, -1,
+		REG_DIV_CLK_AXI_VIDEO_CODEC, 8,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_VC_SRC0, "clk_vc_src0",
+		((const char *[]) {"osc", "clk_disppll", "clk_mipimpll", "clk_cam1pll", "clk_fpll"}),
+		REG_CLK_EN_2, 9,
+		REG_DIV_CLK_VC_SRC0, 16, 4, 2,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 27,
+		0, -1,
+		REG_DIV_CLK_VC_SRC0, 8,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_H264C, "clk_h264c",
+		((const char *[]) {"clk_axi_video_codec"}),
+		REG_CLK_EN_2, 10,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_H265C, "clk_h265c",
+		((const char *[]) {"clk_axi_video_codec"}),
+		REG_CLK_EN_2, 11,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_JPEG, "clk_jpeg",
+		((const char *[]) {"clk_axi_video_codec"}),
+		REG_CLK_EN_2, 12,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_APB_JPEG, "clk_apb_jpeg",
+		((const char *[]) {"clk_axi6"}),
+		REG_CLK_EN_2, 13,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_APB_H264C, "clk_apb_h264c",
+		((const char *[]) {"clk_axi6"}),
+		REG_CLK_EN_2, 14,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_APB_H265C, "clk_apb_h265c",
+		((const char *[]) {"clk_axi6"}),
+		REG_CLK_EN_2, 15,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_CAM0, "clk_cam0",
+		((const char *[]) {"clk_cam0pll", "clk_cam0pll_d2", "clk_cam0pll_d3", "clk_mipimpll_d3"}),
+		REG_CLK_EN_2, 16,
+		REG_CLK_CAM0_SRC_DIV, 16, 6, -1,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		REG_CLK_CAM0_SRC_DIV, 8,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_CAM1, "clk_cam1",
+		((const char *[]) {"clk_cam0pll", "clk_cam0pll_d2", "clk_cam0pll_d3", "clk_mipimpll_d3"}),
+		REG_CLK_EN_2, 17,
+		REG_CLK_CAM1_SRC_DIV, 16, 6, -1,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		REG_CLK_CAM1_SRC_DIV, 8,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_CSI_MAC0_VIP, "clk_csi_mac0_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 18,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_CSI_MAC1_VIP, "clk_csi_mac1_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 19,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_ISP_TOP_VIP, "clk_isp_top_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 20,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_IMG_D_VIP, "clk_img_d_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 21,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_IMG_V_VIP, "clk_img_v_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 22,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_SC_TOP_VIP, "clk_sc_top_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 23,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_SC_D_VIP, "clk_sc_d_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 24,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_SC_V1_VIP, "clk_sc_v1_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 25,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_SC_V2_VIP, "clk_sc_v2_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 26,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_SC_V3_VIP, "clk_sc_v3_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 27,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_DWA_VIP, "clk_dwa_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 28,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_BT_VIP, "clk_bt_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 29,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_DISP_VIP, "clk_disp_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 30,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_DSI_MAC_VIP, "clk_dsi_mac_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 31,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_LVDS0_VIP, "clk_lvds0_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_3, 0,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_LVDS1_VIP, "clk_lvds1_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_3, 1,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_CSI0_RX_VIP, "clk_csi0_rx_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_3, 2,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_CSI1_RX_VIP, "clk_csi1_rx_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_3, 3,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_PAD_VI_VIP, "clk_pad_vi_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_3, 4,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_1M, "clk_1m",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_3, 5,
+		REG_DIV_CLK_1M, 16, 6, 25,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_SPI, "clk_spi",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_3, 6,
+		REG_DIV_CLK_SPI, 16, 6, 8,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 30,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_I2C, "clk_i2c",
+		((const char *[]) {"osc", "clk_axi6"}),
+		REG_CLK_EN_3, 7,
+		REG_DIV_CLK_I2C, 16, 4, 1,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 31,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_PM, "clk_pm",
+		((const char *[]) {"clk_axi6"}),
+		REG_CLK_EN_3, 8,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_TIMER0, "clk_timer0",
+		((const char *[]) {"clk_xtal_misc"}),
+		REG_CLK_EN_3, 9,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_TIMER1, "clk_timer1",
+		((const char *[]) {"clk_xtal_misc"}),
+		REG_CLK_EN_3, 10,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_TIMER2, "clk_timer2",
+		((const char *[]) {"clk_xtal_misc"}),
+		REG_CLK_EN_3, 11,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_TIMER3, "clk_timer3",
+		((const char *[]) {"clk_xtal_misc"}),
+		REG_CLK_EN_3, 12,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_TIMER4, "clk_timer4",
+		((const char *[]) {"clk_xtal_misc"}),
+		REG_CLK_EN_3, 13,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_TIMER5, "clk_timer5",
+		((const char *[]) {"clk_xtal_misc"}),
+		REG_CLK_EN_3, 14,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_TIMER6, "clk_timer6",
+		((const char *[]) {"clk_xtal_misc"}),
+		REG_CLK_EN_3, 15,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_TIMER7, "clk_timer7",
+		((const char *[]) {"clk_xtal_misc"}),
+		REG_CLK_EN_3, 16,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_I2C0, "clk_apb_i2c0",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_3, 17,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_I2C1, "clk_apb_i2c1",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_3, 18,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_I2C2, "clk_apb_i2c2",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_3, 19,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_I2C3, "clk_apb_i2c3",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_3, 20,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_I2C4, "clk_apb_i2c4",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_3, 21,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_WGN, "clk_wgn",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_3, 22,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_WGN0, "clk_wgn0",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_3, 23,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_WGN1, "clk_wgn1",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_3, 24,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_WGN2, "clk_wgn2",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_3, 25,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_KEYSCAN, "clk_keyscan",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_3, 26,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_AHB_SF1, "clk_ahb_sf1",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_3, 27,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_VC_SRC1, "clk_vc_src1",
+		((const char *[]) {"osc", "clk_cam1pll"}),
+		REG_CLK_EN_3, 28,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		REG_CLK_BYP_1, 0,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_SRC_VIP_SYS_2, "clk_src_vip_sys_2",
+		((const char *[]) {"osc", "clk_mipimpll", "clk_cam0pll", "clk_disppll", "clk_fpll"}),
+		REG_CLK_EN_3, 29,
+		REG_DIV_CLK_SRC_VIP_SYS_2, 16, 4, 2,
+		0, -1, 0, 0,
+		REG_CLK_BYP_1, 1,
+		0, -1,
+		REG_DIV_CLK_SRC_VIP_SYS_2, 8,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_PAD_VI1_VIP, "clk_pad_vi1_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_3, 30,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_CFG_REG_VIP, "clk_cfg_reg_vip",
+		((const char *[]) {"clk_axi6"}),
+		REG_CLK_EN_3, 31,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_CFG_REG_VC, "clk_cfg_reg_vc",
+		((const char *[]) {"clk_axi6"}),
+		REG_CLK_EN_4, 0,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_AUDSRC, "clk_audsrc",
+		((const char *[]) {"osc", "clk_a0pll", "a24k_clk"}),
+		REG_CLK_EN_4, 1,
+		REG_DIV_CLK_AUDSRC, 16, 8, 18,
+		0, -1, 0, 0,
+		REG_CLK_BYP_1, 2,
+		0, -1,
+		REG_DIV_CLK_AUDSRC, 8,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_APB_AUDSRC, "clk_apb_audsrc",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_4, 2,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_VC_SRC2, "clk_vc_src2",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_4, 3,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		REG_CLK_BYP_1, 3,
+		0, -1,
+		0, -1,
+		0),
+	CV180X_CLK(CV180X_CLK_PWM_SRC, "clk_pwm_src",
+		((const char *[]) {"osc", "clk_fpll", "clk_disppll"}),
+		REG_CLK_EN_4, 4,
+		REG_DIV_CLK_PWM_SRC_0, 16, 6, 10,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 15,
+		0, -1,
+		REG_DIV_CLK_PWM_SRC_0, 8,
+		0),
+	CV180X_CLK(CV180X_CLK_AP_DEBUG, "clk_ap_debug",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_4, 5,
+		REG_DIV_CLK_AP_DEBUG, 16, 4, 5,
+		0, -1, 0, 0,
+		REG_CLK_BYP_1, 4,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_SRC_RTC_SYS_0, "clk_src_rtc_sys_0",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_4, 6,
+		REG_DIV_CLK_RTCSYS_SRC_0, 16, 4, 5,
+		0, -1, 0, 0,
+		REG_CLK_BYP_1, 5,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_PAD_VI2_VIP, "clk_pad_vi2_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 7,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_CSI_BE_VIP, "clk_csi_be_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 8,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_VIP_IP0, "clk_vip_ip0",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 9,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_VIP_IP1, "clk_vip_ip1",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 10,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_VIP_IP2, "clk_vip_ip2",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 11,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_VIP_IP3, "clk_vip_ip3",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 12,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_C906_0, "clk_c906_0",
+		((const char *[]) {"osc", "clk_fpll", "clk_tpll", "clk_a0pll", "clk_mipimpll", "clk_mpll"}),
+		REG_CLK_EN_4, 13,
+		REG_DIV_CLK_C906_0_0, 16, 4, 1,
+		REG_DIV_CLK_C906_0_1, 16, 4, 2,
+		REG_CLK_BYP_1, 6,
+		REG_CLK_SEL_0, 23,
+		REG_DIV_CLK_C906_0_0, 8,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_C906_1, "clk_c906_1",
+		((const char *[]) {"osc", "clk_fpll", "clk_tpll", "clk_a0pll", "clk_disppll", "clk_mpll"}),
+		REG_CLK_EN_4, 14,
+		REG_DIV_CLK_C906_1_0, 16, 4, 2,
+		REG_DIV_CLK_C906_1_1, 16, 4, 2,
+		REG_CLK_BYP_1, 7,
+		REG_CLK_SEL_0, 24,
+		REG_DIV_CLK_C906_1_0, 8,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_SRC_VIP_SYS_3, "clk_src_vip_sys_3",
+		((const char *[]) {"osc", "clk_mipimpll", "clk_cam0pll", "clk_disppll", "clk_fpll"}),
+		REG_CLK_EN_4, 15,
+		REG_DIV_CLK_SRC_VIP_SYS_3, 16, 4, 2,
+		0, -1, 0, 0,
+		REG_CLK_BYP_1, 8,
+		0, -1,
+		REG_DIV_CLK_SRC_VIP_SYS_3, 8,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_SRC_VIP_SYS_4, "clk_src_vip_sys_4",
+		((const char *[]) {"osc", "clk_mipimpll", "clk_cam0pll", "clk_disppll", "clk_fpll"}),
+		REG_CLK_EN_4, 16,
+		REG_DIV_CLK_SRC_VIP_SYS_4, 16, 4, 3,
+		0, -1, 0, 0,
+		REG_CLK_BYP_1, 9,
+		0, -1,
+		REG_DIV_CLK_SRC_VIP_SYS_4, 8,
+		0),
+	CV180X_CLK(CV180X_CLK_IVE_VIP, "clk_ive_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 17,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_RAW_VIP, "clk_raw_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 18,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_OSDC_VIP, "clk_osdc_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 19,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV180X_CLK(CV180X_CLK_CSI_MAC2_VIP, "clk_csi_mac2_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 20,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV180X_CLK(CV180X_CLK_CAM0_VIP, "clk_cam0_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 21,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+};
+
+static int __init cvi_clk_flags_setup(char *arg)
+{
+	int ret;
+	unsigned long flags;
+
+	ret = kstrtol(arg, 0, &flags);
+	if (ret)
+		return ret;
+
+	cvi_clk_flags = flags;
+	pr_info("cvi_clk_flags = 0x%lX\n", cvi_clk_flags);
+
+	return 1;
+}
+__setup("cvi_clk_flags=", cvi_clk_flags_setup);
+
+static unsigned long cv180x_pll_rate_calc(u32 regval, s16 post_div_sel, unsigned long parent_rate)
+{
+	u64 numerator;
+	u32 predivsel, postdivsel, divsel;
+	u32 denominator;
+
+	predivsel = regval & 0x7f;
+	postdivsel = post_div_sel < 0 ? (regval >> 8) & 0x7f : (u32)post_div_sel;
+	divsel = (regval >> 17) & 0x7f;
+
+	numerator = parent_rate * divsel;
+	denominator = predivsel * postdivsel;
+	do_div(numerator, denominator);
+
+	return (unsigned long)numerator;
+}
+
+static unsigned long cv180x_g6_pll_recalc_rate(struct clk_hw *hw,
+					       unsigned long parent_rate)
+{
+	struct cv180x_pll_hw_clock *pll_hw = to_cv180x_pll_clk(hw);
+	unsigned long rate;
+	u32 regval;
+
+	regval = readl(pll_hw->base + pll_hw->pll.reg_csr);
+	rate = cv180x_pll_rate_calc(regval, pll_hw->pll.post_div_sel, parent_rate);
+
+	return rate;
+}
+
+static long cv180x_g6_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+				     unsigned long *prate)
+{
+	return rate;
+}
+
+static int cv180x_g6_pll_calc_csr(unsigned long parent_rate, unsigned long rate, u32 *csr)
+{
+	u64 numerator;
+	u32 denominator;
+	u32 divsel;		/* [23:17] DIV_SEL */
+	u32 postdivsel = 1;	/* [14:8] POST_DIV_SEL */
+	u32 ictrl = 7;		/* [26:24] ICTRL */
+	u32 selmode = 1;	/* [16:15] SEL_MODE */
+	u32 predivsel = 1;	/* [6:0] PRE_DIV_SEL */
+	u32 vco_clks[] = {900, 1000, 1100, 1200, 1300, 1400, 1500, 1600};
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(vco_clks); i++) {
+		if ((vco_clks[i] * 1000000) % rate == 0) {
+			postdivsel = vco_clks[i] * 1000000 / rate;
+			rate = vco_clks[i] * 1000000;
+			pr_debug("rate=%ld, postdivsel=%d\n", rate, postdivsel);
+			break;
+		}
+	}
+
+	numerator = rate;
+	denominator = parent_rate;
+
+	do_div(numerator, denominator);
+
+	divsel = (u32)numerator & 0x7f;
+	*csr = (divsel << 17) | (postdivsel << 8) | (ictrl << 24) | (selmode << 15) | predivsel;
+
+	pr_debug("csr=0x%08x\n", *csr);
+
+	return 0;
+}
+
+static int cv180x_g6_pll_set_rate(struct clk_hw *hw, unsigned long rate,
+				  unsigned long parent_rate)
+{
+	struct cv180x_pll_hw_clock *pll_hw = to_cv180x_pll_clk(hw);
+	unsigned long flags = 0;
+	int ret;
+	u32 reg_g6_pll_status;
+	u32 regval_csr;
+	u32 regval_g6_pll_status;
+	u32 g6_pll_update_status = 0;
+	ktime_t timeout;
+
+	reg_g6_pll_status = (pll_hw->pll.reg_csr & ~PLL_STATUS_MASK) + PLL_STATUS_OFFSET;
+
+	if (pll_hw->lock)
+		spin_lock_irqsave(pll_hw->lock, flags);
+	else
+		__acquire(pll_hw->lock);
+
+	/* calculate csr register */
+	ret = cv180x_g6_pll_calc_csr(parent_rate, rate, &regval_csr);
+	if (ret < 0)
+		return ret;
+
+	/* csr register */
+	writel(regval_csr, pll_hw->base + pll_hw->pll.reg_csr);
+
+	if (pll_hw->pll.reg_csr == REG_MPLL_CSR)
+		g6_pll_update_status = BIT(0);
+	else if (pll_hw->pll.reg_csr == REG_TPLL_CSR)
+		g6_pll_update_status = BIT(1);
+	else if (pll_hw->pll.reg_csr == REG_FPLL_CSR)
+		g6_pll_update_status = BIT(2);
+
+	/* wait for pll setting updated */
+	timeout = ktime_add_ms(ktime_get(), CV180X_PLL_LOCK_TIMEOUT_MS);
+	while (1) {
+		regval_g6_pll_status = readl(pll_hw->base + reg_g6_pll_status);
+		if ((regval_g6_pll_status & g6_pll_update_status) == 0)
+			break;
+
+		if (ktime_after(ktime_get(), timeout)) {
+			pr_err("timeout waiting for pll update, g6_pll_status = 0x%08x\n",
+			       regval_g6_pll_status);
+			break;
+		}
+		cpu_relax();
+	}
+
+	if (pll_hw->lock)
+		spin_unlock_irqrestore(pll_hw->lock, flags);
+	else
+		__release(pll_hw->lock);
+
+	return 0;
+}
+
+static const struct clk_ops cv180x_g6_pll_ops = {
+	.recalc_rate = cv180x_g6_pll_recalc_rate,
+	.round_rate = cv180x_g6_pll_round_rate,
+	.set_rate = cv180x_g6_pll_set_rate,
+};
+
+static unsigned long cv180x_g2_pll_recalc_rate(struct clk_hw *hw,
+					       unsigned long parent_rate)
+{
+	struct cv180x_pll_hw_clock *pll_hw = to_cv180x_pll_clk(hw);
+	u32 reg_ssc_set;
+	u32 reg_g2_ssc_ctrl;
+	u32 regval_csr;
+	u32 regval_ssc_set;
+	u32 regval_g2_ssc_ctrl;
+	u64 numerator;
+	u32 denominator;
+	unsigned long clk_ref;
+	unsigned long rate;
+
+	regval_csr = readl(pll_hw->base + pll_hw->pll.reg_csr);
+
+	/* pll without synthesizer */
+	if (pll_hw->pll.reg_ssc == 0) {
+		clk_ref = parent_rate;
+		goto rate_calc;
+	}
+
+	/* calculate synthesizer freq */
+	reg_ssc_set = (pll_hw->pll.reg_ssc & ~SSC_SYN_SET_MASK) + SSC_SYN_SET_OFFSET;
+	reg_g2_ssc_ctrl = (pll_hw->pll.reg_ssc & ~G2_SSC_CTRL_MASK) + G2_SSC_CTRL_OFFSET;
+
+	regval_ssc_set = readl(pll_hw->base + reg_ssc_set);
+	regval_g2_ssc_ctrl = readl(pll_hw->base + reg_g2_ssc_ctrl);
+
+	/* bit0 sel_syn_clk */
+	numerator = (regval_g2_ssc_ctrl & 0x1) ? parent_rate : (parent_rate >> 1);
+
+	numerator <<= 26;
+	denominator = regval_ssc_set;
+	if (denominator)
+		do_div(numerator, denominator);
+	else
+		pr_err("pll ssc_set is zero\n");
+
+	clk_ref = numerator;
+
+rate_calc:
+	rate = cv180x_pll_rate_calc(regval_csr, pll_hw->pll.post_div_sel, clk_ref);
+
+	return rate;
+}
+
+static const struct {
+	unsigned long rate;
+	u32 csr;
+	u32 ssc_set;
+} g2_pll_rate_lut[] = {
+	// {.rate = 48000000, .csr = 0x00129201, .ssc_set = 629145600},
+	// {.rate = 406425600, .csr = 0x010E9201, .ssc_set = 594430839},
+	// {.rate = 417792000, .csr = 0x01109201, .ssc_set = 642509804},
+	// {.rate = 768000000, .csr = 0x00108101, .ssc_set = 419430400},
+	// {.rate = 832000000, .csr = 0x00108101, .ssc_set = 387166523},
+	// {.rate = 1032000000, .csr = 0x00148101, .ssc_set = 390167814},
+	// {.rate = 1050000000, .csr = 0x00168101, .ssc_set = 421827145},
+	// {.rate = 1056000000, .csr = 0x00208100, .ssc_set = 412977625},
+	// {.rate = 1125000000, .csr = 0x00168101, .ssc_set = 393705325},
+	{.rate = 1188000000, .csr = 0x00188101, .ssc_set = 610080582},
+};
+
+static int cv180x_g2_pll_get_setting_from_lut(unsigned long rate, u32 *csr,
+					      u32 *ssc_set)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(g2_pll_rate_lut); i++) {
+		if (rate == g2_pll_rate_lut[i].rate) {
+			*csr = g2_pll_rate_lut[i].csr;
+			*ssc_set = g2_pll_rate_lut[i].ssc_set;
+			return 0;
+		}
+	}
+
+	*csr = 0;
+	*ssc_set = 0;
+	return -ENOENT;
+}
+
+static long cv180x_g2_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+				     unsigned long *prate)
+{
+	return rate;
+}
+
+static int cv180x_g2_pll_set_rate(struct clk_hw *hw, unsigned long rate,
+				  unsigned long parent_rate)
+{
+	struct cv180x_pll_hw_clock *pll_hw = to_cv180x_pll_clk(hw);
+	unsigned long flags = 0;
+	int ret;
+	u32 reg_ssc_set;
+	u32 reg_ssc_ctrl;
+	u32 reg_g2_pll_status;
+	u32 regval_csr;
+	u32 regval_ssc_set;
+	u32 regval_ssc_ctrl;
+	u32 regval_g2_pll_status;
+	u32 g2_pll_update_status = 0;
+	ktime_t timeout;
+
+	/* pll without synthesizer */
+	if (pll_hw->pll.reg_ssc == 0)
+		return -ENOENT;
+
+	ret = cv180x_g2_pll_get_setting_from_lut(rate, &regval_csr,
+						 &regval_ssc_set);
+	if (ret < 0)
+		return ret;
+
+	reg_ssc_set = (pll_hw->pll.reg_ssc & ~SSC_SYN_SET_MASK) + SSC_SYN_SET_OFFSET;
+	reg_ssc_ctrl = pll_hw->pll.reg_ssc;
+	reg_g2_pll_status = (pll_hw->pll.reg_csr & ~PLL_STATUS_MASK) + PLL_STATUS_OFFSET;
+
+	if (pll_hw->lock)
+		spin_lock_irqsave(pll_hw->lock, flags);
+	else
+		__acquire(pll_hw->lock);
+
+	/* set synthersizer */
+	writel(regval_ssc_set, pll_hw->base + reg_ssc_set);
+
+	/* bit 0 toggle */
+	regval_ssc_ctrl = readl(pll_hw->base + reg_ssc_ctrl);
+	regval_ssc_ctrl ^= 0x00000001;
+	writel(regval_ssc_ctrl, pll_hw->base + reg_ssc_ctrl);
+
+	/* csr register */
+	writel(regval_csr, pll_hw->base + pll_hw->pll.reg_csr);
+
+	if (pll_hw->pll.reg_csr == REG_MIPIMPLL_CSR)
+		g2_pll_update_status = BIT(0);
+	else if (pll_hw->pll.reg_csr == REG_APLL0_CSR)
+		g2_pll_update_status = BIT(1);
+	else if (pll_hw->pll.reg_csr == REG_DISPPLL_CSR)
+		g2_pll_update_status = BIT(2);
+	else if (pll_hw->pll.reg_csr == REG_CAM0PLL_CSR)
+		g2_pll_update_status = BIT(3);
+	else if (pll_hw->pll.reg_csr == REG_CAM1PLL_CSR)
+		g2_pll_update_status = BIT(4);
+
+	/* wait for pll setting updated */
+	timeout = ktime_add_ms(ktime_get(), CV180X_PLL_LOCK_TIMEOUT_MS);
+	while (1) {
+		regval_g2_pll_status = readl(pll_hw->base + reg_g2_pll_status);
+		if ((regval_g2_pll_status & g2_pll_update_status) == 0)
+			break;
+
+		if (ktime_after(ktime_get(), timeout)) {
+			pr_err("timeout waiting for pll update, g2_pll_status = 0x%08x\n",
+			       regval_g2_pll_status);
+			break;
+		}
+		cpu_relax();
+	}
+
+	if (pll_hw->lock)
+		spin_unlock_irqrestore(pll_hw->lock, flags);
+	else
+		__release(pll_hw->lock);
+
+	return 0;
+}
+
+static const struct clk_ops cv180x_g2_pll_ops = {
+	.recalc_rate = cv180x_g2_pll_recalc_rate,
+	.round_rate = cv180x_g2_pll_round_rate,
+	.set_rate = cv180x_g2_pll_set_rate,
+};
+
+static const struct clk_ops cv180x_g2d_pll_ops = {
+	.recalc_rate = cv180x_g2_pll_recalc_rate,
+};
+
+static struct clk_hw *cv180x_clk_register_pll(struct cv180x_pll_hw_clock *pll_clk,
+					    void __iomem *sys_base)
+{
+	struct clk_hw *hw;
+	struct clk_init_data init;
+	int err;
+
+	pll_clk->lock = &cv180x_clk_lock;
+	pll_clk->base = sys_base;
+
+	if (cvi_clk_flags) {
+		/* copy clk_init_data for modification */
+		memcpy(&init, pll_clk->hw.init, sizeof(init));
+
+		init.flags |= cvi_clk_flags;
+		pll_clk->hw.init = &init;
+	}
+
+	hw = &pll_clk->hw;
+
+	err = clk_hw_register(NULL, hw);
+	if (err)
+		return ERR_PTR(err);
+
+	return hw;
+}
+
+static void cv180x_clk_unregister_pll(struct clk_hw *hw)
+{
+	struct cv180x_pll_hw_clock *pll_hw = to_cv180x_pll_clk(hw);
+
+	clk_hw_unregister(hw);
+	kfree(pll_hw);
+}
+
+static int cv180x_clk_register_plls(struct cv180x_pll_hw_clock *clks,
+				    int num_clks,
+				    struct cv180x_clock_data *data)
+{
+	struct clk_hw *hw;
+	void __iomem *pll_base = data->base;
+	int i;
+
+	for (i = 0; i < num_clks; i++) {
+		struct cv180x_pll_hw_clock *cv180x_clk = &clks[i];
+
+		hw = cv180x_clk_register_pll(cv180x_clk, pll_base);
+		if (IS_ERR(hw)) {
+			pr_err("%s: failed to register clock %s\n",
+			       __func__, cv180x_clk->pll.name);
+			goto err_clk;
+		}
+
+		data->hw_data.hws[clks[i].pll.id] = hw;
+
+		clk_hw_register_clkdev(hw, cv180x_clk->pll.name, NULL);
+	}
+
+	return 0;
+
+err_clk:
+	while (i--)
+		cv180x_clk_unregister_pll(data->hw_data.hws[clks[i].pll.id]);
+
+	return PTR_ERR(hw);
+}
+
+static int cv180x_clk_is_bypassed(struct cv180x_hw_clock *clk_hw)
+{
+	u32 val;
+	void __iomem *reg_addr = clk_hw->base + clk_hw->mux[0].reg;
+
+	if (clk_hw->mux[0].shift >= 0) {
+		val = readl(reg_addr) >> clk_hw->mux[0].shift;
+		val &= 0x1; //width
+	} else {
+		val = 0;
+	}
+
+	return val;
+}
+
+static int cv180x_clk_get_clk_sel(struct cv180x_hw_clock *clk_hw)
+{
+	u32 val;
+	void __iomem *reg_addr = clk_hw->base + clk_hw->mux[1].reg;
+
+	if (clk_hw->mux[1].shift >= 0) {
+		val = readl(reg_addr) >> clk_hw->mux[1].shift;
+		val &= 0x1; //width
+		val ^= 0x1; //invert value
+	} else {
+		val = 0;
+	}
+
+	return val;
+}
+
+static int cv180x_clk_get_src_sel(struct cv180x_hw_clock *clk_hw)
+{
+	u32 val;
+	void __iomem *reg_addr = clk_hw->base + clk_hw->mux[2].reg;
+
+	if (clk_hw->mux[2].shift >= 0) {
+		val = readl(reg_addr) >> clk_hw->mux[2].shift;
+		val &= 0x3; //width
+	} else {
+		val = 0;
+	}
+
+	return val;
+}
+
+static unsigned long cv180x_clk_div_recalc_rate(struct clk_hw *hw,
+					      unsigned long parent_rate)
+{
+	struct cv180x_hw_clock *clk_hw = to_cv180x_clk(hw);
+	unsigned int clk_sel = cv180x_clk_get_clk_sel(clk_hw);
+	void __iomem *reg_addr = clk_hw->base + clk_hw->div[clk_sel].reg;
+	unsigned int val;
+	unsigned long rate;
+
+	if ((clk_hw->mux[0].shift >= 0) && cv180x_clk_is_bypassed(clk_hw))
+		return parent_rate;
+
+	if ((clk_hw->div[clk_sel].initval > 0) && !(readl(reg_addr) & BIT(3))) {
+		val = clk_hw->div[clk_sel].initval;
+	} else {
+		val = readl(reg_addr) >> clk_hw->div[clk_sel].shift;
+		val &= div_mask(clk_hw->div[clk_sel].width);
+	}
+	rate = divider_recalc_rate(hw, parent_rate, val, NULL,
+				   clk_hw->div[clk_sel].flags,
+				   clk_hw->div[clk_sel].width);
+
+	return rate;
+}
+
+static long cv180x_clk_div_round_rate(struct clk_hw *hw, unsigned long rate,
+				      unsigned long *prate)
+{
+	struct cv180x_hw_clock *clk_hw = to_cv180x_clk(hw);
+	unsigned int clk_sel = cv180x_clk_get_clk_sel(clk_hw);
+
+	if ((clk_hw->mux[0].shift >= 0) && cv180x_clk_is_bypassed(clk_hw))
+		return DIV_ROUND_UP_ULL((u64)*prate, 1);
+
+	return divider_round_rate(hw, rate, prate, NULL,
+				  clk_hw->div[clk_sel].width, clk_hw->div[clk_sel].flags);
+}
+
+static long cv180x_clk_div_calc_round_rate(struct clk_hw *hw, unsigned long rate,
+					 unsigned long *prate)
+{
+	struct cv180x_hw_clock *clk_hw = to_cv180x_clk(hw);
+
+	if (clk_hw->div[0].shift > 0)
+		return divider_round_rate(hw, rate, prate, NULL,
+					clk_hw->div[0].width, clk_hw->div[0].flags);
+	else
+		return DIV_ROUND_UP_ULL((u64)*prate, 1);
+}
+
+static int cv180x_clk_div_determine_rate(struct clk_hw *hw,
+				       struct clk_rate_request *req)
+{
+	struct clk_hw *current_parent;
+	unsigned long parent_rate;
+	unsigned long best_delta;
+	unsigned long best_rate;
+	u32 parent_count;
+	long rate;
+	u32 which;
+
+	pr_debug("%s()_%d: req->rate=%ld\n", __func__, __LINE__, req->rate);
+
+	parent_count = clk_hw_get_num_parents(hw);
+	pr_debug("%s()_%d: parent_count=%d\n", __func__, __LINE__, parent_count);
+
+	if ((parent_count < 2) || (clk_hw_get_flags(hw) & CLK_SET_RATE_NO_REPARENT)) {
+		rate = cv180x_clk_div_round_rate(hw, req->rate, &req->best_parent_rate);
+		if (rate < 0)
+			return rate;
+
+		req->rate = rate;
+		return 0;
+	}
+
+	/* Unless we can do better, stick with current parent */
+	current_parent = clk_hw_get_parent(hw);
+	parent_rate = clk_hw_get_rate(current_parent);
+	best_rate = cv180x_clk_div_calc_round_rate(hw, req->rate, &parent_rate);
+	best_delta = abs(best_rate - req->rate);
+
+	pr_debug("%s()_%d: parent_rate=%ld, best_rate=%ld, best_delta=%ld\n",
+		 __func__, __LINE__, parent_rate, best_rate, best_delta);
+
+	/* Check whether any other parent clock can produce a better result */
+	for (which = 0; which < parent_count; which++) {
+		struct clk_hw *parent = clk_hw_get_parent_by_index(hw, which);
+		unsigned long delta;
+		unsigned long other_rate;
+
+		pr_debug("%s()_%d: idx=%d, parent_rate=%ld, best_rate=%ld, best_delta=%ld\n",
+			 __func__, __LINE__, which, parent_rate, best_rate, best_delta);
+
+		if (!parent)
+			continue;
+
+		if (parent == current_parent)
+			continue;
+
+		/* Not support CLK_SET_RATE_PARENT */
+		parent_rate = clk_hw_get_rate(parent);
+		other_rate = cv180x_clk_div_calc_round_rate(hw, req->rate, &parent_rate);
+		delta = abs(other_rate - req->rate);
+		pr_debug("%s()_%d: parent_rate=%ld, other_rate=%ld, delta=%ld\n",
+			 __func__, __LINE__, parent_rate, other_rate, delta);
+		if (delta < best_delta) {
+			best_delta = delta;
+			best_rate = other_rate;
+			req->best_parent_hw = parent;
+			req->best_parent_rate = parent_rate;
+			pr_debug("%s()_%d: parent_rate=%ld, best_rate=%ld, best_delta=%ld\n",
+				 __func__, __LINE__, parent_rate, best_rate, best_delta);
+		}
+	}
+
+	req->rate = best_rate;
+
+	return 0;
+}
+
+static int cv180x_clk_div_set_rate(struct clk_hw *hw, unsigned long rate,
+				 unsigned long parent_rate)
+{
+	struct cv180x_hw_clock *clk_hw = to_cv180x_clk(hw);
+	unsigned int clk_sel = cv180x_clk_get_clk_sel(clk_hw);
+	void __iomem *reg_addr = clk_hw->base + clk_hw->div[clk_sel].reg;
+	unsigned long flags = 0;
+	int value;
+	u32 val;
+
+	value = divider_get_val(rate, parent_rate, NULL,
+				clk_hw->div[clk_sel].width,
+				clk_hw->div[clk_sel].flags);
+	if (value < 0)
+		return value;
+
+	if (clk_hw->lock)
+		spin_lock_irqsave(clk_hw->lock, flags);
+	else
+		__acquire(clk_hw->lock);
+
+	val = readl(reg_addr);
+	val &= ~(div_mask(clk_hw->div[clk_sel].width) << clk_hw->div[clk_sel].shift);
+	val |= (u32)value << clk_hw->div[clk_sel].shift;
+	if (!(clk_hw->div[clk_sel].initval < 0))
+		val |= BIT(3);
+	writel(val, reg_addr);
+
+	if (clk_hw->lock)
+		spin_unlock_irqrestore(clk_hw->lock, flags);
+	else
+		__release(clk_hw->lock);
+
+	return 0;
+}
+
+static void cv180x_clk_gate_endisable(struct clk_hw *hw, int enable)
+{
+	struct cv180x_hw_clock *clk_hw = to_cv180x_clk(hw);
+	void __iomem *reg_addr = clk_hw->base + clk_hw->gate.reg;
+	unsigned long flags = 0;
+	u32 reg;
+
+	if (clk_hw->lock)
+		spin_lock_irqsave(clk_hw->lock, flags);
+	else
+		__acquire(clk_hw->lock);
+
+	reg = readl(reg_addr);
+
+	if (enable)
+		reg |= BIT(clk_hw->gate.shift);
+	else
+		reg &= ~BIT(clk_hw->gate.shift);
+
+	writel(reg, reg_addr);
+
+	if (clk_hw->lock)
+		spin_unlock_irqrestore(clk_hw->lock, flags);
+	else
+		__release(clk_hw->lock);
+}
+
+static int cv180x_clk_gate_enable(struct clk_hw *hw)
+{
+	cv180x_clk_gate_endisable(hw, 1);
+
+	return 0;
+}
+
+static void cv180x_clk_gate_disable(struct clk_hw *hw)
+{
+	cv180x_clk_gate_endisable(hw, 0);
+}
+
+static int cv180x_clk_gate_is_enabled(struct clk_hw *hw)
+{
+	u32 reg;
+	struct cv180x_hw_clock *clk_hw = to_cv180x_clk(hw);
+	void __iomem *reg_addr = clk_hw->base + clk_hw->gate.reg;
+
+	reg = readl(reg_addr);
+
+	reg &= BIT(clk_hw->gate.shift);
+
+	if (clk_hw_get_flags(hw) & CLK_IGNORE_UNUSED)
+		return __clk_get_enable_count(hw->clk) ? (reg ? 1 : 0) : 0;
+	else
+		return reg ? 1 : 0;
+}
+
+static u8 cv180x_clk_mux_get_parent(struct clk_hw *hw)
+{
+	struct cv180x_hw_clock *clk_hw = to_cv180x_clk(hw);
+	u8 clk_sel = cv180x_clk_get_clk_sel(clk_hw);
+	u8 src_sel = cv180x_clk_get_src_sel(clk_hw);
+	u8 parent_idx = 0;
+
+	/*
+	 * | 0     | 1     | 2     | 3     | 4     | 5     |
+	 * +-------+-------+-------+-------+-------+-------+
+	 * | XTAL  | DIV_1 | src_0 | src_1 | src_2 | src_3 |
+	 * | XTAL  | src_0 | src_1 | src_2 | src_3 |       |
+	 * | DIV_1 | src_0 | src_1 | src_2 | src_3 |       |
+	 * | src_0 | src_1 | src_2 | src_3 |       |       |
+	 * +-------+-------+-------+-------+-------+-------+
+	 */
+
+	if (clk_hw->mux[0].shift >= 0) {
+		// clk with bypass reg
+		if (cv180x_clk_is_bypassed(clk_hw)) {
+			parent_idx = 0;
+		} else {
+			if (clk_hw->mux[1].shift >= 0) {
+				// clk with clk_sel reg
+				if (clk_sel) {
+					parent_idx = 1;
+				} else {
+					parent_idx = src_sel + 2;
+				}
+			} else {
+				// clk without clk_sel reg
+				parent_idx = src_sel + 1;
+			}
+		}
+	} else {
+		// clk without bypass reg
+		if (clk_hw->mux[1].shift >= 0) {
+			// clk with clk_sel reg
+			if (clk_sel) {
+				parent_idx = 0;
+			} else {
+				parent_idx = src_sel + 1;
+			}
+		} else {
+			//clk without clk_sel reg
+			parent_idx = src_sel;
+		}
+	}
+
+	return parent_idx;
+}
+
+static int cv180x_clk_mux_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct cv180x_hw_clock *clk_hw = to_cv180x_clk(hw);
+	unsigned long flags = 0;
+	void __iomem *reg_addr;
+	unsigned int reg;
+
+	if (clk_hw->lock)
+		spin_lock_irqsave(clk_hw->lock, flags);
+	else
+		__acquire(clk_hw->lock);
+
+	/*
+	 * | 0     | 1     | 2     | 3     | 4     | 5     |
+	 * +-------+-------+-------+-------+-------+-------+
+	 * | XTAL  | DIV_1 | src_0 | src_1 | src_2 | src_3 |
+	 * | XTAL  | src_0 | src_1 | src_2 | src_3 |       |
+	 * | DIV_1 | src_0 | src_1 | src_2 | src_3 |       |
+	 * | src_0 | src_1 | src_2 | src_3 |       |       |
+	 * +-------+-------+-------+-------+-------+-------+
+	 */
+
+	if (index == 0) {
+		if (clk_hw->mux[0].shift >= 0) {
+			// set bypass
+			reg_addr = clk_hw->base + clk_hw->mux[0].reg;
+			reg = readl(reg_addr);
+			reg |= 1 << clk_hw->mux[0].shift;
+			writel(reg, reg_addr);
+			goto unlock_release;
+		} else if (clk_hw->mux[1].shift >= 0) {
+			// set clk_sel to DIV_1
+			reg_addr = clk_hw->base + clk_hw->mux[1].reg;
+			reg = readl(reg_addr);
+			reg &= ~(1 << clk_hw->mux[1].shift);
+			writel(reg, reg_addr);
+			goto unlock_release;
+		}
+	} else if (index == 1) {
+		if (clk_hw->mux[0].shift >= 0) {
+			// clear bypass
+			reg_addr = clk_hw->base + clk_hw->mux[0].reg;
+			reg = readl(reg_addr);
+			reg &= ~(0x1 << clk_hw->mux[0].shift);
+			writel(reg, reg_addr);
+
+			if (clk_hw->mux[1].shift >= 0) {
+				// set clk_sel to DIV_1
+				reg_addr = clk_hw->base + clk_hw->mux[1].reg;
+				reg = readl(reg_addr);
+				reg &= ~(1 << clk_hw->mux[1].shift);
+				writel(reg, reg_addr);
+				goto unlock_release;
+			} else {
+				index--;
+			}
+		} else if (clk_hw->mux[1].shift >= 0) {
+			// set clk_sel to DIV_0
+			reg_addr = clk_hw->base + clk_hw->mux[1].reg;
+			reg = readl(reg_addr);
+			reg |= 1 << clk_hw->mux[1].shift;
+			writel(reg, reg_addr);
+			index--;
+		}
+	} else {
+		if (clk_hw->mux[0].shift >= 0) {
+			// clear bypass
+			reg_addr = clk_hw->base + clk_hw->mux[0].reg;
+			reg = readl(reg_addr);
+			reg &= ~(0x1 << clk_hw->mux[0].shift);
+			writel(reg, reg_addr);
+			index--;
+		}
+
+		if (clk_hw->mux[1].shift >= 0) {
+			// set clk_sel to DIV_0
+			reg_addr = clk_hw->base + clk_hw->mux[1].reg;
+			reg = readl(reg_addr);
+			reg |= 1 << clk_hw->mux[1].shift;
+			writel(reg, reg_addr);
+			index--;
+		}
+	}
+
+	if (index < 0) {
+		pr_err("index is negative(%d)\n", index);
+		goto unlock_release;
+	}
+
+	// set src_sel reg
+	reg_addr = clk_hw->base + clk_hw->mux[2].reg;
+	reg = readl(reg_addr);
+	reg &= ~(0x3 << clk_hw->mux[2].shift); // clear bits
+	reg |= (index & 0x3) << clk_hw->mux[2].shift; //set bits
+	writel(reg, reg_addr);
+
+unlock_release:
+	if (clk_hw->lock)
+		spin_unlock_irqrestore(clk_hw->lock, flags);
+	else
+		__release(clk_hw->lock);
+
+	return 0;
+}
+
+static const struct clk_ops cv180x_clk_ops = {
+	// gate
+	.enable = cv180x_clk_gate_enable,
+	.disable = cv180x_clk_gate_disable,
+	.is_enabled = cv180x_clk_gate_is_enabled,
+
+	// div
+	.recalc_rate = cv180x_clk_div_recalc_rate,
+	.round_rate = cv180x_clk_div_round_rate,
+	.determine_rate = cv180x_clk_div_determine_rate,
+	.set_rate = cv180x_clk_div_set_rate,
+
+	//mux
+	.get_parent = cv180x_clk_mux_get_parent,
+	.set_parent = cv180x_clk_mux_set_parent,
+};
+
+static struct clk_hw *cv180x_register_clk(struct cv180x_hw_clock *cv180x_clk,
+					  void __iomem *sys_base)
+{
+	struct clk_hw *hw;
+	struct clk_init_data init;
+	int err;
+
+	cv180x_clk->gate.flags = 0;
+	cv180x_clk->div[0].flags = CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO |
+				 CLK_DIVIDER_ROUND_CLOSEST;
+	cv180x_clk->div[1].flags = CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO |
+				 CLK_DIVIDER_ROUND_CLOSEST;
+	cv180x_clk->mux[0].flags = 0; /* clk byp */
+	cv180x_clk->mux[1].flags = 0; /* clk sel */
+	cv180x_clk->mux[2].flags = 0; /* div_0 src_sel */
+	cv180x_clk->base = sys_base;
+	cv180x_clk->lock = &cv180x_clk_lock;
+
+	if (cvi_clk_flags) {
+		/* copy clk_init_data for modification */
+		memcpy(&init, cv180x_clk->hw.init, sizeof(init));
+
+		init.flags |= cvi_clk_flags;
+		cv180x_clk->hw.init = &init;
+	}
+
+	hw = &cv180x_clk->hw;
+	err = clk_hw_register(NULL, hw);
+	if (err) {
+		return ERR_PTR(err);
+	}
+
+	return hw;
+}
+
+static void cv180x_unregister_clk(struct clk_hw *hw)
+{
+	struct cv180x_hw_clock *cv180x_clk = to_cv180x_clk(hw);
+
+	clk_hw_unregister(hw);
+	kfree(cv180x_clk);
+}
+static int cv180x_register_clks(struct cv180x_hw_clock *clks,
+				int num_clks,
+				struct cv180x_clock_data *data)
+{
+	struct clk_hw *hw;
+	void __iomem *sys_base = data->base;
+	unsigned int i;
+
+	for (i = 0; i < num_clks; i++) {
+		struct cv180x_hw_clock *cv180x_clk = &clks[i];
+
+		hw = cv180x_register_clk(cv180x_clk, sys_base);
+
+		if (IS_ERR(hw)) {
+			pr_err("%s: failed to register clock %s\n",
+			       __func__, cv180x_clk->name);
+			goto err_clk;
+		}
+		data->hw_data.hws[clks[i].id] = hw;
+		clk_hw_register_clkdev(hw, cv180x_clk->name, NULL);
+	}
+
+	return 0;
+
+err_clk:
+	while (i--)
+		cv180x_unregister_clk(data->hw_data.hws[clks[i].id]);
+
+	return PTR_ERR(hw);
+}
+
+static const struct of_device_id cvi_clk_match_ids_tables[] = {
+	{
+		.compatible = "cvitek,cv180x-clk",
+	},
+	{}
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int cv180x_clk_suspend(void)
+{
+	memcpy_fromio(clk_data->clken_saved_regs,
+		      clk_data->base + REG_CLK_EN_START,
+		      REG_CLK_EN_NUM * 4);
+
+	memcpy_fromio(clk_data->clksel_saved_regs,
+		      clk_data->base + REG_CLK_SEL_START,
+		      REG_CLK_SEL_NUM * 4);
+
+	memcpy_fromio(clk_data->clkbyp_saved_regs,
+		      clk_data->base + REG_CLK_BYP_START,
+		      REG_CLK_BYP_NUM * 4);
+
+	memcpy_fromio(clk_data->clkdiv_saved_regs,
+		      clk_data->base + REG_CLK_DIV_START,
+		      REG_CLK_DIV_NUM * 4);
+
+	memcpy_fromio(clk_data->g2_clkdiv_saved_regs,
+		      clk_data->base + REG_CLK_G2_DIV_START,
+		      REG_CLK_G2_DIV_NUM * 4);
+
+	memcpy_fromio(clk_data->pll_g2_csr_saved_regs,
+		      clk_data->base + REG_PLL_G2_CSR_START,
+		      REG_PLL_G2_CSR_NUM * 4);
+
+	memcpy_fromio(clk_data->pll_g6_csr_saved_regs,
+		      clk_data->base + REG_PLL_G6_CSR_START,
+		      REG_PLL_G6_CSR_NUM * 4);
+
+	clk_data->a0pll_ssc_syn_set_saved_reg =
+		readl(clk_data->base + REG_APLL_SSC_SYN_SET);
+
+	clk_data->disppll_ssc_syn_set_saved_reg =
+		readl(clk_data->base + REG_DISPPLL_SSC_SYN_SET);
+
+	clk_data->cam0pll_ssc_syn_set_saved_reg =
+		readl(clk_data->base + REG_CAM0PLL_SSC_SYN_SET);
+
+	clk_data->cam1pll_ssc_syn_set_saved_reg =
+		readl(clk_data->base + REG_CAM1PLL_SSC_SYN_SET);
+
+	return 0;
+}
+
+static void cv180x_clk_resume(void)
+{
+	uint32_t regval;
+
+	/* switch clock to xtal */
+	writel(0xffffffff, clk_data->base + REG_CLK_BYP_0);
+	writel(0x0000000f, clk_data->base + REG_CLK_BYP_1);
+
+	memcpy_toio(clk_data->base + REG_CLK_EN_START,
+		    clk_data->clken_saved_regs,
+		    REG_CLK_EN_NUM * 4);
+
+	memcpy_toio(clk_data->base + REG_CLK_SEL_START,
+		    clk_data->clksel_saved_regs,
+		    REG_CLK_SEL_NUM * 4);
+
+	memcpy_toio(clk_data->base + REG_CLK_DIV_START,
+		    clk_data->clkdiv_saved_regs,
+		    REG_CLK_DIV_NUM * 4);
+
+	memcpy_toio(clk_data->base + REG_CLK_G2_DIV_START,
+		    clk_data->g2_clkdiv_saved_regs,
+		    REG_CLK_G2_DIV_NUM * 4);
+
+	memcpy_toio(clk_data->base + REG_PLL_G6_CSR_START,
+		    clk_data->pll_g6_csr_saved_regs,
+		    REG_PLL_G6_CSR_NUM * 4);
+
+	/* wait for pll setting updated */
+	while (readl(clk_data->base + REG_PLL_G6_STATUS) & 0x7) {
+	}
+
+	/* A0PLL */
+	if (clk_data->a0pll_ssc_syn_set_saved_reg !=
+	    readl(clk_data->base + REG_APLL_SSC_SYN_SET)) {
+		pr_debug("%s: update A0PLL\n", __func__);
+		writel(clk_data->a0pll_ssc_syn_set_saved_reg,
+		       clk_data->base + REG_APLL_SSC_SYN_SET);
+
+		/* toggle software update */
+		regval = readl(clk_data->base + REG_APLL_SSC_SYN_CTRL);
+		regval ^= 1;
+		writel(regval, clk_data->base + REG_APLL_SSC_SYN_CTRL);
+	}
+
+	/* DISPPLL */
+	if (clk_data->disppll_ssc_syn_set_saved_reg !=
+	    readl(clk_data->base + REG_DISPPLL_SSC_SYN_SET)) {
+		pr_debug("%s: update DISPPLL\n", __func__);
+		writel(clk_data->disppll_ssc_syn_set_saved_reg,
+		       clk_data->base + REG_DISPPLL_SSC_SYN_SET);
+
+		/* toggle software update */
+		regval = readl(clk_data->base + REG_DISPPLL_SSC_SYN_CTRL);
+		regval ^= 1;
+		writel(regval, clk_data->base + REG_DISPPLL_SSC_SYN_CTRL);
+	}
+
+	/* CAM0PLL */
+	if (clk_data->cam0pll_ssc_syn_set_saved_reg !=
+	    readl(clk_data->base + REG_CAM0PLL_SSC_SYN_SET)) {
+		pr_debug("%s: update CAM0PLL\n", __func__);
+		writel(clk_data->cam0pll_ssc_syn_set_saved_reg,
+		       clk_data->base + REG_CAM0PLL_SSC_SYN_SET);
+
+		/* toggle software update */
+		regval = readl(clk_data->base + REG_CAM0PLL_SSC_SYN_CTRL);
+		regval ^= 1;
+		writel(regval, clk_data->base + REG_CAM0PLL_SSC_SYN_CTRL);
+	}
+
+	/* CAM1PLL */
+	if (clk_data->cam1pll_ssc_syn_set_saved_reg !=
+	    readl(clk_data->base + REG_CAM1PLL_SSC_SYN_SET)) {
+		pr_debug("%s: update CAM1PLL\n", __func__);
+		writel(clk_data->cam1pll_ssc_syn_set_saved_reg,
+		       clk_data->base + REG_CAM1PLL_SSC_SYN_SET);
+
+		/* toggle software update */
+		regval = readl(clk_data->base + REG_CAM1PLL_SSC_SYN_CTRL);
+		regval ^= 1;
+		writel(regval, clk_data->base + REG_CAM1PLL_SSC_SYN_CTRL);
+	}
+
+	memcpy_toio(clk_data->base + REG_PLL_G2_CSR_START,
+		    clk_data->pll_g2_csr_saved_regs,
+		    REG_PLL_G2_CSR_NUM * 4);
+
+	/* wait for pll setting updated */
+	while (readl(clk_data->base + REG_PLL_G2_STATUS) & 0x1F) {
+	}
+
+	memcpy_toio(clk_data->base + REG_CLK_BYP_START,
+		    clk_data->clkbyp_saved_regs,
+		    REG_CLK_BYP_NUM * 4);
+}
+
+static struct syscore_ops cv180x_clk_syscore_ops = {
+	.suspend = cv180x_clk_suspend,
+	.resume = cv180x_clk_resume,
+};
+#endif /* CONFIG_PM_SLEEP */
+
+static void __init cvi_clk_init(struct device_node *node)
+{
+	int num_clks;
+	int i;
+	int ret = 0;
+	int of_num_clks;
+	struct clk *clk;
+
+	of_num_clks = of_clk_get_parent_count(node);
+	for (i = 0; i < of_num_clks; i++) {
+		clk = of_clk_get(node, i);
+		clk_register_clkdev(clk, __clk_get_name(clk), NULL);
+		clk_put(clk);
+	}
+
+	num_clks = ARRAY_SIZE(cv180x_pll_clks) +
+		   ARRAY_SIZE(cv180x_clks);
+
+	clk_data = kzalloc(sizeof(struct cv180x_clock_data) +
+			   sizeof(struct clk_hw) * num_clks,
+			   GFP_KERNEL);
+	if (!clk_data) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	for (i = 0; i < num_clks; i++)
+		clk_data->hw_data.hws[i] = ERR_PTR(-ENOENT);
+
+	clk_data->hw_data.num = num_clks;
+
+	clk_data->lock = &cv180x_clk_lock;
+
+	clk_data->base = of_iomap(node, 0);
+	if (!clk_data->base) {
+		pr_err("Failed to map address range for cvitek,cv180x-clk node\n");
+		return;
+	}
+
+	cv180x_clk_register_plls(cv180x_pll_clks,
+			       ARRAY_SIZE(cv180x_pll_clks),
+			       clk_data);
+
+	cv180x_register_clks(cv180x_clks,
+			   ARRAY_SIZE(cv180x_clks),
+			   clk_data);
+
+
+	/* register clk-provider */
+	ret = of_clk_add_hw_provider(node, of_clk_hw_onecell_get, &clk_data->hw_data);
+	if (ret)
+		pr_err("Unable to add hw clk provider\n");
+
+	/* force enable clocks */
+	// clk_prepare_enable(clk_data->hw_data.hws[CV180X_CLK_DSI_MAC_VIP]->clk);
+	// clk_prepare_enable(clk_data->hw_data.hws[CV180X_CLK_DISP_VIP]->clk);
+	// clk_prepare_enable(clk_data->hw_data.hws[CV180X_CLK_BT_VIP]->clk);
+	// clk_prepare_enable(clk_data->hw_data.hws[CV180X_CLK_SC_TOP_VIP]->clk);
+
+#ifdef CONFIG_PM_SLEEP
+	register_syscore_ops(&cv180x_clk_syscore_ops);
+#endif
+
+	if (!ret)
+		return;
+
+out:
+	pr_err("%s failed error number %d\n", __func__, ret);
+}
+CLK_OF_DECLARE(cvi_clk, "cvitek,cv180x-clk", cvi_clk_init);
diff --git a/drivers/clk/cvitek/clk-cv181x.c b/drivers/clk/cvitek/clk-cv181x.c
new file mode 100644
index 000000000000..561fb1fcb832
--- /dev/null
+++ b/drivers/clk/cvitek/clk-cv181x.c
@@ -0,0 +1,2848 @@
+/*
+ * Copyright (c) 2021 CVITEK
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include <linux/syscore_ops.h>
+
+#include <dt-bindings/clock/cv181x-clock.h>
+
+#define CV181X_CLK_FLAGS_ALL	(CLK_GET_RATE_NOCACHE)
+// #define CV181X_CLK_FLAGS_ALL	(CLK_GET_RATE_NOCACHE | CLK_IS_CRITICAL)
+// #define CV181X_CLK_FLAGS_ALL	(CLK_GET_RATE_NOCACHE | CLK_IGNORE_UNUSED)
+#define CV181X_CLK_FLAGS_MUX	(CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT)
+
+/* top_pll_g2 */
+#define REG_PLL_G2_CTRL			0x800
+#define REG_PLL_G2_STATUS		0x804
+#define REG_MIPIMPLL_CSR		0x808
+#define REG_APLL0_CSR			0x80C
+#define REG_DISPPLL_CSR			0x810
+#define REG_CAM0PLL_CSR			0x814
+#define REG_CAM1PLL_CSR			0x818
+#define REG_PLL_G2_SSC_SYN_CTRL		0x840
+#define REG_APLL_SSC_SYN_CTRL		0x850
+#define REG_APLL_SSC_SYN_SET		0x854
+#define REG_APLL_SSC_SYN_SPAN		0x858
+#define REG_APLL_SSC_SYN_STEP		0x85C
+#define REG_DISPPLL_SSC_SYN_CTRL	0x860
+#define REG_DISPPLL_SSC_SYN_SET		0x864
+#define REG_DISPPLL_SSC_SYN_SPAN	0x868
+#define REG_DISPPLL_SSC_SYN_STEP	0x86C
+#define REG_CAM0PLL_SSC_SYN_CTRL	0x870
+#define REG_CAM0PLL_SSC_SYN_SET		0x874
+#define REG_CAM0PLL_SSC_SYN_SPAN	0x878
+#define REG_CAM0PLL_SSC_SYN_STEP	0x87C
+#define REG_CAM1PLL_SSC_SYN_CTRL	0x880
+#define REG_CAM1PLL_SSC_SYN_SET		0x884
+#define REG_CAM1PLL_SSC_SYN_SPAN	0x888
+#define REG_CAM1PLL_SSC_SYN_STEP	0x88C
+#define REG_APLL_FRAC_DIV_CTRL		0x890
+#define REG_APLL_FRAC_DIV_M		0x894
+#define REG_APLL_FRAC_DIV_N		0x898
+#define REG_MIPIMPLL_CLK_CSR		0x8A0
+#define REG_A0PLL_CLK_CSR		0x8A4
+#define REG_DISPPLL_CLK_CSR		0x8A8
+#define REG_CAM0PLL_CLK_CSR		0x8AC
+#define REG_CAM1PLL_CLK_CSR		0x8B0
+#define REG_CLK_CAM0_SRC_DIV		0x8C0
+#define REG_CLK_CAM1_SRC_DIV		0x8C4
+
+/* top_pll_g6 */
+#define REG_PLL_G6_CTRL			0x900
+#define REG_PLL_G6_STATUS		0x904
+#define REG_MPLL_CSR			0x908
+#define REG_TPLL_CSR			0x90C
+#define REG_FPLL_CSR			0x910
+#define REG_PLL_G6_SSC_SYN_CTRL		0x940
+#define REG_DPLL_SSC_SYN_CTRL		0x950
+#define REG_DPLL_SSC_SYN_SET		0x954
+#define REG_DPLL_SSC_SYN_SPAN		0x958
+#define REG_DPLL_SSC_SYN_STEP		0x95C
+#define REG_MPLL_SSC_SYN_CTRL		0x960
+#define REG_MPLL_SSC_SYN_SET		0x964
+#define REG_MPLL_SSC_SYN_SPAN		0x968
+#define REG_MPLL_SSC_SYN_STEP		0x96C
+#define REG_TPLL_SSC_SYN_CTRL		0x970
+#define REG_TPLL_SSC_SYN_SET		0x974
+#define REG_TPLL_SSC_SYN_SPAN		0x978
+#define REG_TPLL_SSC_SYN_STEP		0x97C
+
+/* clkgen */
+#define REG_CLK_EN_0			0x000
+#define REG_CLK_EN_1			0x004
+#define REG_CLK_EN_2			0x008
+#define REG_CLK_EN_3			0x00C
+#define REG_CLK_EN_4			0x010
+#define REG_CLK_SEL_0			0x020
+#define REG_CLK_BYP_0			0x030
+#define REG_CLK_BYP_1			0x034
+
+#define REG_DIV_CLK_A53_0		0x040
+#define REG_DIV_CLK_A53_1		0x044
+#define REG_DIV_CLK_CPU_AXI0		0x048
+#define REG_DIV_CLK_CPU_GIC		0x050
+#define REG_DIV_CLK_TPU			0x054
+#define REG_DIV_CLK_EMMC		0x064
+#define REG_DIV_CLK_100K_EMMC		0x06C
+#define REG_DIV_CLK_SD0			0x070
+#define REG_DIV_CLK_100K_SD0		0x078
+#define REG_DIV_CLK_SD1			0x07C
+#define REG_DIV_CLK_100K_SD1		0x084
+#define REG_DIV_CLK_SPI_NAND		0x088
+#define REG_DIV_CLK_500M_ETH0		0x08C
+#define REG_DIV_CLK_500M_ETH1		0x090
+#define REG_DIV_CLK_GPIO_DB		0x094
+#define REG_DIV_CLK_SDMA_AUD0		0x098
+#define REG_DIV_CLK_SDMA_AUD1		0x09C
+#define REG_DIV_CLK_SDMA_AUD2		0x0A0
+#define REG_DIV_CLK_SDMA_AUD3		0x0A4
+#define REG_DIV_CLK_CAM0_200		0x0A8
+#define REG_DIV_CLK_AXI4		0x0B8
+#define REG_DIV_CLK_AXI6		0x0BC
+#define REG_DIV_CLK_DSI_ESC		0x0C4
+#define REG_DIV_CLK_AXI_VIP		0x0C8
+#define REG_DIV_CLK_SRC_VIP_SYS_0	0x0D0
+#define REG_DIV_CLK_SRC_VIP_SYS_1	0x0D8
+#define REG_DIV_CLK_DISP_SRC_VIP	0x0E0
+#define REG_DIV_CLK_AXI_VIDEO_CODEC	0x0E4
+#define REG_DIV_CLK_VC_SRC0		0x0EC
+#define REG_DIV_CLK_1M			0x0FC
+#define REG_DIV_CLK_SPI			0x100
+#define REG_DIV_CLK_I2C			0x104
+#define REG_DIV_CLK_SRC_VIP_SYS_2	0x110
+#define REG_DIV_CLK_AUDSRC		0x118
+#define REG_DIV_CLK_PWM_SRC_0		0x120
+#define REG_DIV_CLK_AP_DEBUG		0x128
+#define REG_DIV_CLK_RTCSYS_SRC_0	0x12C
+#define REG_DIV_CLK_C906_0_0		0x130
+#define REG_DIV_CLK_C906_0_1		0x134
+#define REG_DIV_CLK_C906_1_0		0x138
+#define REG_DIV_CLK_C906_1_1		0x13C
+#define REG_DIV_CLK_SRC_VIP_SYS_3	0x140
+#define REG_DIV_CLK_SRC_VIP_SYS_4	0x144
+
+#define REG_PLL_G2_CSR_NUM		(REG_CAM1PLL_CSR / 4 - REG_MIPIMPLL_CSR / 4 + 1)
+#define REG_PLL_G2_CSR_START		REG_MIPIMPLL_CSR
+
+#define REG_PLL_G6_CSR_NUM		(REG_FPLL_CSR / 4 - REG_MPLL_CSR / 4 + 1)
+#define REG_PLL_G6_CSR_START		REG_MPLL_CSR
+
+#define REG_CLK_EN_NUM			(REG_CLK_EN_4 / 4 - REG_CLK_EN_0 / 4 + 1)
+#define REG_CLK_EN_START		REG_CLK_EN_0
+
+#define REG_CLK_SEL_NUM			(REG_CLK_SEL_0 / 4  - REG_CLK_SEL_0 / 4 + 1)
+#define REG_CLK_SEL_START		REG_CLK_SEL_0
+
+#define REG_CLK_BYP_NUM			(REG_CLK_BYP_1 / 4 - REG_CLK_BYP_0 / 4 + 1)
+#define REG_CLK_BYP_START		REG_CLK_BYP_0
+
+#define REG_CLK_DIV_NUM			(REG_DIV_CLK_SRC_VIP_SYS_4 / 4 - REG_DIV_CLK_A53_0 / 4 + 1)
+#define REG_CLK_DIV_START		REG_DIV_CLK_A53_0
+
+#define REG_CLK_G2_DIV_NUM		(REG_CLK_CAM1_SRC_DIV / 4 - REG_CLK_CAM0_SRC_DIV / 4 + 1)
+#define REG_CLK_G2_DIV_START		REG_CLK_CAM0_SRC_DIV
+
+#define CV181X_PLL_LOCK_TIMEOUT_MS	200
+
+/* PLL status register offset */
+#define PLL_STATUS_MASK			0xFF
+#define PLL_STATUS_OFFSET		0x04
+
+/* G2 Synthesizer register offset */
+#define G2_SSC_CTRL_MASK		0xFF
+#define G2_SSC_CTRL_OFFSET		0x40
+#define SSC_SYN_SET_MASK		0x0F
+#define SSC_SYN_SET_OFFSET		0x04
+
+#define to_cv181x_pll_clk(_hw) container_of(_hw, struct cv181x_pll_hw_clock, hw)
+#define to_cv181x_clk(_hw) container_of(_hw, struct cv181x_hw_clock, hw)
+
+#define div_mask(width) ((1 << (width)) - 1)
+
+static DEFINE_SPINLOCK(cv181x_clk_lock);
+
+struct cv181x_clock_data {
+	void __iomem *base;
+	spinlock_t *lock;
+	struct clk_hw_onecell_data hw_data;
+#ifdef CONFIG_PM_SLEEP
+	uint32_t clken_saved_regs[REG_CLK_EN_NUM];
+	uint32_t clksel_saved_regs[REG_CLK_SEL_NUM];
+	uint32_t clkbyp_saved_regs[REG_CLK_BYP_NUM];
+	uint32_t clkdiv_saved_regs[REG_CLK_DIV_NUM];
+	uint32_t g2_clkdiv_saved_regs[REG_CLK_G2_DIV_NUM];
+	uint32_t pll_g2_csr_saved_regs[REG_PLL_G2_CSR_NUM];
+	uint32_t a0pll_ssc_syn_set_saved_reg;
+	uint32_t disppll_ssc_syn_set_saved_reg;
+	uint32_t cam0pll_ssc_syn_set_saved_reg;
+	uint32_t cam1pll_ssc_syn_set_saved_reg;
+	uint32_t pll_g6_csr_saved_regs[REG_PLL_G6_CSR_NUM];
+#endif /* CONFIG_PM_SLEEP */
+};
+
+struct cv181x_gate {
+	u32		reg;
+	s8		shift;
+	unsigned long	flags;
+};
+
+struct cv181x_div {
+	u32		reg;
+	s8		shift;
+	s8		width;
+	s16		initval;
+	unsigned long	flags;
+};
+
+struct cv181x_mux {
+	u32		reg;
+	s8		shift;
+	s8		width;
+	unsigned long	flags;
+};
+
+struct cv181x_hw_clock {
+	unsigned int id;
+	const char *name;
+	struct clk_hw hw;
+	void __iomem *base;
+	spinlock_t *lock;
+
+	struct cv181x_gate gate;
+	struct cv181x_div div[2]; /* 0: DIV_IN0, 1: DIV_IN1 */
+	struct cv181x_mux mux[3]; /* 0: bypass, 1: CLK_SEL, 2: CLK_SRC(DIV_IN0_SRC_MUX) */
+};
+
+struct cv181x_pll_clock {
+	unsigned int	id;
+	const char	*name;
+	u32		reg_csr;
+	u32		reg_ssc;
+	s16		post_div_sel; /* -1: postdiv*/
+	unsigned long	flags;
+};
+
+struct cv181x_pll_hw_clock {
+	struct cv181x_pll_clock pll;
+	void __iomem *base;
+	spinlock_t *lock;
+	struct clk_hw hw;
+};
+
+static const struct clk_ops cv181x_g6_pll_ops;
+static const struct clk_ops cv181x_g2_pll_ops;
+static const struct clk_ops cv181x_g2d_pll_ops;
+static const struct clk_ops cv181x_clk_ops;
+
+static struct cv181x_clock_data *clk_data;
+
+static unsigned long cvi_clk_flags;
+
+#define CV181X_CLK(_id, _name, _parents, _gate_reg, _gate_shift,		\
+			_div_0_reg, _div_0_shift,			\
+			_div_0_width, _div_0_initval,			\
+			_div_1_reg, _div_1_shift,			\
+			_div_1_width, _div_1_initval,			\
+			_mux_0_reg, _mux_0_shift,			\
+			_mux_1_reg, _mux_1_shift,			\
+			_mux_2_reg, _mux_2_shift, _flags) {		\
+		.id = _id,						\
+		.name = _name,						\
+		.gate.reg = _gate_reg,					\
+		.gate.shift = _gate_shift,				\
+		.div[0].reg = _div_0_reg,				\
+		.div[0].shift = _div_0_shift,				\
+		.div[0].width = _div_0_width,				\
+		.div[0].initval = _div_0_initval,			\
+		.div[1].reg = _div_1_reg,				\
+		.div[1].shift = _div_1_shift,				\
+		.div[1].width = _div_1_width,				\
+		.div[1].initval = _div_1_initval,			\
+		.mux[0].reg = _mux_0_reg,				\
+		.mux[0].shift = _mux_0_shift,				\
+		.mux[0].width = 1,					\
+		.mux[1].reg = _mux_1_reg,				\
+		.mux[1].shift = _mux_1_shift,				\
+		.mux[1].width = 1,					\
+		.mux[2].reg = _mux_2_reg,				\
+		.mux[2].shift = _mux_2_shift,				\
+		.mux[2].width = 2,					\
+		.hw.init = CLK_HW_INIT_PARENTS(				\
+				_name, _parents,			\
+				&cv181x_clk_ops,				\
+				_flags | CV181X_CLK_FLAGS_ALL),		\
+	}
+
+
+#define CLK_G6_PLL(_id, _name, _parent, _reg_csr, _flags) {		\
+		.pll.id = _id,						\
+		.pll.name = _name,					\
+		.pll.reg_csr = _reg_csr,				\
+		.pll.reg_ssc = 0,					\
+		.pll.post_div_sel = -1,					\
+		.hw.init = CLK_HW_INIT_PARENTS(_name, _parent,		\
+					       &cv181x_g6_pll_ops,	\
+					       _flags |			\
+					       CV181X_CLK_FLAGS_ALL),	\
+	}
+
+#define CLK_G2_PLL(_id, _name, _parent, _reg_csr, _reg_ssc, _flags) {	\
+		.pll.id = _id,						\
+		.pll.name = _name,					\
+		.pll.reg_csr = _reg_csr,				\
+		.pll.reg_ssc = _reg_ssc,				\
+		.pll.post_div_sel = -1,					\
+		.hw.init = CLK_HW_INIT_PARENTS(_name, _parent,		\
+					       &cv181x_g2_pll_ops,	\
+					       _flags |			\
+					       CV181X_CLK_FLAGS_ALL),	\
+	}
+
+#define CLK_G2D_PLL(_id, _name, _parent, _reg_csr, _reg_ssc,		\
+			_post_div_sel, _flags) {			\
+		.pll.id = _id,						\
+		.pll.name = _name,					\
+		.pll.reg_csr = _reg_csr,				\
+		.pll.reg_ssc = _reg_ssc,				\
+		.pll.post_div_sel = _post_div_sel,			\
+		.hw.init = CLK_HW_INIT_PARENTS(_name, _parent,		\
+					       &cv181x_g2d_pll_ops,	\
+					       _flags |			\
+					       CV181X_CLK_FLAGS_ALL),	\
+	}
+
+const char *const cv181x_pll_parent[] = {"osc"};
+const char *const cv181x_frac_pll_parent[] = {"clk_mipimpll"};
+
+/*
+ * All PLL clocks are marked as CRITICAL, hence they are very crucial
+ * for the functioning of the SoC
+ */
+static struct cv181x_pll_hw_clock cv181x_pll_clks[] = {
+	CLK_G6_PLL(CV181X_CLK_MPLL, "clk_mpll", cv181x_pll_parent, REG_MPLL_CSR, 0),
+	CLK_G6_PLL(CV181X_CLK_TPLL, "clk_tpll", cv181x_pll_parent, REG_TPLL_CSR, 0),
+	CLK_G6_PLL(CV181X_CLK_FPLL, "clk_fpll", cv181x_pll_parent, REG_FPLL_CSR, 0),
+	CLK_G2_PLL(CV181X_CLK_MIPIMPLL, "clk_mipimpll", cv181x_pll_parent, REG_MIPIMPLL_CSR, 0, 0),
+	CLK_G2_PLL(CV181X_CLK_A0PLL, "clk_a0pll", cv181x_frac_pll_parent, REG_APLL0_CSR, REG_APLL_SSC_SYN_CTRL, 0),
+	CLK_G2_PLL(CV181X_CLK_DISPPLL, "clk_disppll", cv181x_frac_pll_parent, REG_DISPPLL_CSR,
+			REG_DISPPLL_SSC_SYN_CTRL, 0),
+	CLK_G2_PLL(CV181X_CLK_CAM0PLL, "clk_cam0pll", cv181x_frac_pll_parent, REG_CAM0PLL_CSR, REG_CAM0PLL_SSC_SYN_CTRL,
+		CLK_IGNORE_UNUSED),
+	CLK_G2_PLL(CV181X_CLK_CAM1PLL, "clk_cam1pll", cv181x_frac_pll_parent, REG_CAM1PLL_CSR,
+			REG_CAM1PLL_SSC_SYN_CTRL, 0),
+	CLK_G2D_PLL(CV181X_CLK_MIPIMPLL_D3, "clk_mipimpll_d3", cv181x_pll_parent, REG_MIPIMPLL_CSR,
+		0, 3, CLK_IGNORE_UNUSED),
+	CLK_G2D_PLL(CV181X_CLK_CAM0PLL_D2, "clk_cam0pll_d2", cv181x_frac_pll_parent, REG_CAM0PLL_CSR,
+		REG_CAM0PLL_SSC_SYN_CTRL, 2, CLK_IGNORE_UNUSED),
+	CLK_G2D_PLL(CV181X_CLK_CAM0PLL_D3, "clk_cam0pll_d3", cv181x_frac_pll_parent, REG_CAM0PLL_CSR,
+		REG_CAM0PLL_SSC_SYN_CTRL, 3, CLK_IGNORE_UNUSED),
+};
+
+/*
+ * Clocks marked as CRITICAL are needed for the proper functioning
+ * of the SoC.
+ */
+static struct cv181x_hw_clock cv181x_clks[] = {
+	CV181X_CLK(CV181X_CLK_A53, "clk_a53",
+		((const char *[]) {"osc", "clk_fpll", "clk_tpll", "clk_a0pll", "clk_mipimpll", "clk_mpll"}),
+		REG_CLK_EN_0, 0,
+		REG_DIV_CLK_A53_0, 16, 4, 1,
+		REG_DIV_CLK_A53_1, 16, 4, 2,
+		REG_CLK_BYP_0, 0,
+		REG_CLK_SEL_0, 0,
+		REG_DIV_CLK_A53_0, 8,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_CPU_AXI0, "clk_cpu_axi0",
+		((const char *[]) {"osc", "clk_fpll", "clk_disppll"}),
+		REG_CLK_EN_0, 1,
+		REG_DIV_CLK_CPU_AXI0, 16, 4, 3,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 1,
+		0, -1,
+		REG_DIV_CLK_CPU_AXI0, 8,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_CPU_GIC, "clk_cpu_gic",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_0, 2,
+		REG_DIV_CLK_CPU_GIC, 16, 4, 5,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 2,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_XTAL_A53, "clk_xtal_a53",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_0, 3,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_TPU, "clk_tpu",
+		((const char *[]) {"osc", "clk_tpll", "clk_a0pll", "clk_mipimpll", "clk_fpll"}),
+		REG_CLK_EN_0, 4,
+		REG_DIV_CLK_TPU, 16, 4, 3,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 3,
+		0, -1,
+		REG_DIV_CLK_TPU, 8,
+		0),
+	CV181X_CLK(CV181X_CLK_TPU_FAB, "clk_tpu_fab",
+		((const char *[]) {"osc", "clk_mipimpll"}),
+		REG_CLK_EN_0, 5,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 4,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_AHB_ROM, "clk_ahb_rom",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_0, 6,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_DDR_AXI_REG, "clk_ddr_axi_reg",
+		((const char *[]) {"clk_axi6"}),
+		REG_CLK_EN_0, 7,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_RTC_25M, "clk_rtc_25m",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_0, 8,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_TEMPSEN, "clk_tempsen",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_0, 9,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_SARADC, "clk_saradc",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_0, 10,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_EFUSE, "clk_efuse",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_0, 11,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_APB_EFUSE, "clk_apb_efuse",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_0, 12,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_DEBUG, "clk_debug",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_0, 13,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_XTAL_MISC, "clk_xtal_misc",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_0, 14,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_AXI4_EMMC, "clk_axi4_emmc",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_0, 15,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_EMMC, "clk_emmc",
+		((const char *[]) {"osc", "clk_fpll", "clk_disppll"}),
+		REG_CLK_EN_0, 16,
+		REG_DIV_CLK_EMMC, 16, 5, 15,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 5,
+		0, -1,
+		REG_DIV_CLK_EMMC, 8,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_100K_EMMC, "clk_100k_emmc",
+		((const char *[]) {"clk_1m"}),
+		REG_CLK_EN_0, 17,
+		REG_DIV_CLK_100K_EMMC, 16, 8, 10,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_AXI4_SD0, "clk_axi4_sd0",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_0, 18,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_SD0, "clk_sd0",
+		((const char *[]) {"osc", "clk_fpll", "clk_disppll"}),
+		REG_CLK_EN_0, 19,
+		REG_DIV_CLK_SD0, 16, 5, 15,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 6,
+		0, -1,
+		REG_DIV_CLK_SD0, 8,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_100K_SD0, "clk_100k_sd0",
+		((const char *[]) {"clk_1m"}),
+		REG_CLK_EN_0, 20,
+		REG_DIV_CLK_100K_SD0, 16, 8, 10,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_AXI4_SD1, "clk_axi4_sd1",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_0, 21,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_SD1, "clk_sd1",
+		((const char *[]) {"osc", "clk_fpll", "clk_disppll"}),
+		REG_CLK_EN_0, 22,
+		REG_DIV_CLK_SD1, 16, 5, 15,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 7,
+		0, -1,
+		REG_DIV_CLK_SD1, 8,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_100K_SD1, "clk_100k_sd1",
+		((const char *[]) {"clk_1m"}),
+		REG_CLK_EN_0, 23,
+		REG_DIV_CLK_100K_SD1, 16, 8, 10,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_SPI_NAND, "clk_spi_nand",
+		((const char *[]) {"osc", "clk_fpll", "clk_disppll"}),
+		REG_CLK_EN_0, 24,
+		REG_DIV_CLK_SPI_NAND, 16, 5, 8,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 8,
+		0, -1,
+		REG_DIV_CLK_SPI_NAND, 8,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_500M_ETH0, "clk_500m_eth0",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_0, 25,
+		REG_DIV_CLK_500M_ETH0, 16, 4, 3,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 9,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_AXI4_ETH0, "clk_axi4_eth0",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_0, 26,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_500M_ETH1, "clk_500m_eth1",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_0, 27,
+		REG_DIV_CLK_500M_ETH1, 16, 4, 3,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 10,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_AXI4_ETH1, "clk_axi4_eth1",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_0, 28,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_GPIO, "clk_apb_gpio",
+		((const char *[]) {"clk_axi6"}),
+		REG_CLK_EN_0, 29,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_GPIO_INTR, "clk_apb_gpio_intr",
+		((const char *[]) {"clk_axi6"}),
+		REG_CLK_EN_0, 30,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_GPIO_DB, "clk_gpio_db",
+		((const char *[]) {"clk_1m"}),
+		REG_CLK_EN_0, 31,
+		REG_DIV_CLK_GPIO_DB, 16, 16, 10,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_AHB_SF, "clk_ahb_sf",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 0,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_SDMA_AXI, "clk_sdma_axi",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 1,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_SDMA_AUD0, "clk_sdma_aud0",
+		((const char *[]) {"osc", "clk_a0pll", "a24k_clk"}),
+		REG_CLK_EN_1, 2,
+		REG_DIV_CLK_SDMA_AUD0, 16, 8, 18,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 11,
+		0, -1,
+		REG_DIV_CLK_SDMA_AUD0, 8,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_SDMA_AUD1, "clk_sdma_aud1",
+		((const char *[]) {"osc", "clk_a0pll", "a24k_clk"}),
+		REG_CLK_EN_1, 3,
+		REG_DIV_CLK_SDMA_AUD1, 16, 8, 18,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 12,
+		0, -1,
+		REG_DIV_CLK_SDMA_AUD1, 8,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_SDMA_AUD2, "clk_sdma_aud2",
+		((const char *[]) {"osc", "clk_a0pll", "a24k_clk"}),
+		REG_CLK_EN_1, 4,
+		REG_DIV_CLK_SDMA_AUD2, 16, 8, 18,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 13,
+		0, -1,
+		REG_DIV_CLK_SDMA_AUD2, 8,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_SDMA_AUD3, "clk_sdma_aud3",
+		((const char *[]) {"osc", "clk_a0pll", "a24k_clk"}),
+		REG_CLK_EN_1, 5,
+		REG_DIV_CLK_SDMA_AUD3, 16, 8, 18,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 14,
+		0, -1,
+		REG_DIV_CLK_SDMA_AUD3, 8,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_I2C, "clk_apb_i2c",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 6,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_WDT, "clk_apb_wdt",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_1, 7,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_PWM, "clk_pwm",
+		((const char *[]) {"clk_pwm_src"}),
+		REG_CLK_EN_1, 8,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_SPI0, "clk_apb_spi0",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 9,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_SPI1, "clk_apb_spi1",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 10,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_SPI2, "clk_apb_spi2",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 11,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_SPI3, "clk_apb_spi3",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 12,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_CAM0_200, "clk_cam0_200",
+		((const char *[]) {"osc", "osc", "clk_disppll"}),
+		REG_CLK_EN_1, 13,
+		REG_DIV_CLK_CAM0_200, 16, 4, 1,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 16,
+		0, -1,
+		REG_DIV_CLK_CAM0_200, 8,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_UART0, "clk_uart0",
+		((const char *[]) {"clk_cam0_200"}),
+		REG_CLK_EN_1, 14,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_UART0, "clk_apb_uart0",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 15,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_UART1, "clk_uart1",
+		((const char *[]) {"clk_cam0_200"}),
+		REG_CLK_EN_1, 16,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_UART1, "clk_apb_uart1",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 17,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_UART2, "clk_uart2",
+		((const char *[]) {"clk_cam0_200"}),
+		REG_CLK_EN_1, 18,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_UART2, "clk_apb_uart2",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 19,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_UART3, "clk_uart3",
+		((const char *[]) {"clk_cam0_200"}),
+		REG_CLK_EN_1, 20,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_UART3, "clk_apb_uart3",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 21,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_UART4, "clk_uart4",
+		((const char *[]) {"clk_cam0_200"}),
+		REG_CLK_EN_1, 22,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_UART4, "clk_apb_uart4",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 23,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_I2S0, "clk_apb_i2s0",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 24,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_I2S1, "clk_apb_i2s1",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 25,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_I2S2, "clk_apb_i2s2",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 26,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_I2S3, "clk_apb_i2s3",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 27,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_AXI4_USB, "clk_axi4_usb",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 28,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_APB_USB, "clk_apb_usb",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_1, 29,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_125M_USB, "clk_125m_usb",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_1, 30,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 17,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_33K_USB, "clk_33k_usb",
+		((const char *[]) {"clk_1m"}),
+		REG_CLK_EN_1, 31,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_12M_USB, "clk_12m_usb",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_2, 0,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 18,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_AXI4, "clk_axi4",
+		((const char *[]) {"osc", "clk_fpll", "clk_disppll"}),
+		REG_CLK_EN_2, 1,
+		REG_DIV_CLK_AXI4, 16, 4, 5,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 19,
+		0, -1,
+		REG_DIV_CLK_AXI4, 8,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_AXI6, "clk_axi6",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_2, 2,
+		REG_DIV_CLK_AXI6, 16, 4, 15,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 20,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_DSI_ESC, "clk_dsi_esc",
+		((const char *[]) {"osc", "clk_axi6"}),
+		REG_CLK_EN_2, 3,
+		REG_DIV_CLK_DSI_ESC, 16, 4, 5,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 21,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_AXI_VIP, "clk_axi_vip",
+		((const char *[]) {"osc", "clk_mipimpll", "clk_cam0pll", "clk_disppll", "clk_fpll"}),
+		REG_CLK_EN_2, 4,
+		REG_DIV_CLK_AXI_VIP, 16, 4, 3,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 22,
+		0, -1,
+		REG_DIV_CLK_AXI_VIP, 8,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_SRC_VIP_SYS_0, "clk_src_vip_sys_0",
+		((const char *[]) {"osc", "clk_mipimpll", "clk_cam0pll", "clk_disppll", "clk_fpll"}),
+		REG_CLK_EN_2, 5,
+		REG_DIV_CLK_SRC_VIP_SYS_0, 16, 4, 6,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 23,
+		0, -1,
+		REG_DIV_CLK_SRC_VIP_SYS_0, 8,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_SRC_VIP_SYS_1, "clk_src_vip_sys_1",
+		((const char *[]) {"osc", "clk_mipimpll", "clk_cam0pll", "clk_disppll", "clk_fpll"}),
+		REG_CLK_EN_2, 6,
+		REG_DIV_CLK_SRC_VIP_SYS_1, 16, 4, 5,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 24,
+		0, -1,
+		REG_DIV_CLK_SRC_VIP_SYS_1, 8,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_DISP_SRC_VIP, "clk_disp_src_vip",
+		((const char *[]) {"osc", "clk_disppll"}),
+		REG_CLK_EN_2, 7,
+		REG_DIV_CLK_DISP_SRC_VIP, 16, 4, 8,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 25,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_AXI_VIDEO_CODEC, "clk_axi_video_codec",
+		((const char *[]) {"osc", "clk_a0pll", "clk_mipimpll", "clk_cam1pll", "clk_fpll"}),
+		REG_CLK_EN_2, 8,
+		REG_DIV_CLK_AXI_VIDEO_CODEC, 16, 4, 2,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 26,
+		0, -1,
+		REG_DIV_CLK_AXI_VIDEO_CODEC, 8,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_VC_SRC0, "clk_vc_src0",
+		((const char *[]) {"osc", "clk_disppll", "clk_mipimpll", "clk_cam1pll", "clk_fpll"}),
+		REG_CLK_EN_2, 9,
+		REG_DIV_CLK_VC_SRC0, 16, 4, 2,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 27,
+		0, -1,
+		REG_DIV_CLK_VC_SRC0, 8,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_H264C, "clk_h264c",
+		((const char *[]) {"clk_axi_video_codec"}),
+		REG_CLK_EN_2, 10,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_H265C, "clk_h265c",
+		((const char *[]) {"clk_axi_video_codec"}),
+		REG_CLK_EN_2, 11,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_JPEG, "clk_jpeg",
+		((const char *[]) {"clk_axi_video_codec"}),
+		REG_CLK_EN_2, 12,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_APB_JPEG, "clk_apb_jpeg",
+		((const char *[]) {"clk_axi6"}),
+		REG_CLK_EN_2, 13,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_APB_H264C, "clk_apb_h264c",
+		((const char *[]) {"clk_axi6"}),
+		REG_CLK_EN_2, 14,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_APB_H265C, "clk_apb_h265c",
+		((const char *[]) {"clk_axi6"}),
+		REG_CLK_EN_2, 15,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_CAM0, "clk_cam0",
+		((const char *[]) {"clk_cam0pll", "clk_cam0pll_d2", "clk_cam0pll_d3", "clk_mipimpll_d3"}),
+		REG_CLK_EN_2, 16,
+		REG_CLK_CAM0_SRC_DIV, 16, 6, -1,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		REG_CLK_CAM0_SRC_DIV, 8,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_CAM1, "clk_cam1",
+		((const char *[]) {"clk_cam0pll", "clk_cam0pll_d2", "clk_cam0pll_d3", "clk_mipimpll_d3"}),
+		REG_CLK_EN_2, 17,
+		REG_CLK_CAM1_SRC_DIV, 16, 6, -1,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		REG_CLK_CAM1_SRC_DIV, 8,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_CSI_MAC0_VIP, "clk_csi_mac0_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 18,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_CSI_MAC1_VIP, "clk_csi_mac1_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 19,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_ISP_TOP_VIP, "clk_isp_top_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 20,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_IMG_D_VIP, "clk_img_d_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 21,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_IMG_V_VIP, "clk_img_v_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 22,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_SC_TOP_VIP, "clk_sc_top_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 23,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_SC_D_VIP, "clk_sc_d_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 24,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_SC_V1_VIP, "clk_sc_v1_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 25,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_SC_V2_VIP, "clk_sc_v2_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 26,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_SC_V3_VIP, "clk_sc_v3_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 27,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_DWA_VIP, "clk_dwa_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 28,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_BT_VIP, "clk_bt_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 29,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_DISP_VIP, "clk_disp_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 30,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_DSI_MAC_VIP, "clk_dsi_mac_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_2, 31,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_LVDS0_VIP, "clk_lvds0_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_3, 0,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_LVDS1_VIP, "clk_lvds1_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_3, 1,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_CSI0_RX_VIP, "clk_csi0_rx_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_3, 2,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_CSI1_RX_VIP, "clk_csi1_rx_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_3, 3,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_PAD_VI_VIP, "clk_pad_vi_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_3, 4,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_1M, "clk_1m",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_3, 5,
+		REG_DIV_CLK_1M, 16, 6, 25,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_SPI, "clk_spi",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_3, 6,
+		REG_DIV_CLK_SPI, 16, 6, 8,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 30,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_I2C, "clk_i2c",
+		((const char *[]) {"osc", "clk_axi6"}),
+		REG_CLK_EN_3, 7,
+		REG_DIV_CLK_I2C, 16, 4, 1,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 31,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_PM, "clk_pm",
+		((const char *[]) {"clk_axi6"}),
+		REG_CLK_EN_3, 8,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_TIMER0, "clk_timer0",
+		((const char *[]) {"clk_xtal_misc"}),
+		REG_CLK_EN_3, 9,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_TIMER1, "clk_timer1",
+		((const char *[]) {"clk_xtal_misc"}),
+		REG_CLK_EN_3, 10,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_TIMER2, "clk_timer2",
+		((const char *[]) {"clk_xtal_misc"}),
+		REG_CLK_EN_3, 11,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_TIMER3, "clk_timer3",
+		((const char *[]) {"clk_xtal_misc"}),
+		REG_CLK_EN_3, 12,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_TIMER4, "clk_timer4",
+		((const char *[]) {"clk_xtal_misc"}),
+		REG_CLK_EN_3, 13,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_TIMER5, "clk_timer5",
+		((const char *[]) {"clk_xtal_misc"}),
+		REG_CLK_EN_3, 14,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_TIMER6, "clk_timer6",
+		((const char *[]) {"clk_xtal_misc"}),
+		REG_CLK_EN_3, 15,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_TIMER7, "clk_timer7",
+		((const char *[]) {"clk_xtal_misc"}),
+		REG_CLK_EN_3, 16,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_I2C0, "clk_apb_i2c0",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_3, 17,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_I2C1, "clk_apb_i2c1",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_3, 18,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_I2C2, "clk_apb_i2c2",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_3, 19,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_I2C3, "clk_apb_i2c3",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_3, 20,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_I2C4, "clk_apb_i2c4",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_3, 21,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_WGN, "clk_wgn",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_3, 22,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_WGN0, "clk_wgn0",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_3, 23,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_WGN1, "clk_wgn1",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_3, 24,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_WGN2, "clk_wgn2",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_3, 25,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_KEYSCAN, "clk_keyscan",
+		((const char *[]) {"osc"}),
+		REG_CLK_EN_3, 26,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_AHB_SF1, "clk_ahb_sf1",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_3, 27,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_VC_SRC1, "clk_vc_src1",
+		((const char *[]) {"osc", "clk_cam1pll"}),
+		REG_CLK_EN_3, 28,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		REG_CLK_BYP_1, 0,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_SRC_VIP_SYS_2, "clk_src_vip_sys_2",
+		((const char *[]) {"osc", "clk_mipimpll", "clk_cam0pll", "clk_disppll", "clk_fpll"}),
+		REG_CLK_EN_3, 29,
+		REG_DIV_CLK_SRC_VIP_SYS_2, 16, 4, 2,
+		0, -1, 0, 0,
+		REG_CLK_BYP_1, 1,
+		0, -1,
+		REG_DIV_CLK_SRC_VIP_SYS_2, 8,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_PAD_VI1_VIP, "clk_pad_vi1_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_3, 30,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_CFG_REG_VIP, "clk_cfg_reg_vip",
+		((const char *[]) {"clk_axi6"}),
+		REG_CLK_EN_3, 31,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_CFG_REG_VC, "clk_cfg_reg_vc",
+		((const char *[]) {"clk_axi6"}),
+		REG_CLK_EN_4, 0,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_AUDSRC, "clk_audsrc",
+		((const char *[]) {"osc", "clk_a0pll", "a24k_clk"}),
+		REG_CLK_EN_4, 1,
+		REG_DIV_CLK_AUDSRC, 16, 8, 18,
+		0, -1, 0, 0,
+		REG_CLK_BYP_1, 2,
+		0, -1,
+		REG_DIV_CLK_AUDSRC, 8,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_APB_AUDSRC, "clk_apb_audsrc",
+		((const char *[]) {"clk_axi4"}),
+		REG_CLK_EN_4, 2,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_VC_SRC2, "clk_vc_src2",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_4, 3,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		REG_CLK_BYP_1, 3,
+		0, -1,
+		0, -1,
+		0),
+	CV181X_CLK(CV181X_CLK_PWM_SRC, "clk_pwm_src",
+		((const char *[]) {"osc", "clk_fpll", "clk_disppll"}),
+		REG_CLK_EN_4, 4,
+		REG_DIV_CLK_PWM_SRC_0, 16, 6, 10,
+		0, -1, 0, 0,
+		REG_CLK_BYP_0, 15,
+		0, -1,
+		REG_DIV_CLK_PWM_SRC_0, 8,
+		0),
+	CV181X_CLK(CV181X_CLK_AP_DEBUG, "clk_ap_debug",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_4, 5,
+		REG_DIV_CLK_AP_DEBUG, 16, 4, 5,
+		0, -1, 0, 0,
+		REG_CLK_BYP_1, 4,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_SRC_RTC_SYS_0, "clk_src_rtc_sys_0",
+		((const char *[]) {"osc", "clk_fpll"}),
+		REG_CLK_EN_4, 6,
+		REG_DIV_CLK_RTCSYS_SRC_0, 16, 4, 5,
+		0, -1, 0, 0,
+		REG_CLK_BYP_1, 5,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_PAD_VI2_VIP, "clk_pad_vi2_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 7,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_CSI_BE_VIP, "clk_csi_be_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 8,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_VIP_IP0, "clk_vip_ip0",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 9,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_VIP_IP1, "clk_vip_ip1",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 10,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_VIP_IP2, "clk_vip_ip2",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 11,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_VIP_IP3, "clk_vip_ip3",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 12,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_C906_0, "clk_c906_0",
+		((const char *[]) {"osc", "clk_fpll", "clk_tpll", "clk_a0pll", "clk_mipimpll", "clk_mpll"}),
+		REG_CLK_EN_4, 13,
+		REG_DIV_CLK_C906_0_0, 16, 4, 1,
+		REG_DIV_CLK_C906_0_1, 16, 4, 2,
+		REG_CLK_BYP_1, 6,
+		REG_CLK_SEL_0, 23,
+		REG_DIV_CLK_C906_0_0, 8,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_C906_1, "clk_c906_1",
+		((const char *[]) {"osc", "clk_fpll", "clk_tpll", "clk_a0pll", "clk_disppll", "clk_mpll"}),
+		REG_CLK_EN_4, 14,
+		REG_DIV_CLK_C906_1_0, 16, 4, 2,
+		REG_DIV_CLK_C906_1_1, 16, 4, 2,
+		REG_CLK_BYP_1, 7,
+		REG_CLK_SEL_0, 24,
+		REG_DIV_CLK_C906_1_0, 8,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_SRC_VIP_SYS_3, "clk_src_vip_sys_3",
+		((const char *[]) {"osc", "clk_mipimpll", "clk_cam0pll", "clk_disppll", "clk_fpll"}),
+		REG_CLK_EN_4, 15,
+		REG_DIV_CLK_SRC_VIP_SYS_3, 16, 4, 2,
+		0, -1, 0, 0,
+		REG_CLK_BYP_1, 8,
+		0, -1,
+		REG_DIV_CLK_SRC_VIP_SYS_3, 8,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_SRC_VIP_SYS_4, "clk_src_vip_sys_4",
+		((const char *[]) {"osc", "clk_mipimpll", "clk_cam0pll", "clk_disppll", "clk_fpll"}),
+		REG_CLK_EN_4, 16,
+		REG_DIV_CLK_SRC_VIP_SYS_4, 16, 4, 3,
+		0, -1, 0, 0,
+		REG_CLK_BYP_1, 9,
+		0, -1,
+		REG_DIV_CLK_SRC_VIP_SYS_4, 8,
+		0),
+	CV181X_CLK(CV181X_CLK_IVE_VIP, "clk_ive_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 17,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_RAW_VIP, "clk_raw_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 18,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_OSDC_VIP, "clk_osdc_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 19,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+	CV181X_CLK(CV181X_CLK_CSI_MAC2_VIP, "clk_csi_mac2_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 20,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IGNORE_UNUSED),
+	CV181X_CLK(CV181X_CLK_CAM0_VIP, "clk_cam0_vip",
+		((const char *[]) {"clk_axi_vip"}),
+		REG_CLK_EN_4, 21,
+		0, -1, 0, 0,
+		0, -1, 0, 0,
+		0, -1,
+		0, -1,
+		0, -1,
+		CLK_IS_CRITICAL),
+};
+
+static int __init cvi_clk_flags_setup(char *arg)
+{
+	int ret;
+	unsigned long flags;
+
+	ret = kstrtol(arg, 0, &flags);
+	if (ret)
+		return ret;
+
+	cvi_clk_flags = flags;
+	pr_info("cvi_clk_flags = 0x%lX\n", cvi_clk_flags);
+
+	return 1;
+}
+__setup("cvi_clk_flags=", cvi_clk_flags_setup);
+
+static unsigned long cv181x_pll_rate_calc(u32 regval, s16 post_div_sel, unsigned long parent_rate)
+{
+	u64 numerator;
+	u32 predivsel, postdivsel, divsel;
+	u32 denominator;
+
+	predivsel = regval & 0x7f;
+	postdivsel = post_div_sel < 0 ? (regval >> 8) & 0x7f : (u32)post_div_sel;
+	divsel = (regval >> 17) & 0x7f;
+
+	numerator = parent_rate * divsel;
+	denominator = predivsel * postdivsel;
+	do_div(numerator, denominator);
+
+	return (unsigned long)numerator;
+}
+
+static unsigned long cv181x_g6_pll_recalc_rate(struct clk_hw *hw,
+					       unsigned long parent_rate)
+{
+	struct cv181x_pll_hw_clock *pll_hw = to_cv181x_pll_clk(hw);
+	unsigned long rate;
+	u32 regval;
+
+	regval = readl(pll_hw->base + pll_hw->pll.reg_csr);
+	rate = cv181x_pll_rate_calc(regval, pll_hw->pll.post_div_sel, parent_rate);
+
+	return rate;
+}
+
+static long cv181x_g6_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+				     unsigned long *prate)
+{
+	return rate;
+}
+
+static int cv181x_g6_pll_calc_csr(unsigned long parent_rate, unsigned long rate, u32 *csr)
+{
+	u64 numerator;
+	u32 denominator;
+	u32 divsel;		/* [23:17] DIV_SEL */
+	u32 postdivsel = 1;	/* [14:8] POST_DIV_SEL */
+	u32 ictrl = 7;		/* [26:24] ICTRL */
+	u32 selmode = 1;	/* [16:15] SEL_MODE */
+	u32 predivsel = 1;	/* [6:0] PRE_DIV_SEL */
+	u32 vco_clks[] = {900, 1000, 1100, 1200, 1300, 1400, 1500, 1600};
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(vco_clks); i++) {
+		if ((vco_clks[i] * 1000000) % rate == 0) {
+			postdivsel = vco_clks[i] * 1000000 / rate;
+			rate = vco_clks[i] * 1000000;
+			pr_debug("rate=%ld, postdivsel=%d\n", rate, postdivsel);
+			break;
+		}
+	}
+
+	numerator = rate;
+	denominator = parent_rate;
+
+	do_div(numerator, denominator);
+
+	divsel = (u32)numerator & 0x7f;
+	*csr = (divsel << 17) | (postdivsel << 8) | (ictrl << 24) | (selmode << 15) | predivsel;
+
+	pr_debug("csr=0x%08x\n", *csr);
+
+	return 0;
+}
+
+static int cv181x_g6_pll_set_rate(struct clk_hw *hw, unsigned long rate,
+				  unsigned long parent_rate)
+{
+	struct cv181x_pll_hw_clock *pll_hw = to_cv181x_pll_clk(hw);
+	unsigned long flags = 0;
+	int ret;
+	u32 reg_g6_pll_status;
+	u32 regval_csr;
+	u32 regval_g6_pll_status;
+	u32 g6_pll_update_status = 0;
+	ktime_t timeout;
+
+	reg_g6_pll_status = (pll_hw->pll.reg_csr & ~PLL_STATUS_MASK) + PLL_STATUS_OFFSET;
+
+	if (pll_hw->lock)
+		spin_lock_irqsave(pll_hw->lock, flags);
+	else
+		__acquire(pll_hw->lock);
+
+	/* calculate csr register */
+	ret = cv181x_g6_pll_calc_csr(parent_rate, rate, &regval_csr);
+	if (ret < 0)
+		return ret;
+
+	/* csr register */
+	writel(regval_csr, pll_hw->base + pll_hw->pll.reg_csr);
+
+	if (pll_hw->pll.reg_csr == REG_MPLL_CSR)
+		g6_pll_update_status = BIT(0);
+	else if (pll_hw->pll.reg_csr == REG_TPLL_CSR)
+		g6_pll_update_status = BIT(1);
+	else if (pll_hw->pll.reg_csr == REG_FPLL_CSR)
+		g6_pll_update_status = BIT(2);
+
+	/* wait for pll setting updated */
+	timeout = ktime_add_ms(ktime_get(), CV181X_PLL_LOCK_TIMEOUT_MS);
+	while (1) {
+		regval_g6_pll_status = readl(pll_hw->base + reg_g6_pll_status);
+		if ((regval_g6_pll_status & g6_pll_update_status) == 0)
+			break;
+
+		if (ktime_after(ktime_get(), timeout)) {
+			pr_err("timeout waiting for pll update, g6_pll_status = 0x%08x\n",
+			       regval_g6_pll_status);
+			break;
+		}
+		cpu_relax();
+	}
+
+	if (pll_hw->lock)
+		spin_unlock_irqrestore(pll_hw->lock, flags);
+	else
+		__release(pll_hw->lock);
+
+	return 0;
+}
+
+static const struct clk_ops cv181x_g6_pll_ops = {
+	.recalc_rate = cv181x_g6_pll_recalc_rate,
+	.round_rate = cv181x_g6_pll_round_rate,
+	.set_rate = cv181x_g6_pll_set_rate,
+};
+
+static unsigned long cv181x_g2_pll_recalc_rate(struct clk_hw *hw,
+					       unsigned long parent_rate)
+{
+	struct cv181x_pll_hw_clock *pll_hw = to_cv181x_pll_clk(hw);
+	u32 reg_ssc_set;
+	u32 reg_g2_ssc_ctrl;
+	u32 regval_csr;
+	u32 regval_ssc_set;
+	u32 regval_g2_ssc_ctrl;
+	u64 numerator;
+	u32 denominator;
+	unsigned long clk_ref;
+	unsigned long rate;
+
+	regval_csr = readl(pll_hw->base + pll_hw->pll.reg_csr);
+
+	/* pll without synthesizer */
+	if (pll_hw->pll.reg_ssc == 0) {
+		clk_ref = parent_rate;
+		goto rate_calc;
+	}
+
+	/* calculate synthesizer freq */
+	reg_ssc_set = (pll_hw->pll.reg_ssc & ~SSC_SYN_SET_MASK) + SSC_SYN_SET_OFFSET;
+	reg_g2_ssc_ctrl = (pll_hw->pll.reg_ssc & ~G2_SSC_CTRL_MASK) + G2_SSC_CTRL_OFFSET;
+
+	regval_ssc_set = readl(pll_hw->base + reg_ssc_set);
+	regval_g2_ssc_ctrl = readl(pll_hw->base + reg_g2_ssc_ctrl);
+
+	/* bit0 sel_syn_clk */
+	numerator = (regval_g2_ssc_ctrl & 0x1) ? parent_rate : (parent_rate >> 1);
+
+	numerator <<= 26;
+	denominator = regval_ssc_set;
+	if (denominator)
+		do_div(numerator, denominator);
+	else
+		pr_err("pll ssc_set is zero\n");
+
+	clk_ref = numerator;
+
+rate_calc:
+	rate = cv181x_pll_rate_calc(regval_csr, pll_hw->pll.post_div_sel, clk_ref);
+
+	return rate;
+}
+
+static const struct {
+	unsigned long rate;
+	u32 csr;
+	u32 ssc_set;
+} g2_pll_rate_lut[] = {
+	// {.rate = 48000000, .csr = 0x00129201, .ssc_set = 629145600},
+	// {.rate = 406425600, .csr = 0x010E9201, .ssc_set = 594430839},
+	// {.rate = 417792000, .csr = 0x01109201, .ssc_set = 642509804},
+	// {.rate = 768000000, .csr = 0x00108101, .ssc_set = 419430400},
+	// {.rate = 832000000, .csr = 0x00108101, .ssc_set = 387166523},
+	// {.rate = 1032000000, .csr = 0x00148101, .ssc_set = 390167814},
+	// {.rate = 1050000000, .csr = 0x00168101, .ssc_set = 421827145},
+	// {.rate = 1056000000, .csr = 0x00208100, .ssc_set = 412977625},
+	// {.rate = 1125000000, .csr = 0x00168101, .ssc_set = 393705325},
+	// {.rate = 1188000000, .csr = 0x00188101, .ssc_set = 610080582}, //postdiv=1
+	{.rate = 1188000000, .csr = 0x00308201, .ssc_set = 610080582}, //postdiv=2
+};
+
+static int cv181x_g2_pll_get_setting_from_lut(unsigned long rate, u32 *csr,
+					      u32 *ssc_set)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(g2_pll_rate_lut); i++) {
+		if (rate == g2_pll_rate_lut[i].rate) {
+			*csr = g2_pll_rate_lut[i].csr;
+			*ssc_set = g2_pll_rate_lut[i].ssc_set;
+			return 0;
+		}
+	}
+
+	*csr = 0;
+	*ssc_set = 0;
+	return -ENOENT;
+}
+
+static long cv181x_g2_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+				     unsigned long *prate)
+{
+	return rate;
+}
+
+static int cv181x_g2_pll_set_rate(struct clk_hw *hw, unsigned long rate,
+				  unsigned long parent_rate)
+{
+	struct cv181x_pll_hw_clock *pll_hw = to_cv181x_pll_clk(hw);
+	unsigned long flags = 0;
+	int ret;
+	u32 reg_ssc_set;
+	u32 reg_ssc_ctrl;
+	u32 reg_g2_pll_status;
+	u32 regval_csr;
+	u32 regval_ssc_set;
+	u32 regval_ssc_ctrl;
+	u32 regval_g2_pll_status;
+	u32 g2_pll_update_status = 0;
+	ktime_t timeout;
+
+	/* pll without synthesizer */
+	if (pll_hw->pll.reg_ssc == 0)
+		return -ENOENT;
+
+	ret = cv181x_g2_pll_get_setting_from_lut(rate, &regval_csr,
+						 &regval_ssc_set);
+	if (ret < 0)
+		return ret;
+
+	reg_ssc_set = (pll_hw->pll.reg_ssc & ~SSC_SYN_SET_MASK) + SSC_SYN_SET_OFFSET;
+	reg_ssc_ctrl = pll_hw->pll.reg_ssc;
+	reg_g2_pll_status = (pll_hw->pll.reg_csr & ~PLL_STATUS_MASK) + PLL_STATUS_OFFSET;
+
+	if (pll_hw->lock)
+		spin_lock_irqsave(pll_hw->lock, flags);
+	else
+		__acquire(pll_hw->lock);
+
+	/* set synthersizer */
+	writel(regval_ssc_set, pll_hw->base + reg_ssc_set);
+
+	/* bit 0 toggle */
+	regval_ssc_ctrl = readl(pll_hw->base + reg_ssc_ctrl);
+	regval_ssc_ctrl ^= 0x00000001;
+	writel(regval_ssc_ctrl, pll_hw->base + reg_ssc_ctrl);
+
+	/* csr register */
+	writel(regval_csr, pll_hw->base + pll_hw->pll.reg_csr);
+
+	if (pll_hw->pll.reg_csr == REG_MIPIMPLL_CSR)
+		g2_pll_update_status = BIT(0);
+	else if (pll_hw->pll.reg_csr == REG_APLL0_CSR)
+		g2_pll_update_status = BIT(1);
+	else if (pll_hw->pll.reg_csr == REG_DISPPLL_CSR)
+		g2_pll_update_status = BIT(2);
+	else if (pll_hw->pll.reg_csr == REG_CAM0PLL_CSR)
+		g2_pll_update_status = BIT(3);
+	else if (pll_hw->pll.reg_csr == REG_CAM1PLL_CSR)
+		g2_pll_update_status = BIT(4);
+
+	/* wait for pll setting updated */
+	timeout = ktime_add_ms(ktime_get(), CV181X_PLL_LOCK_TIMEOUT_MS);
+	while (1) {
+		regval_g2_pll_status = readl(pll_hw->base + reg_g2_pll_status);
+		if ((regval_g2_pll_status & g2_pll_update_status) == 0)
+			break;
+
+		if (ktime_after(ktime_get(), timeout)) {
+			pr_err("timeout waiting for pll update, g2_pll_status = 0x%08x\n",
+			       regval_g2_pll_status);
+			break;
+		}
+		cpu_relax();
+	}
+
+	if (pll_hw->lock)
+		spin_unlock_irqrestore(pll_hw->lock, flags);
+	else
+		__release(pll_hw->lock);
+
+	return 0;
+}
+
+static const struct clk_ops cv181x_g2_pll_ops = {
+	.recalc_rate = cv181x_g2_pll_recalc_rate,
+	.round_rate = cv181x_g2_pll_round_rate,
+	.set_rate = cv181x_g2_pll_set_rate,
+};
+
+static const struct clk_ops cv181x_g2d_pll_ops = {
+	.recalc_rate = cv181x_g2_pll_recalc_rate,
+};
+
+static struct clk_hw *cv181x_clk_register_pll(struct cv181x_pll_hw_clock *pll_clk,
+					    void __iomem *sys_base)
+{
+	struct clk_hw *hw;
+	struct clk_init_data init;
+	int err;
+
+	pll_clk->lock = &cv181x_clk_lock;
+	pll_clk->base = sys_base;
+
+	if (cvi_clk_flags) {
+		/* copy clk_init_data for modification */
+		memcpy(&init, pll_clk->hw.init, sizeof(init));
+
+		init.flags |= cvi_clk_flags;
+		pll_clk->hw.init = &init;
+	}
+
+	hw = &pll_clk->hw;
+
+	err = clk_hw_register(NULL, hw);
+	if (err)
+		return ERR_PTR(err);
+
+	return hw;
+}
+
+static void cv181x_clk_unregister_pll(struct clk_hw *hw)
+{
+	struct cv181x_pll_hw_clock *pll_hw = to_cv181x_pll_clk(hw);
+
+	clk_hw_unregister(hw);
+	kfree(pll_hw);
+}
+
+static int cv181x_clk_register_plls(struct cv181x_pll_hw_clock *clks,
+				    int num_clks,
+				    struct cv181x_clock_data *data)
+{
+	struct clk_hw *hw;
+	void __iomem *pll_base = data->base;
+	int i;
+
+	for (i = 0; i < num_clks; i++) {
+		struct cv181x_pll_hw_clock *cv181x_clk = &clks[i];
+
+		hw = cv181x_clk_register_pll(cv181x_clk, pll_base);
+		if (IS_ERR(hw)) {
+			pr_err("%s: failed to register clock %s\n",
+			       __func__, cv181x_clk->pll.name);
+			goto err_clk;
+		}
+
+		data->hw_data.hws[clks[i].pll.id] = hw;
+
+		clk_hw_register_clkdev(hw, cv181x_clk->pll.name, NULL);
+	}
+
+	return 0;
+
+err_clk:
+	while (i--)
+		cv181x_clk_unregister_pll(data->hw_data.hws[clks[i].pll.id]);
+
+	return PTR_ERR(hw);
+}
+
+static int cv181x_clk_is_bypassed(struct cv181x_hw_clock *clk_hw)
+{
+	u32 val;
+	void __iomem *reg_addr = clk_hw->base + clk_hw->mux[0].reg;
+
+	if (clk_hw->mux[0].shift >= 0) {
+		val = readl(reg_addr) >> clk_hw->mux[0].shift;
+		val &= 0x1; //width
+	} else {
+		val = 0;
+	}
+
+	return val;
+}
+
+static int cv181x_clk_get_clk_sel(struct cv181x_hw_clock *clk_hw)
+{
+	u32 val;
+	void __iomem *reg_addr = clk_hw->base + clk_hw->mux[1].reg;
+
+	if (clk_hw->mux[1].shift >= 0) {
+		val = readl(reg_addr) >> clk_hw->mux[1].shift;
+		val &= 0x1; //width
+		val ^= 0x1; //invert value
+	} else {
+		val = 0;
+	}
+
+	return val;
+}
+
+static int cv181x_clk_get_src_sel(struct cv181x_hw_clock *clk_hw)
+{
+	u32 val;
+	void __iomem *reg_addr = clk_hw->base + clk_hw->mux[2].reg;
+
+	if (clk_hw->mux[2].shift >= 0) {
+		val = readl(reg_addr) >> clk_hw->mux[2].shift;
+		val &= 0x3; //width
+	} else {
+		val = 0;
+	}
+
+	return val;
+}
+
+static unsigned long cv181x_clk_div_recalc_rate(struct clk_hw *hw,
+					      unsigned long parent_rate)
+{
+	struct cv181x_hw_clock *clk_hw = to_cv181x_clk(hw);
+	unsigned int clk_sel = cv181x_clk_get_clk_sel(clk_hw);
+	void __iomem *reg_addr = clk_hw->base + clk_hw->div[clk_sel].reg;
+	unsigned int val;
+	unsigned long rate;
+
+	if ((clk_hw->mux[0].shift >= 0) && cv181x_clk_is_bypassed(clk_hw))
+		return parent_rate;
+
+	if ((clk_hw->div[clk_sel].initval > 0) && !(readl(reg_addr) & BIT(3))) {
+		val = clk_hw->div[clk_sel].initval;
+	} else {
+		val = readl(reg_addr) >> clk_hw->div[clk_sel].shift;
+		val &= div_mask(clk_hw->div[clk_sel].width);
+	}
+	rate = divider_recalc_rate(hw, parent_rate, val, NULL,
+				   clk_hw->div[clk_sel].flags,
+				   clk_hw->div[clk_sel].width);
+
+	return rate;
+}
+
+static long cv181x_clk_div_round_rate(struct clk_hw *hw, unsigned long rate,
+				      unsigned long *prate)
+{
+	struct cv181x_hw_clock *clk_hw = to_cv181x_clk(hw);
+	unsigned int clk_sel = cv181x_clk_get_clk_sel(clk_hw);
+
+	if ((clk_hw->mux[0].shift >= 0) && cv181x_clk_is_bypassed(clk_hw))
+		return DIV_ROUND_UP_ULL((u64)*prate, 1);
+
+	return divider_round_rate(hw, rate, prate, NULL,
+				  clk_hw->div[clk_sel].width, clk_hw->div[clk_sel].flags);
+}
+
+static long cv181x_clk_div_calc_round_rate(struct clk_hw *hw, unsigned long rate,
+					 unsigned long *prate)
+{
+	struct cv181x_hw_clock *clk_hw = to_cv181x_clk(hw);
+
+	if (clk_hw->div[0].shift > 0)
+		return divider_round_rate(hw, rate, prate, NULL,
+					clk_hw->div[0].width, clk_hw->div[0].flags);
+	else
+		return DIV_ROUND_UP_ULL((u64)*prate, 1);
+}
+
+static int cv181x_clk_div_determine_rate(struct clk_hw *hw,
+				       struct clk_rate_request *req)
+{
+	struct clk_hw *current_parent;
+	unsigned long parent_rate;
+	unsigned long best_delta;
+	unsigned long best_rate;
+	u32 parent_count;
+	long rate;
+	u32 which;
+
+	pr_debug("%s()_%d: req->rate=%ld\n", __func__, __LINE__, req->rate);
+
+	parent_count = clk_hw_get_num_parents(hw);
+	pr_debug("%s()_%d: parent_count=%d\n", __func__, __LINE__, parent_count);
+
+	if ((parent_count < 2) || (clk_hw_get_flags(hw) & CLK_SET_RATE_NO_REPARENT)) {
+		rate = cv181x_clk_div_round_rate(hw, req->rate, &req->best_parent_rate);
+		if (rate < 0)
+			return rate;
+
+		req->rate = rate;
+		return 0;
+	}
+
+	/* Unless we can do better, stick with current parent */
+	current_parent = clk_hw_get_parent(hw);
+	parent_rate = clk_hw_get_rate(current_parent);
+	best_rate = cv181x_clk_div_calc_round_rate(hw, req->rate, &parent_rate);
+	best_delta = abs(best_rate - req->rate);
+
+	pr_debug("%s()_%d: parent_rate=%ld, best_rate=%ld, best_delta=%ld\n",
+		 __func__, __LINE__, parent_rate, best_rate, best_delta);
+
+	/* Check whether any other parent clock can produce a better result */
+	for (which = 0; which < parent_count; which++) {
+		struct clk_hw *parent = clk_hw_get_parent_by_index(hw, which);
+		unsigned long delta;
+		unsigned long other_rate;
+
+		pr_debug("%s()_%d: idx=%d, parent_rate=%ld, best_rate=%ld, best_delta=%ld\n",
+			 __func__, __LINE__, which, parent_rate, best_rate, best_delta);
+
+		if (!parent)
+			continue;
+
+		if (parent == current_parent)
+			continue;
+
+		/* Not support CLK_SET_RATE_PARENT */
+		parent_rate = clk_hw_get_rate(parent);
+		other_rate = cv181x_clk_div_calc_round_rate(hw, req->rate, &parent_rate);
+		delta = abs(other_rate - req->rate);
+		pr_debug("%s()_%d: parent_rate=%ld, other_rate=%ld, delta=%ld\n",
+			 __func__, __LINE__, parent_rate, other_rate, delta);
+		if (delta < best_delta) {
+			best_delta = delta;
+			best_rate = other_rate;
+			req->best_parent_hw = parent;
+			req->best_parent_rate = parent_rate;
+			pr_debug("%s()_%d: parent_rate=%ld, best_rate=%ld, best_delta=%ld\n",
+				 __func__, __LINE__, parent_rate, best_rate, best_delta);
+		}
+	}
+
+	req->rate = best_rate;
+
+	return 0;
+}
+
+static int cv181x_clk_div_set_rate(struct clk_hw *hw, unsigned long rate,
+				 unsigned long parent_rate)
+{
+	struct cv181x_hw_clock *clk_hw = to_cv181x_clk(hw);
+	unsigned int clk_sel = cv181x_clk_get_clk_sel(clk_hw);
+	void __iomem *reg_addr = clk_hw->base + clk_hw->div[clk_sel].reg;
+	unsigned long flags = 0;
+	int value;
+	u32 val;
+
+	pr_debug("%s()_%d:%s, rate=%ld, parent_rate=%ld\n", __func__, __LINE__, clk_hw->name, rate, parent_rate);
+
+	if (clk_hw->div[clk_sel].shift < 0)
+		pr_err("Error: %s: div[%d].shift = %d\n", __func__, clk_sel, clk_hw->div[clk_sel].shift);
+
+	value = divider_get_val(rate, parent_rate, NULL,
+				clk_hw->div[clk_sel].width,
+				clk_hw->div[clk_sel].flags);
+	if (value < 0)
+		return value;
+
+	if (clk_hw->lock)
+		spin_lock_irqsave(clk_hw->lock, flags);
+	else
+		__acquire(clk_hw->lock);
+
+	val = readl(reg_addr);
+	val &= ~(div_mask(clk_hw->div[clk_sel].width) << clk_hw->div[clk_sel].shift);
+	val |= (u32)value << clk_hw->div[clk_sel].shift;
+	if (!(clk_hw->div[clk_sel].initval < 0))
+		val |= BIT(3);
+	writel(val, reg_addr);
+
+	if (clk_hw->lock)
+		spin_unlock_irqrestore(clk_hw->lock, flags);
+	else
+		__release(clk_hw->lock);
+
+	return 0;
+}
+
+static void cv181x_clk_gate_endisable(struct clk_hw *hw, int enable)
+{
+	struct cv181x_hw_clock *clk_hw = to_cv181x_clk(hw);
+	void __iomem *reg_addr = clk_hw->base + clk_hw->gate.reg;
+	unsigned long flags = 0;
+	u32 reg;
+
+	if (clk_hw->gate.shift < 0)
+		pr_err("Error: %s: gate.shift = %d\n", __func__, clk_hw->gate.shift);
+
+	if (clk_hw->lock)
+		spin_lock_irqsave(clk_hw->lock, flags);
+	else
+		__acquire(clk_hw->lock);
+
+	reg = readl(reg_addr);
+
+	if (enable)
+		reg |= BIT(clk_hw->gate.shift);
+	else
+		reg &= ~BIT(clk_hw->gate.shift);
+
+	writel(reg, reg_addr);
+
+	if (clk_hw->lock)
+		spin_unlock_irqrestore(clk_hw->lock, flags);
+	else
+		__release(clk_hw->lock);
+}
+
+static int cv181x_clk_gate_enable(struct clk_hw *hw)
+{
+	cv181x_clk_gate_endisable(hw, 1);
+
+	return 0;
+}
+
+static void cv181x_clk_gate_disable(struct clk_hw *hw)
+{
+	cv181x_clk_gate_endisable(hw, 0);
+}
+
+static int cv181x_clk_gate_is_enabled(struct clk_hw *hw)
+{
+	u32 reg;
+	struct cv181x_hw_clock *clk_hw = to_cv181x_clk(hw);
+	void __iomem *reg_addr = clk_hw->base + clk_hw->gate.reg;
+
+	if (clk_hw->gate.shift < 0)
+		pr_err("Error: %s: gate.shift = %d\n", __func__, clk_hw->gate.shift);
+
+	reg = readl(reg_addr);
+
+	reg &= BIT(clk_hw->gate.shift);
+
+	if (clk_hw_get_flags(hw) & CLK_IGNORE_UNUSED)
+		return __clk_get_enable_count(hw->clk) ? (reg ? 1 : 0) : 0;
+	else
+		return reg ? 1 : 0;
+}
+
+static u8 cv181x_clk_mux_get_parent(struct clk_hw *hw)
+{
+	struct cv181x_hw_clock *clk_hw = to_cv181x_clk(hw);
+	u8 clk_sel = cv181x_clk_get_clk_sel(clk_hw);
+	u8 src_sel = cv181x_clk_get_src_sel(clk_hw);
+	u8 parent_idx = 0;
+
+	/*
+	 * | 0     | 1     | 2     | 3     | 4     | 5     |
+	 * +-------+-------+-------+-------+-------+-------+
+	 * | XTAL  | DIV_1 | src_0 | src_1 | src_2 | src_3 |
+	 * | XTAL  | src_0 | src_1 | src_2 | src_3 |       |
+	 * | DIV_1 | src_0 | src_1 | src_2 | src_3 |       |
+	 * | src_0 | src_1 | src_2 | src_3 |       |       |
+	 * +-------+-------+-------+-------+-------+-------+
+	 */
+
+	if (clk_hw->mux[0].shift >= 0) {
+		// clk with bypass reg
+		if (cv181x_clk_is_bypassed(clk_hw)) {
+			parent_idx = 0;
+		} else {
+			if (clk_hw->mux[1].shift >= 0) {
+				// clk with clk_sel reg
+				if (clk_sel) {
+					parent_idx = 1;
+				} else {
+					parent_idx = src_sel + 2;
+				}
+			} else {
+				// clk without clk_sel reg
+				parent_idx = src_sel + 1;
+			}
+		}
+	} else {
+		// clk without bypass reg
+		if (clk_hw->mux[1].shift >= 0) {
+			// clk with clk_sel reg
+			if (clk_sel) {
+				parent_idx = 0;
+			} else {
+				parent_idx = src_sel + 1;
+			}
+		} else {
+			//clk without clk_sel reg
+			parent_idx = src_sel;
+		}
+	}
+
+	return parent_idx;
+}
+
+static int cv181x_clk_mux_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct cv181x_hw_clock *clk_hw = to_cv181x_clk(hw);
+	unsigned long flags = 0;
+	void __iomem *reg_addr;
+	unsigned int reg;
+
+	if (clk_hw->lock)
+		spin_lock_irqsave(clk_hw->lock, flags);
+	else
+		__acquire(clk_hw->lock);
+
+	/*
+	 * | 0     | 1     | 2     | 3     | 4     | 5     |
+	 * +-------+-------+-------+-------+-------+-------+
+	 * | XTAL  | DIV_1 | src_0 | src_1 | src_2 | src_3 |
+	 * | XTAL  | src_0 | src_1 | src_2 | src_3 |       |
+	 * | DIV_1 | src_0 | src_1 | src_2 | src_3 |       |
+	 * | src_0 | src_1 | src_2 | src_3 |       |       |
+	 * +-------+-------+-------+-------+-------+-------+
+	 */
+
+	if (index == 0) {
+		if (clk_hw->mux[0].shift >= 0) {
+			// set bypass
+			reg_addr = clk_hw->base + clk_hw->mux[0].reg;
+			reg = readl(reg_addr);
+			reg |= 1 << clk_hw->mux[0].shift;
+			writel(reg, reg_addr);
+			goto unlock_release;
+		} else if (clk_hw->mux[1].shift >= 0) {
+			// set clk_sel to DIV_1
+			reg_addr = clk_hw->base + clk_hw->mux[1].reg;
+			reg = readl(reg_addr);
+			reg &= ~(1 << clk_hw->mux[1].shift);
+			writel(reg, reg_addr);
+			goto unlock_release;
+		}
+	} else if (index == 1) {
+		if (clk_hw->mux[0].shift >= 0) {
+			// clear bypass
+			reg_addr = clk_hw->base + clk_hw->mux[0].reg;
+			reg = readl(reg_addr);
+			reg &= ~(0x1 << clk_hw->mux[0].shift);
+			writel(reg, reg_addr);
+
+			if (clk_hw->mux[1].shift >= 0) {
+				// set clk_sel to DIV_1
+				reg_addr = clk_hw->base + clk_hw->mux[1].reg;
+				reg = readl(reg_addr);
+				reg &= ~(1 << clk_hw->mux[1].shift);
+				writel(reg, reg_addr);
+				goto unlock_release;
+			} else {
+				index--;
+			}
+		} else if (clk_hw->mux[1].shift >= 0) {
+			// set clk_sel to DIV_0
+			reg_addr = clk_hw->base + clk_hw->mux[1].reg;
+			reg = readl(reg_addr);
+			reg |= 1 << clk_hw->mux[1].shift;
+			writel(reg, reg_addr);
+			index--;
+		}
+	} else {
+		if (clk_hw->mux[0].shift >= 0) {
+			// clear bypass
+			reg_addr = clk_hw->base + clk_hw->mux[0].reg;
+			reg = readl(reg_addr);
+			reg &= ~(0x1 << clk_hw->mux[0].shift);
+			writel(reg, reg_addr);
+			index--;
+		}
+
+		if (clk_hw->mux[1].shift >= 0) {
+			// set clk_sel to DIV_0
+			reg_addr = clk_hw->base + clk_hw->mux[1].reg;
+			reg = readl(reg_addr);
+			reg |= 1 << clk_hw->mux[1].shift;
+			writel(reg, reg_addr);
+			index--;
+		}
+	}
+
+	if (index < 0) {
+		pr_err("index is negative(%d)\n", index);
+		goto unlock_release;
+	}
+
+	// set src_sel reg
+	reg_addr = clk_hw->base + clk_hw->mux[2].reg;
+	reg = readl(reg_addr);
+	reg &= ~(0x3 << clk_hw->mux[2].shift); // clear bits
+	reg |= (index & 0x3) << clk_hw->mux[2].shift; //set bits
+	writel(reg, reg_addr);
+
+unlock_release:
+	if (clk_hw->lock)
+		spin_unlock_irqrestore(clk_hw->lock, flags);
+	else
+		__release(clk_hw->lock);
+
+	return 0;
+}
+
+static const struct clk_ops cv181x_clk_ops = {
+	// gate
+	.enable = cv181x_clk_gate_enable,
+	.disable = cv181x_clk_gate_disable,
+	.is_enabled = cv181x_clk_gate_is_enabled,
+
+	// div
+	.recalc_rate = cv181x_clk_div_recalc_rate,
+	.round_rate = cv181x_clk_div_round_rate,
+	.determine_rate = cv181x_clk_div_determine_rate,
+	.set_rate = cv181x_clk_div_set_rate,
+
+	//mux
+	.get_parent = cv181x_clk_mux_get_parent,
+	.set_parent = cv181x_clk_mux_set_parent,
+};
+
+static struct clk_hw *cv181x_register_clk(struct cv181x_hw_clock *cv181x_clk,
+					  void __iomem *sys_base)
+{
+	struct clk_hw *hw;
+	struct clk_init_data init;
+	int err;
+
+	cv181x_clk->gate.flags = 0;
+	cv181x_clk->div[0].flags = CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO |
+				 CLK_DIVIDER_ROUND_CLOSEST;
+	cv181x_clk->div[1].flags = CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO |
+				 CLK_DIVIDER_ROUND_CLOSEST;
+	cv181x_clk->mux[0].flags = 0; /* clk byp */
+	cv181x_clk->mux[1].flags = 0; /* clk sel */
+	cv181x_clk->mux[2].flags = 0; /* div_0 src_sel */
+	cv181x_clk->base = sys_base;
+	cv181x_clk->lock = &cv181x_clk_lock;
+
+	if (cvi_clk_flags) {
+		/* copy clk_init_data for modification */
+		memcpy(&init, cv181x_clk->hw.init, sizeof(init));
+
+		init.flags |= cvi_clk_flags;
+		cv181x_clk->hw.init = &init;
+	}
+
+	hw = &cv181x_clk->hw;
+	err = clk_hw_register(NULL, hw);
+	if (err) {
+		return ERR_PTR(err);
+	}
+
+	return hw;
+}
+
+static void cv181x_unregister_clk(struct clk_hw *hw)
+{
+	struct cv181x_hw_clock *cv181x_clk = to_cv181x_clk(hw);
+
+	clk_hw_unregister(hw);
+	kfree(cv181x_clk);
+}
+static int cv181x_register_clks(struct cv181x_hw_clock *clks,
+				int num_clks,
+				struct cv181x_clock_data *data)
+{
+	struct clk_hw *hw;
+	void __iomem *sys_base = data->base;
+	unsigned int i;
+
+	for (i = 0; i < num_clks; i++) {
+		struct cv181x_hw_clock *cv181x_clk = &clks[i];
+
+		hw = cv181x_register_clk(cv181x_clk, sys_base);
+
+		if (IS_ERR(hw)) {
+			pr_err("%s: failed to register clock %s\n",
+			       __func__, cv181x_clk->name);
+			goto err_clk;
+		}
+		data->hw_data.hws[clks[i].id] = hw;
+		clk_hw_register_clkdev(hw, cv181x_clk->name, NULL);
+	}
+
+	return 0;
+
+err_clk:
+	while (i--)
+		cv181x_unregister_clk(data->hw_data.hws[clks[i].id]);
+
+	return PTR_ERR(hw);
+}
+
+static const struct of_device_id cvi_clk_match_ids_tables[] = {
+	{
+		.compatible = "cvitek,cv181x-clk",
+	},
+	{}
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int cv181x_clk_suspend(void)
+{
+	memcpy_fromio(clk_data->clken_saved_regs,
+		      clk_data->base + REG_CLK_EN_START,
+		      REG_CLK_EN_NUM * 4);
+
+	memcpy_fromio(clk_data->clksel_saved_regs,
+		      clk_data->base + REG_CLK_SEL_START,
+		      REG_CLK_SEL_NUM * 4);
+
+	memcpy_fromio(clk_data->clkbyp_saved_regs,
+		      clk_data->base + REG_CLK_BYP_START,
+		      REG_CLK_BYP_NUM * 4);
+
+	memcpy_fromio(clk_data->clkdiv_saved_regs,
+		      clk_data->base + REG_CLK_DIV_START,
+		      REG_CLK_DIV_NUM * 4);
+
+	memcpy_fromio(clk_data->g2_clkdiv_saved_regs,
+		      clk_data->base + REG_CLK_G2_DIV_START,
+		      REG_CLK_G2_DIV_NUM * 4);
+
+	memcpy_fromio(clk_data->pll_g2_csr_saved_regs,
+		      clk_data->base + REG_PLL_G2_CSR_START,
+		      REG_PLL_G2_CSR_NUM * 4);
+
+	memcpy_fromio(clk_data->pll_g6_csr_saved_regs,
+		      clk_data->base + REG_PLL_G6_CSR_START,
+		      REG_PLL_G6_CSR_NUM * 4);
+
+	clk_data->a0pll_ssc_syn_set_saved_reg =
+		readl(clk_data->base + REG_APLL_SSC_SYN_SET);
+
+	clk_data->disppll_ssc_syn_set_saved_reg =
+		readl(clk_data->base + REG_DISPPLL_SSC_SYN_SET);
+
+	clk_data->cam0pll_ssc_syn_set_saved_reg =
+		readl(clk_data->base + REG_CAM0PLL_SSC_SYN_SET);
+
+	clk_data->cam1pll_ssc_syn_set_saved_reg =
+		readl(clk_data->base + REG_CAM1PLL_SSC_SYN_SET);
+
+	return 0;
+}
+
+static void cv181x_clk_resume(void)
+{
+	uint32_t regval;
+
+	/* switch clock to xtal */
+	writel(0xffffffff, clk_data->base + REG_CLK_BYP_0);
+	writel(0x0000000f, clk_data->base + REG_CLK_BYP_1);
+
+	memcpy_toio(clk_data->base + REG_CLK_EN_START,
+		    clk_data->clken_saved_regs,
+		    REG_CLK_EN_NUM * 4);
+
+	memcpy_toio(clk_data->base + REG_CLK_SEL_START,
+		    clk_data->clksel_saved_regs,
+		    REG_CLK_SEL_NUM * 4);
+
+	memcpy_toio(clk_data->base + REG_CLK_DIV_START,
+		    clk_data->clkdiv_saved_regs,
+		    REG_CLK_DIV_NUM * 4);
+
+	memcpy_toio(clk_data->base + REG_CLK_G2_DIV_START,
+		    clk_data->g2_clkdiv_saved_regs,
+		    REG_CLK_G2_DIV_NUM * 4);
+
+	memcpy_toio(clk_data->base + REG_PLL_G6_CSR_START,
+		    clk_data->pll_g6_csr_saved_regs,
+		    REG_PLL_G6_CSR_NUM * 4);
+
+	/* wait for pll setting updated */
+	while (readl(clk_data->base + REG_PLL_G6_STATUS) & 0x7) {
+	}
+
+	/* A0PLL */
+	if (clk_data->a0pll_ssc_syn_set_saved_reg !=
+	    readl(clk_data->base + REG_APLL_SSC_SYN_SET)) {
+		pr_debug("%s: update A0PLL\n", __func__);
+		writel(clk_data->a0pll_ssc_syn_set_saved_reg,
+		       clk_data->base + REG_APLL_SSC_SYN_SET);
+
+		/* toggle software update */
+		regval = readl(clk_data->base + REG_APLL_SSC_SYN_CTRL);
+		regval ^= 1;
+		writel(regval, clk_data->base + REG_APLL_SSC_SYN_CTRL);
+	}
+
+	/* DISPPLL */
+	if (clk_data->disppll_ssc_syn_set_saved_reg !=
+	    readl(clk_data->base + REG_DISPPLL_SSC_SYN_SET)) {
+		pr_debug("%s: update DISPPLL\n", __func__);
+		writel(clk_data->disppll_ssc_syn_set_saved_reg,
+		       clk_data->base + REG_DISPPLL_SSC_SYN_SET);
+
+		/* toggle software update */
+		regval = readl(clk_data->base + REG_DISPPLL_SSC_SYN_CTRL);
+		regval ^= 1;
+		writel(regval, clk_data->base + REG_DISPPLL_SSC_SYN_CTRL);
+	}
+
+	/* CAM0PLL */
+	if (clk_data->cam0pll_ssc_syn_set_saved_reg !=
+	    readl(clk_data->base + REG_CAM0PLL_SSC_SYN_SET)) {
+		pr_debug("%s: update CAM0PLL\n", __func__);
+		writel(clk_data->cam0pll_ssc_syn_set_saved_reg,
+		       clk_data->base + REG_CAM0PLL_SSC_SYN_SET);
+
+		/* toggle software update */
+		regval = readl(clk_data->base + REG_CAM0PLL_SSC_SYN_CTRL);
+		regval ^= 1;
+		writel(regval, clk_data->base + REG_CAM0PLL_SSC_SYN_CTRL);
+	}
+
+	/* CAM1PLL */
+	if (clk_data->cam1pll_ssc_syn_set_saved_reg !=
+	    readl(clk_data->base + REG_CAM1PLL_SSC_SYN_SET)) {
+		pr_debug("%s: update CAM1PLL\n", __func__);
+		writel(clk_data->cam1pll_ssc_syn_set_saved_reg,
+		       clk_data->base + REG_CAM1PLL_SSC_SYN_SET);
+
+		/* toggle software update */
+		regval = readl(clk_data->base + REG_CAM1PLL_SSC_SYN_CTRL);
+		regval ^= 1;
+		writel(regval, clk_data->base + REG_CAM1PLL_SSC_SYN_CTRL);
+	}
+
+	memcpy_toio(clk_data->base + REG_PLL_G2_CSR_START,
+		    clk_data->pll_g2_csr_saved_regs,
+		    REG_PLL_G2_CSR_NUM * 4);
+
+	/* wait for pll setting updated */
+	while (readl(clk_data->base + REG_PLL_G2_STATUS) & 0x1F) {
+	}
+
+	memcpy_toio(clk_data->base + REG_CLK_BYP_START,
+		    clk_data->clkbyp_saved_regs,
+		    REG_CLK_BYP_NUM * 4);
+}
+
+static struct syscore_ops cv181x_clk_syscore_ops = {
+	.suspend = cv181x_clk_suspend,
+	.resume = cv181x_clk_resume,
+};
+#endif /* CONFIG_PM_SLEEP */
+
+static void __init cvi_clk_init(struct device_node *node)
+{
+	int num_clks;
+	int i;
+	int ret = 0;
+	int of_num_clks;
+	struct clk *clk;
+
+	of_num_clks = of_clk_get_parent_count(node);
+	for (i = 0; i < of_num_clks; i++) {
+		clk = of_clk_get(node, i);
+		clk_register_clkdev(clk, __clk_get_name(clk), NULL);
+		clk_put(clk);
+	}
+
+	num_clks = ARRAY_SIZE(cv181x_pll_clks) +
+		   ARRAY_SIZE(cv181x_clks);
+
+	clk_data = kzalloc(sizeof(struct cv181x_clock_data) +
+			   sizeof(struct clk_hw) * num_clks,
+			   GFP_KERNEL);
+	if (!clk_data) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	for (i = 0; i < num_clks; i++)
+		clk_data->hw_data.hws[i] = ERR_PTR(-ENOENT);
+
+	clk_data->hw_data.num = num_clks;
+
+	clk_data->lock = &cv181x_clk_lock;
+
+	clk_data->base = of_iomap(node, 0);
+	if (!clk_data->base) {
+		pr_err("Failed to map address range for cvitek,cv181x-clk node\n");
+		return;
+	}
+
+	cv181x_clk_register_plls(cv181x_pll_clks,
+			       ARRAY_SIZE(cv181x_pll_clks),
+			       clk_data);
+
+	cv181x_register_clks(cv181x_clks,
+			   ARRAY_SIZE(cv181x_clks),
+			   clk_data);
+
+
+	/* register clk-provider */
+	ret = of_clk_add_hw_provider(node, of_clk_hw_onecell_get, &clk_data->hw_data);
+	if (ret)
+		pr_err("Unable to add hw clk provider\n");
+
+	/* force enable clocks */
+	// clk_prepare_enable(clk_data->hw_data.hws[CV181X_CLK_DSI_MAC_VIP]->clk);
+	// clk_prepare_enable(clk_data->hw_data.hws[CV181X_CLK_DISP_VIP]->clk);
+	// clk_prepare_enable(clk_data->hw_data.hws[CV181X_CLK_BT_VIP]->clk);
+	// clk_prepare_enable(clk_data->hw_data.hws[CV181X_CLK_SC_TOP_VIP]->clk);
+
+#ifdef CONFIG_PM_SLEEP
+	register_syscore_ops(&cv181x_clk_syscore_ops);
+#endif
+
+	if (!ret)
+		return;
+
+out:
+	pr_err("%s failed error number %d\n", __func__, ret);
+}
+CLK_OF_DECLARE(cvi_clk, "cvitek,cv181x-clk", cvi_clk_init);
diff --git a/drivers/clk/cvitek/clk-cv182x.c b/drivers/clk/cvitek/clk-cv182x.c
new file mode 100644
index 000000000000..6051bf4ccac4
--- /dev/null
+++ b/drivers/clk/cvitek/clk-cv182x.c
@@ -0,0 +1,1862 @@
+/*
+ * Copyright (c) 2020 CVITEK
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include <linux/syscore_ops.h>
+
+#include <dt-bindings/clock/cv182x-clock.h>
+
+#define CV182X_CLK_FLAGS_ALL	(CLK_GET_RATE_NOCACHE)
+//#define CV182X_CLK_FLAGS_ALL	(CLK_GET_RATE_NOCACHE | CLK_IS_CRITICAL)
+#define CV182X_CLK_FLAGS_MUX	(CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT)
+
+/* top_pll_g2 */
+#define CV182X_CLK_PLL_G2_CTRL		0x800
+#define CV182X_CLK_PLL_G2_STATUS	0x804
+#define CV182X_CLK_MIPIMPLL_CSR		0x808
+#define CV182X_CLK_A0PLL_CSR		0x80C
+#define CV182X_CLK_DISPPLL_CSR		0x810
+#define CV182X_CLK_CAM0PLL_CSR		0x814
+#define CV182X_CLK_CAM1PLL_CSR		0x818
+#define CV182X_CLK_PLL_G2_SSC_SYN_CTRL	0x840
+#define CV182X_CLK_A0PLL_SSC_SYN_CTRL	0x850
+#define CV182X_CLK_A0PLL_SSC_SYN_SET	0x854
+#define CV182X_CLK_A0PLL_SSC_SYN_SPAN	0x858
+#define CV182X_CLK_A0PLL_SSC_SYN_STEP	0x85C
+#define CV182X_CLK_DISPPLL_SSC_SYN_CTRL	0x860
+#define CV182X_CLK_DISPPLL_SSC_SYN_SET	0x864
+#define CV182X_CLK_DISPPLL_SSC_SYN_SPAN	0x868
+#define CV182X_CLK_DISPPLL_SSC_SYN_STEP	0x86C
+#define CV182X_CLK_CAM0PLL_SSC_SYN_CTRL	0x870
+#define CV182X_CLK_CAM0PLL_SSC_SYN_SET	0x874
+#define CV182X_CLK_CAM0PLL_SSC_SYN_SPAN	0x878
+#define CV182X_CLK_CAM0PLL_SSC_SYN_STEP	0x87C
+#define CV182X_CLK_CAM1PLL_SSC_SYN_CTRL	0x880
+#define CV182X_CLK_CAM1PLL_SSC_SYN_SET	0x884
+#define CV182X_CLK_CAM1PLL_SSC_SYN_SPAN	0x888
+#define CV182X_CLK_CAM1PLL_SSC_SYN_STEP	0x88C
+
+/* top_pll_g6 */
+#define CV182X_CLK_PLL_G6_CTRL		0x900
+#define CV182X_CLK_PLL_G6_STATUS	0x904
+#define CV182X_CLK_MPLL_CSR		0x908
+#define CV182X_CLK_TPLL_CSR		0x90C
+#define CV182X_CLK_FPLL_CSR		0x910
+#define CV182X_CLK_PLL_G6_SSC_SYN_CTRL	0x940
+
+/* clkgen */
+#define CV182X_CLK_ENABLE0		0x000
+#define CV182X_CLK_ENABLE1		0x004
+#define CV182X_CLK_ENABLE2		0x008
+#define CV182X_CLK_ENABLE3		0x00C
+#define CV182X_CLK_ENABLE4		0x010
+#define CV182X_CLK_SELECT		0x020
+#define CV182X_CLK_BYPASS0		0x030
+#define CV182X_CLK_BYPASS1		0x034
+#define CV182X_CLK_A53_DIV0		0x040
+#define CV182X_CLK_A53_DIV1		0x044
+#define CV182X_CLK_CPU_AXI0_DIV0	0x048
+#define CV182X_CLK_CPU_AXI0_DIV1	0x04C
+#define CV182X_CLK_CPU_GIC_DIV		0x050
+#define CV182X_CLK_TPU_DIV0		0x054
+#define CV182X_CLK_TPU_DIV1		0x058
+#define CV182X_CLK_TPU_FAB_DIV0		0x05C
+#define CV182X_CLK_TPU_FAB_DIV1		0x060
+#define CV182X_CLK_EMMC_DIV0		0x064
+#define CV182X_CLK_EMMC_DIV1		0x068
+#define CV182X_CLK_100K_EMMC_DIV	0x06C
+#define CV182X_CLK_SD0_DIV0		0x070
+#define CV182X_CLK_SD0_DIV1		0x074
+#define CV182X_CLK_100K_SD0_DIV		0x078
+#define CV182X_CLK_SD1_DIV0		0x07C
+#define CV182X_CLK_SD1_DIV1		0x080
+#define CV182X_CLK_100K_SD1_DIV		0x084
+#define CV182X_CLK_SPI_NAND_DIV		0x088
+#define CV182X_CLK_500M_ETH0_DIV	0x08C
+#define CV182X_CLK_500M_ETH1_DIV	0x090
+#define CV182X_CLK_GPIO_DB_DIV		0x094
+#define CV182X_CLK_SDMA_AUD0_DIV	0x098
+#define CV182X_CLK_SDMA_AUD1_DIV	0x09C
+#define CV182X_CLK_SDMA_AUD2_DIV	0x0A0
+#define CV182X_CLK_SDMA_AUD3_DIV	0x0A4
+#define CV182X_CLK_187P5M_DIV		0x0A8
+#define CV182X_CLK_125M_USB_DIV		0x0AC
+#define CV182X_CLK_33K_USB_DIV		0x0B0
+#define CV182X_CLK_12M_USB_DIV		0x0B4
+#define CV182X_CLK_AXI4_DIV		0x0B8
+#define CV182X_CLK_AXI6_DIV0		0x0BC
+#define CV182X_CLK_AXI6_DIV1		0x0C0
+#define CV182X_CLK_DSI_ESC_DIV		0x0C4
+#define CV182X_CLK_AXI_VIP_DIV0		0x0C8
+#define CV182X_CLK_AXI_VIP_DIV1		0x0CC
+#define CV182X_CLK_SRC_VIP_SYS_0_DIV0	0x0D0
+#define CV182X_CLK_SRC_VIP_SYS_0_DIV1	0x0D4
+#define CV182X_CLK_SRC_VIP_SYS_1_DIV0	0x0D8
+#define CV182X_CLK_SRC_VIP_SYS_1_DIV1	0x0DC
+#define CV182X_CLK_DISP_SRC_VIP_DIV	0x0E0
+#define CV182X_CLK_AXI_VIDEO_CODEC_DIV0	0x0E4
+#define CV182X_CLK_AXI_VIDEO_CODEC_DIV1	0x0E8
+#define CV182X_CLK_VC_SRC0_DIV0		0x0EC
+#define CV182X_CLK_VC_SRC0_DIV1		0x0F0
+#define CV182X_CLK_CAM0_DIV		0x0F4
+#define CV182X_CLK_CAM1_DIV		0x0F8
+#define CV182X_CLK_1M_DIV		0x0FC
+#define CV182X_CLK_SPI_DIV		0x100
+#define CV182X_CLK_I2C_DIV		0x104
+#define CV182X_CLK_VC_SRC1_DIV0		0x108
+#define CV182X_CLK_VC_SRC1_DIV1		0x10C
+#define CV182X_CLK_SRC_VIP_SYS_2_DIV0	0x110
+#define CV182X_CLK_SRC_VIP_SYS_2_DIV1	0x114
+#define CV182X_CLK_AUDSRC_DIV		0x118
+#define CV182X_CLK_VC_SRC2_DIV		0x11C
+#define CV182X_CLK_PWM_SRC_DIV0		0x120
+#define CV182X_CLK_PWM_SRC_DIV1		0x124
+#define CV182X_CLK_AP_DEBUG_DIV		0x128
+#define CV182X_CLK_SRC_RTC_SYS_0_DIV	0x12C
+
+#define CV182X_PLL_G2_CSR_NUM		(CV182X_CLK_CAM1PLL_CSR / 4 - CV182X_CLK_MIPIMPLL_CSR / 4 + 1)
+#define CV182X_PLL_G2_CSR_START		CV182X_CLK_MIPIMPLL_CSR
+
+#define CV182X_PLL_G6_CSR_NUM		(CV182X_CLK_FPLL_CSR / 4 - CV182X_CLK_MPLL_CSR / 4 + 1)
+#define CV182X_PLL_G6_CSR_START		CV182X_CLK_MPLL_CSR
+
+#define CV182X_CLKEN_NUM		(CV182X_CLK_ENABLE4 / 4 - CV182X_CLK_ENABLE0 / 4 + 1)
+#define CV182X_CLKEN_START		CV182X_CLK_ENABLE0
+
+#define CV182X_CLKSEL_NUM		(CV182X_CLK_SELECT / 4  - CV182X_CLK_SELECT / 4 + 1)
+#define CV182X_CLKSEL_START		CV182X_CLK_SELECT
+
+#define CV182X_CLKBYP_NUM		(CV182X_CLK_BYPASS1 / 4 - CV182X_CLK_BYPASS0 / 4 + 1)
+#define CV182X_CLKBYP_START		CV182X_CLK_BYPASS0
+
+#define CV182X_CLKDIV_NUM		(CV182X_CLK_SRC_RTC_SYS_0_DIV / 4 - CV182X_CLK_A53_DIV0 / 4 + 1)
+#define CV182X_CLKDIV_START		CV182X_CLK_A53_DIV0
+
+#define CV182X_VCSYS_BUS_IDLE		0x03000210
+#define CV182X_BUS_IDLE_TIMEOUT_MS	1
+
+/* PLL status register offset */
+#define PLL_STATUS_MASK			0xFF
+#define PLL_STATUS_OFFSET		0x04
+
+/* G2 Synthesizer register offset */
+#define G2_SSC_CTRL_MASK		0xFF
+#define G2_SSC_CTRL_OFFSET		0x40
+#define SSC_SYN_SET_MASK		0x0F
+#define SSC_SYN_SET_OFFSET		0x04
+
+#define to_cv182x_pll_clk(_hw) container_of(_hw, struct cv182x_pll_hw_clock, hw)
+#define to_cv182x_div_clk(_hw) container_of(_hw, struct cv182x_div_hw_clock, hw)
+#define to_cv182x_gate_clk(_hw) container_of(_hw, struct cv182x_gate_hw_clock, hw)
+
+#define div_mask(width) ((1 << (width)) - 1)
+
+static DEFINE_SPINLOCK(cv182x_clk_lock);
+
+struct cv182x_clock_data {
+	void __iomem *base;
+	spinlock_t *lock;
+	struct clk_hw_onecell_data hw_data;
+#ifdef CONFIG_PM_SLEEP
+	uint32_t clken_saved_regs[CV182X_CLKEN_NUM];
+	uint32_t clksel_saved_regs[CV182X_CLKSEL_NUM];
+	uint32_t clkbyp_saved_regs[CV182X_CLKBYP_NUM];
+	uint32_t clkdiv_saved_regs[CV182X_CLKDIV_NUM];
+	uint32_t pll_g2_csr_saved_regs[CV182X_PLL_G2_CSR_NUM];
+	uint32_t a0pll_ssc_syn_set_saved_reg;
+	uint32_t disppll_ssc_syn_set_saved_reg;
+	uint32_t cam0pll_ssc_syn_set_saved_reg;
+	uint32_t cam1pll_ssc_syn_set_saved_reg;
+	uint32_t pll_g6_csr_saved_regs[CV182X_PLL_G6_CSR_NUM];
+#endif /* CONFIG_PM_SLEEP */
+};
+
+struct cv182x_gate_clock {
+	unsigned int	id;
+	const char	*name;
+	const char	*parent;
+	u32		reg;
+	s8		shift;
+	u32		idle_reg;
+	u32		idle_state;
+	unsigned long	gate_flags;
+};
+
+struct cv182x_gate_hw_clock {
+	struct cv182x_gate_clock gate;
+	void __iomem *base;
+	spinlock_t *lock;
+	struct clk_hw hw;
+};
+
+struct cv182x_mux_clock {
+	unsigned int	id;
+	const char	*name;
+	const char      * const *parents;
+	s8		num_parents;
+	u32		reg;
+	s8		shift;
+	unsigned long	flags;
+};
+
+struct cv182x_div_clock {
+	unsigned int	id;
+	const char	*name;
+	u32		reg;
+	u8		shift;
+	u8		width;
+	u32		initval;
+	const struct clk_div_table *table;
+	unsigned long div_flags;
+};
+
+struct cv182x_div_hw_clock {
+	struct cv182x_div_clock div;
+	void __iomem *base;
+	spinlock_t *lock;
+	struct clk_hw hw;
+};
+
+struct cv182x_composite_clock {
+	unsigned int	id;
+	const char	*name;
+	const char	*parent;
+	const char      * const *parents;
+	unsigned int	num_parents;
+	unsigned long	flags;
+
+	u32		gate_reg;
+	u32		mux_reg;
+	u32		div_reg;
+
+	s8		gate_shift;
+	s8		mux_shift;
+	s8		div_shift;
+	s8		div_width;
+	s16		div_initval;
+	const struct clk_div_table *table;
+};
+
+struct cv182x_pll_clock {
+	unsigned int	id;
+	const char	*name;
+	u32		reg_csr;
+	u32		reg_ssc;
+	unsigned long	flags;
+};
+
+struct cv182x_pll_hw_clock {
+	struct cv182x_pll_clock pll;
+	void __iomem *base;
+	spinlock_t *lock;
+	struct clk_hw hw;
+};
+
+static const struct clk_ops cv182x_g6_pll_ops;
+static const struct clk_ops cv182x_g2_pll_ops;
+static const struct clk_ops cv182x_clk_div_ops;
+static const struct clk_ops cv182x_clk_gate_ops;
+
+static struct cv182x_clock_data *clk_data;
+
+static unsigned long cvi_clk_flags;
+
+#define GATE_DIV(_id, _name, _parent, _gate_reg, _gate_shift, _div_reg,	\
+			_div_shift, _div_width, _div_initval, _table,	\
+			_flags) {					\
+		.id = _id,						\
+		.parent = _parent,					\
+		.name = _name,						\
+		.gate_reg = _gate_reg,					\
+		.gate_shift = _gate_shift,				\
+		.div_reg = _div_reg,					\
+		.div_shift = _div_shift,				\
+		.div_width = _div_width,				\
+		.div_initval = _div_initval,				\
+		.table = _table,					\
+		.mux_shift = -1,					\
+		.flags = _flags | CV182X_CLK_FLAGS_ALL,			\
+	}
+
+#define GATE_MUX(_id, _name, _parents, _gate_reg, _gate_shift,		\
+			_mux_reg, _mux_shift, _flags) {			\
+		.id = _id,						\
+		.parents = _parents,					\
+		.num_parents = ARRAY_SIZE(_parents),			\
+		.name = _name,						\
+		.gate_reg = _gate_reg,					\
+		.gate_shift = _gate_shift,				\
+		.div_shift = -1,					\
+		.mux_reg = _mux_reg,					\
+		.mux_shift = _mux_shift,				\
+		.flags = _flags |					\
+			 CV182X_CLK_FLAGS_ALL |	 CV182X_CLK_FLAGS_MUX,	\
+	}
+
+#define CLK_G6_PLL(_id, _name, _parent, _reg_csr, _flags) {		\
+		.pll.id = _id,						\
+		.pll.name = _name,					\
+		.pll.reg_csr = _reg_csr,				\
+		.pll.reg_ssc = 0,					\
+		.hw.init = CLK_HW_INIT_PARENTS(_name, _parent,		\
+					       &cv182x_g6_pll_ops,	\
+					       _flags |			\
+					       CV182X_CLK_FLAGS_ALL),	\
+	}
+
+#define CLK_G2_PLL(_id, _name, _parent, _reg_csr, _reg_ssc, _flags) {	\
+		.pll.id = _id,						\
+		.pll.name = _name,					\
+		.pll.reg_csr = _reg_csr,				\
+		.pll.reg_ssc = _reg_ssc,				\
+		.hw.init = CLK_HW_INIT_PARENTS(_name, _parent,		\
+					       &cv182x_g2_pll_ops,	\
+					       _flags |			\
+					       CV182X_CLK_FLAGS_ALL),	\
+	}
+
+#define CLK_DIV(_id, _name, _parent, _reg, _shift, _width, _initval,	\
+			_table,	_flags) {			\
+		.div.id = _id,						\
+		.div.name = _name,					\
+		.div.reg = _reg,					\
+		.div.shift = _shift,					\
+		.div.width = _width,					\
+		.div.initval = _initval,				\
+		.div.table = _table,					\
+		.hw.init = CLK_HW_INIT(_name, _parent,			\
+				       &cv182x_clk_div_ops,		\
+				       _flags | CV182X_CLK_FLAGS_ALL),	\
+	}
+
+#define CLK_GATE(_id, _name, _parent, _reg, _shift, _flags) {		\
+		.gate.id = _id,						\
+		.gate.name = _name,					\
+		.gate.reg = _reg,					\
+		.gate.shift = _shift,					\
+		.gate.idle_reg = 0,					\
+		.gate.idle_state = 0,					\
+		.hw.init = CLK_HW_INIT(_name, _parent,			\
+				       &cv182x_clk_gate_ops,		\
+				       _flags | CV182X_CLK_FLAGS_ALL),	\
+	}
+
+#define CLK_GATE_IDLE(_id, _name, _parent, _reg, _shift, _flags,	\
+			_idle_reg, _idle_state) {			\
+		.gate.id = _id,						\
+		.gate.name = _name,					\
+		.gate.reg = _reg,					\
+		.gate.shift = _shift,					\
+		.gate.idle_reg = _idle_reg,				\
+		.gate.idle_state = _idle_state,				\
+		.hw.init = CLK_HW_INIT(_name, _parent,			\
+				       &cv182x_clk_gate_ops,		\
+				       _flags | CV182X_CLK_FLAGS_ALL),	\
+	}
+
+const char *const cv182x_pll_parent[] = {"osc"};
+const char *const cv182x_frac_pll_parent[] = {"clk_mipimpll"};
+
+/*
+ * All PLL clocks are marked as CRITICAL, hence they are very crucial
+ * for the functioning of the SoC
+ */
+static struct cv182x_pll_hw_clock cv182x_pll_clks[] = {
+	CLK_G6_PLL(CV182X_CLK_MPLL, "clk_mpll", cv182x_pll_parent,
+		CV182X_CLK_MPLL_CSR, 0),
+	CLK_G6_PLL(CV182X_CLK_TPLL, "clk_tpll", cv182x_pll_parent,
+		CV182X_CLK_TPLL_CSR, 0),
+	CLK_G6_PLL(CV182X_CLK_FPLL, "clk_fpll", cv182x_pll_parent,
+		CV182X_CLK_FPLL_CSR, 0),
+	CLK_G2_PLL(CV182X_CLK_MIPIMPLL, "clk_mipimpll", cv182x_pll_parent,
+		CV182X_CLK_MIPIMPLL_CSR, 0, 0),
+	CLK_G2_PLL(CV182X_CLK_A0PLL, "clk_a0pll", cv182x_frac_pll_parent,
+		CV182X_CLK_A0PLL_CSR, CV182X_CLK_A0PLL_SSC_SYN_CTRL, 0),
+	CLK_G2_PLL(CV182X_CLK_DISPPLL, "clk_disppll", cv182x_frac_pll_parent,
+		CV182X_CLK_DISPPLL_CSR, CV182X_CLK_DISPPLL_SSC_SYN_CTRL, 0),
+	CLK_G2_PLL(CV182X_CLK_CAM0PLL, "clk_cam0pll", cv182x_frac_pll_parent,
+		CV182X_CLK_CAM0PLL_CSR, CV182X_CLK_CAM0PLL_SSC_SYN_CTRL, 0),
+	CLK_G2_PLL(CV182X_CLK_CAM1PLL, "clk_cam1pll", cv182x_frac_pll_parent,
+		CV182X_CLK_CAM1PLL_CSR, CV182X_CLK_CAM1PLL_SSC_SYN_CTRL, 0),
+};
+
+/*
+ * Clocks marked as CRITICAL are needed for the proper functioning
+ * of the SoC.
+ */
+static struct cv182x_gate_hw_clock cv182x_gate_clks[] = {
+	CLK_GATE(CV182X_CLK_XTAL_A53, "clk_xtal_a53", "osc",
+	  CV182X_CLK_ENABLE0, 3, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_AHB_ROM, "clk_ahb_rom", "clk_div_axi4",
+	  CV182X_CLK_ENABLE0, 6, 0),
+	CLK_GATE(CV182X_CLK_DDR_AXI_REG, "clk_ddr_axi_reg", "clk_mux_axi6",
+	  CV182X_CLK_ENABLE0, 7, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_RTC_25M, "clk_rtc_25m", "osc",
+	  CV182X_CLK_ENABLE0, 8, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_TEMPSEN, "clk_tempsen", "osc",
+	  CV182X_CLK_ENABLE0, 9, 0),
+	CLK_GATE(CV182X_CLK_SARADC, "clk_saradc", "osc",
+	  CV182X_CLK_ENABLE0, 10, 0),
+	CLK_GATE(CV182X_CLK_EFUSE, "clk_efuse", "osc",
+	  CV182X_CLK_ENABLE0, 11, 0),
+	CLK_GATE(CV182X_CLK_APB_EFUSE, "clk_apb_efuse", "osc",
+	  CV182X_CLK_ENABLE0, 12, 0),
+	CLK_GATE(CV182X_CLK_XTAL_MISC, "clk_xtal_misc", "osc",
+	  CV182X_CLK_ENABLE0, 14, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_AXI4_EMMC, "clk_axi4_emmc", "clk_div_axi4",
+	  CV182X_CLK_ENABLE0, 15, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_AXI4_SD0, "clk_axi4_sd0", "clk_div_axi4",
+	  CV182X_CLK_ENABLE0, 18, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_AXI4_SD1, "clk_axi4_sd1", "clk_div_axi4",
+	  CV182X_CLK_ENABLE0, 21, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_AXI4_ETH0, "clk_axi4_eth0", "clk_div_axi4",
+	  CV182X_CLK_ENABLE0, 26, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_AXI4_ETH1, "clk_axi4_eth1", "clk_div_axi4",
+	  CV182X_CLK_ENABLE0, 28, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_GPIO, "clk_apb_gpio", "clk_mux_axi6",
+	  CV182X_CLK_ENABLE0, 29, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_GPIO_INTR, "clk_apb_gpio_intr", "clk_mux_axi6",
+	  CV182X_CLK_ENABLE0, 30, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_AHB_SF, "clk_ahb_sf", "clk_div_axi4",
+	  CV182X_CLK_ENABLE1, 0, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_SDMA_AXI, "clk_sdma_axi", "clk_div_axi4",
+	  CV182X_CLK_ENABLE1, 1, 0),
+	CLK_GATE(CV182X_CLK_APB_I2C, "clk_apb_i2c", "clk_div_axi4",
+	  CV182X_CLK_ENABLE1, 6, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_WDT, "clk_apb_wdt", "osc",
+	  CV182X_CLK_ENABLE1, 7, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_SPI0, "clk_apb_spi0", "clk_div_axi4",
+	  CV182X_CLK_ENABLE1, 9, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_SPI1, "clk_apb_spi1", "clk_div_axi4",
+	  CV182X_CLK_ENABLE1, 10, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_SPI2, "clk_apb_spi2", "clk_div_axi4",
+	  CV182X_CLK_ENABLE1, 11, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_SPI3, "clk_apb_spi3", "clk_div_axi4",
+	  CV182X_CLK_ENABLE1, 12, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_187P5M, "clk_187p5m", "clk_div_187p5m",
+	  CV182X_CLK_ENABLE1, 13, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_UART0, "clk_apb_uart0", "clk_div_axi4",
+	  CV182X_CLK_ENABLE1, 15, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_UART1, "clk_apb_uart1", "clk_div_axi4",
+	  CV182X_CLK_ENABLE1, 17, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_UART2, "clk_apb_uart2", "clk_div_axi4",
+	  CV182X_CLK_ENABLE1, 19, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_UART3, "clk_apb_uart3", "clk_div_axi4",
+	  CV182X_CLK_ENABLE1, 21, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_UART4, "clk_apb_uart4", "clk_div_axi4",
+	  CV182X_CLK_ENABLE1, 23, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_I2S0, "clk_apb_i2s0", "clk_div_axi4",
+	  CV182X_CLK_ENABLE1, 24, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_I2S1, "clk_apb_i2s1", "clk_div_axi4",
+	  CV182X_CLK_ENABLE1, 25, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_I2S2, "clk_apb_i2s2", "clk_div_axi4",
+	  CV182X_CLK_ENABLE1, 26, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_I2S3, "clk_apb_i2s3", "clk_div_axi4",
+	  CV182X_CLK_ENABLE1, 27, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_AXI4_USB, "clk_axi4_usb", "clk_div_axi4",
+	  CV182X_CLK_ENABLE1, 28, 0),
+	CLK_GATE(CV182X_CLK_APB_USB, "clk_apb_usb", "clk_div_axi4",
+	  CV182X_CLK_ENABLE1, 29, 0),
+	CLK_GATE(CV182X_CLK_AXI4, "clk_axi4", "clk_div_axi4",
+	  CV182X_CLK_ENABLE2, 1, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_AXI6, "clk_axi6", "clk_mux_axi6",
+	  CV182X_CLK_ENABLE2, 2, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_H264C, "clk_h264c", "clk_axi_video_codec",
+	  CV182X_CLK_ENABLE2, 10, 0),
+	CLK_GATE(CV182X_CLK_H265C, "clk_h265c", "clk_axi_video_codec",
+	  CV182X_CLK_ENABLE2, 11, 0),
+	CLK_GATE(CV182X_CLK_JPEG, "clk_jpeg", "clk_axi_video_codec",
+	  CV182X_CLK_ENABLE2, 12, 0),
+	CLK_GATE(CV182X_CLK_APB_JPEG, "clk_apb_jpeg", "clk_axi6",
+	  CV182X_CLK_ENABLE2, 13, 0),
+	CLK_GATE(CV182X_CLK_APB_H264C, "clk_apb_h264c", "clk_axi6",
+	  CV182X_CLK_ENABLE2, 14, 0),
+	CLK_GATE(CV182X_CLK_APB_H265C, "clk_apb_h265c", "clk_axi6",
+	  CV182X_CLK_ENABLE2, 15, 0),
+	CLK_GATE(CV182X_CLK_CSI_MAC0_VIP, "clk_csi_mac0_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE2, 18, 0),
+	CLK_GATE(CV182X_CLK_CSI_MAC1_VIP, "clk_csi_mac1_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE2, 19, 0),
+	CLK_GATE(CV182X_CLK_ISP_TOP_VIP, "clk_isp_top_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE2, 20, 0),
+	CLK_GATE(CV182X_CLK_IMG_D_VIP, "clk_img_d_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE2, 21, 0),
+	CLK_GATE(CV182X_CLK_IMG_V_VIP, "clk_img_v_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE2, 22, 0),
+	CLK_GATE(CV182X_CLK_SC_TOP_VIP, "clk_sc_top_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE2, 23, 0),
+	CLK_GATE(CV182X_CLK_SC_D_VIP, "clk_sc_d_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE2, 24, 0),
+	CLK_GATE(CV182X_CLK_SC_V1_VIP, "clk_sc_v1_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE2, 25, 0),
+	CLK_GATE(CV182X_CLK_SC_V2_VIP, "clk_sc_v2_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE2, 26, 0),
+	CLK_GATE(CV182X_CLK_SC_V3_VIP, "clk_sc_v3_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE2, 27, 0),
+	CLK_GATE(CV182X_CLK_LDC_VIP, "clk_ldc_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE2, 28, 0),
+	CLK_GATE(CV182X_CLK_BT_VIP, "clk_bt_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE2, 29, 0),
+	CLK_GATE(CV182X_CLK_DISP_VIP, "clk_disp_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE2, 30, 0),
+	CLK_GATE(CV182X_CLK_DSI_MAC_VIP, "clk_dsi_mac_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE2, 31, 0),
+	CLK_GATE(CV182X_CLK_LVDS0_VIP, "clk_lvds0_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE3, 0, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_LVDS1_VIP, "clk_lvds1_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE3, 1, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_CSI0_RX_VIP, "clk_csi0_rx_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE3, 2, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_CSI1_RX_VIP, "clk_csi1_rx_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE3, 3, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_PAD_VI_VIP, "clk_pad_vi_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE3, 4, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_1M, "clk_1m", "clk_div_1m",
+	  CV182X_CLK_ENABLE3, 5, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_PM, "clk_pm", "clk_mux_axi6",
+	  CV182X_CLK_ENABLE3, 8, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_TIMER0, "clk_timer0", "osc",
+	  CV182X_CLK_ENABLE3, 9, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_TIMER1, "clk_timer1", "osc",
+	  CV182X_CLK_ENABLE3, 10, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_TIMER2, "clk_timer2", "osc",
+	  CV182X_CLK_ENABLE3, 11, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_TIMER3, "clk_timer3", "osc",
+	  CV182X_CLK_ENABLE3, 12, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_TIMER4, "clk_timer4", "osc",
+	  CV182X_CLK_ENABLE3, 13, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_TIMER5, "clk_timer5", "osc",
+	  CV182X_CLK_ENABLE3, 14, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_TIMER6, "clk_timer6", "osc",
+	  CV182X_CLK_ENABLE3, 15, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_TIMER7, "clk_timer7", "osc",
+	  CV182X_CLK_ENABLE3, 16, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_I2C0, "clk_apb_i2c0", "clk_div_axi4",
+	  CV182X_CLK_ENABLE3, 17, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_I2C1, "clk_apb_i2c1", "clk_div_axi4",
+	  CV182X_CLK_ENABLE3, 18, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_I2C2, "clk_apb_i2c2", "clk_div_axi4",
+	  CV182X_CLK_ENABLE3, 19, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_I2C3, "clk_apb_i2c3", "clk_div_axi4",
+	  CV182X_CLK_ENABLE3, 20, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_APB_I2C4, "clk_apb_i2c4", "clk_div_axi4",
+	  CV182X_CLK_ENABLE3, 21, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_WGN, "clk_wgn", "osc",
+	  CV182X_CLK_ENABLE3, 22, 0),
+	CLK_GATE(CV182X_CLK_WGN0, "clk_wgn0", "osc",
+	  CV182X_CLK_ENABLE3, 23, 0),
+	CLK_GATE(CV182X_CLK_WGN1, "clk_wgn1", "osc",
+	  CV182X_CLK_ENABLE3, 24, 0),
+	CLK_GATE(CV182X_CLK_WGN2, "clk_wgn2", "osc",
+	  CV182X_CLK_ENABLE3, 25, 0),
+	CLK_GATE(CV182X_CLK_KEYSCAN, "clk_keyscan", "osc",
+	  CV182X_CLK_ENABLE3, 26, 0),
+	CLK_GATE(CV182X_CLK_AHB_SF1, "clk_ahb_sf1", "clk_div_axi4",
+	  CV182X_CLK_ENABLE3, 27, 0),
+	CLK_GATE(CV182X_CLK_PAD_VI1_VIP, "clk_pad_vi1_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE3, 30, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_CFG_REG_VIP, "clk_cfg_reg_vip", "clk_mux_axi6",
+	  CV182X_CLK_ENABLE3, 31, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_CFG_REG_VC, "clk_cfg_reg_vc", "clk_mux_axi6",
+	  CV182X_CLK_ENABLE4, 0, 0),
+	CLK_GATE(CV182X_CLK_APB_AUDSRC, "clk_apb_audsrc", "clk_div_axi4",
+	  CV182X_CLK_ENABLE4, 2, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_PWM_SRC, "clk_pwm_src", "clk_mux_pwm_src",
+	  CV182X_CLK_ENABLE4, 4, 0),
+	CLK_GATE(CV182x_CLK_PAD_VI2_VIP, "clk_pad_vi2_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE4, 7, CLK_IS_CRITICAL),
+	CLK_GATE(CV182X_CLK_CSI_BE_VIP, "clk_csi_be_vip", "clk_axi_vip",
+	  CV182X_CLK_ENABLE4, 8, CLK_IS_CRITICAL),
+
+	//CLK_GATE(CV182X_CLK_AXI_VIDEO_CODEC, "clk_axi_video_codec", "clk_mux_axi_video_codec",
+	//	CV182X_CLK_ENABLE2, 8, 0),
+	CLK_GATE_IDLE(CV182X_CLK_AXI_VIDEO_CODEC, "clk_axi_video_codec", "clk_mux_axi_video_codec",
+		CV182X_CLK_ENABLE2, 8, 0, CV182X_VCSYS_BUS_IDLE, 0x7F),
+};
+
+static const char * const clk_axi6_parents[] = { "clk_div_1_axi6", "clk_div_0_axi6" };
+static const char * const clk_a53_parents[] = { "clk_div_1_a53", "clk_div_0_a53" };
+static const char * const clk_cpu_axi0_parents[] = { "clk_div_1_cpu_axi0", "clk_div_0_cpu_axi0" };
+static const char * const clk_tpu_parents[] = { "clk_div_1_tpu", "clk_div_0_tpu" };
+static const char * const clk_tpu_fab_parents[] = { "clk_div_1_tpu_fab", "clk_div_0_tpu_fab" };
+static const char * const clk_debug_parents[] = { "clk_mux_axi6", "osc" };
+static const char * const clk_emmc_parents[] = { "clk_div_1_emmc", "clk_div_0_emmc" };
+static const char * const clk_sd0_parents[] = { "clk_div_1_sd0", "clk_div_0_sd0" };
+static const char * const clk_sd1_parents[] = { "clk_div_1_sd1", "clk_div_0_sd1" };
+static const char * const clk_apb_pwm_parents[] = { "clk_mux_axi6", "clk_mux_pwm_src" };
+static const char * const clk_uart0_parents[] = { "clk_div_187p5m", "osc" };
+static const char * const clk_uart1_parents[] = { "clk_div_187p5m", "osc" };
+static const char * const clk_uart2_parents[] = { "clk_div_187p5m", "osc" };
+static const char * const clk_uart3_parents[] = { "clk_div_187p5m", "osc" };
+static const char * const clk_uart4_parents[] = { "clk_div_187p5m", "osc" };
+static const char * const clk_axi_vip_parents[] = { "clk_div_1_axi_vip", "clk_div_0_axi_vip" };
+static const char * const clk_src_vip_sys_0_parents[] = { "clk_div_1_src_vip_sys_0", "clk_div_0_src_vip_sys_0" };
+static const char * const clk_src_vip_sys_1_parents[] = { "clk_div_1_src_vip_sys_1", "clk_div_0_src_vip_sys_1" };
+static const char * const clk_axi_video_codec_parents[] = { "clk_div_1_axi_video_codec", "clk_div_0_axi_video_codec" };
+static const char * const clk_vc_src0_parents[] = { "clk_div_1_vc_src0", "clk_div_0_vc_src0" };
+static const char * const clk_vc_src1_parents[] = { "clk_div_1_vc_src1", "clk_div_0_vc_src1" };
+static const char * const clk_src_vip_sys_2_parents[] = { "clk_div_1_src_vip_sys_2", "clk_div_0_src_vip_sys_2" };
+static const char * const clk_pwm_src_parents[] = { "clk_div_1_pwm_src", "clk_div_0_pwm_src" };
+// static const char * const clk_axi_video_codec_1_parents[] = { "clk_mipimpll", "clk_cam1pll" };
+
+static const struct cv182x_mux_clock cv182x_mux_clks[] = {
+	{ CV182X_CLK_MUX_AXI6, "clk_mux_axi6", clk_axi6_parents, 2,
+	   CV182X_CLK_SELECT, 14, 0 },
+	{ CV182X_CLK_MUX_PWM_SRC, "clk_mux_pwm_src", clk_pwm_src_parents, 2,
+	   CV182X_CLK_SELECT, 22, 0 },
+	{ CV182X_CLK_MUX_AXI_VIDEO_CODEC, "clk_mux_axi_video_codec", clk_axi_video_codec_parents, 2,
+	   CV182X_CLK_SELECT, 18, 0 },
+	// ECO bit for clk_axi_video_codec divider1
+	// { CV182X_CLK_MUX_AXI_VIDEO_CODEC_1, "clk_mux_axi_video_codec_1", clk_axi_video_codec_1_parents, 2,
+	//    CV182X_CLK_SELECT, 31, 0 },
+};
+
+/*
+ * Clocks marked as CRITICAL are needed for the proper functioning
+ * of the SoC.
+ */
+static struct cv182x_div_hw_clock cv182x_div_clks[] = {
+	CLK_DIV(CV182X_CLK_DIV_0_A53, "clk_div_0_a53", "clk_mpll",
+		CV182X_CLK_A53_DIV0, 16, 5, 1, NULL, CLK_SET_RATE_PARENT),
+	CLK_DIV(CV182X_CLK_DIV_1_A53, "clk_div_1_a53", "clk_fpll",
+		CV182X_CLK_A53_DIV1, 16, 5, 2, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_0_CPU_AXI0, "clk_div_0_cpu_axi0", "clk_mipimpll",
+		CV182X_CLK_CPU_AXI0_DIV0, 16, 5, 2, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_1_CPU_AXI0, "clk_div_1_cpu_axi0", "clk_fpll",
+		CV182X_CLK_CPU_AXI0_DIV1, 16, 5, 3, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_0_TPU, "clk_div_0_tpu", "clk_tpll",
+		CV182X_CLK_TPU_DIV0, 16, 5, 2, NULL, CLK_SET_RATE_PARENT),
+	CLK_DIV(CV182X_CLK_DIV_1_TPU, "clk_div_1_tpu", "clk_fpll",
+		CV182X_CLK_TPU_DIV1, 16, 5, 3, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_0_TPU_FAB, "clk_div_0_tpu_fab", "clk_mipimpll",
+		CV182X_CLK_TPU_FAB_DIV0, 16, 5, 4, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_1_TPU_FAB, "clk_div_1_tpu_fab", "clk_fpll",
+		CV182X_CLK_TPU_FAB_DIV1, 16, 5, 5, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_0_EMMC, "clk_div_0_emmc", "clk_fpll",
+		CV182X_CLK_EMMC_DIV0, 16, 5, 15, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_1_EMMC, "clk_div_1_emmc", "clk_disppll",
+		CV182X_CLK_EMMC_DIV1, 16, 5, 12, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_0_SD0, "clk_div_0_sd0", "clk_fpll",
+		CV182X_CLK_SD0_DIV0, 16, 5, 15, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_1_SD0, "clk_div_1_sd0", "clk_disppll",
+		CV182X_CLK_SD0_DIV1, 16, 5, 12, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_0_SD1, "clk_div_0_sd1", "clk_fpll",
+		CV182X_CLK_SD1_DIV0, 16, 5, 15, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_1_SD1, "clk_div_1_sd1", "clk_disppll",
+		CV182X_CLK_SD1_DIV1, 16, 5, 12, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_AXI4, "clk_div_axi4", "clk_fpll",
+		CV182X_CLK_AXI4_DIV, 16, 5, 5, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_0_AXI6, "clk_div_0_axi6", "clk_fpll",
+		CV182X_CLK_AXI6_DIV0, 16, 5, 15, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_1_AXI6, "clk_div_1_axi6", "clk_mpll",
+		CV182X_CLK_AXI6_DIV1, 16, 5, 9, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_0_AXI_VIP, "clk_div_0_axi_vip", "clk_mipimpll",
+		CV182X_CLK_AXI_VIP_DIV0, 16, 5, 4, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_1_AXI_VIP, "clk_div_1_axi_vip", "clk_fpll",
+		CV182X_CLK_AXI_VIP_DIV1, 16, 5, 5, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_0_SRC_VIP_SYS_0, "clk_div_0_src_vip_sys_0", "clk_mipimpll",
+		CV182X_CLK_SRC_VIP_SYS_0_DIV0, 16, 5, 6, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_1_SRC_VIP_SYS_0, "clk_div_1_src_vip_sys_0", "clk_fpll",
+		CV182X_CLK_SRC_VIP_SYS_0_DIV1, 16, 5, 8, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_0_SRC_VIP_SYS_1, "clk_div_0_src_vip_sys_1", "clk_fpll",
+		CV182X_CLK_SRC_VIP_SYS_1_DIV0, 16, 5, 5, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_1_SRC_VIP_SYS_1, "clk_div_1_src_vip_sys_1", "clk_mipimpll",
+		CV182X_CLK_SRC_VIP_SYS_1_DIV1, 16, 5, 4, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_0_AXI_VIDEO_CODEC, "clk_div_0_axi_video_codec", "clk_fpll",
+		CV182X_CLK_AXI_VIDEO_CODEC_DIV0, 16, 4, 5, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_1_AXI_VIDEO_CODEC, "clk_div_1_axi_video_codec", "clk_cam1pll",
+		CV182X_CLK_AXI_VIDEO_CODEC_DIV1, 16, 4, 4, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_0_VC_SRC0, "clk_div_0_vc_src0", "clk_fpll",
+		CV182X_CLK_VC_SRC0_DIV0, 16, 4, 4, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_1_VC_SRC0, "clk_div_1_vc_src0", "clk_a0pll",
+		CV182X_CLK_VC_SRC0_DIV1, 16, 4, 2, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_1M, "clk_div_1m", "osc",
+		CV182X_CLK_1M_DIV, 16, 6, 25, NULL, CLK_IS_CRITICAL),
+	CLK_DIV(CV182X_CLK_DIV_0_VC_SRC1, "clk_div_0_vc_src1", "clk_cam1pll",
+		CV182X_CLK_VC_SRC1_DIV0, 16, 4, 2, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_1_VC_SRC1, "clk_div_1_vc_src1", "clk_fpll",
+		CV182X_CLK_VC_SRC1_DIV1, 16, 4, 3, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_0_SRC_VIP_SYS_2, "clk_div_0_src_vip_sys_2", "clk_mipimpll",
+		CV182X_CLK_SRC_VIP_SYS_2_DIV0, 16, 5, 2, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_1_SRC_VIP_SYS_2, "clk_div_1_src_vip_sys_2", "clk_fpll",
+		CV182X_CLK_SRC_VIP_SYS_2_DIV1, 16, 5, 4, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_0_PWM_SRC, "clk_div_0_pwm_src", "clk_disppll",
+		CV182X_CLK_PWM_SRC_DIV0, 16, 6, 8, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_1_PWM_SRC, "clk_div_1_pwm_src", "clk_cam0pll",
+		CV182X_CLK_PWM_SRC_DIV1, 16, 6, 8, NULL, 0),
+	CLK_DIV(CV182X_CLK_DIV_187P5M, "clk_div_187p5m", "clk_fpll",
+	  CV182X_CLK_187P5M_DIV, 16, 5, 8, NULL, 0),
+};
+
+/*
+ * Clocks marked as CRITICAL are all needed for the proper functioning
+ * of the SoC.
+ */
+static struct cv182x_composite_clock cv182x_composite_clks[] = {
+	GATE_MUX(CV182X_CLK_A53, "clk_a53", clk_a53_parents,
+		CV182X_CLK_ENABLE0, 0, CV182X_CLK_SELECT, 0, CLK_IS_CRITICAL),
+	GATE_MUX(CV182X_CLK_CPU_AXI0, "clk_cpu_axi0", clk_cpu_axi0_parents,
+		CV182X_CLK_ENABLE0, 1, CV182X_CLK_SELECT, 1, CLK_IS_CRITICAL),
+	GATE_MUX(CV182X_CLK_TPU, "clk_tpu", clk_tpu_parents,
+		CV182X_CLK_ENABLE0, 4, CV182X_CLK_SELECT, 2, 0),
+	GATE_MUX(CV182X_CLK_TPU_FAB, "clk_tpu_fab", clk_tpu_fab_parents,
+		CV182X_CLK_ENABLE0, 5, CV182X_CLK_SELECT, 3, 0),
+	GATE_MUX(CV182X_CLK_DEBUG, "clk_debug", clk_debug_parents,
+		CV182X_CLK_ENABLE0, 13, CV182X_CLK_SELECT, 4, CLK_IS_CRITICAL),
+	GATE_MUX(CV182X_CLK_EMMC, "clk_emmc", clk_emmc_parents,
+		CV182X_CLK_ENABLE0, 16, CV182X_CLK_SELECT, 5, CLK_IS_CRITICAL),
+	GATE_MUX(CV182X_CLK_SD0, "clk_sd0", clk_sd0_parents,
+		CV182X_CLK_ENABLE0, 19, CV182X_CLK_SELECT, 6, CLK_IS_CRITICAL),
+	GATE_MUX(CV182X_CLK_SD1, "clk_sd1", clk_sd1_parents,
+		CV182X_CLK_ENABLE0, 22, CV182X_CLK_SELECT, 7, CLK_IS_CRITICAL),
+	GATE_MUX(CV182X_CLK_APB_PWM, "clk_apb_pwm", clk_apb_pwm_parents,
+		CV182X_CLK_ENABLE1, 8, CV182X_CLK_SELECT, 8, CLK_IS_CRITICAL),
+	GATE_MUX(CV182X_CLK_UART0, "clk_uart0", clk_uart0_parents,
+		CV182X_CLK_ENABLE1, 14, CV182X_CLK_SELECT, 9, CLK_IS_CRITICAL),
+	GATE_MUX(CV182X_CLK_UART1, "clk_uart1", clk_uart1_parents,
+		CV182X_CLK_ENABLE1, 16, CV182X_CLK_SELECT, 10, CLK_IS_CRITICAL),
+	GATE_MUX(CV182X_CLK_UART2, "clk_uart2", clk_uart2_parents,
+		CV182X_CLK_ENABLE1, 18, CV182X_CLK_SELECT, 11, CLK_IS_CRITICAL),
+	GATE_MUX(CV182X_CLK_UART3, "clk_uart3", clk_uart3_parents,
+		CV182X_CLK_ENABLE1, 20, CV182X_CLK_SELECT, 12, CLK_IS_CRITICAL),
+	GATE_MUX(CV182X_CLK_UART4, "clk_uart4", clk_uart4_parents,
+		CV182X_CLK_ENABLE1, 22, CV182X_CLK_SELECT, 13, CLK_IS_CRITICAL),
+	GATE_MUX(CV182X_CLK_AXI_VIP, "clk_axi_vip", clk_axi_vip_parents,
+		CV182X_CLK_ENABLE2, 4, CV182X_CLK_SELECT, 15, 0),
+	GATE_MUX(CV182X_CLK_SRC_VIP_SYS_0, "clk_src_vip_sys_0", clk_src_vip_sys_0_parents,
+		CV182X_CLK_ENABLE2, 5, CV182X_CLK_SELECT, 16, 0),
+	GATE_MUX(CV182X_CLK_SRC_VIP_SYS_1, "clk_src_vip_sys_1", clk_src_vip_sys_1_parents,
+		CV182X_CLK_ENABLE2, 6, CV182X_CLK_SELECT, 17, 0),
+	//GATE_MUX(CV182X_CLK_AXI_VIDEO_CODEC, "clk_axi_video_codec", clk_axi_video_codec_parents,
+	//	CV182X_CLK_ENABLE2, 8, CV182X_CLK_SELECT, 18, 0),
+	GATE_MUX(CV182X_CLK_VC_SRC0, "clk_vc_src0", clk_vc_src0_parents,
+		CV182X_CLK_ENABLE2, 9, CV182X_CLK_SELECT, 19, 0),
+	GATE_MUX(CV182X_CLK_VC_SRC1, "clk_vc_src1", clk_vc_src1_parents,
+		CV182X_CLK_ENABLE3, 28, CV182X_CLK_SELECT, 20, 0),
+	GATE_MUX(CV182X_CLK_SRC_VIP_SYS_2, "clk_src_vip_sys_2", clk_src_vip_sys_2_parents,
+		CV182X_CLK_ENABLE3, 29, CV182X_CLK_SELECT, 21, 0),
+	GATE_DIV(CV182X_CLK_CPU_GIC, "clk_cpu_gic", "clk_fpll",
+		CV182X_CLK_ENABLE0, 2, CV182X_CLK_CPU_GIC_DIV, 16, 5, 5, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV182X_CLK_100K_EMMC, "clk_100k_emmc", "clk_div_1m",
+		CV182X_CLK_ENABLE0, 17, CV182X_CLK_100K_EMMC_DIV, 16, 8, 10, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV182X_CLK_100K_SD0, "clk_100k_sd0", "clk_div_1m",
+		CV182X_CLK_ENABLE0, 20, CV182X_CLK_100K_SD0_DIV, 16, 8, 10, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV182X_CLK_100K_SD1, "clk_100k_sd1", "clk_div_1m",
+		CV182X_CLK_ENABLE0, 23, CV182X_CLK_100K_SD1_DIV, 16, 8, 10, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV182X_CLK_SPI_NAND, "clk_spi_nand", "clk_fpll",
+		CV182X_CLK_ENABLE0, 24, CV182X_CLK_SPI_NAND_DIV, 16, 5, 8, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV182X_CLK_500M_ETH0, "clk_500m_eth0", "clk_fpll",
+		CV182X_CLK_ENABLE0, 25, CV182X_CLK_500M_ETH0_DIV, 16, 5, 3, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV182X_CLK_500M_ETH1, "clk_500m_eth1", "clk_fpll",
+		CV182X_CLK_ENABLE0, 27, CV182X_CLK_500M_ETH1_DIV, 16, 5, 3, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV182X_CLK_GPIO_DB, "clk_gpio_db", "clk_div_1m",
+		CV182X_CLK_ENABLE0, 31, CV182X_CLK_GPIO_DB_DIV, 16, 16, 10, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV182X_CLK_SDMA_AUD0, "clk_sdma_aud0", "clk_a0pll",
+		CV182X_CLK_ENABLE1, 2, CV182X_CLK_SDMA_AUD0_DIV, 16, 8, 18, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV182X_CLK_SDMA_AUD1, "clk_sdma_aud1", "clk_a0pll",
+		CV182X_CLK_ENABLE1, 3, CV182X_CLK_SDMA_AUD1_DIV, 16, 8, 18, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV182X_CLK_SDMA_AUD2, "clk_sdma_aud2", "clk_a0pll",
+		CV182X_CLK_ENABLE1, 4, CV182X_CLK_SDMA_AUD2_DIV, 16, 8, 18, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV182X_CLK_SDMA_AUD3, "clk_sdma_aud3", "clk_a0pll",
+		CV182X_CLK_ENABLE1, 5, CV182X_CLK_SDMA_AUD3_DIV, 16, 8, 18, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV182X_CLK_125M_USB, "clk_125m_usb", "clk_fpll",
+		CV182X_CLK_ENABLE1, 30, CV182X_CLK_125M_USB_DIV, 16, 5, 12, NULL, 0),
+	GATE_DIV(CV182X_CLK_33K_USB, "clk_33k_usb", "clk_div_1m",
+		CV182X_CLK_ENABLE1, 31, CV182X_CLK_33K_USB_DIV, 16, 9, 1, NULL, 0),
+	GATE_DIV(CV182X_CLK_12M_USB, "clk_12m_usb", "clk_fpll",
+		CV182X_CLK_ENABLE2, 0, CV182X_CLK_12M_USB_DIV, 16, 7, 125, NULL, 0),
+	GATE_DIV(CV182X_CLK_DSI_ESC, "clk_dsi_esc", "clk_mux_axi6",
+		CV182X_CLK_ENABLE2, 3, CV182X_CLK_DSI_ESC_DIV, 16, 5, 5, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV182X_CLK_DISP_SRC_VIP, "clk_disp_src_vip", "clk_disppll",
+		CV182X_CLK_ENABLE2, 7, CV182X_CLK_DISP_SRC_VIP_DIV, 16, 6, 8, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV182X_CLK_CAM0, "clk_cam0", "clk_cam0pll",
+		CV182X_CLK_ENABLE2, 16, CV182X_CLK_CAM0_DIV, 16, 6, 14, NULL, 0),
+	GATE_DIV(CV182X_CLK_CAM1, "clk_cam1", "clk_cam1pll",
+		CV182X_CLK_ENABLE2, 17, CV182X_CLK_CAM1_DIV, 16, 6, 14, NULL, 0),
+	GATE_DIV(CV182X_CLK_SPI, "clk_spi", "clk_fpll",
+		CV182X_CLK_ENABLE3, 6, CV182X_CLK_SPI_DIV, 16, 6, 8, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV182X_CLK_I2C, "clk_i2c", "clk_mux_axi6",
+		CV182X_CLK_ENABLE3, 7, CV182X_CLK_I2C_DIV, 16, 4, 1, NULL, 0),
+	GATE_DIV(CV182X_CLK_AUDSRC, "clk_audsrc", "clk_a0pll",
+		CV182X_CLK_ENABLE4, 1, CV182X_CLK_AUDSRC_DIV, 16, 8, 18, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV182X_CLK_VC_SRC2, "clk_vc_src2", "clk_fpll",
+		CV182X_CLK_ENABLE4, 3, CV182X_CLK_VC_SRC2_DIV, 16, 4, 3, NULL, 0),
+	GATE_DIV(CV182x_CLK_AP_DEBUG, "clk_ap_debug", "clk_fpll",
+		CV182X_CLK_ENABLE4, 5, CV182X_CLK_AP_DEBUG_DIV, 16, 5, 5, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV182x_CLK_SRC_RTC_SYS_0, "clk_src_rtc_sys_0", "clk_fpll",
+		CV182X_CLK_ENABLE4, 6, CV182X_CLK_SRC_RTC_SYS_0_DIV, 16, 5, 5, NULL, CLK_IS_CRITICAL),
+};
+
+static int __init cvi_clk_flags_setup(char *arg)
+{
+	int ret;
+	unsigned long flags;
+
+	ret = kstrtol(arg, 0, &flags);
+	if (ret)
+		return ret;
+
+	cvi_clk_flags = flags;
+	pr_info("cvi_clk_flags = 0x%lX\n", cvi_clk_flags);
+
+	return 1;
+}
+__setup("cvi_clk_flags=", cvi_clk_flags_setup);
+
+static unsigned long cv182x_pll_rate_calc(u32 regval, unsigned long parent_rate)
+{
+	u64 numerator;
+	u32 predivsel, postdivsel, divsel;
+	u32 denominator;
+
+	predivsel = regval & 0x7f;
+	postdivsel = (regval >> 8) & 0x7f;
+	divsel = (regval >> 17) & 0x7f;
+
+	numerator = parent_rate * divsel;
+	denominator = predivsel * postdivsel;
+	do_div(numerator, denominator);
+
+	return (unsigned long)numerator;
+}
+
+static unsigned long cv182x_g6_pll_recalc_rate(struct clk_hw *hw,
+					       unsigned long parent_rate)
+{
+	struct cv182x_pll_hw_clock *pll_hw = to_cv182x_pll_clk(hw);
+	unsigned long rate;
+	u32 regval;
+
+	regval = readl(pll_hw->base + pll_hw->pll.reg_csr);
+	rate = cv182x_pll_rate_calc(regval, parent_rate);
+
+	return rate;
+}
+
+static long cv182x_g6_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+				     unsigned long *prate)
+{
+	return rate;
+}
+
+static int cv182x_g6_pll_calc_csr(unsigned long parent_rate, unsigned long rate, u32 *csr)
+{
+	u64 numerator;
+	u32 denominator;
+	u32 divsel;		/* [23:17] DIV_SEL */
+	u32 postdivsel = 1;	/* [14:8] POST_DIV_SEL */
+	u32 ictrl = 7;		/* [26:24] ICTRL */
+	u32 selmode = 1;	/* [16:15] SEL_MODE */
+	u32 predivsel = 1;	/* [6:0] PRE_DIV_SEL */
+	u32 vco_clks[] = {900, 1000, 1100, 1200, 1300, 1400, 1500, 1600};
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(vco_clks); i++) {
+		if ((vco_clks[i] * 1000000) % rate == 0) {
+			postdivsel = vco_clks[i] * 1000000 / rate;
+			rate = vco_clks[i] * 1000000;
+			pr_debug("rate=%ld, postdivsel=%d\n", rate, postdivsel);
+			break;
+		}
+	}
+
+	numerator = rate;
+	denominator = parent_rate;
+
+	do_div(numerator, denominator);
+
+	divsel = (u32)numerator & 0x7f;
+	*csr = (divsel << 17) | (postdivsel << 8) | (ictrl << 24) | (selmode << 15) | predivsel;
+
+	pr_debug("csr=0x%08x\n", *csr);
+
+	return 0;
+}
+
+static int cv182x_g6_pll_set_rate(struct clk_hw *hw, unsigned long rate,
+				  unsigned long parent_rate)
+{
+	struct cv182x_pll_hw_clock *pll_hw = to_cv182x_pll_clk(hw);
+	unsigned long flags = 0;
+	int ret;
+	u32 reg_g6_pll_status;
+	u32 regval_csr;
+	u32 regval_g6_pll_status;
+
+	reg_g6_pll_status = (pll_hw->pll.reg_csr & ~PLL_STATUS_MASK) + PLL_STATUS_OFFSET;
+
+	if (pll_hw->lock)
+		spin_lock_irqsave(pll_hw->lock, flags);
+	else
+		__acquire(pll_hw->lock);
+
+	/* calculate csr register */
+	ret = cv182x_g6_pll_calc_csr(parent_rate, rate, &regval_csr);
+	if (ret < 0)
+		return ret;
+
+	/* csr register */
+	writel(regval_csr, pll_hw->base + pll_hw->pll.reg_csr);
+
+	/* wait for pll setting updated */
+	do {
+		regval_g6_pll_status = readl(pll_hw->base + reg_g6_pll_status);
+	} while (regval_g6_pll_status & 0x07);
+
+	if (pll_hw->lock)
+		spin_unlock_irqrestore(pll_hw->lock, flags);
+	else
+		__release(pll_hw->lock);
+
+	return 0;
+}
+
+static const struct clk_ops cv182x_g6_pll_ops = {
+	.recalc_rate = cv182x_g6_pll_recalc_rate,
+	.round_rate = cv182x_g6_pll_round_rate,
+	.set_rate = cv182x_g6_pll_set_rate,
+};
+
+static unsigned long cv182x_g2_pll_recalc_rate(struct clk_hw *hw,
+					       unsigned long parent_rate)
+{
+	struct cv182x_pll_hw_clock *pll_hw = to_cv182x_pll_clk(hw);
+	u32 reg_ssc_set;
+	u32 reg_g2_ssc_ctrl;
+	u32 regval_csr;
+	u32 regval_ssc_set;
+	u32 regval_g2_ssc_ctrl;
+	u64 numerator;
+	u32 denominator;
+	unsigned long clk_ref;
+	unsigned long rate;
+
+	regval_csr = readl(pll_hw->base + pll_hw->pll.reg_csr);
+
+	/* pll without synthesizer */
+	if (pll_hw->pll.reg_ssc == 0) {
+		clk_ref = parent_rate;
+		goto rate_calc;
+	}
+
+	/* calculate synthesizer freq */
+	reg_ssc_set = (pll_hw->pll.reg_ssc & ~SSC_SYN_SET_MASK) + SSC_SYN_SET_OFFSET;
+	reg_g2_ssc_ctrl = (pll_hw->pll.reg_ssc & ~G2_SSC_CTRL_MASK) + G2_SSC_CTRL_OFFSET;
+
+	regval_ssc_set = readl(pll_hw->base + reg_ssc_set);
+	regval_g2_ssc_ctrl = readl(pll_hw->base + reg_g2_ssc_ctrl);
+
+	/* bit0 sel_syn_clk */
+	numerator = (regval_g2_ssc_ctrl & 0x1) ? parent_rate : (parent_rate >> 1);
+
+	numerator <<= 26;
+	denominator = regval_ssc_set;
+	do_div(numerator, denominator);
+
+	clk_ref = numerator;
+
+rate_calc:
+	rate = cv182x_pll_rate_calc(regval_csr, clk_ref);
+
+	return rate;
+}
+
+static const struct {
+	unsigned long rate;
+	u32 csr;
+	u32 ssc_set;
+} g2_pll_rate_lut[] = {
+	{.rate = 48000000, .csr = 0x00129201, .ssc_set = 419430400},
+	{.rate = 406425600, .csr = 0x01108201, .ssc_set = 396287226},
+	{.rate = 417792000, .csr = 0x01108201, .ssc_set = 385505882},
+	{.rate = 768000000, .csr = 0x00108101, .ssc_set = 419430400},
+	{.rate = 832000000, .csr = 0x00108101, .ssc_set = 387166523},
+	{.rate = 1032000000, .csr = 0x00148101, .ssc_set = 390167814},
+	{.rate = 1050000000, .csr = 0x00168101, .ssc_set = 421827145},
+	{.rate = 1056000000, .csr = 0x00208100, .ssc_set = 412977625},
+	{.rate = 1125000000, .csr = 0x00168101, .ssc_set = 393705325},
+	{.rate = 1188000000, .csr = 0x00188101, .ssc_set = 406720388},
+};
+
+static int cv182x_g2_pll_get_setting_from_lut(unsigned long rate, u32 *csr,
+					      u32 *ssc_set)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(g2_pll_rate_lut); i++) {
+		if (rate == g2_pll_rate_lut[i].rate) {
+			*csr = g2_pll_rate_lut[i].csr;
+			*ssc_set = g2_pll_rate_lut[i].ssc_set;
+			return 0;
+		}
+	}
+
+	*csr = 0;
+	*ssc_set = 0;
+	return -ENOENT;
+}
+
+static long cv182x_g2_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+				     unsigned long *prate)
+{
+	return rate;
+}
+
+static int cv182x_g2_pll_set_rate(struct clk_hw *hw, unsigned long rate,
+				  unsigned long parent_rate)
+{
+	struct cv182x_pll_hw_clock *pll_hw = to_cv182x_pll_clk(hw);
+	unsigned long flags = 0;
+	int ret;
+	u32 reg_ssc_set;
+	u32 reg_ssc_ctrl;
+	u32 reg_g2_pll_status;
+	u32 regval_csr;
+	u32 regval_ssc_set;
+	u32 regval_ssc_ctrl;
+	u32 regval_g2_pll_status;
+
+	/* pll without synthesizer */
+	if (pll_hw->pll.reg_ssc == 0)
+		return -ENOENT;
+
+	ret = cv182x_g2_pll_get_setting_from_lut(rate, &regval_csr,
+						 &regval_ssc_set);
+	if (ret < 0)
+		return ret;
+
+	reg_ssc_set = (pll_hw->pll.reg_ssc & ~SSC_SYN_SET_MASK) + SSC_SYN_SET_OFFSET;
+	reg_ssc_ctrl = pll_hw->pll.reg_ssc;
+	reg_g2_pll_status = (pll_hw->pll.reg_csr & ~PLL_STATUS_MASK) + PLL_STATUS_OFFSET;
+
+	if (pll_hw->lock)
+		spin_lock_irqsave(pll_hw->lock, flags);
+	else
+		__acquire(pll_hw->lock);
+
+	/* set synthersizer */
+	writel(regval_ssc_set, pll_hw->base + reg_ssc_set);
+
+	/* bit 0 toggle */
+	regval_ssc_ctrl = readl(pll_hw->base + reg_ssc_ctrl);
+	regval_ssc_ctrl ^= 0x00000001;
+	writel(regval_ssc_ctrl, pll_hw->base + reg_ssc_ctrl);
+
+	/* csr register */
+	writel(regval_csr, pll_hw->base + pll_hw->pll.reg_csr);
+
+	/* wait for pll setting updated */
+	do {
+		regval_g2_pll_status = readl(pll_hw->base + reg_g2_pll_status);
+	} while (regval_g2_pll_status & 0x1F);
+
+	if (pll_hw->lock)
+		spin_unlock_irqrestore(pll_hw->lock, flags);
+	else
+		__release(pll_hw->lock);
+
+	return 0;
+}
+
+static const struct clk_ops cv182x_g2_pll_ops = {
+	.recalc_rate = cv182x_g2_pll_recalc_rate,
+	.round_rate = cv182x_g2_pll_round_rate,
+	.set_rate = cv182x_g2_pll_set_rate,
+};
+
+static struct clk_hw *cv182x_clk_register_pll(struct cv182x_pll_hw_clock *pll_clk,
+					      void __iomem *sys_base)
+{
+	struct clk_hw *hw;
+	struct clk_init_data init;
+	int err;
+
+	pll_clk->lock = &cv182x_clk_lock;
+	pll_clk->base = sys_base;
+
+	if (cvi_clk_flags) {
+		/* copy clk_init_data for modification */
+		memcpy(&init, pll_clk->hw.init, sizeof(init));
+
+		init.flags |= cvi_clk_flags;
+		pll_clk->hw.init = &init;
+	}
+
+	hw = &pll_clk->hw;
+
+	err = clk_hw_register(NULL, hw);
+	if (err)
+		return ERR_PTR(err);
+
+	return hw;
+}
+
+static void cv182x_clk_unregister_pll(struct clk_hw *hw)
+{
+	struct cv182x_pll_hw_clock *pll_hw = to_cv182x_pll_clk(hw);
+
+	clk_hw_unregister(hw);
+	kfree(pll_hw);
+}
+
+static int cv182x_clk_register_plls(struct cv182x_pll_hw_clock *clks,
+				    int num_clks,
+				    struct cv182x_clock_data *data)
+{
+	struct clk_hw *hw;
+	void __iomem *pll_base = data->base;
+	int i;
+
+	for (i = 0; i < num_clks; i++) {
+		struct cv182x_pll_hw_clock *cv182x_clk = &clks[i];
+
+		hw = cv182x_clk_register_pll(cv182x_clk, pll_base);
+		if (IS_ERR(hw)) {
+			pr_err("%s: failed to register clock %s\n",
+			       __func__, cv182x_clk->pll.name);
+			goto err_clk;
+		}
+
+		data->hw_data.hws[clks[i].pll.id] = hw;
+
+		clk_hw_register_clkdev(hw, cv182x_clk->pll.name, NULL);
+	}
+
+	return 0;
+
+err_clk:
+	while (i--)
+		cv182x_clk_unregister_pll(data->hw_data.hws[clks[i].pll.id]);
+
+	return PTR_ERR(hw);
+}
+
+static int cv182x_clk_register_mux(const struct cv182x_mux_clock *clks,
+				   int num_clks,
+				   struct cv182x_clock_data *data)
+{
+	struct clk_hw *hw;
+	void __iomem *sys_base = data->base;
+	int i;
+
+	for (i = 0; i < num_clks; i++) {
+		hw = clk_hw_register_mux(NULL, clks[i].name,
+					 clks[i].parents,
+					 clks[i].num_parents,
+					 clks[i].flags | cvi_clk_flags,
+					 sys_base + clks[i].reg,
+					 clks[i].shift, 1, 0,
+					 &cv182x_clk_lock);
+		if (IS_ERR(hw)) {
+			pr_err("%s: failed to register clock %s\n",
+			       __func__, clks[i].name);
+			goto err_clk;
+		}
+
+		data->hw_data.hws[clks[i].id] = hw;
+
+		clk_hw_register_clkdev(hw, clks[i].name, NULL);
+	}
+
+	return 0;
+
+err_clk:
+	while (i--)
+		clk_hw_unregister_mux(data->hw_data.hws[clks[i].id]);
+
+	return PTR_ERR(hw);
+}
+
+static unsigned long cv182x_clk_div_recalc_rate(struct clk_hw *hw,
+						unsigned long parent_rate)
+{
+	struct cv182x_div_hw_clock *div_hw = to_cv182x_div_clk(hw);
+	struct cv182x_div_clock *div = &div_hw->div;
+	void __iomem *reg_addr = div_hw->base + div->reg;
+	unsigned int val;
+	unsigned long rate;
+
+	if (!(readl(reg_addr) & BIT(3))) {
+		val = div->initval;
+	} else {
+		val = readl(reg_addr) >> div->shift;
+		val &= div_mask(div->width);
+	}
+
+	rate = divider_recalc_rate(hw, parent_rate, val, div->table,
+				   div->div_flags, div->width);
+
+	return rate;
+}
+
+static long cv182x_clk_div_round_rate(struct clk_hw *hw, unsigned long rate,
+				      unsigned long *prate)
+{
+	struct cv182x_div_hw_clock *div_hw = to_cv182x_div_clk(hw);
+	struct cv182x_div_clock *div = &div_hw->div;
+
+	return divider_round_rate(hw, rate, prate, div->table,
+				  div->width, div->div_flags);
+}
+
+
+static int cv182x_clk_div_determine_rate(struct clk_hw *hw,
+					 struct clk_rate_request *req)
+{
+	req->rate = cv182x_clk_div_round_rate(hw, min(req->rate, req->max_rate),
+					      &req->best_parent_rate);
+	return 0;
+}
+
+static int cv182x_clk_div_set_rate(struct clk_hw *hw, unsigned long rate,
+				   unsigned long parent_rate)
+{
+	struct cv182x_div_hw_clock *div_hw = to_cv182x_div_clk(hw);
+	struct cv182x_div_clock *div = &div_hw->div;
+	void __iomem *reg_addr = div_hw->base + div->reg;
+	unsigned long flags = 0;
+	int value;
+	u32 val;
+
+	value = divider_get_val(rate, parent_rate, div->table,
+				div->width, div_hw->div.div_flags);
+	if (value < 0)
+		return value;
+
+	if (div_hw->lock)
+		spin_lock_irqsave(div_hw->lock, flags);
+	else
+		__acquire(div_hw->lock);
+
+	val = readl(reg_addr);
+	val &= ~(div_mask(div->width) << div_hw->div.shift);
+	val |= (u32)value << div->shift;
+	val |= BIT(3);
+	writel(val, reg_addr);
+
+	if (div_hw->lock)
+		spin_unlock_irqrestore(div_hw->lock, flags);
+	else
+		__release(div_hw->lock);
+
+	return 0;
+}
+
+static const struct clk_ops cv182x_clk_div_ops = {
+	.recalc_rate = cv182x_clk_div_recalc_rate,
+	.round_rate = cv182x_clk_div_round_rate,
+	.determine_rate = cv182x_clk_div_determine_rate,
+	.set_rate = cv182x_clk_div_set_rate,
+};
+
+static struct clk_hw *cv182x_clk_register_div(struct cv182x_div_hw_clock *div_clk,
+					      void __iomem *sys_base)
+{
+	struct clk_hw *hw;
+	struct clk_init_data init;
+	int err;
+
+	div_clk->div.div_flags = CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO |
+				 CLK_DIVIDER_ROUND_CLOSEST;
+	div_clk->base = sys_base;
+	div_clk->lock = &cv182x_clk_lock;
+
+	if (cvi_clk_flags) {
+		/* copy clk_init_data for modification */
+		memcpy(&init, div_clk->hw.init, sizeof(init));
+
+		init.flags |= cvi_clk_flags;
+		div_clk->hw.init = &init;
+	}
+
+	hw = &div_clk->hw;
+	err = clk_hw_register(NULL, hw);
+	if (err)
+		return ERR_PTR(err);
+
+	return hw;
+}
+
+static void cv182x_clk_unregister_div(struct clk_hw *hw)
+{
+	struct cv182x_div_hw_clock *div_hw = to_cv182x_div_clk(hw);
+
+	clk_hw_unregister(hw);
+	kfree(div_hw);
+}
+
+static int cv182x_clk_register_divs(struct cv182x_div_hw_clock *clks,
+				    int num_clks,
+				    struct cv182x_clock_data *data)
+{
+	struct clk_hw *hw;
+	void __iomem *sys_base = data->base;
+	unsigned int i;
+
+	for (i = 0; i < num_clks; i++) {
+		struct cv182x_div_hw_clock *cv182x_clk = &clks[i];
+
+		hw = cv182x_clk_register_div(cv182x_clk, sys_base);
+		if (IS_ERR(hw)) {
+			pr_err("%s: failed to register clock %s\n",
+			       __func__, cv182x_clk->div.name);
+			goto err_clk;
+		}
+
+		data->hw_data.hws[clks[i].div.id] = hw;
+
+		clk_hw_register_clkdev(hw, cv182x_clk->div.name, NULL);
+	}
+
+	return 0;
+
+err_clk:
+	while (i--)
+		cv182x_clk_unregister_div(data->hw_data.hws[clks[i].div.id]);
+
+	return PTR_ERR(hw);
+}
+
+static void cv182x_clk_gate_endisable(struct clk_hw *hw, int enable)
+{
+	struct cv182x_gate_hw_clock *gate_hw = to_cv182x_gate_clk(hw);
+	struct cv182x_gate_clock *gate = &gate_hw->gate;
+	void __iomem *reg_addr = gate_hw->base + gate->reg;
+	unsigned long flags = 0;
+	u32 reg;
+
+	if (gate_hw->lock)
+		spin_lock_irqsave(gate_hw->lock, flags);
+	else
+		__acquire(gate_hw->lock);
+
+	reg = readl(reg_addr);
+
+	if (enable)
+		reg |= BIT(gate->shift);
+	else
+		reg &= ~BIT(gate->shift);
+
+	writel(reg, reg_addr);
+
+	if (gate_hw->lock)
+		spin_unlock_irqrestore(gate_hw->lock, flags);
+	else
+		__release(gate_hw->lock);
+}
+
+static int cv182x_clk_gate_enable(struct clk_hw *hw)
+{
+	cv182x_clk_gate_endisable(hw, 1);
+
+	return 0;
+}
+
+static void cv182x_clk_gate_disable(struct clk_hw *hw)
+{
+	struct cv182x_gate_hw_clock *gate_hw = to_cv182x_gate_clk(hw);
+	struct cv182x_gate_clock *gate = &gate_hw->gate;
+
+	/* bypass clk disable if need to wait bus idle*/
+	if (gate->idle_reg)
+		return;
+
+	cv182x_clk_gate_endisable(hw, 0);
+}
+
+static int cv182x_clk_gate_is_enabled(struct clk_hw *hw)
+{
+	u32 reg;
+	struct cv182x_gate_hw_clock *gate_hw = to_cv182x_gate_clk(hw);
+	struct cv182x_gate_clock *gate = &gate_hw->gate;
+	void __iomem *reg_addr = gate_hw->base + gate->reg;
+
+	reg = readl(reg_addr);
+
+	reg &= BIT(gate->shift);
+
+	return reg ? 1 : 0;
+}
+
+static void cv182x_clk_gate_unprepare(struct clk_hw *hw)
+{
+	struct cv182x_gate_hw_clock *gate_hw = to_cv182x_gate_clk(hw);
+	struct cv182x_gate_clock *gate = &gate_hw->gate;
+	void __iomem *idle_reg;
+	u32 idle_state;
+	ktime_t timeout;
+
+	/* wait for axi bus idle */
+	if (gate->idle_reg) {
+		idle_reg = ioremap(gate->idle_reg, 4);
+		if (WARN_ON(!idle_reg))
+			return;
+
+		timeout = ktime_add_ms(ktime_get(), CV182X_BUS_IDLE_TIMEOUT_MS);
+		while ((idle_state = readl(idle_reg)) != gate->idle_state) {
+			if (ktime_after(ktime_get(), timeout)) {
+				pr_err("%s: wait for idle timeout\n", clk_hw_get_name(hw));
+				break;
+			}
+			cpu_relax();
+		}
+
+		iounmap(idle_reg);
+
+		if (idle_state == gate->idle_state) {
+			cv182x_clk_gate_endisable(hw, 0);
+		}
+	}
+}
+
+static const struct clk_ops cv182x_clk_gate_ops = {
+	.enable = cv182x_clk_gate_enable,
+	.disable = cv182x_clk_gate_disable,
+	.is_enabled = cv182x_clk_gate_is_enabled,
+	.unprepare = cv182x_clk_gate_unprepare,
+};
+
+static struct clk_hw *cv182x_clk_register_gate(struct cv182x_gate_hw_clock *gate_clk,
+					       void __iomem *sys_base)
+{
+
+	struct clk_hw *hw;
+	struct clk_init_data init;
+	int err;
+
+	gate_clk->gate.gate_flags = 0;
+	gate_clk->base = sys_base;
+	gate_clk->lock = &cv182x_clk_lock;
+
+	if (cvi_clk_flags) {
+		/* copy clk_init_data for modification */
+		memcpy(&init, gate_clk->hw.init, sizeof(init));
+
+		init.flags |= cvi_clk_flags;
+		gate_clk->hw.init = &init;
+	}
+
+	hw = &gate_clk->hw;
+	err = clk_hw_register(NULL, hw);
+	if (err) {
+		return ERR_PTR(err);
+	}
+
+	return hw;
+}
+
+static void cv182x_clk_unregister_gate(struct clk_hw *hw)
+{
+	struct cv182x_gate_hw_clock *gate_hw = to_cv182x_gate_clk(hw);
+
+	clk_hw_unregister(hw);
+	kfree(gate_hw);
+}
+
+static int cv182x_clk_register_gates(struct cv182x_gate_hw_clock *clks,
+				     int num_clks,
+				     struct cv182x_clock_data *data)
+{
+	struct clk_hw *hw;
+	void __iomem *sys_base = data->base;
+	unsigned int i;
+
+	for (i = 0; i < num_clks; i++) {
+		struct cv182x_gate_hw_clock *cv182x_clk = &clks[i];
+
+		hw = cv182x_clk_register_gate(cv182x_clk, sys_base);
+
+		if (IS_ERR(hw)) {
+			pr_err("%s: failed to register clock %s\n",
+			       __func__, cv182x_clk->gate.name);
+			goto err_clk;
+		}
+
+		data->hw_data.hws[clks[i].gate.id] = hw;
+		clk_hw_register_clkdev(hw, cv182x_clk->gate.name, NULL);
+	}
+
+	return 0;
+
+err_clk:
+	while (i--)
+		cv182x_clk_unregister_gate(data->hw_data.hws[clks[i].gate.id]);
+
+	return PTR_ERR(hw);
+
+}
+
+static struct clk_hw *cv182x_clk_register_composite(struct cv182x_composite_clock *clks,
+						    void __iomem *sys_base)
+{
+	struct clk_hw *hw;
+	struct clk_mux *mux = NULL;
+	struct cv182x_gate_hw_clock *gate_hws = NULL;
+	struct cv182x_div_hw_clock *div_hws = NULL;
+	struct clk_hw *mux_hw = NULL, *gate_hw = NULL, *div_hw = NULL;
+	const struct clk_ops *mux_ops = NULL, *gate_ops = NULL, *div_ops = NULL;
+	const char * const *parent_names;
+	const char *parent;
+	int num_parents;
+	int ret;
+
+	if (clks->mux_shift >= 0) {
+		mux = kzalloc(sizeof(*mux), GFP_KERNEL);
+		if (!mux)
+			return ERR_PTR(-ENOMEM);
+
+		mux->reg = sys_base + clks->mux_reg;
+		mux->mask = 1;
+		mux->shift = clks->mux_shift;
+		mux_hw = &mux->hw;
+		mux_ops = &clk_mux_ops;
+		mux->lock = &cv182x_clk_lock;
+
+		parent_names = clks->parents;
+		num_parents = clks->num_parents;
+	} else {
+		parent = clks->parent;
+		parent_names = &parent;
+		num_parents = 1;
+	}
+
+	if (clks->gate_shift >= 0) {
+		gate_hws = kzalloc(sizeof(*gate_hws), GFP_KERNEL);
+		if (!gate_hws) {
+			ret = -ENOMEM;
+			goto err_out;
+		}
+
+		gate_hws->base = sys_base;
+		gate_hws->gate.reg = clks->gate_reg;
+		gate_hws->gate.shift = clks->gate_shift;
+		gate_hws->gate.gate_flags = 0;
+		gate_hws->lock = &cv182x_clk_lock;
+
+		gate_hw = &gate_hws->hw;
+		gate_ops = &cv182x_clk_gate_ops;
+	}
+
+	if (clks->div_shift >= 0) {
+		div_hws = kzalloc(sizeof(*div_hws), GFP_KERNEL);
+		if (!div_hws) {
+			ret = -ENOMEM;
+			goto err_out;
+		}
+
+		div_hws->base = sys_base;
+		div_hws->div.reg = clks->div_reg;
+		div_hws->div.shift = clks->div_shift;
+		div_hws->div.width = clks->div_width;
+		div_hws->div.table = clks->table;
+		div_hws->div.initval = clks->div_initval;
+		div_hws->lock = &cv182x_clk_lock;
+		div_hws->div.div_flags = CLK_DIVIDER_ONE_BASED |
+					 CLK_DIVIDER_ROUND_CLOSEST |
+					 CLK_DIVIDER_ALLOW_ZERO;
+
+		div_hw = &div_hws->hw;
+		div_ops = &cv182x_clk_div_ops;
+	}
+
+	hw = clk_hw_register_composite(NULL, clks->name, parent_names,
+				       num_parents, mux_hw, mux_ops, div_hw,
+				       div_ops, gate_hw, gate_ops,
+				       clks->flags | cvi_clk_flags);
+
+	if (IS_ERR(hw)) {
+		ret = PTR_ERR(hw);
+		goto err_out;
+	}
+
+	return hw;
+
+err_out:
+	kfree(div_hws);
+	kfree(gate_hws);
+	kfree(mux);
+
+	return ERR_PTR(ret);
+}
+
+static void cv182x_clk_unregister_composite(struct clk_hw *hw)
+{
+	struct clk_composite *composite;
+
+	composite = to_clk_composite(hw);
+
+	clk_hw_unregister(hw);
+	kfree(composite);
+}
+
+static int cv182x_clk_register_composites(struct cv182x_composite_clock *clks,
+					  int num_clks,
+					  struct cv182x_clock_data *data)
+{
+	struct clk_hw *hw;
+	void __iomem *sys_base = data->base;
+	int i;
+
+	for (i = 0; i < num_clks; i++) {
+		struct cv182x_composite_clock *cv182x_clk = &clks[i];
+
+		hw = cv182x_clk_register_composite(cv182x_clk, sys_base);
+		if (IS_ERR(hw)) {
+			pr_err("%s: failed to register clock %s\n",
+			       __func__, cv182x_clk->name);
+			goto err_clk;
+		}
+
+		data->hw_data.hws[clks[i].id] = hw;
+
+		clk_hw_register_clkdev(hw, cv182x_clk->name, NULL);
+	}
+
+	return 0;
+
+err_clk:
+	while (i--)
+		cv182x_clk_unregister_composite(data->hw_data.hws[clks[i].id]);
+
+	return PTR_ERR(hw);
+}
+
+static const struct of_device_id cvi_clk_match_ids_tables[] = {
+	{
+		.compatible = "cvitek,cv182x-clk",
+	},
+	{}
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int cv182x_clk_suspend(void)
+{
+	memcpy_fromio(clk_data->clken_saved_regs,
+		      clk_data->base + CV182X_CLKEN_START,
+		      CV182X_CLKEN_NUM * 4);
+
+	memcpy_fromio(clk_data->clksel_saved_regs,
+		      clk_data->base + CV182X_CLKSEL_START,
+		      CV182X_CLKSEL_NUM * 4);
+
+	memcpy_fromio(clk_data->clkbyp_saved_regs,
+		      clk_data->base + CV182X_CLKBYP_START,
+		      CV182X_CLKBYP_NUM * 4);
+
+	memcpy_fromio(clk_data->clkdiv_saved_regs,
+		      clk_data->base + CV182X_CLKDIV_START,
+		      CV182X_CLKDIV_NUM * 4);
+
+	memcpy_fromio(clk_data->pll_g2_csr_saved_regs,
+		      clk_data->base + CV182X_PLL_G2_CSR_START,
+		      CV182X_PLL_G2_CSR_NUM * 4);
+
+	memcpy_fromio(clk_data->pll_g6_csr_saved_regs,
+		      clk_data->base + CV182X_PLL_G6_CSR_START,
+		      CV182X_PLL_G6_CSR_NUM * 4);
+
+	clk_data->a0pll_ssc_syn_set_saved_reg =
+		readl(clk_data->base + CV182X_CLK_A0PLL_SSC_SYN_SET);
+
+	clk_data->disppll_ssc_syn_set_saved_reg =
+		readl(clk_data->base + CV182X_CLK_DISPPLL_SSC_SYN_SET);
+
+	clk_data->cam0pll_ssc_syn_set_saved_reg =
+		readl(clk_data->base + CV182X_CLK_CAM0PLL_SSC_SYN_SET);
+
+	clk_data->cam1pll_ssc_syn_set_saved_reg =
+		readl(clk_data->base + CV182X_CLK_CAM1PLL_SSC_SYN_SET);
+
+	return 0;
+}
+
+static void cv182x_clk_resume(void)
+{
+	uint32_t regval;
+
+	/* switch clock to xtal */
+	writel(0xffffffff, clk_data->base + CV182X_CLK_BYPASS0);
+	writel(0x0000000f, clk_data->base + CV182X_CLK_BYPASS1);
+
+	memcpy_toio(clk_data->base + CV182X_CLKEN_START,
+		    clk_data->clken_saved_regs,
+		    CV182X_CLKEN_NUM * 4);
+
+	memcpy_toio(clk_data->base + CV182X_CLKSEL_START,
+		    clk_data->clksel_saved_regs,
+		    CV182X_CLKSEL_NUM * 4);
+
+	memcpy_toio(clk_data->base + CV182X_CLKDIV_START,
+		    clk_data->clkdiv_saved_regs,
+		    CV182X_CLKDIV_NUM * 4);
+
+	memcpy_toio(clk_data->base + CV182X_PLL_G6_CSR_START,
+		    clk_data->pll_g6_csr_saved_regs,
+		    CV182X_PLL_G6_CSR_NUM * 4);
+
+	/* wait for pll setting updated */
+	while (readl(clk_data->base + CV182X_CLK_PLL_G6_STATUS) & 0x7) {
+	}
+
+	/* A0PLL */
+	if (clk_data->a0pll_ssc_syn_set_saved_reg !=
+	    readl(clk_data->base + CV182X_CLK_A0PLL_SSC_SYN_SET)) {
+		pr_debug("%s: update A0PLL\n", __func__);
+		writel(clk_data->a0pll_ssc_syn_set_saved_reg,
+		       clk_data->base + CV182X_CLK_A0PLL_SSC_SYN_SET);
+
+		/* toggle software update */
+		regval = readl(clk_data->base + CV182X_CLK_A0PLL_SSC_SYN_CTRL);
+		regval ^= 1;
+		writel(regval, clk_data->base + CV182X_CLK_A0PLL_SSC_SYN_CTRL);
+	}
+
+	/* DISPPLL */
+	if (clk_data->disppll_ssc_syn_set_saved_reg !=
+	    readl(clk_data->base + CV182X_CLK_DISPPLL_SSC_SYN_SET)) {
+		pr_debug("%s: update DISPPLL\n", __func__);
+		writel(clk_data->disppll_ssc_syn_set_saved_reg,
+		       clk_data->base + CV182X_CLK_DISPPLL_SSC_SYN_SET);
+
+		/* toggle software update */
+		regval = readl(clk_data->base + CV182X_CLK_DISPPLL_SSC_SYN_CTRL);
+		regval ^= 1;
+		writel(regval, clk_data->base + CV182X_CLK_DISPPLL_SSC_SYN_CTRL);
+	}
+
+	/* CAM0PLL */
+	if (clk_data->cam0pll_ssc_syn_set_saved_reg !=
+	    readl(clk_data->base + CV182X_CLK_CAM0PLL_SSC_SYN_SET)) {
+		pr_debug("%s: update CAM0PLL\n", __func__);
+		writel(clk_data->cam0pll_ssc_syn_set_saved_reg,
+		       clk_data->base + CV182X_CLK_CAM0PLL_SSC_SYN_SET);
+
+		/* toggle software update */
+		regval = readl(clk_data->base + CV182X_CLK_CAM0PLL_SSC_SYN_CTRL);
+		regval ^= 1;
+		writel(regval, clk_data->base + CV182X_CLK_CAM0PLL_SSC_SYN_CTRL);
+	}
+
+	/* CAM1PLL */
+	if (clk_data->cam1pll_ssc_syn_set_saved_reg !=
+	    readl(clk_data->base + CV182X_CLK_CAM1PLL_SSC_SYN_SET)) {
+		pr_debug("%s: update CAM1PLL\n", __func__);
+		writel(clk_data->cam1pll_ssc_syn_set_saved_reg,
+		       clk_data->base + CV182X_CLK_CAM1PLL_SSC_SYN_SET);
+
+		/* toggle software update */
+		regval = readl(clk_data->base + CV182X_CLK_CAM1PLL_SSC_SYN_CTRL);
+		regval ^= 1;
+		writel(regval, clk_data->base + CV182X_CLK_CAM1PLL_SSC_SYN_CTRL);
+	}
+
+	memcpy_toio(clk_data->base + CV182X_PLL_G2_CSR_START,
+		    clk_data->pll_g2_csr_saved_regs,
+		    CV182X_PLL_G2_CSR_NUM * 4);
+
+	/* wait for pll setting updated */
+	while (readl(clk_data->base + CV182X_CLK_PLL_G2_STATUS) & 0x1F) {
+	}
+
+	memcpy_toio(clk_data->base + CV182X_CLKBYP_START,
+		    clk_data->clkbyp_saved_regs,
+		    CV182X_CLKBYP_NUM * 4);
+}
+
+static struct syscore_ops cv182x_clk_syscore_ops = {
+	.suspend = cv182x_clk_suspend,
+	.resume = cv182x_clk_resume,
+};
+#endif /* CONFIG_PM_SLEEP */
+
+static void __init cvi_clk_init(struct device_node *node)
+{
+	int num_clks;
+	int i;
+	int ret = 0;
+
+	num_clks = ARRAY_SIZE(cv182x_pll_clks) +
+		   ARRAY_SIZE(cv182x_div_clks) +
+		   ARRAY_SIZE(cv182x_mux_clks) +
+		   ARRAY_SIZE(cv182x_composite_clks) +
+		   ARRAY_SIZE(cv182x_gate_clks);
+
+	clk_data = kzalloc(sizeof(struct cv182x_clock_data) +
+			   sizeof(struct clk_hw) * num_clks,
+			   GFP_KERNEL);
+	if (!clk_data) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	for (i = 0; i < num_clks; i++)
+		clk_data->hw_data.hws[i] = ERR_PTR(-ENOENT);
+
+	clk_data->hw_data.num = num_clks;
+
+	clk_data->lock = &cv182x_clk_lock;
+
+	clk_data->base = of_iomap(node, 0);
+	if (!clk_data->base) {
+		pr_err("Failed to map address range for cvitek,cv182x-clk node\n");
+		return;
+	}
+
+	cv182x_clk_register_plls(cv182x_pll_clks,
+				 ARRAY_SIZE(cv182x_pll_clks),
+				 clk_data);
+
+	cv182x_clk_register_divs(cv182x_div_clks,
+				 ARRAY_SIZE(cv182x_div_clks),
+				 clk_data);
+
+	cv182x_clk_register_mux(cv182x_mux_clks,
+				ARRAY_SIZE(cv182x_mux_clks),
+				clk_data);
+
+	cv182x_clk_register_composites(cv182x_composite_clks,
+				       ARRAY_SIZE(cv182x_composite_clks),
+				       clk_data);
+
+	cv182x_clk_register_gates(cv182x_gate_clks,
+				  ARRAY_SIZE(cv182x_gate_clks),
+				  clk_data);
+
+	/* register clk-provider */
+	ret = of_clk_add_hw_provider(node, of_clk_hw_onecell_get, &clk_data->hw_data);
+	if (ret)
+		pr_err("Unable to add hw clk provider\n");
+
+	/* force enable clocks */
+	clk_prepare_enable(clk_data->hw_data.hws[CV182X_CLK_DSI_MAC_VIP]->clk);
+	clk_prepare_enable(clk_data->hw_data.hws[CV182X_CLK_DISP_VIP]->clk);
+	clk_prepare_enable(clk_data->hw_data.hws[CV182X_CLK_BT_VIP]->clk);
+	clk_prepare_enable(clk_data->hw_data.hws[CV182X_CLK_SC_TOP_VIP]->clk);
+
+#ifdef CONFIG_PM_SLEEP
+	register_syscore_ops(&cv182x_clk_syscore_ops);
+#endif
+
+	if (!ret)
+		return;
+
+out:
+	pr_err("%s failed error number %d\n", __func__, ret);
+}
+CLK_OF_DECLARE(cvi_clk, "cvitek,cv182x-clk", cvi_clk_init);
diff --git a/drivers/clk/cvitek/clk-cv1835.c b/drivers/clk/cvitek/clk-cv1835.c
new file mode 100644
index 000000000000..f3970bb137a6
--- /dev/null
+++ b/drivers/clk/cvitek/clk-cv1835.c
@@ -0,0 +1,1703 @@
+/*
+ * Copyright (c) 2020 CVITEK
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+
+#include <dt-bindings/clock/cv1835-clock.h>
+
+#define CV1835_CLK_FLAGS_ALL	(CLK_GET_RATE_NOCACHE)
+// #define CV1835_CLK_FLAGS_ALL	(CLK_GET_RATE_NOCACHE | CLK_IS_CRITICAL)
+// #define CV1835_CLK_FLAGS_ALL	(CLK_GET_RATE_NOCACHE | CLK_IGNORE_UNUSED)
+#define CV1835_CLK_FLAGS_MUX	(CLK_SET_RATE_PARENT | CLK_SET_RATE_NO_REPARENT)
+
+/* top_pll_g2 */
+#define CV1835_CLK_PLL_G2_CTRL		0x800
+#define CV1835_CLK_PLL_G2_STATUS	0x804
+#define CV1835_CLK_MIPIMPLL_CSR		0x808
+#define CV1835_CLK_A0PLL_CSR		0x80C
+#define CV1835_CLK_DISPPLL_CSR		0x810
+#define CV1835_CLK_CAM0PLL_CSR		0x814
+#define CV1835_CLK_CAM1PLL_CSR		0x818
+#define CV1835_CLK_PLL_G2_SSC_SYN_CTRL	0x840
+#define CV1835_CLK_A0PLL_SSC_SYN_CTRL	0x850
+#define CV1835_CLK_A0PLL_SSC_SYN_SET	0x854
+#define CV1835_CLK_A0PLL_SSC_SYN_SPAN	0x858
+#define CV1835_CLK_A0PLL_SSC_SYN_STEP	0x85C
+#define CV1835_CLK_DISPPLL_SSC_SYN_CTRL	0x860
+#define CV1835_CLK_DISPPLL_SSC_SYN_SET	0x864
+#define CV1835_CLK_DISPPLL_SSC_SYN_SPAN	0x868
+#define CV1835_CLK_DISPPLL_SSC_SYN_STEP	0x86C
+#define CV1835_CLK_CAM0PLL_SSC_SYN_CTRL	0x870
+#define CV1835_CLK_CAM0PLL_SSC_SYN_SET	0x874
+#define CV1835_CLK_CAM0PLL_SSC_SYN_SPAN	0x878
+#define CV1835_CLK_CAM0PLL_SSC_SYN_STEP	0x87C
+#define CV1835_CLK_CAM1PLL_SSC_SYN_CTRL	0x880
+#define CV1835_CLK_CAM1PLL_SSC_SYN_SET	0x884
+#define CV1835_CLK_CAM1PLL_SSC_SYN_SPAN	0x888
+#define CV1835_CLK_CAM1PLL_SSC_SYN_STEP	0x88C
+
+/* top_pll_g6 */
+#define CV1835_CLK_PLL_G6_CTRL		0x900
+#define CV1835_CLK_PLL_G6_STATUS	0x904
+#define CV1835_CLK_MPLL_CSR		0x908
+#define CV1835_CLK_TPLL_CSR		0x90C
+#define CV1835_CLK_FPLL_CSR		0x910
+#define CV1835_CLK_PLL_G6_SSC_SYN_CTRL	0x940
+
+/* clkgen */
+#define CV1835_CLK_ENABLE0		0x000
+#define CV1835_CLK_ENABLE1		0x004
+#define CV1835_CLK_ENABLE2		0x008
+#define CV1835_CLK_ENABLE3		0x00C
+#define CV1835_CLK_ENABLE4		0x010
+#define CV1835_CLK_SELECT		0x020
+#define CV1835_CLK_BYPASS0		0x030
+#define CV1835_CLK_BYPASS1		0x034
+#define CV1835_CLK_A53_DIV0		0x040
+#define CV1835_CLK_A53_DIV1		0x044
+#define CV1835_CLK_CPU_AXI0_DIV0	0x048
+#define CV1835_CLK_CPU_AXI0_DIV1	0x04C
+#define CV1835_CLK_CPU_GIC_DIV		0x050
+#define CV1835_CLK_TPU_AXI_DIV0		0x054
+#define CV1835_CLK_TPU_AXI_DIV1		0x058
+#define CV1835_CLK_TPU_FAB_DIV0		0x05C
+#define CV1835_CLK_TPU_FAB_DIV1		0x060
+#define CV1835_CLK_EMMC_DIV0		0x064
+#define CV1835_CLK_EMMC_DIV1		0x068
+#define CV1835_CLK_100K_EMMC_DIV	0x06C
+#define CV1835_CLK_SD0_DIV0		0x070
+#define CV1835_CLK_SD0_DIV1		0x074
+#define CV1835_CLK_100K_SD0_DIV		0x078
+#define CV1835_CLK_SD1_DIV0		0x07C
+#define CV1835_CLK_SD1_DIV1		0x080
+#define CV1835_CLK_100K_SD1_DIV		0x084
+#define CV1835_CLK_SPI_NAND_DIV		0x088
+#define CV1835_CLK_500M_ETH0_DIV	0x08C
+#define CV1835_CLK_500M_ETH1_DIV	0x090
+#define CV1835_CLK_GPIO_DB_DIV		0x094
+#define CV1835_CLK_SDMA_AUD0_DIV	0x098
+#define CV1835_CLK_SDMA_AUD1_DIV	0x09C
+#define CV1835_CLK_SDMA_AUD2_DIV	0x0A0
+#define CV1835_CLK_SDMA_AUD3_DIV	0x0A4
+#define CV1835_CLK_187P5M_DIV		0x0A8
+#define CV1835_CLK_125M_USB_DIV		0x0AC
+#define CV1835_CLK_33K_USB_DIV		0x0B0
+#define CV1835_CLK_12M_USB_DIV		0x0B4
+#define CV1835_CLK_AXI4_DIV		0x0B8
+#define CV1835_CLK_AXI6_DIV0		0x0BC
+#define CV1835_CLK_AXI6_DIV1		0x0C0
+#define CV1835_CLK_DSI_ESC_DIV		0x0C4
+#define CV1835_CLK_AXI_VIP_DIV0		0x0C8
+#define CV1835_CLK_AXI_VIP_DIV1		0x0CC
+#define CV1835_CLK_SRC_VIP_SYS_0_DIV0	0x0D0
+#define CV1835_CLK_SRC_VIP_SYS_0_DIV1	0x0D4
+#define CV1835_CLK_SRC_VIP_SYS_1_DIV0	0x0D8
+#define CV1835_CLK_SRC_VIP_SYS_1_DIV1	0x0DC
+#define CV1835_CLK_DISP_SRC_VIP_DIV	0x0E0
+#define CV1835_CLK_AXI_VIDEO_CODEC_DIV0	0x0E4
+#define CV1835_CLK_AXI_VIDEO_CODEC_DIV1	0x0E8
+#define CV1835_CLK_VC_SRC0_DIV0		0x0EC
+#define CV1835_CLK_VC_SRC0_DIV1		0x0F0
+#define CV1835_CLK_CAM0_DIV		0x0F4
+#define CV1835_CLK_CAM1_DIV		0x0F8
+#define CV1835_CLK_1M_DIV		0x0FC
+#define CV1835_CLK_SPI_DIV		0x100
+#define CV1835_CLK_I2C_DIV		0x104
+#define CV1835_CLK_VC_SRC1_DIV0		0x108
+#define CV1835_CLK_VC_SRC1_DIV1		0x10C
+#define CV1835_CLK_SRC_VIP_SYS_2_DIV0	0x110
+#define CV1835_CLK_SRC_VIP_SYS_2_DIV1	0x114
+#define CV1835_CLK_AUDSRC_DIV		0x118
+#define CV1835_CLK_VC_SRC2_DIV		0x11C
+#define CV1835_CLK_PWM_SRC_DIV0		0x120
+#define CV1835_CLK_PWM_SRC_DIV1		0x124
+
+#define CV1835_VCSYS_BUS_IDLE		0x03000210
+#define CV1835_BUS_IDLE_TIMEOUT_MS	1
+
+/* PLL status register offset */
+#define PLL_STATUS_MASK			0xFF
+#define PLL_STATUS_OFFSET		0x04
+
+/* G2 Synthesizer register offset */
+#define G2_SSC_CTRL_MASK		0xFF
+#define G2_SSC_CTRL_OFFSET		0x40
+#define SSC_SYN_SET_MASK		0x0F
+#define SSC_SYN_SET_OFFSET		0x04
+
+#define to_cv1835_pll_clk(_hw) container_of(_hw, struct cv1835_pll_hw_clock, hw)
+#define to_cv1835_div_clk(_hw) container_of(_hw, struct cv1835_div_hw_clock, hw)
+#define to_cv1835_gate_clk(_hw) container_of(_hw, struct cv1835_gate_hw_clock, hw)
+
+#define div_mask(width) ((1 << (width)) - 1)
+
+static DEFINE_SPINLOCK(cv1835_clk_lock);
+
+struct cv1835_clock_data {
+	void __iomem *base;
+	spinlock_t *lock;
+	struct clk_hw_onecell_data hw_data;
+};
+
+struct cv1835_gate_clock {
+	unsigned int	id;
+	const char	*name;
+	const char	*parent;
+	u32		reg;
+	s8		shift;
+	u32		idle_reg;
+	u32		idle_state;
+	unsigned long	gate_flags;
+};
+
+struct cv1835_gate_hw_clock {
+	struct cv1835_gate_clock gate;
+	void __iomem *base;
+	spinlock_t *lock;
+	struct clk_hw hw;
+};
+
+struct cv1835_mux_clock {
+	unsigned int	id;
+	const char	*name;
+	const char      * const *parents;
+	s8		num_parents;
+	u32		reg;
+	s8		shift;
+	unsigned long	flags;
+};
+
+struct cv1835_div_clock {
+	unsigned int	id;
+	const char	*name;
+	u32		reg;
+	u8		shift;
+	u8		width;
+	u32		initval;
+	const struct clk_div_table *table;
+	unsigned long div_flags;
+};
+
+struct cv1835_div_hw_clock {
+	struct cv1835_div_clock div;
+	void __iomem *base;
+	spinlock_t *lock;
+	struct clk_hw hw;
+};
+
+struct cv1835_composite_clock {
+	unsigned int	id;
+	const char	*name;
+	const char	*parent;
+	const char      * const *parents;
+	unsigned int	num_parents;
+	unsigned long	flags;
+
+	u32		gate_reg;
+	u32		mux_reg;
+	u32		div_reg;
+
+	s8		gate_shift;
+	s8		mux_shift;
+	s8		div_shift;
+	s8		div_width;
+	s16		div_initval;
+	const struct clk_div_table *table;
+};
+
+struct cv1835_pll_clock {
+	unsigned int	id;
+	const char	*name;
+	u32		reg_csr;
+	u32		reg_ssc;
+	unsigned long	flags;
+};
+
+struct cv1835_pll_hw_clock {
+	struct cv1835_pll_clock pll;
+	void __iomem *base;
+	spinlock_t *lock;
+	struct clk_hw hw;
+};
+
+static const struct clk_ops cv1835_g6_pll_ops;
+static const struct clk_ops cv1835_g2_pll_ops;
+static const struct clk_ops cv1835_clk_div_ops;
+static const struct clk_ops cv1835_clk_gate_ops;
+
+static unsigned long cvi_clk_flags;
+
+#define GATE_DIV(_id, _name, _parent, _gate_reg, _gate_shift, _div_reg,	\
+			_div_shift, _div_width, _div_initval, _table,	\
+			_flags) {					\
+		.id = _id,						\
+		.parent = _parent,					\
+		.name = _name,						\
+		.gate_reg = _gate_reg,					\
+		.gate_shift = _gate_shift,				\
+		.div_reg = _div_reg,					\
+		.div_shift = _div_shift,				\
+		.div_width = _div_width,				\
+		.div_initval = _div_initval,				\
+		.table = _table,					\
+		.mux_shift = -1,					\
+		.flags = _flags | CV1835_CLK_FLAGS_ALL,			\
+	}
+
+#define GATE_MUX(_id, _name, _parents, _gate_reg, _gate_shift,		\
+			_mux_reg, _mux_shift, _flags) {			\
+		.id = _id,						\
+		.parents = _parents,					\
+		.num_parents = ARRAY_SIZE(_parents),			\
+		.name = _name,						\
+		.gate_reg = _gate_reg,					\
+		.gate_shift = _gate_shift,				\
+		.div_shift = -1,					\
+		.mux_reg = _mux_reg,					\
+		.mux_shift = _mux_shift,				\
+		.flags = _flags |					\
+			 CV1835_CLK_FLAGS_ALL | CV1835_CLK_FLAGS_MUX,	\
+	}
+
+#define CLK_G6_PLL(_id, _name, _parent, _reg_csr, _flags) {		\
+		.pll.id = _id,						\
+		.pll.name = _name,					\
+		.pll.reg_csr = _reg_csr,				\
+		.pll.reg_ssc = 0,					\
+		.hw.init = CLK_HW_INIT_PARENTS(_name, _parent,		\
+					       &cv1835_g6_pll_ops,	\
+					       _flags |			\
+					       CV1835_CLK_FLAGS_ALL),	\
+	}
+
+#define CLK_G2_PLL(_id, _name, _parent, _reg_csr, _reg_ssc, _flags) {	\
+		.pll.id = _id,						\
+		.pll.name = _name,					\
+		.pll.reg_csr = _reg_csr,				\
+		.pll.reg_ssc = _reg_ssc,				\
+		.hw.init = CLK_HW_INIT_PARENTS(_name, _parent,		\
+					       &cv1835_g2_pll_ops,	\
+					       _flags |			\
+					       CV1835_CLK_FLAGS_ALL),	\
+	}
+
+#define CLK_DIV(_id, _name, _parent, _reg, _shift, _width, _initval,	\
+			_table,	_flags) {				\
+		.div.id = _id,						\
+		.div.name = _name,					\
+		.div.reg = _reg,					\
+		.div.shift = _shift,					\
+		.div.width = _width,					\
+		.div.initval = _initval,				\
+		.div.table = _table,					\
+		.hw.init = CLK_HW_INIT(_name, _parent,			\
+				       &cv1835_clk_div_ops,		\
+				       _flags | CV1835_CLK_FLAGS_ALL),	\
+	}
+
+#define CLK_GATE(_id, _name, _parent, _reg, _shift, _flags) {		\
+		.gate.id = _id,						\
+		.gate.name = _name,					\
+		.gate.reg = _reg,					\
+		.gate.shift = _shift,					\
+		.gate.idle_reg = 0,					\
+		.gate.idle_state = 0,					\
+		.hw.init = CLK_HW_INIT(_name, _parent,			\
+				       &cv1835_clk_gate_ops,		\
+				       _flags | CV1835_CLK_FLAGS_ALL),	\
+	}
+
+#define CLK_GATE_IDLE(_id, _name, _parent, _reg, _shift, _flags,	\
+			_idle_reg, _idle_state) {			\
+		.gate.id = _id,						\
+		.gate.name = _name,					\
+		.gate.reg = _reg,					\
+		.gate.shift = _shift,					\
+		.gate.idle_reg = _idle_reg,				\
+		.gate.idle_state = _idle_state,				\
+		.hw.init = CLK_HW_INIT(_name, _parent,			\
+				       &cv1835_clk_gate_ops,		\
+				       _flags | CV1835_CLK_FLAGS_ALL),	\
+	}
+
+const char *const cv1835_pll_parent[] = {"osc"};
+const char *const cv1835_frac_pll_parent[] = {"clk_mipimpll"};
+
+/*
+ * All PLL clocks are marked as CRITICAL, hence they are very crucial
+ * for the functioning of the SoC
+ */
+static struct cv1835_pll_hw_clock cv1835_pll_clks[] = {
+	CLK_G6_PLL(CV1835_CLK_MPLL, "clk_mpll", cv1835_pll_parent,
+		CV1835_CLK_MPLL_CSR, 0),
+	CLK_G6_PLL(CV1835_CLK_TPLL, "clk_tpll", cv1835_pll_parent,
+		CV1835_CLK_TPLL_CSR, 0),
+	CLK_G6_PLL(CV1835_CLK_FPLL, "clk_fpll", cv1835_pll_parent,
+		CV1835_CLK_FPLL_CSR, 0),
+	CLK_G2_PLL(CV1835_CLK_MIPIMPLL, "clk_mipimpll", cv1835_pll_parent,
+		CV1835_CLK_MIPIMPLL_CSR, 0, 0),
+	CLK_G2_PLL(CV1835_CLK_A0PLL, "clk_a0pll", cv1835_frac_pll_parent,
+		CV1835_CLK_A0PLL_CSR, CV1835_CLK_A0PLL_SSC_SYN_CTRL, 0),
+	CLK_G2_PLL(CV1835_CLK_DISPPLL, "clk_disppll", cv1835_frac_pll_parent,
+		CV1835_CLK_DISPPLL_CSR, CV1835_CLK_DISPPLL_SSC_SYN_CTRL, 0),
+	CLK_G2_PLL(CV1835_CLK_CAM0PLL, "clk_cam0pll", cv1835_frac_pll_parent,
+		CV1835_CLK_CAM0PLL_CSR, CV1835_CLK_CAM0PLL_SSC_SYN_CTRL, 0),
+	CLK_G2_PLL(CV1835_CLK_CAM1PLL, "clk_cam1pll", cv1835_frac_pll_parent,
+		CV1835_CLK_CAM1PLL_CSR, CV1835_CLK_CAM1PLL_SSC_SYN_CTRL, 0),
+};
+
+/*
+ * Clocks marked as CRITICAL are needed for the proper functioning
+ * of the SoC.
+ */
+static struct cv1835_gate_hw_clock cv1835_gate_clks[] = {
+	CLK_GATE(CV1835_CLK_XTAL_A53, "clk_xtal_a53", "osc",
+		CV1835_CLK_ENABLE0, 3, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_AHB_ROM, "clk_ahb_rom", "clk_div_axi4",
+		CV1835_CLK_ENABLE0, 6, 0),
+	CLK_GATE(CV1835_CLK_DDR_AXI_REG, "clk_ddr_axi_reg", "clk_mux_axi6",
+		CV1835_CLK_ENABLE0, 7, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_RTC_25M, "clk_rtc_25m", "osc",
+		CV1835_CLK_ENABLE0, 8, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_TEMPSEN, "clk_tempsen", "osc",
+		CV1835_CLK_ENABLE0, 9, 0),
+	CLK_GATE(CV1835_CLK_SARADC, "clk_saradc", "osc",
+		CV1835_CLK_ENABLE0, 10, 0),
+	CLK_GATE(CV1835_CLK_EFUSE, "clk_efuse", "osc",
+		CV1835_CLK_ENABLE0, 11, 0),
+	CLK_GATE(CV1835_CLK_APB_EFUSE, "clk_apb_efuse", "osc",
+		CV1835_CLK_ENABLE0, 12, 0),
+	CLK_GATE(CV1835_CLK_XTAL_MISC, "clk_xtal_misc", "osc",
+		CV1835_CLK_ENABLE0, 14, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_AXI4_EMMC, "clk_axi4_emmc", "clk_div_axi4",
+		CV1835_CLK_ENABLE0, 15, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_AXI4_SD0, "clk_axi4_sd0", "clk_div_axi4",
+		CV1835_CLK_ENABLE0, 18, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_AXI4_SD1, "clk_axi4_sd1", "clk_div_axi4",
+		CV1835_CLK_ENABLE0, 21, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_AXI4_ETH0, "clk_axi4_eth0", "clk_div_axi4",
+		CV1835_CLK_ENABLE0, 26, 0),
+	CLK_GATE(CV1835_CLK_AXI4_ETH1, "clk_axi4_eth1", "clk_div_axi4",
+		CV1835_CLK_ENABLE0, 28, 0),
+	CLK_GATE(CV1835_CLK_APB_GPIO, "clk_apb_gpio", "clk_mux_axi6",
+		CV1835_CLK_ENABLE0, 29, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_GPIO_INTR, "clk_apb_gpio_intr", "clk_mux_axi6",
+		CV1835_CLK_ENABLE0, 30, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_AHB_SF, "clk_ahb_sf", "clk_div_axi4",
+		CV1835_CLK_ENABLE1, 0, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_SDMA_AXI, "clk_sdma_axi", "clk_div_axi4",
+		CV1835_CLK_ENABLE1, 1, 0),
+	CLK_GATE(CV1835_CLK_APB_I2C, "clk_apb_i2c", "clk_div_axi4",
+		CV1835_CLK_ENABLE1, 6, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_WDT, "clk_apb_wdt", "osc",
+		CV1835_CLK_ENABLE1, 7, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_SPI0, "clk_apb_spi0", "clk_div_axi4",
+		CV1835_CLK_ENABLE1, 9, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_SPI1, "clk_apb_spi1", "clk_div_axi4",
+		CV1835_CLK_ENABLE1, 10, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_SPI2, "clk_apb_spi2", "clk_div_axi4",
+		CV1835_CLK_ENABLE1, 11, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_SPI3, "clk_apb_spi3", "clk_div_axi4",
+		CV1835_CLK_ENABLE1, 12, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_187P5M, "clk_187p5m", "clk_div_187p5m",
+		CV1835_CLK_ENABLE1, 13, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_UART0, "clk_apb_uart0", "clk_div_axi4",
+		CV1835_CLK_ENABLE1, 15, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_UART1, "clk_apb_uart1", "clk_div_axi4",
+		CV1835_CLK_ENABLE1, 17, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_UART2, "clk_apb_uart2", "clk_div_axi4",
+		CV1835_CLK_ENABLE1, 19, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_UART3, "clk_apb_uart3", "clk_div_axi4",
+		CV1835_CLK_ENABLE1, 21, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_UART4, "clk_apb_uart4", "clk_div_axi4",
+		CV1835_CLK_ENABLE1, 23, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_I2S0, "clk_apb_i2s0", "clk_div_axi4",
+		CV1835_CLK_ENABLE1, 24, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_I2S1, "clk_apb_i2s1", "clk_div_axi4",
+		CV1835_CLK_ENABLE1, 25, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_I2S2, "clk_apb_i2s2", "clk_div_axi4",
+		CV1835_CLK_ENABLE1, 26, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_I2S3, "clk_apb_i2s3", "clk_div_axi4",
+		CV1835_CLK_ENABLE1, 27, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_AXI4_USB, "clk_axi4_usb", "clk_div_axi4",
+		CV1835_CLK_ENABLE1, 28, 0),
+	CLK_GATE(CV1835_CLK_APB_USB, "clk_apb_usb", "clk_div_axi4",
+		CV1835_CLK_ENABLE1, 29, 0),
+	CLK_GATE(CV1835_CLK_AXI4, "clk_axi4", "clk_div_axi4",
+		CV1835_CLK_ENABLE2, 1, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_AXI6, "clk_axi6", "clk_mux_axi6",
+		CV1835_CLK_ENABLE2, 2, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_H264C, "clk_h264c", "clk_axi_video_codec",
+		CV1835_CLK_ENABLE2, 10, 0),
+	CLK_GATE(CV1835_CLK_H265C, "clk_h265c", "clk_axi_video_codec",
+		CV1835_CLK_ENABLE2, 11, 0),
+	CLK_GATE(CV1835_CLK_JPEG, "clk_jpeg", "clk_axi_video_codec",
+		CV1835_CLK_ENABLE2, 12, 0),
+	CLK_GATE(CV1835_CLK_APB_JPEG, "clk_apb_jpeg", "clk_axi6",
+		CV1835_CLK_ENABLE2, 13, 0),
+	CLK_GATE(CV1835_CLK_APB_H264C, "clk_apb_h264c", "clk_axi6",
+		CV1835_CLK_ENABLE2, 14, 0),
+	CLK_GATE(CV1835_CLK_APB_H265C, "clk_apb_h265c", "clk_axi6",
+		CV1835_CLK_ENABLE2, 15, 0),
+	CLK_GATE(CV1835_CLK_CSI_MAC0_VIP, "clk_csi_mac0_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE2, 18, 0),
+	CLK_GATE(CV1835_CLK_CSI_MAC1_VIP, "clk_csi_mac1_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE2, 19, 0),
+	CLK_GATE(CV1835_CLK_ISP_TOP_VIP, "clk_isp_top_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE2, 20, 0),
+	CLK_GATE(CV1835_CLK_IMG_D_VIP, "clk_img_d_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE2, 21, 0),
+	CLK_GATE(CV1835_CLK_IMG_V_VIP, "clk_img_v_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE2, 22, 0),
+	CLK_GATE(CV1835_CLK_SC_TOP_VIP, "clk_sc_top_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE2, 23, 0),
+	CLK_GATE(CV1835_CLK_SC_D_VIP, "clk_sc_d_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE2, 24, 0),
+	CLK_GATE(CV1835_CLK_SC_V1_VIP, "clk_sc_v1_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE2, 25, 0),
+	CLK_GATE(CV1835_CLK_SC_V2_VIP, "clk_sc_v2_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE2, 26, 0),
+	CLK_GATE(CV1835_CLK_SC_V3_VIP, "clk_sc_v3_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE2, 27, 0),
+	CLK_GATE(CV1835_CLK_DWA_VIP, "clk_dwa_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE2, 28, 0),
+	CLK_GATE(CV1835_CLK_BT_VIP, "clk_bt_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE2, 29, 0),
+	CLK_GATE(CV1835_CLK_DISP_VIP, "clk_disp_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE2, 30, 0),
+	CLK_GATE(CV1835_CLK_DSI_MAC_VIP, "clk_dsi_mac_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE2, 31, 0),
+	CLK_GATE(CV1835_CLK_LVDS0_VIP, "clk_lvds0_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE3, 0, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_LVDS1_VIP, "clk_lvds1_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE3, 1, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_CSI0_RX_VIP, "clk_csi0_rx_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE3, 2, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_CSI1_RX_VIP, "clk_csi1_rx_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE3, 3, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_PAD_VI_VIP, "clk_pad_vi_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE3, 4, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_1M, "clk_1m", "clk_div_1m",
+		CV1835_CLK_ENABLE3, 5, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_PM, "clk_pm", "clk_mux_axi6",
+		CV1835_CLK_ENABLE3, 8, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_TIMER0, "clk_timer0", "osc",
+		CV1835_CLK_ENABLE3, 9, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_TIMER1, "clk_timer1", "osc",
+		CV1835_CLK_ENABLE3, 10, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_TIMER2, "clk_timer2", "osc",
+		CV1835_CLK_ENABLE3, 11, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_TIMER3, "clk_timer3", "osc",
+		CV1835_CLK_ENABLE3, 12, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_TIMER4, "clk_timer4", "osc",
+		CV1835_CLK_ENABLE3, 13, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_TIMER5, "clk_timer5", "osc",
+		CV1835_CLK_ENABLE3, 14, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_TIMER6, "clk_timer6", "osc",
+		CV1835_CLK_ENABLE3, 15, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_TIMER7, "clk_timer7", "osc",
+		CV1835_CLK_ENABLE3, 16, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_I2C0, "clk_apb_i2c0", "clk_div_axi4",
+		CV1835_CLK_ENABLE3, 17, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_I2C1, "clk_apb_i2c1", "clk_div_axi4",
+		CV1835_CLK_ENABLE3, 18, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_I2C2, "clk_apb_i2c2", "clk_div_axi4",
+		CV1835_CLK_ENABLE3, 19, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_I2C3, "clk_apb_i2c3", "clk_div_axi4",
+		CV1835_CLK_ENABLE3, 20, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_APB_I2C4, "clk_apb_i2c4", "clk_div_axi4",
+		CV1835_CLK_ENABLE3, 21, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_WGN, "clk_wgn", "osc",
+		CV1835_CLK_ENABLE3, 22, 0),
+	CLK_GATE(CV1835_CLK_WGN0, "clk_wgn0", "osc",
+		CV1835_CLK_ENABLE3, 23, 0),
+	CLK_GATE(CV1835_CLK_WGN1, "clk_wgn1", "osc",
+		CV1835_CLK_ENABLE3, 24, 0),
+	CLK_GATE(CV1835_CLK_WGN2, "clk_wgn2", "osc",
+		CV1835_CLK_ENABLE3, 25, 0),
+	CLK_GATE(CV1835_CLK_KEYSCAN, "clk_keyscan", "osc",
+		CV1835_CLK_ENABLE3, 26, 0),
+	CLK_GATE(CV1835_CLK_AHB_SF1, "clk_ahb_sf1", "clk_div_axi4",
+		CV1835_CLK_ENABLE3, 27, 0),
+	CLK_GATE(CV1835_CLK_PAD_VI1_VIP, "clk_pad_vi1_vip", "clk_axi_vip",
+		CV1835_CLK_ENABLE3, 30, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_CFG_REG_VIP, "clk_cfg_reg_vip", "clk_mux_axi6",
+		CV1835_CLK_ENABLE3, 31, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_CFG_REG_VC, "clk_cfg_reg_vc", "clk_mux_axi6",
+		CV1835_CLK_ENABLE4, 0, 0),
+	CLK_GATE(CV1835_CLK_APB_AUDSRC, "clk_apb_audsrc", "clk_div_axi4",
+		CV1835_CLK_ENABLE4, 2, CLK_IS_CRITICAL),
+	CLK_GATE(CV1835_CLK_PWM_SRC, "clk_pwm_src", "clk_mux_pwm_src",
+		CV1835_CLK_ENABLE4, 4, 0),
+	CLK_GATE_IDLE(CV1835_CLK_AXI_VIDEO_CODEC, "clk_axi_video_codec", "clk_mux_axi_video_codec",
+		CV1835_CLK_ENABLE2, 8, 0, CV1835_VCSYS_BUS_IDLE, 0x7F),
+};
+
+static const char * const clk_axi6_parents[] = { "clk_div_1_axi6", "clk_div_0_axi6" };
+static const char * const clk_a53_parents[] = { "clk_div_1_a53", "clk_div_0_a53" };
+static const char * const clk_cpu_axi0_parents[] = { "clk_div_1_cpu_axi0", "clk_div_0_cpu_axi0" };
+static const char * const clk_tpu_axi_parents[] = { "clk_div_1_tpu_axi", "clk_div_0_tpu_axi" };
+static const char * const clk_tpu_fab_parents[] = { "clk_div_1_tpu_fab", "clk_div_0_tpu_fab" };
+static const char * const clk_debug_parents[] = { "clk_mux_axi6", "osc" };
+static const char * const clk_emmc_parents[] = { "clk_div_1_emmc", "clk_div_0_emmc" };
+static const char * const clk_sd0_parents[] = { "clk_div_1_sd0", "clk_div_0_sd0" };
+static const char * const clk_sd1_parents[] = { "clk_div_1_sd1", "clk_div_0_sd1" };
+static const char * const clk_apb_pwm_parents[] = { "clk_mux_axi6", "clk_mux_pwm_src" };
+static const char * const clk_uart0_parents[] = { "clk_div_187p5m", "osc" };
+static const char * const clk_uart1_parents[] = { "clk_div_187p5m", "osc" };
+static const char * const clk_uart2_parents[] = { "clk_div_187p5m", "osc" };
+static const char * const clk_uart3_parents[] = { "clk_div_187p5m", "osc" };
+static const char * const clk_uart4_parents[] = { "clk_div_187p5m", "osc" };
+static const char * const clk_axi_vip_parents[] = { "clk_div_1_axi_vip", "clk_div_0_axi_vip" };
+static const char * const clk_src_vip_sys_0_parents[] = { "clk_div_1_src_vip_sys_0", "clk_div_0_src_vip_sys_0" };
+static const char * const clk_src_vip_sys_1_parents[] = { "clk_div_1_src_vip_sys_1", "clk_div_0_src_vip_sys_1" };
+static const char * const clk_axi_video_codec_parents[] = { "clk_div_1_axi_video_codec", "clk_div_0_axi_video_codec" };
+static const char * const clk_vc_src0_parents[] = { "clk_div_1_vc_src0", "clk_div_0_vc_src0" };
+static const char * const clk_vc_src1_parents[] = { "clk_div_1_vc_src1", "clk_div_0_vc_src1" };
+static const char * const clk_src_vip_sys_2_parents[] = { "clk_div_1_src_vip_sys_2", "clk_div_0_src_vip_sys_2" };
+static const char * const clk_pwm_src_parents[] = { "clk_div_1_pwm_src", "clk_div_0_pwm_src" };
+static const char * const clk_axi_video_codec_1_parents[] = { "clk_mipimpll", "clk_cam1pll" };
+
+static const struct cv1835_mux_clock cv1835_mux_clks[] = {
+	{ CV1835_CLK_MUX_AXI6, "clk_mux_axi6", clk_axi6_parents, 2,
+	   CV1835_CLK_SELECT, 14, 0 },
+	{ CV1835_CLK_MUX_PWM_SRC, "clk_mux_pwm_src", clk_pwm_src_parents, 2,
+	   CV1835_CLK_SELECT, 22, 0 },
+	{ CV1835_CLK_MUX_AXI_VIDEO_CODEC, "clk_mux_axi_video_codec", clk_axi_video_codec_parents, 2,
+	   CV1835_CLK_SELECT, 18, 0 },
+	// ECO bit for clk_axi_video_codec divider1
+	{ CV1835_CLK_MUX_AXI_VIDEO_CODEC_1, "clk_mux_axi_video_codec_1", clk_axi_video_codec_1_parents, 2,
+	   CV1835_CLK_SELECT, 31, 0 },
+};
+
+/*
+ * Clocks marked as CRITICAL are needed for the proper functioning
+ * of the SoC.
+ */
+static struct cv1835_div_hw_clock cv1835_div_clks[] = {
+	CLK_DIV(CV1835_CLK_DIV_0_A53, "clk_div_0_a53", "clk_mpll",
+		CV1835_CLK_A53_DIV0, 16, 5, 1, NULL, CLK_SET_RATE_PARENT),
+	CLK_DIV(CV1835_CLK_DIV_1_A53, "clk_div_1_a53", "clk_fpll",
+		CV1835_CLK_A53_DIV1, 16, 5, 2, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_0_CPU_AXI0, "clk_div_0_cpu_axi0", "clk_mipimpll",
+		CV1835_CLK_CPU_AXI0_DIV0, 16, 5, 2, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_1_CPU_AXI0, "clk_div_1_cpu_axi0", "clk_fpll",
+		CV1835_CLK_CPU_AXI0_DIV1, 16, 5, 3, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_0_TPU_AXI, "clk_div_0_tpu_axi", "clk_tpll",
+		CV1835_CLK_TPU_AXI_DIV0, 16, 5, 1, NULL, CLK_SET_RATE_PARENT),
+	CLK_DIV(CV1835_CLK_DIV_1_TPU_AXI, "clk_div_1_tpu_axi", "clk_fpll",
+		CV1835_CLK_TPU_AXI_DIV1, 16, 5, 2, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_0_TPU_FAB, "clk_div_0_tpu_fab", "clk_mipimpll",
+		CV1835_CLK_TPU_FAB_DIV0, 16, 5, 2, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_1_TPU_FAB, "clk_div_1_tpu_fab", "clk_fpll",
+		CV1835_CLK_TPU_FAB_DIV1, 16, 5, 3, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_0_EMMC, "clk_div_0_emmc", "clk_fpll",
+		CV1835_CLK_EMMC_DIV0, 16, 5, 15, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_1_EMMC, "clk_div_1_emmc", "clk_disppll",
+		CV1835_CLK_EMMC_DIV1, 16, 5, 12, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_0_SD0, "clk_div_0_sd0", "clk_fpll",
+		CV1835_CLK_SD0_DIV0, 16, 5, 15, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_1_SD0, "clk_div_1_sd0", "clk_disppll",
+		CV1835_CLK_SD0_DIV1, 16, 5, 12, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_0_SD1, "clk_div_0_sd1", "clk_fpll",
+		CV1835_CLK_SD1_DIV0, 16, 5, 15, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_1_SD1, "clk_div_1_sd1", "clk_disppll",
+		CV1835_CLK_SD1_DIV1, 16, 5, 12, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_AXI4, "clk_div_axi4", "clk_fpll",
+		CV1835_CLK_AXI4_DIV, 16, 5, 5, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_0_AXI6, "clk_div_0_axi6", "clk_fpll",
+		CV1835_CLK_AXI6_DIV0, 16, 5, 15, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_1_AXI6, "clk_div_1_axi6", "clk_mpll",
+		CV1835_CLK_AXI6_DIV1, 16, 5, 10, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_0_AXI_VIP, "clk_div_0_axi_vip", "clk_mipimpll",
+		CV1835_CLK_AXI_VIP_DIV0, 16, 5, 3, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_1_AXI_VIP, "clk_div_1_axi_vip", "clk_fpll",
+		CV1835_CLK_AXI_VIP_DIV1, 16, 5, 4, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_0_SRC_VIP_SYS_0, "clk_div_0_src_vip_sys_0", "clk_fpll",
+		CV1835_CLK_SRC_VIP_SYS_0_DIV0, 16, 5, 6, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_1_SRC_VIP_SYS_0, "clk_div_1_src_vip_sys_0", "clk_mipimpll",
+		CV1835_CLK_SRC_VIP_SYS_0_DIV1, 16, 5, 5, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_0_SRC_VIP_SYS_1, "clk_div_0_src_vip_sys_1", "clk_fpll",
+		CV1835_CLK_SRC_VIP_SYS_1_DIV0, 16, 5, 5, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_1_SRC_VIP_SYS_1, "clk_div_1_src_vip_sys_1", "clk_mipimpll",
+		CV1835_CLK_SRC_VIP_SYS_1_DIV1, 16, 5, 4, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_0_AXI_VIDEO_CODEC, "clk_div_0_axi_video_codec", "clk_fpll",
+		CV1835_CLK_AXI_VIDEO_CODEC_DIV0, 16, 4, 3, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_1_AXI_VIDEO_CODEC, "clk_div_1_axi_video_codec", "clk_mux_axi_video_codec_1",
+		CV1835_CLK_AXI_VIDEO_CODEC_DIV1, 16, 4, 3, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_0_VC_SRC0, "clk_div_0_vc_src0", "clk_a0pll",
+		CV1835_CLK_VC_SRC0_DIV0, 16, 4, 1, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_1_VC_SRC0, "clk_div_1_vc_src0", "clk_fpll",
+		CV1835_CLK_VC_SRC0_DIV1, 16, 4, 4, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_1M, "clk_div_1m", "osc",
+		CV1835_CLK_1M_DIV, 16, 6, 25, NULL, CLK_IS_CRITICAL),
+	CLK_DIV(CV1835_CLK_DIV_0_VC_SRC1, "clk_div_0_vc_src1", "clk_cam1pll",
+		CV1835_CLK_VC_SRC1_DIV0, 16, 4, 2, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_1_VC_SRC1, "clk_div_1_vc_src1", "clk_fpll",
+		CV1835_CLK_VC_SRC1_DIV1, 16, 4, 3, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_0_SRC_VIP_SYS_2, "clk_div_0_src_vip_sys_2", "clk_mipimpll",
+		CV1835_CLK_SRC_VIP_SYS_2_DIV0, 16, 5, 3, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_1_SRC_VIP_SYS_2, "clk_div_1_src_vip_sys_2", "clk_fpll",
+		CV1835_CLK_SRC_VIP_SYS_2_DIV1, 16, 5, 4, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_0_PWM_SRC, "clk_div_0_pwm_src", "clk_disppll",
+		CV1835_CLK_PWM_SRC_DIV0, 16, 6, 8, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_1_PWM_SRC, "clk_div_1_pwm_src", "clk_cam0pll",
+		CV1835_CLK_PWM_SRC_DIV1, 16, 6, 8, NULL, 0),
+	CLK_DIV(CV1835_CLK_DIV_187P5M, "clk_div_187p5m", "clk_fpll",
+	  CV1835_CLK_187P5M_DIV, 16, 5, 8, NULL, 0),
+};
+
+/*
+ * Clocks marked as CRITICAL are all needed for the proper functioning
+ * of the SoC.
+ */
+static struct cv1835_composite_clock cv1835_composite_clks[] = {
+	GATE_MUX(CV1835_CLK_A53, "clk_a53", clk_a53_parents,
+		CV1835_CLK_ENABLE0, 0, CV1835_CLK_SELECT, 0, CLK_IS_CRITICAL),
+	GATE_MUX(CV1835_CLK_CPU_AXI0, "clk_cpu_axi0", clk_cpu_axi0_parents,
+		CV1835_CLK_ENABLE0, 1, CV1835_CLK_SELECT, 1, CLK_IS_CRITICAL),
+	GATE_MUX(CV1835_CLK_TPU_AXI, "clk_tpu_axi", clk_tpu_axi_parents,
+		CV1835_CLK_ENABLE0, 4, CV1835_CLK_SELECT, 2, 0),
+	GATE_MUX(CV1835_CLK_TPU_FAB, "clk_tpu_fab", clk_tpu_fab_parents,
+		CV1835_CLK_ENABLE0, 5, CV1835_CLK_SELECT, 3, 0),
+	GATE_MUX(CV1835_CLK_DEBUG, "clk_debug", clk_debug_parents,
+		CV1835_CLK_ENABLE0, 13, CV1835_CLK_SELECT, 4, CLK_IS_CRITICAL),
+	GATE_MUX(CV1835_CLK_EMMC, "clk_emmc", clk_emmc_parents,
+		CV1835_CLK_ENABLE0, 16, CV1835_CLK_SELECT, 5, CLK_IS_CRITICAL),
+	GATE_MUX(CV1835_CLK_SD0, "clk_sd0", clk_sd0_parents,
+		CV1835_CLK_ENABLE0, 19, CV1835_CLK_SELECT, 6, CLK_IS_CRITICAL),
+	GATE_MUX(CV1835_CLK_SD1, "clk_sd1", clk_sd1_parents,
+		CV1835_CLK_ENABLE0, 22, CV1835_CLK_SELECT, 7, CLK_IS_CRITICAL),
+	GATE_MUX(CV1835_CLK_APB_PWM, "clk_apb_pwm", clk_apb_pwm_parents,
+		CV1835_CLK_ENABLE1, 8, CV1835_CLK_SELECT, 8, CLK_IS_CRITICAL),
+	GATE_MUX(CV1835_CLK_UART0, "clk_uart0", clk_uart0_parents,
+		CV1835_CLK_ENABLE1, 14, CV1835_CLK_SELECT, 9, CLK_IS_CRITICAL),
+	GATE_MUX(CV1835_CLK_UART1, "clk_uart1", clk_uart1_parents,
+		CV1835_CLK_ENABLE1, 16, CV1835_CLK_SELECT, 10, CLK_IS_CRITICAL),
+	GATE_MUX(CV1835_CLK_UART2, "clk_uart2", clk_uart2_parents,
+		CV1835_CLK_ENABLE1, 18, CV1835_CLK_SELECT, 11, CLK_IS_CRITICAL),
+	GATE_MUX(CV1835_CLK_UART3, "clk_uart3", clk_uart3_parents,
+		CV1835_CLK_ENABLE1, 20, CV1835_CLK_SELECT, 12, CLK_IS_CRITICAL),
+	GATE_MUX(CV1835_CLK_UART4, "clk_uart4", clk_uart4_parents,
+		CV1835_CLK_ENABLE1, 22, CV1835_CLK_SELECT, 13, CLK_IS_CRITICAL),
+	GATE_MUX(CV1835_CLK_AXI_VIP, "clk_axi_vip", clk_axi_vip_parents,
+		CV1835_CLK_ENABLE2, 4, CV1835_CLK_SELECT, 15, 0),
+	GATE_MUX(CV1835_CLK_SRC_VIP_SYS_0, "clk_src_vip_sys_0", clk_src_vip_sys_0_parents,
+		CV1835_CLK_ENABLE2, 5, CV1835_CLK_SELECT, 16, 0),
+	GATE_MUX(CV1835_CLK_SRC_VIP_SYS_1, "clk_src_vip_sys_1", clk_src_vip_sys_1_parents,
+		CV1835_CLK_ENABLE2, 6, CV1835_CLK_SELECT, 17, 0),
+	GATE_MUX(CV1835_CLK_VC_SRC0, "clk_vc_src0", clk_vc_src0_parents,
+		CV1835_CLK_ENABLE2, 9, CV1835_CLK_SELECT, 19, 0),
+	GATE_MUX(CV1835_CLK_VC_SRC1, "clk_vc_src1", clk_vc_src1_parents,
+		CV1835_CLK_ENABLE3, 28, CV1835_CLK_SELECT, 20, 0),
+	GATE_MUX(CV1835_CLK_SRC_VIP_SYS_2, "clk_src_vip_sys_2", clk_src_vip_sys_2_parents,
+		CV1835_CLK_ENABLE3, 29, CV1835_CLK_SELECT, 21, 0),
+	GATE_DIV(CV1835_CLK_CPU_GIC, "clk_cpu_gic", "clk_fpll",
+		CV1835_CLK_ENABLE0, 2, CV1835_CLK_CPU_GIC_DIV, 16, 5, 5, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV1835_CLK_100K_EMMC, "clk_100k_emmc", "clk_div_1m",
+		CV1835_CLK_ENABLE0, 17, CV1835_CLK_100K_EMMC_DIV, 16, 8, 10, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV1835_CLK_100K_SD0, "clk_100k_sd0", "clk_div_1m",
+		CV1835_CLK_ENABLE0, 20, CV1835_CLK_100K_SD0_DIV, 16, 8, 10, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV1835_CLK_100K_SD1, "clk_100k_sd1", "clk_div_1m",
+		CV1835_CLK_ENABLE0, 23, CV1835_CLK_100K_SD1_DIV, 16, 8, 10, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV1835_CLK_SPI_NAND, "clk_spi_nand", "clk_fpll",
+		CV1835_CLK_ENABLE0, 24, CV1835_CLK_SPI_NAND_DIV, 16, 5, 8, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV1835_CLK_500M_ETH0, "clk_500m_eth0", "clk_fpll",
+		CV1835_CLK_ENABLE0, 25, CV1835_CLK_500M_ETH0_DIV, 16, 5, 3, NULL, 0),
+	GATE_DIV(CV1835_CLK_500M_ETH1, "clk_500m_eth1", "clk_fpll",
+		CV1835_CLK_ENABLE0, 27, CV1835_CLK_500M_ETH1_DIV, 16, 5, 3, NULL, 0),
+	GATE_DIV(CV1835_CLK_GPIO_DB, "clk_gpio_db", "clk_div_1m",
+		CV1835_CLK_ENABLE0, 31, CV1835_CLK_GPIO_DB_DIV, 16, 16, 10, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV1835_CLK_SDMA_AUD0, "clk_sdma_aud0", "clk_a0pll",
+		CV1835_CLK_ENABLE1, 2, CV1835_CLK_SDMA_AUD0_DIV, 16, 8, 18, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV1835_CLK_SDMA_AUD1, "clk_sdma_aud1", "clk_a0pll",
+		CV1835_CLK_ENABLE1, 3, CV1835_CLK_SDMA_AUD1_DIV, 16, 8, 18, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV1835_CLK_SDMA_AUD2, "clk_sdma_aud2", "clk_a0pll",
+		CV1835_CLK_ENABLE1, 4, CV1835_CLK_SDMA_AUD2_DIV, 16, 8, 18, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV1835_CLK_SDMA_AUD3, "clk_sdma_aud3", "clk_a0pll",
+		CV1835_CLK_ENABLE1, 5, CV1835_CLK_SDMA_AUD3_DIV, 16, 8, 18, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV1835_CLK_125M_USB, "clk_125m_usb", "clk_fpll",
+		CV1835_CLK_ENABLE1, 30, CV1835_CLK_125M_USB_DIV, 16, 5, 12, NULL, 0),
+	GATE_DIV(CV1835_CLK_33K_USB, "clk_33k_usb", "clk_div_1m",
+		CV1835_CLK_ENABLE1, 31, CV1835_CLK_33K_USB_DIV, 16, 9, 1, NULL, 0),
+	GATE_DIV(CV1835_CLK_12M_USB, "clk_12m_usb", "clk_fpll",
+		CV1835_CLK_ENABLE2, 0, CV1835_CLK_12M_USB_DIV, 16, 7, 125, NULL, 0),
+	GATE_DIV(CV1835_CLK_DSI_ESC, "clk_dsi_esc", "clk_mux_axi6",
+		CV1835_CLK_ENABLE2, 3, CV1835_CLK_DSI_ESC_DIV, 16, 5, 5, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV1835_CLK_DISP_SRC_VIP, "clk_disp_src_vip", "clk_disppll",
+		CV1835_CLK_ENABLE2, 7, CV1835_CLK_DISP_SRC_VIP_DIV, 16, 6, 8, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV1835_CLK_CAM0, "clk_cam0", "clk_cam0pll",
+		CV1835_CLK_ENABLE2, 16, CV1835_CLK_CAM0_DIV, 16, 6, 14, NULL, 0),
+	GATE_DIV(CV1835_CLK_CAM1, "clk_cam1", "clk_cam1pll",
+		CV1835_CLK_ENABLE2, 17, CV1835_CLK_CAM1_DIV, 16, 6, 14, NULL, 0),
+	GATE_DIV(CV1835_CLK_SPI, "clk_spi", "clk_fpll",
+		CV1835_CLK_ENABLE3, 6, CV1835_CLK_SPI_DIV, 16, 6, 8, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV1835_CLK_I2C, "clk_i2c", "clk_mux_axi6",
+		CV1835_CLK_ENABLE3, 7, CV1835_CLK_I2C_DIV, 16, 4, 1, NULL, 0),
+	GATE_DIV(CV1835_CLK_AUDSRC, "clk_audsrc", "clk_a0pll",
+		CV1835_CLK_ENABLE4, 1, CV1835_CLK_AUDSRC_DIV, 16, 8, 18, NULL, CLK_IS_CRITICAL),
+	GATE_DIV(CV1835_CLK_VC_SRC2, "clk_vc_src2", "clk_fpll",
+		CV1835_CLK_ENABLE4, 3, CV1835_CLK_VC_SRC2_DIV, 16, 4, 3, NULL, 0),
+};
+
+static int __init cvi_clk_flags_setup(char *arg)
+{
+	int ret;
+	unsigned long flags;
+
+	ret = kstrtol(arg, 0, &flags);
+	if (ret)
+		return ret;
+
+	cvi_clk_flags = flags;
+	pr_info("cvi_clk_flags = 0x%lX\n", cvi_clk_flags);
+
+	return 1;
+}
+__setup("cvi_clk_flags=", cvi_clk_flags_setup);
+
+static unsigned long cv1835_pll_rate_calc(u32 regval, unsigned long parent_rate)
+{
+	u64 numerator;
+	u32 predivsel, postdivsel, divsel;
+	u32 denominator;
+
+	predivsel = regval & 0x7f;
+	postdivsel = (regval >> 8) & 0x7f;
+	divsel = (regval >> 17) & 0x7f;
+
+	numerator = parent_rate * divsel;
+	denominator = predivsel * postdivsel;
+	do_div(numerator, denominator);
+
+	return (unsigned long)numerator;
+}
+
+static unsigned long cv1835_g6_pll_recalc_rate(struct clk_hw *hw,
+					       unsigned long parent_rate)
+{
+	struct cv1835_pll_hw_clock *pll_hw = to_cv1835_pll_clk(hw);
+	unsigned long rate;
+	u32 regval;
+
+	regval = readl(pll_hw->base + pll_hw->pll.reg_csr);
+	rate = cv1835_pll_rate_calc(regval, parent_rate);
+
+	return rate;
+}
+
+static long cv1835_g6_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+				     unsigned long *prate)
+{
+	return rate;
+}
+
+static int cv1835_g6_pll_calc_csr(unsigned long parent_rate, unsigned long rate, u32 *csr)
+{
+	u64 numerator;
+	u32 denominator;
+	u32 divsel;		/* [23:17] DIV_SEL */
+	u32 postdivsel = 1;	/* [14:8] POST_DIV_SEL */
+	u32 ictrl = 7;		/* [26:24] ICTRL */
+	u32 selmode = 1;	/* [16:15] SEL_MODE */
+	u32 predivsel = 1;	/* [6:0] PRE_DIV_SEL */
+	u32 vco_clks[] = {900, 1000, 1100, 1200, 1300, 1400, 1500, 1600};
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(vco_clks); i++) {
+		if ((vco_clks[i] * 1000000) % rate == 0) {
+			postdivsel = vco_clks[i] * 1000000 / rate;
+			rate = vco_clks[i] * 1000000;
+			pr_debug("rate=%ld, postdivsel=%d\n", rate, postdivsel);
+			break;
+		}
+	}
+
+	numerator = rate;
+	denominator = parent_rate;
+
+	do_div(numerator, denominator);
+
+	divsel = (u32)numerator & 0x7f;
+	*csr = (divsel << 17) | (postdivsel << 8) | (ictrl << 24) | (selmode << 15) | predivsel;
+
+	pr_debug("csr=0x%08x\n", *csr);
+
+	return 0;
+}
+
+static int cv1835_g6_pll_set_rate(struct clk_hw *hw, unsigned long rate,
+				  unsigned long parent_rate)
+{
+	struct cv1835_pll_hw_clock *pll_hw = to_cv1835_pll_clk(hw);
+	unsigned long flags = 0;
+	int ret;
+	u32 reg_g6_pll_status;
+	u32 regval_csr;
+	u32 regval_g6_pll_status;
+
+	reg_g6_pll_status = (pll_hw->pll.reg_csr & ~PLL_STATUS_MASK) + PLL_STATUS_OFFSET;
+
+	if (pll_hw->lock)
+		spin_lock_irqsave(pll_hw->lock, flags);
+	else
+		__acquire(pll_hw->lock);
+
+	/* calculate csr register */
+	ret = cv1835_g6_pll_calc_csr(parent_rate, rate, &regval_csr);
+	if (ret < 0)
+		return ret;
+
+	/* csr register */
+	writel(regval_csr, pll_hw->base + pll_hw->pll.reg_csr);
+
+	/* wait for pll setting updated */
+	do {
+		regval_g6_pll_status = readl(pll_hw->base + reg_g6_pll_status);
+	} while (regval_g6_pll_status & 0x07);
+
+	if (pll_hw->lock)
+		spin_unlock_irqrestore(pll_hw->lock, flags);
+	else
+		__release(pll_hw->lock);
+
+	return 0;
+}
+
+static const struct clk_ops cv1835_g6_pll_ops = {
+	.recalc_rate = cv1835_g6_pll_recalc_rate,
+	.round_rate = cv1835_g6_pll_round_rate,
+	.set_rate = cv1835_g6_pll_set_rate,
+};
+
+static unsigned long cv1835_g2_pll_recalc_rate(struct clk_hw *hw,
+					       unsigned long parent_rate)
+{
+	struct cv1835_pll_hw_clock *pll_hw = to_cv1835_pll_clk(hw);
+	u32 reg_ssc_set;
+	u32 reg_g2_ssc_ctrl;
+	u32 regval_csr;
+	u32 regval_ssc_set;
+	u32 regval_g2_ssc_ctrl;
+	u64 numerator;
+	u32 denominator;
+	unsigned long clk_ref;
+	unsigned long rate;
+
+	regval_csr = readl(pll_hw->base + pll_hw->pll.reg_csr);
+
+	/* pll without synthesizer */
+	if (pll_hw->pll.reg_ssc == 0) {
+		clk_ref = parent_rate;
+		goto rate_calc;
+	}
+
+	/* calculate synthesizer freq */
+	reg_ssc_set = (pll_hw->pll.reg_ssc & ~SSC_SYN_SET_MASK) + SSC_SYN_SET_OFFSET;
+	reg_g2_ssc_ctrl = (pll_hw->pll.reg_ssc & ~G2_SSC_CTRL_MASK) + G2_SSC_CTRL_OFFSET;
+
+	regval_ssc_set = readl(pll_hw->base + reg_ssc_set);
+	regval_g2_ssc_ctrl = readl(pll_hw->base + reg_g2_ssc_ctrl);
+
+	/* bit0 sel_syn_clk */
+	numerator = (regval_g2_ssc_ctrl & 0x1) ? parent_rate : (parent_rate >> 1);
+
+	numerator <<= 26;
+	denominator = regval_ssc_set;
+	do_div(numerator, denominator);
+
+	clk_ref = numerator;
+
+rate_calc:
+	rate = cv1835_pll_rate_calc(regval_csr, clk_ref);
+
+	return rate;
+}
+
+static const struct {
+	unsigned long rate;
+	u32 csr;
+	u32 ssc_set;
+} g2_pll_rate_lut[] = {
+	{.rate = 48000000, .csr = 0x00129201, .ssc_set = 419430400},
+	{.rate = 406425600, .csr = 0x01108201, .ssc_set = 396287226},
+	{.rate = 417792000, .csr = 0x01108201, .ssc_set = 385505882},
+	{.rate = 768000000, .csr = 0x00108101, .ssc_set = 419430400},
+	{.rate = 832000000, .csr = 0x00108101, .ssc_set = 387166523},
+	{.rate = 1032000000, .csr = 0x00148101, .ssc_set = 390167814},
+	{.rate = 1050000000, .csr = 0x00168101, .ssc_set = 421827145},
+	{.rate = 1056000000, .csr = 0x00208100, .ssc_set = 412977625},
+	{.rate = 1125000000, .csr = 0x00168101, .ssc_set = 393705325},
+	{.rate = 1188000000, .csr = 0x00188101, .ssc_set = 406720388},
+};
+
+static int cv1835_g2_pll_get_setting_from_lut(unsigned long rate, u32 *csr,
+					      u32 *ssc_set)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(g2_pll_rate_lut); i++) {
+		if (rate == g2_pll_rate_lut[i].rate) {
+			*csr = g2_pll_rate_lut[i].csr;
+			*ssc_set = g2_pll_rate_lut[i].ssc_set;
+			return 0;
+		}
+	}
+
+	*csr = 0;
+	*ssc_set = 0;
+	return -ENOENT;
+}
+
+static long cv1835_g2_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+				     unsigned long *prate)
+{
+	return rate;
+}
+
+static int cv1835_g2_pll_set_rate(struct clk_hw *hw, unsigned long rate,
+				  unsigned long parent_rate)
+{
+	struct cv1835_pll_hw_clock *pll_hw = to_cv1835_pll_clk(hw);
+	unsigned long flags = 0;
+	int ret;
+	u32 reg_ssc_set;
+	u32 reg_ssc_ctrl;
+	u32 reg_g2_pll_status;
+	u32 regval_csr;
+	u32 regval_ssc_set;
+	u32 regval_ssc_ctrl;
+	u32 regval_g2_pll_status;
+
+	/* pll without synthesizer */
+	if (pll_hw->pll.reg_ssc == 0)
+		return -ENOENT;
+
+	ret = cv1835_g2_pll_get_setting_from_lut(rate, &regval_csr,
+						 &regval_ssc_set);
+	if (ret < 0)
+		return ret;
+
+	reg_ssc_set = (pll_hw->pll.reg_ssc & ~SSC_SYN_SET_MASK) + SSC_SYN_SET_OFFSET;
+	reg_ssc_ctrl = pll_hw->pll.reg_ssc;
+	reg_g2_pll_status = (pll_hw->pll.reg_csr & ~PLL_STATUS_MASK) + PLL_STATUS_OFFSET;
+
+	if (pll_hw->lock)
+		spin_lock_irqsave(pll_hw->lock, flags);
+	else
+		__acquire(pll_hw->lock);
+
+	/* set synthersizer */
+	writel(regval_ssc_set, pll_hw->base + reg_ssc_set);
+
+	/* bit 0 toggle */
+	regval_ssc_ctrl = readl(pll_hw->base + reg_ssc_ctrl);
+	regval_ssc_ctrl ^= 0x00000001;
+	writel(regval_ssc_ctrl, pll_hw->base + reg_ssc_ctrl);
+
+	/* csr register */
+	writel(regval_csr, pll_hw->base + pll_hw->pll.reg_csr);
+
+	/* wait for pll setting updated */
+	do {
+		regval_g2_pll_status = readl(pll_hw->base + reg_g2_pll_status);
+	} while (regval_g2_pll_status & 0x1F);
+
+	if (pll_hw->lock)
+		spin_unlock_irqrestore(pll_hw->lock, flags);
+	else
+		__release(pll_hw->lock);
+
+	return 0;
+}
+
+static const struct clk_ops cv1835_g2_pll_ops = {
+	.recalc_rate = cv1835_g2_pll_recalc_rate,
+	.round_rate = cv1835_g2_pll_round_rate,
+	.set_rate = cv1835_g2_pll_set_rate,
+};
+
+static struct clk_hw *cv1835_clk_register_pll(struct cv1835_pll_hw_clock *pll_clk,
+					      void __iomem *sys_base)
+{
+	struct clk_hw *hw;
+	struct clk_init_data init;
+	int err;
+
+	pll_clk->lock = &cv1835_clk_lock;
+	pll_clk->base = sys_base;
+
+	if (cvi_clk_flags) {
+		/* copy clk_init_data for modification */
+		memcpy(&init, pll_clk->hw.init, sizeof(init));
+
+		init.flags |= cvi_clk_flags;
+		pll_clk->hw.init = &init;
+	}
+
+	hw = &pll_clk->hw;
+
+	err = clk_hw_register(NULL, hw);
+	if (err)
+		return ERR_PTR(err);
+
+	return hw;
+}
+
+static void cv1835_clk_unregister_pll(struct clk_hw *hw)
+{
+	struct cv1835_pll_hw_clock *pll_hw = to_cv1835_pll_clk(hw);
+
+	clk_hw_unregister(hw);
+	kfree(pll_hw);
+}
+
+static int cv1835_clk_register_plls(struct cv1835_pll_hw_clock *clks,
+				    int num_clks,
+				    struct cv1835_clock_data *data)
+{
+	struct clk_hw *hw;
+	void __iomem *pll_base = data->base;
+	int i;
+
+	for (i = 0; i < num_clks; i++) {
+		struct cv1835_pll_hw_clock *cv1835_clk = &clks[i];
+
+		hw = cv1835_clk_register_pll(cv1835_clk, pll_base);
+		if (IS_ERR(hw)) {
+			pr_err("%s: failed to register clock %s\n",
+			       __func__, cv1835_clk->pll.name);
+			goto err_clk;
+		}
+
+		data->hw_data.hws[clks[i].pll.id] = hw;
+
+		clk_hw_register_clkdev(hw, cv1835_clk->pll.name, NULL);
+	}
+
+	return 0;
+
+err_clk:
+	while (i--)
+		cv1835_clk_unregister_pll(data->hw_data.hws[clks[i].pll.id]);
+
+	return PTR_ERR(hw);
+}
+
+static int cv1835_clk_register_mux(const struct cv1835_mux_clock *clks,
+				   int num_clks,
+				   struct cv1835_clock_data *data)
+{
+	struct clk_hw *hw;
+	void __iomem *sys_base = data->base;
+	int i;
+
+	for (i = 0; i < num_clks; i++) {
+		hw = clk_hw_register_mux(NULL, clks[i].name,
+					 clks[i].parents,
+					 clks[i].num_parents,
+					 clks[i].flags | cvi_clk_flags,
+					 sys_base + clks[i].reg,
+					 clks[i].shift, 1, 0,
+					 &cv1835_clk_lock);
+		if (IS_ERR(hw)) {
+			pr_err("%s: failed to register clock %s\n",
+			       __func__, clks[i].name);
+			goto err_clk;
+		}
+
+		data->hw_data.hws[clks[i].id] = hw;
+
+		clk_hw_register_clkdev(hw, clks[i].name, NULL);
+	}
+
+	return 0;
+
+err_clk:
+	while (i--)
+		clk_hw_unregister_mux(data->hw_data.hws[clks[i].id]);
+
+	return PTR_ERR(hw);
+}
+
+static unsigned long cv1835_clk_div_recalc_rate(struct clk_hw *hw,
+						unsigned long parent_rate)
+{
+	struct cv1835_div_hw_clock *div_hw = to_cv1835_div_clk(hw);
+	struct cv1835_div_clock *div = &div_hw->div;
+	void __iomem *reg_addr = div_hw->base + div->reg;
+	unsigned int val;
+	unsigned long rate;
+
+	if (!(readl(reg_addr) & BIT(3))) {
+		val = div->initval;
+	} else {
+		val = readl(reg_addr) >> div->shift;
+		val &= div_mask(div->width);
+	}
+
+	rate = divider_recalc_rate(hw, parent_rate, val, div->table,
+				   div->div_flags, div->width);
+
+	return rate;
+}
+
+static long cv1835_clk_div_round_rate(struct clk_hw *hw, unsigned long rate,
+				      unsigned long *prate)
+{
+	struct cv1835_div_hw_clock *div_hw = to_cv1835_div_clk(hw);
+	struct cv1835_div_clock *div = &div_hw->div;
+
+	return divider_round_rate(hw, rate, prate, div->table,
+				  div->width, div->div_flags);
+}
+
+
+static int cv1835_clk_div_determine_rate(struct clk_hw *hw,
+					 struct clk_rate_request *req)
+{
+	req->rate = cv1835_clk_div_round_rate(hw, min(req->rate, req->max_rate),
+					      &req->best_parent_rate);
+	return 0;
+}
+
+static int cv1835_clk_div_set_rate(struct clk_hw *hw, unsigned long rate,
+				   unsigned long parent_rate)
+{
+	struct cv1835_div_hw_clock *div_hw = to_cv1835_div_clk(hw);
+	struct cv1835_div_clock *div = &div_hw->div;
+	void __iomem *reg_addr = div_hw->base + div->reg;
+	unsigned long flags = 0;
+	int value;
+	u32 val;
+
+	value = divider_get_val(rate, parent_rate, div->table,
+				div->width, div_hw->div.div_flags);
+	if (value < 0)
+		return value;
+
+	if (div_hw->lock)
+		spin_lock_irqsave(div_hw->lock, flags);
+	else
+		__acquire(div_hw->lock);
+
+	val = readl(reg_addr);
+	val &= ~(div_mask(div->width) << div_hw->div.shift);
+	val |= (u32)value << div->shift;
+	val |= BIT(3);
+	writel(val, reg_addr);
+
+	if (div_hw->lock)
+		spin_unlock_irqrestore(div_hw->lock, flags);
+	else
+		__release(div_hw->lock);
+
+	return 0;
+}
+
+static const struct clk_ops cv1835_clk_div_ops = {
+	.recalc_rate = cv1835_clk_div_recalc_rate,
+	.round_rate = cv1835_clk_div_round_rate,
+	.determine_rate = cv1835_clk_div_determine_rate,
+	.set_rate = cv1835_clk_div_set_rate,
+};
+
+static struct clk_hw *cv1835_clk_register_div(struct cv1835_div_hw_clock *div_clk,
+					      void __iomem *sys_base)
+{
+	struct clk_hw *hw;
+	struct clk_init_data init;
+	int err;
+
+	div_clk->div.div_flags = CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO |
+				 CLK_DIVIDER_ROUND_CLOSEST;
+	div_clk->base = sys_base;
+	div_clk->lock = &cv1835_clk_lock;
+
+	if (cvi_clk_flags) {
+		/* copy clk_init_data for modification */
+		memcpy(&init, div_clk->hw.init, sizeof(init));
+
+		init.flags |= cvi_clk_flags;
+		div_clk->hw.init = &init;
+	}
+
+	hw = &div_clk->hw;
+	err = clk_hw_register(NULL, hw);
+	if (err)
+		return ERR_PTR(err);
+
+	return hw;
+}
+
+static void cv1835_clk_unregister_div(struct clk_hw *hw)
+{
+	struct cv1835_div_hw_clock *div_hw = to_cv1835_div_clk(hw);
+
+	clk_hw_unregister(hw);
+	kfree(div_hw);
+}
+
+static int cv1835_clk_register_divs(struct cv1835_div_hw_clock *clks,
+				    int num_clks,
+				    struct cv1835_clock_data *data)
+{
+	struct clk_hw *hw;
+	void __iomem *sys_base = data->base;
+	unsigned int i;
+
+	for (i = 0; i < num_clks; i++) {
+		struct cv1835_div_hw_clock *cv1835_clk = &clks[i];
+
+		hw = cv1835_clk_register_div(cv1835_clk, sys_base);
+		if (IS_ERR(hw)) {
+			pr_err("%s: failed to register clock %s\n",
+			       __func__, cv1835_clk->div.name);
+			goto err_clk;
+		}
+
+		data->hw_data.hws[clks[i].div.id] = hw;
+
+		clk_hw_register_clkdev(hw, cv1835_clk->div.name, NULL);
+	}
+
+	return 0;
+
+err_clk:
+	while (i--)
+		cv1835_clk_unregister_div(data->hw_data.hws[clks[i].div.id]);
+
+	return PTR_ERR(hw);
+}
+
+static void cv1835_clk_gate_endisable(struct clk_hw *hw, int enable)
+{
+	struct cv1835_gate_hw_clock *gate_hw = to_cv1835_gate_clk(hw);
+	struct cv1835_gate_clock *gate = &gate_hw->gate;
+	void __iomem *reg_addr = gate_hw->base + gate->reg;
+	unsigned long flags = 0;
+	u32 reg;
+
+	if (gate_hw->lock)
+		spin_lock_irqsave(gate_hw->lock, flags);
+	else
+		__acquire(gate_hw->lock);
+
+	reg = readl(reg_addr);
+
+	if (enable)
+		reg |= BIT(gate->shift);
+	else
+		reg &= ~BIT(gate->shift);
+
+	writel(reg, reg_addr);
+
+	if (gate_hw->lock)
+		spin_unlock_irqrestore(gate_hw->lock, flags);
+	else
+		__release(gate_hw->lock);
+}
+
+static int cv1835_clk_gate_enable(struct clk_hw *hw)
+{
+	cv1835_clk_gate_endisable(hw, 1);
+
+	return 0;
+}
+
+static void cv1835_clk_gate_disable(struct clk_hw *hw)
+{
+	struct cv1835_gate_hw_clock *gate_hw = to_cv1835_gate_clk(hw);
+	struct cv1835_gate_clock *gate = &gate_hw->gate;
+
+	/* bypass clk disable if need to wait bus idle*/
+	if (gate->idle_reg)
+		return;
+
+	cv1835_clk_gate_endisable(hw, 0);
+}
+
+static int cv1835_clk_gate_is_enabled(struct clk_hw *hw)
+{
+	u32 reg;
+	struct cv1835_gate_hw_clock *gate_hw = to_cv1835_gate_clk(hw);
+	struct cv1835_gate_clock *gate = &gate_hw->gate;
+	void __iomem *reg_addr = gate_hw->base + gate->reg;
+
+	reg = readl(reg_addr);
+
+	reg &= BIT(gate->shift);
+
+	return reg ? 1 : 0;
+}
+
+static void cv1835_clk_gate_unprepare(struct clk_hw *hw)
+{
+	struct cv1835_gate_hw_clock *gate_hw = to_cv1835_gate_clk(hw);
+	struct cv1835_gate_clock *gate = &gate_hw->gate;
+	void __iomem *idle_reg;
+	u32 idle_state;
+	ktime_t timeout;
+
+	/* wait for axi bus idle */
+	if (gate->idle_reg) {
+		idle_reg = ioremap(gate->idle_reg, 4);
+		if (WARN_ON(!idle_reg))
+			return;
+
+		timeout = ktime_add_ms(ktime_get(), CV1835_BUS_IDLE_TIMEOUT_MS);
+		while ((idle_state = readl(idle_reg)) != gate->idle_state) {
+			if (ktime_after(ktime_get(), timeout)) {
+				pr_err("%s: wait for idle timeout\n", clk_hw_get_name(hw));
+				break;
+			}
+			cpu_relax();
+		}
+
+		iounmap(idle_reg);
+
+		if (idle_state == gate->idle_state) {
+			cv1835_clk_gate_endisable(hw, 0);
+		}
+	}
+}
+
+static const struct clk_ops cv1835_clk_gate_ops = {
+	.enable = cv1835_clk_gate_enable,
+	.disable = cv1835_clk_gate_disable,
+	.is_enabled = cv1835_clk_gate_is_enabled,
+	.unprepare = cv1835_clk_gate_unprepare,
+};
+
+static struct clk_hw *cv1835_clk_register_gate(struct cv1835_gate_hw_clock *gate_clk,
+					       void __iomem *sys_base)
+{
+
+	struct clk_hw *hw;
+	struct clk_init_data init;
+	int err;
+
+	gate_clk->gate.gate_flags = 0;
+	gate_clk->base = sys_base;
+	gate_clk->lock = &cv1835_clk_lock;
+
+	if (cvi_clk_flags) {
+		/* copy clk_init_data for modification */
+		memcpy(&init, gate_clk->hw.init, sizeof(init));
+
+		init.flags |= cvi_clk_flags;
+		gate_clk->hw.init = &init;
+	}
+
+	hw = &gate_clk->hw;
+	err = clk_hw_register(NULL, hw);
+	if (err) {
+		return ERR_PTR(err);
+	}
+
+	return hw;
+}
+
+static void cv1835_clk_unregister_gate(struct clk_hw *hw)
+{
+	struct cv1835_gate_hw_clock *gate_hw = to_cv1835_gate_clk(hw);
+
+	clk_hw_unregister(hw);
+	kfree(gate_hw);
+}
+
+static int cv1835_clk_register_gates(struct cv1835_gate_hw_clock *clks,
+				     int num_clks,
+				     struct cv1835_clock_data *data)
+{
+	struct clk_hw *hw;
+	void __iomem *sys_base = data->base;
+	unsigned int i;
+
+	for (i = 0; i < num_clks; i++) {
+		struct cv1835_gate_hw_clock *cv1835_clk = &clks[i];
+
+		hw = cv1835_clk_register_gate(cv1835_clk, sys_base);
+
+		if (IS_ERR(hw)) {
+			pr_err("%s: failed to register clock %s\n",
+			       __func__, cv1835_clk->gate.name);
+			goto err_clk;
+		}
+
+		data->hw_data.hws[clks[i].gate.id] = hw;
+		clk_hw_register_clkdev(hw, cv1835_clk->gate.name, NULL);
+	}
+
+	return 0;
+
+err_clk:
+	while (i--)
+		cv1835_clk_unregister_gate(data->hw_data.hws[clks[i].gate.id]);
+
+	return PTR_ERR(hw);
+
+}
+
+static struct clk_hw *cv1835_clk_register_composite(struct cv1835_composite_clock *clks,
+						    void __iomem *sys_base)
+{
+	struct clk_hw *hw;
+	struct clk_mux *mux = NULL;
+	struct cv1835_gate_hw_clock *gate_hws = NULL;
+	struct cv1835_div_hw_clock *div_hws = NULL;
+	struct clk_hw *mux_hw = NULL, *gate_hw = NULL, *div_hw = NULL;
+	const struct clk_ops *mux_ops = NULL, *gate_ops = NULL, *div_ops = NULL;
+	const char * const *parent_names;
+	const char *parent;
+	int num_parents;
+	int ret;
+
+	if (clks->mux_shift >= 0) {
+		mux = kzalloc(sizeof(*mux), GFP_KERNEL);
+		if (!mux)
+			return ERR_PTR(-ENOMEM);
+
+		mux->reg = sys_base + clks->mux_reg;
+		mux->mask = 1;
+		mux->shift = clks->mux_shift;
+		mux_hw = &mux->hw;
+		mux_ops = &clk_mux_ops;
+		mux->lock = &cv1835_clk_lock;
+
+		parent_names = clks->parents;
+		num_parents = clks->num_parents;
+	} else {
+		parent = clks->parent;
+		parent_names = &parent;
+		num_parents = 1;
+	}
+
+	if (clks->gate_shift >= 0) {
+		gate_hws = kzalloc(sizeof(*gate_hws), GFP_KERNEL);
+		if (!gate_hws) {
+			ret = -ENOMEM;
+			goto err_out;
+		}
+
+		gate_hws->base = sys_base;
+		gate_hws->gate.reg = clks->gate_reg;
+		gate_hws->gate.shift = clks->gate_shift;
+		gate_hws->gate.gate_flags = 0;
+		gate_hws->lock = &cv1835_clk_lock;
+
+		gate_hw = &gate_hws->hw;
+		gate_ops = &cv1835_clk_gate_ops;
+	}
+
+	if (clks->div_shift >= 0) {
+		div_hws = kzalloc(sizeof(*div_hws), GFP_KERNEL);
+		if (!div_hws) {
+			ret = -ENOMEM;
+			goto err_out;
+		}
+
+		div_hws->base = sys_base;
+		div_hws->div.reg = clks->div_reg;
+		div_hws->div.shift = clks->div_shift;
+		div_hws->div.width = clks->div_width;
+		div_hws->div.table = clks->table;
+		div_hws->div.initval = clks->div_initval;
+		div_hws->lock = &cv1835_clk_lock;
+		div_hws->div.div_flags = CLK_DIVIDER_ONE_BASED |
+					 CLK_DIVIDER_ROUND_CLOSEST |
+					 CLK_DIVIDER_ALLOW_ZERO;
+
+		div_hw = &div_hws->hw;
+		div_ops = &cv1835_clk_div_ops;
+	}
+
+	hw = clk_hw_register_composite(NULL, clks->name, parent_names,
+				       num_parents, mux_hw, mux_ops, div_hw,
+				       div_ops, gate_hw, gate_ops,
+				       clks->flags | cvi_clk_flags);
+
+	if (IS_ERR(hw)) {
+		ret = PTR_ERR(hw);
+		goto err_out;
+	}
+
+	return hw;
+
+err_out:
+	kfree(div_hws);
+	kfree(gate_hws);
+	kfree(mux);
+
+	return ERR_PTR(ret);
+}
+
+static void cv1835_clk_unregister_composite(struct clk_hw *hw)
+{
+	struct clk_composite *composite;
+
+	composite = to_clk_composite(hw);
+
+	clk_hw_unregister(hw);
+	kfree(composite);
+}
+
+static int cv1835_clk_register_composites(struct cv1835_composite_clock *clks,
+					  int num_clks,
+					  struct cv1835_clock_data *data)
+{
+	struct clk_hw *hw;
+	void __iomem *sys_base = data->base;
+	int i;
+
+	for (i = 0; i < num_clks; i++) {
+		struct cv1835_composite_clock *cv1835_clk = &clks[i];
+
+		hw = cv1835_clk_register_composite(cv1835_clk, sys_base);
+		if (IS_ERR(hw)) {
+			pr_err("%s: failed to register clock %s\n",
+			       __func__, cv1835_clk->name);
+			goto err_clk;
+		}
+
+		data->hw_data.hws[clks[i].id] = hw;
+
+		clk_hw_register_clkdev(hw, cv1835_clk->name, NULL);
+	}
+
+	return 0;
+
+err_clk:
+	while (i--)
+		cv1835_clk_unregister_composite(data->hw_data.hws[clks[i].id]);
+
+	return PTR_ERR(hw);
+}
+
+static const struct of_device_id cvi_clk_match_ids_tables[] = {
+	{
+		.compatible = "cvitek,cv1835-clk",
+	},
+	{}
+};
+
+static void __init cvi_clk_init(struct device_node *node)
+{
+	struct cv1835_clock_data *clk_data;
+	static void __iomem *base;
+	int num_clks;
+	int i;
+	int ret = 0;
+
+	num_clks = ARRAY_SIZE(cv1835_pll_clks) +
+		   ARRAY_SIZE(cv1835_div_clks) +
+		   ARRAY_SIZE(cv1835_mux_clks) +
+		   ARRAY_SIZE(cv1835_composite_clks) +
+		   ARRAY_SIZE(cv1835_gate_clks);
+
+	clk_data = kzalloc(sizeof(struct cv1835_clock_data) +
+			   sizeof(struct clk_hw) * num_clks,
+			   GFP_KERNEL);
+	if (!clk_data) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	for (i = 0; i < num_clks; i++)
+		clk_data->hw_data.hws[i] = ERR_PTR(-ENOENT);
+
+	clk_data->hw_data.num = num_clks;
+
+	clk_data->lock = &cv1835_clk_lock;
+
+	base = of_iomap(node, 0);
+	if (!base) {
+		pr_err("Failed to map address range for cvitek,cv1835-clk node\n");
+		return;
+	}
+
+	clk_data->base = base;
+
+	cv1835_clk_register_plls(cv1835_pll_clks,
+				 ARRAY_SIZE(cv1835_pll_clks),
+				 clk_data);
+
+	cv1835_clk_register_divs(cv1835_div_clks,
+				 ARRAY_SIZE(cv1835_div_clks),
+				 clk_data);
+
+	cv1835_clk_register_mux(cv1835_mux_clks,
+				ARRAY_SIZE(cv1835_mux_clks),
+				clk_data);
+
+	cv1835_clk_register_composites(cv1835_composite_clks,
+				       ARRAY_SIZE(cv1835_composite_clks),
+				       clk_data);
+
+	cv1835_clk_register_gates(cv1835_gate_clks,
+				  ARRAY_SIZE(cv1835_gate_clks),
+				  clk_data);
+
+	/* register clk-provider */
+	ret = of_clk_add_hw_provider(node, of_clk_hw_onecell_get, &clk_data->hw_data);
+	if (ret)
+		pr_err("Unable to add hw clk provider\n");
+
+	/* force enable clocks */
+	clk_prepare_enable(clk_data->hw_data.hws[CV1835_CLK_DSI_MAC_VIP]->clk);
+	clk_prepare_enable(clk_data->hw_data.hws[CV1835_CLK_DISP_VIP]->clk);
+	clk_prepare_enable(clk_data->hw_data.hws[CV1835_CLK_BT_VIP]->clk);
+	clk_prepare_enable(clk_data->hw_data.hws[CV1835_CLK_SC_TOP_VIP]->clk);
+
+#if defined(CONFIG_COMMON_CLK_CV1832_TPU_500M)
+	/* switch clk_tpu_axi's parent to div1 */
+	ret = clk_set_parent(clk_data->hw_data.hws[CV1835_CLK_TPU_AXI]->clk,
+			     clk_data->hw_data.hws[CV1835_CLK_DIV_1_TPU_AXI]->clk);
+	if (ret)
+		pr_err("Set clk_tpu_axi's parent to div1 failed\n");
+
+	/* Set clk_tpu_axi max rate to 500M */
+	ret = clk_set_max_rate(clk_data->hw_data.hws[CV1835_CLK_TPU_AXI]->clk, 500000000);
+	if (ret)
+		pr_err("Set clk_tpu_axi max rate to 500M failed\n");
+
+	/* Set clk_tpu_axi rate to 500M */
+	ret = clk_set_rate(clk_data->hw_data.hws[CV1835_CLK_TPU_AXI]->clk, 500000000);
+	if (ret)
+		pr_err("Set clk_tpu_axi rate to 500M failed\n");
+
+	/* switch clk_tpu_fab's parent to div1 */
+	ret = clk_set_parent(clk_data->hw_data.hws[CV1835_CLK_TPU_FAB]->clk,
+			     clk_data->hw_data.hws[CV1835_CLK_DIV_1_TPU_FAB]->clk);
+	if (ret)
+		pr_err("Set clk_tpu_fab's parent to div1 failed\n");
+
+	/* Set clk_tpu_fab rate to 300M */
+	ret = clk_set_rate(clk_data->hw_data.hws[CV1835_CLK_TPU_FAB]->clk, 300000000);
+	if (ret)
+		pr_err("Set clk_tpu_fab rate to 300M failed\n");
+#endif
+
+	if (!ret)
+		return;
+
+out:
+	pr_err("%s failed error number %d\n", __func__, ret);
+}
+CLK_OF_DECLARE(cvi_clk, "cvitek,cv1835-clk", cvi_clk_init);
diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index 7e1bd79fbee8..6fef0b8bf293 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -734,6 +734,8 @@ source "drivers/dma/ti/Kconfig"
 
 source "drivers/dma/fsl-dpaa2-qdma/Kconfig"
 
+source "drivers/dma/cvitek/Kconfig"
+
 # clients
 comment "DMA Clients"
 	depends on DMA_ENGINE
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index 948a8da05f8b..e51658a8d18b 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -87,3 +87,4 @@ obj-y += mediatek/
 obj-y += qcom/
 obj-y += ti/
 obj-y += xilinx/
+obj-y += cvitek/
diff --git a/drivers/dma/cvitek/Kconfig b/drivers/dma/cvitek/Kconfig
new file mode 100644
index 000000000000..68a0e02a4738
--- /dev/null
+++ b/drivers/dma/cvitek/Kconfig
@@ -0,0 +1,6 @@
+config DW_DMAC_CVITEK
+        bool "cvitek dma engine based DW DMAC"
+        select DMA_ENGINE
+        help
+          Support the DMA engine for cvitek platform devices.
+
diff --git a/drivers/dma/cvitek/Makefile b/drivers/dma/cvitek/Makefile
new file mode 100644
index 000000000000..e6a372d83831
--- /dev/null
+++ b/drivers/dma/cvitek/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_DW_DMAC_CVITEK) += cvitek-dma.o
diff --git a/drivers/dma/cvitek/cvitek-dma.c b/drivers/dma/cvitek/cvitek-dma.c
new file mode 100644
index 000000000000..d810d7fa7467
--- /dev/null
+++ b/drivers/dma/cvitek/cvitek-dma.c
@@ -0,0 +1,2192 @@
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/clk-provider.h>
+#include <linux/clk.h>
+#include <linux/pm_runtime.h>
+#include <linux/platform_device.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+
+#include <linux/of.h>
+#include <linux/of_dma.h>
+#include <linux/acpi.h>
+#include <linux/acpi_dma.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+
+#include "../dmaengine.h"
+#include "cvitek-dma.h"
+
+#define DRV_NAME "dw_dmac"
+
+/* #define CONFIG_SYSDMA_JIRA_BUG_BM1880_17 */
+
+/*
+ *	The dmaengine doc says that, defer most work to a tasklet is inefficient,
+ *	and there may be schedule latency, and slow down the trans rate.
+ *	so we should avoid this ?
+ */
+
+/* #define DO_NOT_USE_TASK */
+
+static void dw_dma_off(struct dw_dma *dw);
+static void dw_dma_on(struct dw_dma *dw);
+static bool dw_dma_filter(struct dma_chan *chan, void *param);
+static int dw_dma_cyclic_start(struct dma_chan *chan);
+
+#define to_dw_desc(h)	list_entry(h, struct dw_desc, desc_node)
+
+#define DWC_DEFAULT_CTL(_chan) ({				\
+			struct dw_dma_chan *_dwc = to_dw_dma_chan(_chan);	\
+			struct dma_slave_config *_sconfig = &_dwc->dma_sconfig; \
+			bool _is_slave = is_slave_direction(_dwc->direction);	\
+			u8 _smsize = _is_slave ? _sconfig->src_maxburst :	\
+				DW_DMA_MSIZE_32;			\
+			u8 _dmsize = _is_slave ? _sconfig->dst_maxburst :	\
+				DW_DMA_MSIZE_32;			\
+			u8 _dms = (_dwc->direction == DMA_MEM_TO_DEV) ?		\
+				_dwc->dws.p_master : _dwc->dws.m_master;	\
+			u8 _sms = (_dwc->direction == DMA_DEV_TO_MEM) ?		\
+				_dwc->dws.p_master : _dwc->dws.m_master;	\
+										\
+			(DWC_CTL_DST_MSIZE(_dmsize)				\
+			 | DWC_CTL_SRC_MSIZE(_smsize)				\
+			 | DWC_CTL_DMS(_dms)					\
+			 | DWC_CTL_SMS(_sms));					\
+		})
+
+
+static inline struct dw_dma_chan_regs __iomem *
+__dwc_regs(struct dw_dma_chan *dwc)
+{
+	return dwc->ch_regs;
+}
+
+static inline struct dw_dma_regs __iomem *
+__dw_regs(struct dw_dma *dw)
+{
+	return dw->regs;
+}
+
+static inline struct dw_desc *txd_to_dw_desc(struct dma_async_tx_descriptor *txd)
+{
+	return container_of(txd, struct dw_desc, txd);
+}
+
+static inline struct dw_dma_chan *to_dw_dma_chan(struct dma_chan *chan)
+{
+	return container_of(chan, struct dw_dma_chan, chan);
+}
+
+static inline struct dw_dma *to_dw_dma(struct dma_device *ddev)
+{
+	return container_of(ddev, struct dw_dma, dma);
+}
+
+static struct device *chan2dev(struct dma_chan *chan)
+{
+	return &chan->dev->device;
+}
+
+/*
+ * Fix sconfig's burst size according to dw_dmac. We need to convert them as:
+ * 1 -> 0, 4 -> 1, 8 -> 2, 16 -> 3.
+ *
+ * NOTE: burst size 2 is not supported by controller.
+ *
+ * This can be done by finding least significant bit set: n & (n - 1)
+ */
+static inline void convert_burst(u32 *maxburst)
+{
+	if (*maxburst > 1)
+		*maxburst = fls(*maxburst) - 2;
+	else
+		*maxburst = 0;
+}
+
+static inline void dwc_dump_chan_regs(struct dw_dma_chan *dwc)
+{
+	dev_err(chan2dev(&dwc->chan),
+		"  SAR: 0x%llx DAR: 0x%llx LLP: 0x%llx CTL: 0x%llx BLOCK_TS: 0x%llx\n",
+		channel_readq(dwc, SAR),
+		channel_readq(dwc, DAR),
+		channel_readq(dwc, LLP),
+		channel_readq(dwc, CTL),
+		channel_readq(dwc, BLOCK_TS));
+}
+
+static inline void dwc_dump_lli(struct dw_dma_chan *dwc, struct dw_desc *desc)
+{
+	dev_err(chan2dev(&dwc->chan), "  desc: s0x%llx d0x%llx l0x%llx c0x%llx b0x%llx\n",
+		lli_read(desc, sar),
+		lli_read(desc, dar),
+		lli_read(desc, llp),
+		lli_read(desc, ctl),
+		lli_read(desc, block_ts));
+}
+
+#if 0
+#define ENABLE_ALL_REG_STATUS	(0x3 << 0 | 0xFFF << 3 | 0x3F << 16 | 0x1F << 27)
+static void dwc_interrupts_set(struct dw_dma_chan *dwc, bool val)
+{
+	u64 int_val;
+
+	if (val) {
+		/* channel int signal enable*/
+		int_val = DWC_CH_INTSIG_DMA_TRA_DONE;
+		channel_writeq(dwc, INTSIGNAL_ENABLEREG, int_val);
+
+		/*  channel int status enable in reg, all enable*/
+		channel_writeq(dwc, INTSTATUS_ENABLEREG, ENABLE_ALL_REG_STATUS);
+	} else {
+		/* channel int signal disable*/
+		int_val = channel_readq(dwc, INTSIGNAL_ENABLEREG);
+		int_val &= ~DWC_CH_INTSIG_DMA_TRA_DONE;
+		channel_writeq(dwc, INTSIGNAL_ENABLEREG, int_val);
+		/*  channel int status disable in reg, all disable*/
+		int_val = channel_readq(dwc, INTSTATUS);
+		channel_writeq(dwc, INTCLEARREG, int_val);
+		int_val &= ~ENABLE_ALL_REG_STATUS;
+		channel_writeq(dwc, INTSTATUS_ENABLEREG, int_val);
+	}
+}
+#endif
+
+static void dwc_prepare_clk(struct dw_dma *dw)
+{
+	int err;
+
+	dw->clk_count++;
+	if (dw->clk_count == 1)	{
+		err = clk_enable(dw->clk);
+		if (err)
+			dev_err(dw->dev, "CVITEK DMA enable clk_sdma_axi failed\n");
+	}
+}
+
+static void dwc_unprepare_clk(struct dw_dma *dw)
+{
+
+	dw->clk_count--;
+
+	if (dw->clk_count == 0)
+		clk_disable(dw->clk);
+
+	if (dw->clk_count < 0)
+		dev_err(dw->dev, "CVITEK sysDMA clk count is invalid\n");
+}
+
+static void dwc_initialize(struct dw_dma_chan *dwc)
+{
+	u64 cfg = 0, int_status_reg;
+	bool has_device_fc;
+	bool hs_polarity = dwc->dws.hs_polarity;
+	struct dma_slave_config	*sconfig = &dwc->dma_sconfig;
+
+	has_device_fc = sconfig->device_fc;
+	if (test_bit(DW_DMA_IS_INITIALIZED, &dwc->flags))
+		return;
+
+	cfg = DWC_CFG_DST_PER((u64)dwc->dws.dst_id)
+	      | DWC_CFG_SRC_PER((u64)dwc->dws.src_id)
+	      | DWC_CFG_SRC_OSR_LMT((u64)DW_DMA_MAX_NR_REQUESTS - 1)
+	      | DWC_CFG_DST_OSR_LMT((u64)DW_DMA_MAX_NR_REQUESTS - 1)
+	      | DWC_CFG_CH_PRIOR((u64)dwc->priority)
+	      | DWC_CFG_DST_MULTBLK_TYPE(LINK_LIST)
+	      | DWC_CFG_SRC_MULTBLK_TYPE(LINK_LIST);
+
+	/* choose Flowcontrol and handshaking type */
+	switch (dwc->direction) {
+	case DMA_MEM_TO_MEM:
+		cfg |= DWC_CFG_TT_FC((u64)DW_DMA_FC_D_M2M);
+		break;
+	case DMA_MEM_TO_DEV:
+		cfg |= has_device_fc ? DWC_CFG_TT_FC((u64)DW_DMA_FC_DP_M2P)
+		       : DWC_CFG_TT_FC((u64)DW_DMA_FC_D_M2P);
+		cfg |= DWC_CFG_HS_SEL_DST_HW;
+		break;
+	case DMA_DEV_TO_MEM:
+		cfg |= has_device_fc ? DWC_CFG_TT_FC((u64)DW_DMA_FC_SP_P2M)
+		       : DWC_CFG_TT_FC((u64)DW_DMA_FC_D_P2M);
+		cfg |= DWC_CFG_HS_SEL_SRC_HW;
+		break;
+	default:
+		break;
+	}
+
+	/* Set polarity of handshake interface */
+	cfg |= hs_polarity ? DWC_CFG_SRC_HWHS_POL_H | DWC_CFG_DST_HWHS_POL_H : 0;
+
+	channel_writeq(dwc, CFG, cfg);
+	/* Enable interrupts */
+	if (test_bit(DW_DMA_IS_CYCLIC, &dwc->flags))
+		int_status_reg =  DWC_CH_INTSTA_BLOCK_TFR_DONE;
+	else {
+		int_status_reg =  DWC_CH_INTSTA_DMA_TFR_DONE;
+#if 0
+		| DWC_CH_INTSTA_BLOCK_TFR_DONE
+		| DWC_CH_INTSTA_SRC_TFR_COMP_EN
+		| DWC_CH_INTSTA_DST_TFR_COMP_EN
+		| DWC_CH_INTSTA_SRC_DEC_ERR_EN
+		| DWC_CH_INTSTA_DST_DEC_ERR_EN
+		| DWC_CH_INTSTA_LLI_RD_DEV_ERR_EN
+		| DWC_CH_INTSTA_LLI_WD_DEV_ERR_EN
+		| DWC_CH_INTSTA_LLI_RD_SLV_ERR_EN
+		| DWC_CH_INTSTA_LLI_WD_SLV_ERR_EN
+		| DWC_CH_INTSTA_CH_ABORTED_EN;
+#endif
+	}
+
+	channel_writeq(dwc, INTSTATUS_ENABLEREG, int_status_reg);
+
+	set_bit(DW_DMA_IS_INITIALIZED, &dwc->flags);
+}
+
+/* Called with dwc->lock held and bh disabled */
+#define DWC_DMA_MAX_RETRY	3000
+static void dwc_dostart(struct dw_dma_chan *dwc, struct dw_desc *first)
+{
+	u64 ch_en_reg;
+	struct dw_dma *dw = to_dw_dma(dwc->chan.device);
+	u32 retry_count = 0;
+
+	/* ASSERT:  channel is idle */
+	while (dma_readq(dw, CH_EN) & dwc->mask) {
+
+		if (retry_count >= DWC_DMA_MAX_RETRY) {
+			dev_err(chan2dev(&dwc->chan),
+				"%s: BUG: Attempted to start non-idle channel\n",
+				__func__);
+			//dwc_dump_chan_regs(dwc);
+
+			/* The tasklet will hopefully advance the queue... */
+			return;
+		}
+		retry_count++;
+	}
+
+	dwc_initialize(dwc);
+
+	channel_writeq(dwc, LLP, first->txd.phys);
+
+	ch_en_reg = dwc->mask << DW_DMAC_CH_EN_WE_OFFSET;
+	dma_writeq(dw, CH_EN, dwc->mask | ch_en_reg);
+}
+
+static struct dw_desc *dwc_first_active(struct dw_dma_chan *dwc)
+{
+	return to_dw_desc(dwc->active_list.next);
+}
+
+static void dwc_dostart_first_queued(struct dw_dma_chan *dwc)
+{
+	struct dw_desc *desc;
+
+	if (list_empty(&dwc->queue))
+		return;
+
+	list_move(dwc->queue.next, &dwc->active_list);
+	desc = dwc_first_active(dwc);
+	dwc_dostart(dwc, desc);
+}
+
+static dma_cookie_t dwc_tx_submit(struct dma_async_tx_descriptor *tx)
+{
+	unsigned long flags;
+	dma_cookie_t cookie;
+	struct dw_desc *desc = txd_to_dw_desc(tx);
+	struct dw_dma_chan *dwc = to_dw_dma_chan(tx->chan);
+
+	spin_lock_irqsave(&dwc->lock, flags);
+	cookie = dma_cookie_assign(tx);
+	if (test_bit(DW_DMA_IS_CYCLIC, &dwc->flags)) {
+		spin_unlock_irqrestore(&dwc->lock, flags);
+		return cookie;
+	}
+	/*
+	 * REVISIT: We should attempt to chain as many descriptors as
+	 * possible, perhaps even appending to those already submitted
+	 * for DMA. But this is hard to do in a race-free manner.
+	 */
+
+	list_add_tail(&desc->desc_node, &dwc->queue);
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	return cookie;
+}
+
+static struct dw_desc *dwc_desc_get(struct dw_dma_chan *dwc)
+{
+	dma_addr_t phys;
+	struct dw_desc *desc;
+	struct dw_dma *dw = to_dw_dma(dwc->chan.device);
+
+	desc = dma_pool_zalloc(dw->desc_pool, GFP_ATOMIC, &phys);
+	if (!desc)
+		return NULL;
+
+	dwc->descs_allocated++;
+	INIT_LIST_HEAD(&desc->tx_list);
+	dma_async_tx_descriptor_init(&desc->txd, &dwc->chan);
+	desc->txd.tx_submit = dwc_tx_submit;
+	desc->txd.flags = DMA_CTRL_ACK;
+	desc->txd.phys = phys;
+
+	return desc;
+}
+
+static void dwc_desc_put(struct dw_dma_chan *dwc, struct dw_desc *desc)
+{
+	struct dw_desc *child, *_next;
+	struct dw_dma *dw = to_dw_dma(dwc->chan.device);
+
+	if (unlikely(!desc))
+		return;
+
+	list_for_each_entry_safe(child, _next, &desc->tx_list, desc_node) {
+		list_del(&child->desc_node);
+		dma_pool_free(dw->desc_pool, child, child->txd.phys);
+		dwc->descs_allocated--;
+	}
+
+	dma_pool_free(dw->desc_pool, desc, desc->txd.phys);
+	dwc->descs_allocated--;
+}
+
+#ifdef CONFIG_SYSDMA_JIRA_BUG_BM1880_17
+static dma_addr_t fix_dma_bug_copy_get(struct dw_dma_chan *dwc,
+				       struct dma_chan *chan, struct scatterlist *sgl,
+				       int sg_index, int sg_len, int size)
+{
+	int i;
+	dma_addr_t bug_addr;
+	unsigned int *bug_buf = NULL;
+	unsigned char *tmp_buf, *record;
+	unsigned int fix_size;
+	char dma_pool_name[32];
+	struct dbg_fix_sg *db_sg = dwc->bug_info;
+
+	if (!db_sg) {
+		db_sg = kzalloc(sizeof(*db_sg), GFP_ATOMIC);
+		if (!db_sg) {
+			dev_err(chan->device->dev,
+				"BUG: Alloc db_sg failed,No memory !\n");
+			return 0;
+		}
+		dwc->bug_info = db_sg;
+	}
+	db_sg->count = sg_len;
+	if (!db_sg->fix_buf) {
+		db_sg->fix_buf = kcalloc(sg_len, sizeof(struct dbg_fix_buf), GFP_ATOMIC);
+		if (!db_sg->fix_buf) {
+			dev_err(chan->device->dev,
+				"BUG: Alloc fix_buf failed,No memory !\n");
+			return 0;
+		}
+	}
+	if (!dwc->bug_fix_dma_pool) {
+		snprintf(dma_pool_name, sizeof(dma_pool_name), "%s_%x",
+			 "dma_chan_buf", dwc->mask);
+		dwc->bug_fix_dma_pool = dma_pool_create(dma_pool_name, chan->device->dev,
+							PAGE_SIZE, BIT(2), 0);
+		if (!dwc->bug_fix_dma_pool) {
+			dev_err(chan->device->dev, "unable to allocate dma pool\n");
+			return 0;
+		}
+	}
+
+	record = tmp_buf = kzalloc(size, GFP_ATOMIC);
+	if (!tmp_buf) {
+		dev_err(chan->device->dev,
+			"BUG: Alloc tmp_buf failed,No memory !\n");
+		return 0;
+	}
+
+	fix_size = (size << 2);
+	if (unlikely(fix_size > PAGE_SIZE)) {
+		bug_buf = dma_alloc_coherent(chan->device->dev, fix_size,
+					     &bug_addr, GFP_ATOMIC);
+		if (!bug_buf) {
+			dev_err(chan->device->dev,
+				"BUG: Alloc bug_buf failed,No DMA memory !\n");
+			return 0;
+		}
+	} else {
+		bug_buf = dma_pool_zalloc(dwc->bug_fix_dma_pool, GFP_ATOMIC, &bug_addr);
+		if (!bug_buf) {
+			dev_err(chan->device->dev,
+				"BUG: Alloc bug_buf failed,No DMA Pool memory !\n");
+			return 0;
+		}
+	}
+
+	db_sg->fix_buf[sg_index].id = sg_index;
+	db_sg->fix_buf[sg_index].cpu_addr = bug_buf;
+	db_sg->fix_buf[sg_index].dma_hanle = bug_addr;
+	db_sg->fix_buf[sg_index].size = fix_size;
+	db_sg->fix_buf[sg_index].state = 1;
+
+	//sg_copy_to_buffer(sgl, nents, tmp_buf, size);
+	memcpy((void *)tmp_buf, sg_virt(sgl), size);
+
+	for (i = 0; i < size; i++) {
+		memcpy((void *)bug_buf, (void *)tmp_buf, 1);
+		bug_buf++;
+		tmp_buf++;
+	}
+
+	kfree(record);
+
+	return bug_addr;
+}
+
+static void fix_dma_bug_copy_put(struct dw_dma_chan *dwc, struct dma_chan *chan)
+{
+	int i;
+	struct dbg_fix_sg *db_sg;
+	struct dbg_fix_buf *db_buf;
+
+	if (!dwc->bug_info)
+		return;
+	if (!dwc->bug_info->fix_buf)
+		return;
+
+	db_sg = dwc->bug_info;
+	db_buf = db_sg->fix_buf;
+
+	for (i = 0; i < db_sg->count; i++) {
+		if (db_buf->size > PAGE_SIZE) {
+			dma_free_coherent(chan->device->dev, db_buf->size,
+					  db_buf->cpu_addr, db_buf->dma_hanle);
+		} else {
+			dma_pool_free(dwc->bug_fix_dma_pool, db_buf->cpu_addr, db_buf->dma_hanle);
+		}
+		db_buf->state = 0;
+		db_buf++;
+	}
+
+	/* dump info */
+	db_buf = db_sg->fix_buf;
+	for (i = 0; i < db_sg->count; i++) {
+		if (db_buf->state == 1)
+			dev_warn(chan->device->dev,
+				 "db_buf id: %d,cpu_addr %p, dma_hanle %pad, size 0x%x state %d\n",
+				 db_buf->id, db_buf->cpu_addr, &(db_buf->dma_hanle), db_buf->size, db_buf->state);
+	}
+
+	kfree(db_sg->fix_buf);
+	db_sg->fix_buf = NULL;
+}
+#endif
+
+static void dwc_descriptor_complete(struct dw_dma_chan *dwc, struct dw_desc *desc,
+				    bool callback_required)
+{
+	unsigned long flags;
+	struct dw_desc *child;
+	struct dmaengine_desc_callback cb;
+	struct dma_async_tx_descriptor *txd = &desc->txd;
+	struct dw_dma *dw = to_dw_dma(dwc->chan.device);
+
+	spin_lock_irqsave(&dwc->lock, flags);
+	dma_cookie_complete(txd);
+
+	if (callback_required)
+		dmaengine_desc_get_callback(txd, &cb);
+	else
+		memset(&cb, 0, sizeof(cb));
+
+	/* async_tx_ack */
+	list_for_each_entry(child, &desc->tx_list, desc_node)
+		async_tx_ack(&child->txd);
+	async_tx_ack(&desc->txd);
+	dwc_desc_put(dwc, desc);
+
+#ifdef CONFIG_SYSDMA_JIRA_BUG_BM1880_17
+	fix_dma_bug_copy_put(dwc, &dwc->chan);
+#endif
+
+	dmaengine_desc_callback_invoke(&cb, NULL);
+	dwc_unprepare_clk(dw);
+
+	spin_unlock_irqrestore(&dwc->lock, flags);
+}
+
+static void dwc_complete_all(struct dw_dma *dw, struct dw_dma_chan *dwc)
+{
+	unsigned long flags;
+	struct dw_desc *desc, *_desc;
+
+	LIST_HEAD(list);
+
+	spin_lock_irqsave(&dwc->lock, flags);
+
+	/*
+	 * Submit queued descriptors ASAP, i.e. before we go through
+	 * the completed ones.
+	 */
+	list_splice_init(&dwc->active_list, &list);
+	dwc_dostart_first_queued(dwc);
+
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	list_for_each_entry_safe(desc, _desc, &list, desc_node)
+		dwc_descriptor_complete(dwc, desc, true);
+}
+
+/* Returns how many bytes were already received from source */
+static inline u32 dwc_get_sent(struct dw_dma_chan *dwc)
+{
+	u64 bts = channel_readq(dwc, BLOCK_TS);
+	u64 ctl = channel_readq(dwc, CTL);
+
+	return ((bts & DWC_BLOCK_TS_MASK) + 1) * (1 << (ctl >> 8 & 7));
+}
+
+static inline void dwc_chan_disable(struct dw_dma *dw, struct dw_dma_chan *dwc)
+{
+	u64 dma_ch_en;
+
+	dma_ch_en = dma_readq(dw, CH_EN);
+	dma_ch_en |= (dwc->mask << DW_DMAC_CH_EN_WE_OFFSET);
+	dma_ch_en |= (dwc->mask << DW_DMAC_CH_ABORT_WE_OFFSET);
+	dma_ch_en |= (dwc->mask << DW_DMAC_CH_ABORT_OFFSET);
+	dma_ch_en &= ~dwc->mask;
+	dma_writeq(dw, CH_EN, dma_ch_en);
+	while (dma_readq(dw, CH_EN) & dwc->mask)
+		cpu_relax();
+}
+
+static int dwc_resume(struct dma_chan *chan)
+{
+	unsigned long flags;
+	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
+	struct dw_dma *dw = to_dw_dma(dwc->chan.device);
+
+	spin_lock_irqsave(&dwc->lock, flags);
+
+	if (test_bit(DW_DMA_IS_PAUSED, &dwc->flags)) {
+		dma_clear_bit(dw, CH_EN,
+			      (1 << (__ffs(dwc->mask) + DW_DMAC_CH_PAUSE_OFFSET)));
+
+		clear_bit(DW_DMA_IS_PAUSED, &dwc->flags);
+	}
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	return 0;
+}
+
+static int dwc_pause(struct dma_chan *chan)
+{
+	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
+	struct dw_dma *dw = to_dw_dma(dwc->chan.device);
+
+	unsigned long flags;
+	unsigned int count = 20; /* timeout iterations */
+	u64 dma_ch_en;
+
+	spin_lock_irqsave(&dwc->lock, flags);
+
+	dma_set_bit(dw, CH_EN,
+		    (1 << (__ffs(dwc->mask) + DW_DMAC_CH_PAUSE_OFFSET))
+		    | (1 << (__ffs(dwc->mask) + DW_DMAC_CH_PAUSE_EN_OFFSET)));
+
+	while (!(dma_readq(dw, CH_EN)
+		 & (1 << (__ffs(dwc->mask) + DW_DMAC_CH_PAUSE_OFFSET)))
+	       && count--)
+		udelay(2);
+
+	dma_ch_en = dma_readq(dw, CH_EN);
+	dma_ch_en |= (dwc->mask << DW_DMAC_CH_EN_WE_OFFSET);
+	dma_ch_en &= ~dwc->mask;
+	dma_writeq(dw, CH_EN, dma_ch_en);
+
+	set_bit(DW_DMA_IS_PAUSED, &dwc->flags);
+
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	return 0;
+}
+
+static void dwc_scan_descriptors(struct dw_dma *dw, struct dw_dma_chan *dwc)
+{
+	dma_addr_t llp;
+	unsigned long flags;
+	u64 status_xfer;
+	struct dw_desc *desc, *_desc;
+	struct dw_desc *child;
+
+	spin_lock_irqsave(&dwc->lock, flags);
+	llp = channel_readq(dwc, LLP);
+	status_xfer = dma_readq(dw, CH_EN);
+
+	if (~(status_xfer & 0xff) & dwc->mask) {
+		spin_unlock_irqrestore(&dwc->lock, flags);
+		dwc_complete_all(dw, dwc);
+		return;
+	}
+
+	if (list_empty(&dwc->active_list)) {
+		spin_unlock_irqrestore(&dwc->lock, flags);
+		return;
+	}
+
+	list_for_each_entry_safe(desc, _desc, &dwc->active_list, desc_node) {
+		/* Initial residue value */
+		desc->residue = desc->total_len;
+		/* Check first descriptors addr */
+		if (desc->txd.phys == DWC_LLP_LOC(llp)) {
+			spin_unlock_irqrestore(&dwc->lock, flags);
+			return;
+		}
+
+		/* Check first descriptors llp */
+		if (lli_read(desc, llp) == llp) {
+			/* This one is currently in progress */
+			desc->residue -= dwc_get_sent(dwc);
+			spin_unlock_irqrestore(&dwc->lock, flags);
+			return;
+		}
+
+		desc->residue -= desc->len;
+		list_for_each_entry(child, &desc->tx_list, desc_node) {
+			if (lli_read(child, llp) == llp) {
+				/* Currently in progress */
+				desc->residue -= dwc_get_sent(dwc);
+				spin_unlock_irqrestore(&dwc->lock, flags);
+				return;
+			}
+			desc->residue -= child->len;
+		}
+
+		/*
+		 * No descriptors so far seem to be in progress, i.e.
+		 * this one must be done.
+		 */
+		spin_unlock_irqrestore(&dwc->lock, flags);
+		dwc_descriptor_complete(dwc, desc, true);
+		spin_lock_irqsave(&dwc->lock, flags);
+	}
+
+	dev_err(chan2dev(&dwc->chan),
+		"BUG: All descriptors done, but channel not idle!\n");
+
+	/* Try to continue after resetting the channel... */
+	dwc_chan_disable(dw, dwc);
+
+	dwc_dostart_first_queued(dwc);
+	spin_unlock_irqrestore(&dwc->lock, flags);
+}
+
+/*----------------------------------------------------------------------*/
+static void dwc_issue_pending(struct dma_chan *chan)
+{
+	unsigned long flags;
+	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
+
+	if (test_bit(DW_DMA_IS_CYCLIC, &dwc->flags)) {
+		dw_dma_cyclic_start(chan);
+		return;
+	}
+
+	spin_lock_irqsave(&dwc->lock, flags);
+	if (list_empty(&dwc->active_list))
+		dwc_dostart_first_queued(dwc);
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+}
+
+static int dwc_stop_cyclic_all(struct dw_dma_chan *dwc)
+{
+	int i;
+	unsigned long flags;
+	struct dw_desc *desc;
+	struct dma_async_tx_descriptor *txd;
+	struct dw_dma *dw = to_dw_dma(dwc->chan.device);
+
+	desc = dwc->cdesc->desc[0];
+	txd = &desc->txd;
+
+	spin_lock_irqsave(&dwc->lock, flags);
+	dma_cookie_complete(txd);
+
+	clear_bit(DW_DMA_IS_CYCLIC, &dwc->flags);
+
+	for (i = 0; i < dwc->cdesc->periods; i++)
+		dwc_desc_put(dwc, dwc->cdesc->desc[i]);
+
+	kfree(dwc->cdesc->desc);
+	kfree(dwc->cdesc);
+
+	dwc_unprepare_clk(dw);
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	return 0;
+}
+
+static int dwc_terminate_all(struct dma_chan *chan)
+{
+	unsigned long flags;
+	struct dw_desc *desc, *_desc;
+	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
+	struct dw_dma *dw = to_dw_dma(chan->device);
+
+	LIST_HEAD(list);
+
+	spin_lock_irqsave(&dwc->lock, flags);
+	dwc_chan_disable(dw, dwc);
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	dwc_resume(chan);
+
+	if (test_bit(DW_DMA_IS_CYCLIC, &dwc->flags))
+		return dwc_stop_cyclic_all(dwc);
+
+	/* active_list entries will end up before queued entries */
+	spin_lock_irqsave(&dwc->lock, flags);
+	list_splice_init(&dwc->queue, &list);
+	list_splice_init(&dwc->active_list, &list);
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	/* Flush all pending and queued descriptors */
+	list_for_each_entry_safe(desc, _desc, &list, desc_node)
+		dwc_descriptor_complete(dwc, desc, false);
+
+	return 0;
+}
+
+static int dwc_config(struct dma_chan *chan, struct dma_slave_config *sconfig)
+{
+	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
+
+	/* Check if chan will be configured for slave transfers */
+	if (!is_slave_direction(sconfig->direction))
+		return -EINVAL;
+
+	memcpy(&dwc->dma_sconfig, sconfig, sizeof(*sconfig));
+	dwc->direction = sconfig->direction;
+
+	convert_burst(&dwc->dma_sconfig.src_maxburst);
+	convert_burst(&dwc->dma_sconfig.dst_maxburst);
+
+	return 0;
+}
+
+static struct dw_desc *dwc_find_desc(struct dw_dma_chan *dwc, dma_cookie_t c)
+{
+	struct dw_desc *desc;
+
+	list_for_each_entry(desc, &dwc->active_list, desc_node)
+		if (desc->txd.cookie == c)
+			return desc;
+
+	return NULL;
+}
+
+static u32 dwc_get_residue(struct dw_dma_chan *dwc, dma_cookie_t cookie)
+{
+	u32 residue;
+	unsigned long flags;
+	struct dw_desc *desc;
+
+	spin_lock_irqsave(&dwc->lock, flags);
+
+	desc = dwc_find_desc(dwc, cookie);
+	if (desc)
+		if (desc == dwc_first_active(dwc))
+			residue = desc->residue;
+		else
+			residue = desc->total_len;
+	else
+		residue = 0;
+
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	return residue;
+}
+
+static enum dma_status dwc_tx_status(struct dma_chan *chan, dma_cookie_t cookie,
+				     struct dma_tx_state *txstate)
+{
+	enum dma_status ret;
+	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
+
+	ret = dma_cookie_status(chan, cookie, txstate);
+	if (ret == DMA_COMPLETE)
+		return ret;
+
+	if (test_bit(DW_DMA_IS_CYCLIC, &dwc->flags)) {
+		if (cookie == dwc->cdesc->desc[0]->txd.cookie) {
+			dma_set_residue(txstate, dwc->cdesc->desc[0]->residue);
+			return ret;
+		}
+		dma_set_residue(txstate, dwc->cdesc->desc[0]->total_len);
+		return ret;
+	}
+
+	dwc_scan_descriptors(to_dw_dma(chan->device), dwc);
+
+	ret = dma_cookie_status(chan, cookie, txstate);
+	if (ret == DMA_COMPLETE)
+		return ret;
+
+	dma_set_residue(txstate, dwc_get_residue(dwc, cookie));
+
+	if (test_bit(DW_DMA_IS_PAUSED, &dwc->flags) && ret == DMA_IN_PROGRESS)
+		return DMA_PAUSED;
+
+	return ret;
+}
+
+static struct dma_async_tx_descriptor *dwc_prep_dma_memcpy(struct dma_chan *chan,
+		dma_addr_t dest, dma_addr_t src,
+		size_t len, unsigned long flags)
+{
+	u8 m_master;
+	u64 ctl = 0;
+	unsigned int trans_width;
+	unsigned int data_width;
+	size_t offset = 0;
+	size_t xfer_count = 0;
+	struct dw_dma *dw = to_dw_dma(chan->device);
+	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
+	struct dw_desc *desc;
+	struct dw_desc *first;
+	struct dw_desc *prev;
+	unsigned long spin_flags;
+	u32 trans_block;
+
+	m_master = dwc->dws.m_master;
+	data_width = dw->data_width[m_master];
+
+	trans_block = dwc->block_size;
+
+#ifdef DBG_DMA
+	pr_err("%s trans_block %d, len 0x%x\n", __func__, trans_block, (int)len);
+#endif
+
+	if (unlikely(!len))
+		return NULL;
+
+	spin_lock_irqsave(&dwc->lock, spin_flags);
+	dwc_prepare_clk(dw);
+	spin_unlock_irqrestore(&dwc->lock, spin_flags);
+
+
+	dwc->direction = DMA_MEM_TO_MEM;
+
+	/*
+	 * for mem2mem type we defaultly set the src/dst width bits
+	 * to max value 32(axi bus width) consider of performence,
+	 * you can change it by dts.
+	 */
+
+	trans_width = __ffs(data_width | src | dest | len);
+	ctl = DWC_DEFAULT_CTL(chan)
+	      | DWC_CTL_DST_WIDTH(trans_width)
+	      | DWC_CTL_SRC_WIDTH(trans_width)
+	      | DWC_CTL_DST_INC
+	      | DWC_CTL_SRC_INC
+	      | DWC_CTL_DST_STA_EN
+	      | DWC_CTL_SRC_STA_EN;
+
+	/* axi bus max width is 32bits == 4 bytes
+	 * dma max block ts is 32, for one dma transfer, the max data size
+	 * can be transferred is 32 * 4 bytes
+	 */
+	prev = first = NULL;
+	for (offset = 0; offset < len; offset += xfer_count << trans_width) {
+		xfer_count = min_t(size_t, (len - offset) >> trans_width,
+				   trans_block >> trans_width);
+		desc = dwc_desc_get(dwc);
+		if (!desc)
+			goto err_desc_get;
+		lli_write(desc, sar, src + offset);
+		lli_write(desc, dar, dest + offset);
+		lli_write(desc, ctl, ctl | DWC_CTL_SHADOWREG_OR_LLI_VALID);
+		lli_write(desc, block_ts, xfer_count - 1);
+		desc->len = xfer_count << trans_width;
+		if (!first) {
+			first = desc;
+		} else {
+			lli_write(prev, llp, desc->txd.phys);
+			list_add_tail(&desc->desc_node, &first->tx_list);
+		}
+		prev = desc;
+	}
+	/* set the final block in lli,
+	 *dma end this transfer wen the current block completes
+	 */
+	lli_set(prev, ctl, DWC_CTL_SHADOWREG_OR_LLI_LAST);
+
+	if (flags & DMA_PREP_INTERRUPT) {
+		/* Trigger interrupt after last block */
+		lli_set(prev, ctl, DWC_CTL_IOC_BLT_EN);
+	}
+
+	prev->lli.llp = 0;
+	first->txd.flags = flags;
+	first->total_len = len;
+
+	return &first->txd;
+
+err_desc_get:
+	dwc_desc_put(dwc, first);
+	return NULL;
+}
+
+static struct dma_async_tx_descriptor *dwc_prep_dma_slave_sg(struct dma_chan *chan,
+		struct scatterlist *sgl, unsigned int sg_len, enum dma_transfer_direction direction,
+		unsigned long flags, void *context)
+{
+	u8 m_master;
+	u32 src_max_burst;
+	u32 dst_max_burst;
+	u32 trans_block;
+	u64 ctl = 0;
+	unsigned int reg_width;
+	unsigned int mem_width;
+	unsigned int data_width;
+	unsigned int i;
+	size_t total_len = 0;
+	dma_addr_t reg;
+	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
+	struct dw_dma *dw = to_dw_dma(chan->device);
+	struct dma_slave_config *sconfig = &dwc->dma_sconfig;
+	struct dw_desc *prev;
+	struct dw_desc *first;
+	struct scatterlist *sg;
+	unsigned long spin_flags;
+	u64 tmp;
+
+	spin_lock_irqsave(&dwc->lock, spin_flags);
+	dwc_prepare_clk(dw);
+	spin_unlock_irqrestore(&dwc->lock, spin_flags);
+
+	m_master = dwc->dws.m_master;
+	src_max_burst = sconfig->src_maxburst;
+	dst_max_burst = sconfig->dst_maxburst;
+	trans_block = dwc->block_size;
+	data_width = dw->data_width[m_master];
+
+	if (unlikely(!is_slave_direction(direction) || !sg_len))
+		return NULL;
+
+	dwc->direction = direction;
+
+	prev = first = NULL;
+	switch (direction) {
+	case DMA_MEM_TO_DEV:
+		reg_width = __ffs(sconfig->dst_addr_width);
+		reg = sconfig->dst_addr;
+		ctl = (DWC_DEFAULT_CTL(chan)
+		       | DWC_CTL_DST_WIDTH(reg_width)
+		       | DWC_CTL_DST_FIX
+		       | DWC_CTL_SRC_INC
+		       | DWC_CTL_DST_STA_EN
+		       | DWC_CTL_SRC_STA_EN);
+
+		for_each_sg(sgl, sg, sg_len, i) {
+			struct dw_desc *desc;
+			u64 mem, len, dlen, tmp_len;
+
+			mem = sg_dma_address(sg);
+			len = sg_dma_len(sg);
+			/* bug fix axi fix 32bits m2d,
+			 * reg_width <0: 8bits,1:16bits,2:32bits>
+			 */
+#ifdef CONFIG_SYSDMA_JIRA_BUG_BM1880_17
+			if (reg_width != 0x3)
+				mem = (u64)fix_dma_bug_copy_get(dwc, chan, sg, i, sg_len, len);
+			tmp_len = len * (4 >> reg_width);
+#endif
+			tmp_len = len;
+
+#ifdef CONFIG_SYSDMA_JIRA_BUG_BM1880_17
+			mem_width = 2;
+#else
+			mem_width = __ffs(data_width | mem | len);
+#endif
+
+slave_sg_todev_fill_desc:
+			desc = dwc_desc_get(dwc);
+			if (!desc)
+				goto err_desc_get;
+			lli_write(desc, sar, mem);
+			lli_write(desc, dar, reg);
+			lli_write(desc, ctl, ctl |
+				  (DWC_CTL_SRC_WIDTH(mem_width) | DWC_CTL_SHADOWREG_OR_LLI_VALID));
+			if (tmp_len >> mem_width > trans_block) {
+				dlen = trans_block << mem_width;
+				mem += dlen;
+				tmp_len -= dlen;
+			} else {
+				dlen = tmp_len;
+				tmp_len = 0;
+			}
+			/* single trans when dst_max_burst == 0*/
+			lli_write(desc, block_ts, !dst_max_burst ? 0 : ((dlen >> mem_width) - 1));
+			//lli_write(desc, block_ts, dlen);
+			desc->len = dlen;
+			div_u64(desc->len, (4 >> reg_width));
+
+			if (!first) {
+				first = desc;
+			} else {
+				lli_write(prev, llp, desc->txd.phys);
+				list_add_tail(&desc->desc_node, &first->tx_list);
+			}
+			prev = desc;
+			tmp = dlen;
+			div_u64(tmp, (4 >> reg_width));
+			total_len += tmp;
+
+			if (tmp_len)
+				goto slave_sg_todev_fill_desc;
+		}
+		break;
+	case DMA_DEV_TO_MEM:
+		reg_width = __ffs(sconfig->src_addr_width);
+		reg = sconfig->src_addr;
+		ctl = (DWC_DEFAULT_CTL(chan)
+		       | DWC_CTL_SRC_WIDTH(reg_width)
+		       | DWC_CTL_DST_INC
+		       | DWC_CTL_SRC_FIX
+		       | DWC_CTL_DST_STA_EN
+		       | DWC_CTL_SRC_STA_EN);
+
+		for_each_sg(sgl, sg, sg_len, i) {
+			struct dw_desc	*desc;
+			u64 len = 0, dlen = 0, mem = 0;
+
+			mem = sg_dma_address(sg);
+			len = sg_dma_len(sg);
+#ifdef CONFIG_SYSDMA_JIRA_BUG_BM1880_17
+			mem_width = 2;
+#else
+			mem_width = __ffs(data_width | mem | len);
+#endif
+
+slave_sg_fromdev_fill_desc:
+			desc = dwc_desc_get(dwc);
+			if (!desc)
+				goto err_desc_get;
+
+			lli_write(desc, sar, reg);
+			lli_write(desc, dar, mem);
+			ctl |= (DWC_CTL_DST_WIDTH(mem_width) | DWC_CTL_SHADOWREG_OR_LLI_VALID);
+			lli_write(desc, ctl, ctl);
+			if ((len >> reg_width) > trans_block) {
+				dlen = (trans_block << reg_width);
+#ifdef CONFIG_SYSDMA_JIRA_BUG_BM1880_17
+				mem += dlen * (4 >> reg_width);
+#else
+				mem += dlen;
+#endif
+				len -= dlen;
+			} else {
+				dlen = len;
+				len = 0;
+			}
+
+			lli_write(desc, block_ts, !src_max_burst ? 0 : (dlen >> reg_width) - 1);
+			desc->len = dlen;
+
+			if (!first) {
+				first = desc;
+			} else {
+				lli_write(prev, llp, desc->txd.phys);
+				list_add_tail(&desc->desc_node, &first->tx_list);
+			}
+			prev = desc;
+			total_len += dlen;
+
+			if (len)
+				goto slave_sg_fromdev_fill_desc;
+		}
+		break;
+	default:
+		return NULL;
+	}
+
+	/* set the final block in lli,
+	 * dma end this transfer wen the current block completes
+	 */
+	lli_set(prev, ctl, DWC_CTL_SHADOWREG_OR_LLI_LAST);
+
+	if (flags & DMA_PREP_INTERRUPT)
+		/* Trigger interrupt after last block */
+		lli_set(prev, ctl, DWC_CTL_IOC_BLT_EN);
+
+	prev->lli.llp = 0;
+	first->total_len = total_len;
+
+	return &first->txd;
+
+err_desc_get:
+	dev_err(chan2dev(chan),
+		"not enough descriptors available. Direction %d\n", direction);
+	dwc_desc_put(dwc, first);
+	return NULL;
+}
+
+/* --------------------- Cyclic DMA API extensions -------------------- */
+
+/**
+ * dw_dma_cyclic_start - start the cyclic DMA transfer
+ * @chan: the DMA channel to start
+ *
+ * Must be called with soft interrupts disabled. Returns zero on success or
+ * -errno on failure.
+ */
+static int dw_dma_cyclic_start(struct dma_chan *chan)
+{
+	unsigned long flags;
+	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
+
+	if (!test_bit(DW_DMA_IS_CYCLIC, &dwc->flags)) {
+		dev_err(chan2dev(&dwc->chan), "missing prep for cyclic DMA\n");
+		return -ENODEV;
+	}
+
+	spin_lock_irqsave(&dwc->lock, flags);
+
+	/* Enable interrupts to perform cyclic transfer */
+	//dwc_interrupts_set(dwc, true);
+
+	dwc_dostart(dwc, dwc->cdesc->desc[0]);
+
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	return 0;
+}
+
+/**
+ * dw_dma_cyclic_stop - stop the cyclic DMA transfer
+ * @chan: the DMA channel to stop
+ *
+ * Must be called with soft interrupts disabled.
+ */
+void dw_dma_cyclic_stop(struct dma_chan *chan)
+{
+	unsigned long flags;
+	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
+	struct dw_dma *dw = to_dw_dma(dwc->chan.device);
+
+	spin_lock_irqsave(&dwc->lock, flags);
+
+	dwc_chan_disable(dw, dwc);
+
+	spin_unlock_irqrestore(&dwc->lock, flags);
+}
+
+/**
+ * dw_dma_cyclic_prep - prepare the cyclic DMA transfer
+ * @chan: the DMA channel to prepare
+ * @buf_addr: physical DMA address where the buffer starts
+ * @buf_len: total number of bytes for the entire buffer
+ * @period_len: number of bytes for each period
+ * @direction: transfer direction, to or from device
+ *
+ * Must be called before trying to start the transfer. Returns a valid struct
+ * dw_cyclic_desc if successful or an ERR_PTR(-errno) if not successful.
+ */
+static struct dma_async_tx_descriptor *dwc_prep_dma_cyclic(struct dma_chan *chan,
+		dma_addr_t buf_addr, size_t buf_len, size_t period_len,
+		enum dma_transfer_direction direction,
+		unsigned long dma_flags)
+{
+	unsigned int i;
+	unsigned int reg_width;
+	unsigned int periods;
+	unsigned long flags;
+	unsigned long was_cyclic;
+	struct dw_cyclic_desc *cdesc;
+	struct dw_cyclic_desc *retval = NULL;
+	struct dw_desc *desc;
+	struct dw_desc *last = NULL;
+	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
+	struct dma_slave_config *sconfig = &dwc->dma_sconfig;
+	unsigned int tmp_len;
+	size_t target_period_len;
+	u64 ctl_val = 0;
+	struct dw_dma *dw = to_dw_dma(chan->device);
+
+	spin_lock_irqsave(&dwc->lock, flags);
+	dwc_prepare_clk(dw);
+
+	if (!list_empty(&dwc->queue) || !list_empty(&dwc->active_list)) {
+		spin_unlock_irqrestore(&dwc->lock, flags);
+		dev_dbg(chan2dev(&dwc->chan),
+			"queue and/or active list are not empty\n");
+		return ERR_PTR(-EBUSY);
+	}
+
+	was_cyclic = test_and_set_bit(DW_DMA_IS_CYCLIC, &dwc->flags);
+	spin_unlock_irqrestore(&dwc->lock, flags);
+	if (was_cyclic) {
+		dev_dbg(chan2dev(&dwc->chan),
+			"channel already prepared for cyclic DMA\n");
+		return ERR_PTR(-EBUSY);
+	}
+
+	retval = ERR_PTR(-EINVAL);
+
+	if (unlikely(!is_slave_direction(direction)))
+		goto out_err;
+
+	dwc->direction = direction;
+
+	if (direction == DMA_MEM_TO_DEV)
+		reg_width = __ffs(sconfig->dst_addr_width);
+	else
+		reg_width = __ffs(sconfig->src_addr_width);
+
+	/* Change period to 128 bytes due to the maximum LLI data length*/
+	/*of Bitmain sysDMA (32 bytes * 4 bytes bus width)*/
+	tmp_len = (1 << (__ffs(buf_len) - 1));
+	target_period_len = period_len;
+	if (period_len > BM_DMA_PERIOD_LEN)
+		period_len = BM_DMA_PERIOD_LEN;
+
+	if (tmp_len < period_len)
+		period_len = tmp_len;
+
+	periods = buf_len / period_len;
+
+	/* Check for too big/unaligned periods and unaligned DMA buffer. */
+	if (period_len > (dwc->block_size << reg_width))
+		goto out_err;
+	if (unlikely(period_len & ((1 << reg_width) - 1)))
+		goto out_err;
+	if (unlikely(buf_addr & ((1 << reg_width) - 1)))
+		goto out_err;
+
+	retval = ERR_PTR(-ENOMEM);
+
+	cdesc = kzalloc(sizeof(struct dw_cyclic_desc), GFP_ATOMIC);
+	if (!cdesc)
+		goto out_err;
+	cdesc->desc = kcalloc(periods, sizeof(struct dw_desc *), GFP_ATOMIC);
+	if (!cdesc->desc)
+		goto out_err_alloc;
+
+	for (i = 0; i < periods; i++) {
+		desc = dwc_desc_get(dwc);
+		if (!desc)
+			goto out_err_desc_get;
+
+		switch (direction) {
+		case DMA_MEM_TO_DEV:
+			lli_write(desc, dar, sconfig->dst_addr);
+			lli_write(desc, sar, buf_addr + period_len * i);
+			ctl_val = (DWC_DEFAULT_CTL(chan)
+#if defined(CONFIG_ARCH_CVITEK)
+				   | DWC_CTL_ARLEN_EN
+				   | DWC_CTL_ARLEN(7UL)
+				   | DWC_CTL_AWLEN_EN
+				   | DWC_CTL_AWLEN(0UL)
+#endif
+				   | DWC_CTL_SHADOWREG_OR_LLI_VALID
+				   | DWC_CTL_DST_WIDTH(reg_width)
+				   | DWC_CTL_SRC_WIDTH(reg_width)
+				   | DWC_CTL_DST_FIX
+				   | DWC_CTL_SRC_INC);
+			lli_write(desc, ctl, ctl_val);
+
+			if ((period_len * (i + 1)) % target_period_len == 0)
+				lli_set(desc, ctl, DWC_CTL_IOC_BLT_EN);
+			break;
+		case DMA_DEV_TO_MEM:
+			lli_write(desc, dar, buf_addr + period_len * i);
+			lli_write(desc, sar, sconfig->src_addr);
+			ctl_val = (DWC_DEFAULT_CTL(chan)
+#if defined(CONFIG_ARCH_CVITEK)
+				   | DWC_CTL_ARLEN_EN
+				   | DWC_CTL_ARLEN(0UL)
+				   | DWC_CTL_AWLEN_EN
+				   | DWC_CTL_AWLEN(7UL)
+#endif
+				   | DWC_CTL_SHADOWREG_OR_LLI_VALID
+				   | DWC_CTL_SRC_WIDTH(reg_width)
+				   | DWC_CTL_DST_WIDTH(reg_width)
+				   | DWC_CTL_DST_INC
+				   | DWC_CTL_SRC_FIX);
+
+			lli_write(desc, ctl, ctl_val);
+
+			if ((period_len * (i + 1)) % target_period_len == 0)
+				lli_set(desc, ctl, DWC_CTL_IOC_BLT_EN);
+			break;
+		default:
+			break;
+		}
+
+		lli_write(desc, block_ts, (period_len >> reg_width) - 1);
+		cdesc->desc[i] = desc;
+
+		if (last) {
+			lli_write(last, llp, desc->txd.phys);
+			last->total_len = target_period_len;
+		}
+
+		last = desc;
+	}
+
+	/* Let's make a cyclic list */
+	lli_write(last, llp, cdesc->desc[0]->txd.phys);
+
+	/* Trigger interrupt for last block */
+	lli_set(last, ctl, DWC_CTL_IOC_BLT_EN);
+
+	if (dw->log_on)
+		dev_info(chan2dev(&dwc->chan),
+			 "cyclic prepared buf 0x%llx len %zu period %zu periods %d\n",
+			 buf_addr, buf_len, period_len, periods);
+
+	cdesc->desc[0]->total_len = buf_len;
+	cdesc->desc[0]->hw_pos = 0;
+	cdesc->desc[0]->residue = buf_len;
+	cdesc->periods = periods;
+	cdesc->period_len = target_period_len;
+	cdesc->last_sent = 0;
+	dwc->cdesc = cdesc;
+	dwc->hw_pos = 0;
+	dwc->interrupt_count = 0;
+
+	return &cdesc->desc[0]->txd;
+
+out_err_desc_get:
+	while (i--)
+		dwc_desc_put(dwc, cdesc->desc[i]);
+out_err_alloc:
+	kfree(cdesc->desc);
+out_err:
+	kfree(cdesc);
+	clear_bit(DW_DMA_IS_CYCLIC, &dwc->flags);
+
+	return (struct dma_async_tx_descriptor *)retval;
+}
+
+
+static void dwc_handle_cyclic(struct dw_dma *dw, struct dw_dma_chan *dwc)
+{
+	dma_addr_t llp;
+	int i;
+	u32 sent_total = 0;
+	struct dw_desc *desc, *first;
+	struct dmaengine_desc_callback cb;
+	u32 new_hw_pos = 0;
+
+	llp = channel_readq(dwc, LLP);
+	first = dwc->cdesc->desc[0];
+	sent_total += dwc->cdesc->last_sent;
+
+	if (first->txd.phys != DWC_LLP_LOC(llp)) {
+		for (i = 1; i < dwc->cdesc->periods; i++) {
+			desc = dwc->cdesc->desc[i];
+			new_hw_pos += dwc_get_sent(dwc);
+			if (desc->txd.phys == DWC_LLP_LOC(llp))
+				break;
+		}
+	} else
+		new_hw_pos = 0; /* back to ring buffer head */
+
+	if (new_hw_pos >= first->hw_pos)
+		sent_total += new_hw_pos - first->hw_pos;
+	else
+		sent_total += first->total_len + new_hw_pos - first->hw_pos;
+
+	first->hw_pos = new_hw_pos;
+	first->residue = first->total_len - (new_hw_pos - new_hw_pos % dwc->cdesc->period_len);
+	dwc->hw_pos = new_hw_pos;
+	dwc->interrupt_count++;
+
+	if (sent_total > dwc->cdesc->period_len) {
+		dmaengine_desc_get_callback(&first->txd, &cb);
+		dmaengine_desc_callback_invoke(&cb, NULL);
+		dwc->cdesc->last_sent = new_hw_pos % dwc->cdesc->period_len;
+	} else {
+		dwc->cdesc->last_sent = sent_total;
+	}
+
+	if (dw->log_on)
+		dev_info(chan2dev(&dwc->chan),
+			 "SAR:0x%llx DAR:0x%llx residue:%d sent_total:%d ch_status:0x%llx int_status:0x%llx\n",
+			 channel_readq(dwc, SAR), channel_readq(dwc, DAR), first->residue, sent_total,
+			 channel_readq(dwc, STATUS), channel_readq(dwc, INTSTATUS));
+
+	/* TODO error resuem */
+}
+
+/**
+ * dw_dma_cyclic_free - free a prepared cyclic DMA transfer
+ * @chan: the DMA channel to free
+ */
+void dw_dma_cyclic_free(struct dma_chan *chan)
+{
+	unsigned int i;
+	unsigned long flags;
+	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
+	struct dw_dma *dw = to_dw_dma(dwc->chan.device);
+	struct dw_cyclic_desc *cdesc = dwc->cdesc;
+
+	dev_dbg(chan2dev(&dwc->chan), "%s\n", __func__);
+
+	if (!cdesc)
+		return;
+
+	spin_lock_irqsave(&dwc->lock, flags);
+
+	dwc_chan_disable(dw, dwc);
+
+	//dwc_interrupts_set(dwc, false);
+
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	for (i = 0; i < cdesc->periods; i++)
+		dwc_desc_put(dwc, cdesc->desc[i]);
+
+	kfree(cdesc->desc);
+	kfree(cdesc);
+
+	dwc->cdesc = NULL;
+
+	clear_bit(DW_DMA_IS_CYCLIC, &dwc->flags);
+}
+
+static void dwc_free_chan_resources(struct dma_chan *chan)
+{
+	unsigned long flags;
+	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
+	struct dw_dma *dw = to_dw_dma(chan->device);
+
+	LIST_HEAD(list);
+
+	/* ASSERT:  channel is idle */
+	WARN_ON(!list_empty(&dwc->active_list));
+	WARN_ON(!list_empty(&dwc->queue));
+	WARN_ON(dma_readq(to_dw_dma(chan->device), CH_EN) & dwc->mask);
+
+	spin_lock_irqsave(&dwc->lock, flags);
+
+	/* Clear custom channel configuration */
+	memset(&dwc->dws, 0, sizeof(struct dw_dma_slave));
+
+	clear_bit(DW_DMA_IS_INITIALIZED, &dwc->flags);
+
+	/* Disable interrupts */
+	channel_writeq(dwc, INTSTATUS_ENABLEREG, 0);
+	//dwc_interrupts_set(dwc, false);
+
+	/* Disable controller in case it was a last user */
+	dw->in_use &= ~dwc->mask;
+
+	if (!dw->in_use)
+		dw_dma_off(dw);
+
+	spin_unlock_irqrestore(&dwc->lock, flags);
+}
+
+static int dwc_alloc_chan_resources(struct dma_chan *chan)
+{
+	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
+	struct dw_dma *dw = to_dw_dma(chan->device);
+	unsigned long flags;
+
+	spin_lock_irqsave(&dwc->lock, flags);
+	/* ASSERT:  channel is idle */
+	if (dma_readq(dw, CH_EN) & dwc->mask)
+		return -EIO;
+
+	dma_cookie_init(chan);
+
+	/*
+	 * NOTE: some controllers may have additional features that we
+	 * need to initialize here, like "scatter-gather" (which
+	 * doesn't mean what you think it means), and status writeback.
+	 */
+
+	/*
+	 * We need controller-specific data to set up slave transfers.
+	 */
+	if (chan->private && !dw_dma_filter(chan, chan->private)) {
+		dev_warn(chan2dev(chan), "Wrong controller-specific data\n");
+		return -EINVAL;
+	}
+
+	/* Enable controller here if needed */
+
+	if (!dw->in_use)
+		dw_dma_on(dw);
+
+	dw->in_use |= dwc->mask;
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	return 0;
+}
+
+#ifndef DO_NOT_USE_TASK
+static void dw_dma_tasklet(unsigned long data)
+{
+	unsigned int i;
+	struct dw_dma *dw = (struct dw_dma *)data;
+	struct dw_dma_chan *dwc;
+	u64 ch_en;
+
+	ch_en = dma_readq(dw, CH_EN);
+
+	for (i = 0; i < dw->dma.chancnt; i++) {
+		dwc = &dw->chan[i];
+		if (test_bit(DW_DMA_IS_CYCLIC, &dwc->flags)) {
+			if ((ch_en >> i) & 0x1)
+				dwc_handle_cyclic(dw, dwc);
+		} else
+			dwc_scan_descriptors(dw, dwc);
+
+		//dwc_interrupts_set(dwc, true);
+	}
+}
+#endif
+
+static void dw_dma_off(struct dw_dma *dw)
+{
+	unsigned int i;
+
+	dma_writeq(dw, CFG, 0); /* disable dmac and interrupt */
+
+	/* Clear all interrupts on all channels. */
+#if 0
+	for (i = 0; i < dw->dma.chancnt; i++)
+		dwc_interrupts_set(&dw->chan[i], false);
+#endif
+
+	//while (dma_readq(dw, CFG) & DW_CFG_DMA_EN)
+	//	cpu_relax();
+
+	for (i = 0; i < dw->dma.chancnt; i++)
+		clear_bit(DW_DMA_IS_INITIALIZED, &dw->chan[i].flags);
+}
+
+static void dw_dma_on(struct dw_dma *dw)
+{
+	dma_writeq(dw, CFG, DW_CFG_DMA_EN | DW_CFG_DMA_INT_EN);
+}
+
+#ifdef DO_NOT_USE_TASK
+static void instead_of_tasklet(struct dw_dma *dw)
+{
+	unsigned int i;
+	struct dw_dma_chan *dwc;
+	u64 ch_en;
+
+	ch_en = dma_readq(dw, CH_EN);
+
+	for (i = 0; i < dw->dma.chancnt; i++) {
+		dwc = &dw->chan[i];
+		if (test_bit(DW_DMA_IS_CYCLIC, &dwc->flags)) {
+			if ((ch_en >> i) & 0x1)
+				dwc_handle_cyclic(dw, dwc);
+		} else
+			dwc_scan_descriptors(dw, dwc);
+		//dwc_interrupts_set(dwc, true);
+	}
+}
+#endif
+
+static irqreturn_t dw_dma_interrupt(int irq, void *dev_id)
+{
+	int i;
+	u64 status, dwc_status;
+	struct dw_dma *dw = dev_id;
+	struct dw_dma_chan *dwc;
+
+	/* Check if we have any interrupt from the DMAC which is not in use */
+	if (!dw->in_use)
+		return IRQ_NONE;
+
+	status = dma_readq(dw, INTSTATUS);
+	/* Check if we have any interrupt from the DMAC */
+	if (!status)
+		return IRQ_NONE;
+
+	dma_writeq(dw, COMM_INTCLEAR, 0x10f); /* clear all common interrupts */
+	for (i = 0; i < dw->dma.chancnt; i++) {
+		dwc = &dw->chan[i];
+		dwc_status = channel_readq(dwc, INTSTATUS);
+		channel_writeq(dwc, INTCLEARREG, dwc_status);
+		//dwc_interrupts_set(dwc, false);
+	}
+
+	status = dma_readq(dw, INTSTATUS);
+	if (status) {
+		dev_dbg(dw->dma.dev,
+			"BUG: Unexpected interrupts pending: 0x%llx\n",
+			status);
+	}
+
+#ifdef DO_NOT_USE_TASK
+	instead_of_tasklet(dw);
+#else
+	tasklet_schedule(&dw->tasklet);
+#endif
+	return IRQ_HANDLED;
+}
+
+static int dw_dma_channel_init(struct platform_device *pdev,
+			       struct dw_dma *dw)
+{
+	int i;
+
+	dw->chan = devm_kcalloc(dw->dev, dw->nr_channels,
+				sizeof(*dw->chan), GFP_KERNEL);
+	if (!dw->chan)
+		return -ENOMEM;
+
+	/* Create a pool of consistent memory blocks for hardware descriptors */
+	dw->desc_pool = dmam_pool_create("dw_dmac_desc_pool", dw->dev,
+					 sizeof(struct dw_desc), 64, 0);
+	if (!dw->desc_pool) {
+		dev_err(dw->dev, "No memory for descriptors dma pool\n");
+		return -ENOMEM;
+	}
+
+	INIT_LIST_HEAD(&dw->dma.channels);
+	for (i = 0; i < dw->nr_channels; i++) {
+		struct dw_dma_chan *dwc = &dw->chan[i];
+
+		dwc->chan.device = &dw->dma;
+		dma_cookie_init(&dwc->chan);
+		if (dw->chan_allocation_order == CHAN_ALLOCATION_ASCENDING)
+			list_add_tail(&dwc->chan.device_node, &dw->dma.channels);
+		else
+			list_add(&dwc->chan.device_node, &dw->dma.channels);
+
+		/* 7 is highest priority & 0 is lowest. */
+		if (dw->chan_priority == CHAN_PRIORITY_ASCENDING)
+			dwc->priority = dw->nr_channels - i - 1;
+		else
+			dwc->priority = i;
+
+		dwc->ch_regs = &__dw_regs(dw)->CHAN[i];
+		spin_lock_init(&dwc->lock);
+		dwc->mask = 1 << i;
+
+		channel_writeq(dwc, INTCLEARREG, 0xffffffff);
+
+		INIT_LIST_HEAD(&dwc->active_list);
+		INIT_LIST_HEAD(&dwc->queue);
+
+		dwc->direction = DMA_TRANS_NONE;
+		dwc->block_size = dw->block_size;
+		dwc->axi_tr_width = dw->block_size;
+	}
+
+	dma_clear_bit(dw, CH_EN, DW_DMA_CHAN_MASK);
+
+	/* channel en bit set */
+	dma_set_bit(dw, CH_EN, DW_DMA_CHAN_MASK << DW_DMAC_CH_EN_WE_OFFSET);
+	dma_set_bit(dw, CH_EN, DW_DMA_CHAN_MASK << DW_DMAC_CH_PAUSE_EN_OFFSET);
+
+	/* Set capabilities */
+	dma_cap_set(DMA_SLAVE, dw->dma.cap_mask);
+	dma_cap_set(DMA_PRIVATE, dw->dma.cap_mask);
+	dma_cap_set(DMA_MEMCPY, dw->dma.cap_mask);
+	dma_cap_set(DMA_CYCLIC, dw->dma.cap_mask);
+
+	dw->dma.dev = dw->dev;
+	dw->dma.device_alloc_chan_resources = dwc_alloc_chan_resources;
+	dw->dma.device_free_chan_resources = dwc_free_chan_resources;
+
+	dw->dma.device_prep_dma_memcpy = dwc_prep_dma_memcpy;
+	dw->dma.device_prep_slave_sg = dwc_prep_dma_slave_sg;
+	dw->dma.device_prep_dma_cyclic = dwc_prep_dma_cyclic;
+
+	dw->dma.device_config = dwc_config;
+	dw->dma.device_pause = dwc_pause;
+	dw->dma.device_resume = dwc_resume;
+	dw->dma.device_terminate_all = dwc_terminate_all;
+
+	dw->dma.device_tx_status = dwc_tx_status;
+	dw->dma.device_issue_pending = dwc_issue_pending;
+
+	/* DMA capabilities */
+	dw->dma.src_addr_widths = DW_DMA_BUSWIDTHS;
+	dw->dma.dst_addr_widths = DW_DMA_BUSWIDTHS;
+	dw->dma.directions = BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV) |
+			     BIT(DMA_MEM_TO_MEM);
+	dw->dma.residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;
+
+	return 0;
+}
+
+static int dw_dma_parse_dt(struct platform_device *pdev,
+			   struct dw_dma *dw)
+{
+	u32 tmp, arr[DW_DMA_MAX_NR_MASTERS];
+	struct device_node *np = pdev->dev.of_node;
+
+	if (!np) {
+		dev_err(&pdev->dev, "Missing DT data\n");
+		return -EINVAL;
+	}
+
+	/* set default config, can be override by dt */
+	dw->nr_masters = 2;
+	dw->is_private = true;
+	dw->is_memcpy = true;
+	dw->chan_allocation_order = CHAN_ALLOCATION_ASCENDING;
+	dw->chan_priority = CHAN_PRIORITY_ASCENDING;
+
+	of_property_read_u8(np, "dma-masters", &dw->nr_masters);
+	if (dw->nr_masters < 1 || dw->nr_masters > DW_DMA_MAX_NR_MASTERS)
+		return -EINVAL;
+
+	of_property_read_u8(np, "dma-channels", &dw->nr_channels);
+	if (dw->nr_channels > DW_DMA_MAX_NR_CHANNELS)
+		return -EINVAL;
+
+	if (of_property_read_bool(np, "is_private"))
+		dw->is_private = true;
+
+	of_property_read_u8(np, "chan_allocation_order",
+			    &dw->chan_allocation_order);
+	of_property_read_u8(np, "chan_priority", &dw->chan_priority);
+	of_property_read_u32(np, "block_size", &dw->block_size);
+	of_property_read_u32(np, "block-ts", &dw->block_ts);
+	of_property_read_u32(np, "axi_tr_width", &dw->axi_tr_width);
+	if (!of_property_read_u32_array(np, "data-width", arr, dw->nr_masters)) {
+		for (tmp = 0; tmp < dw->nr_masters; tmp++)
+			dw->data_width[tmp] = arr[tmp];
+	}
+
+	return 0;
+}
+
+static int dw_dma_resource_init(struct platform_device *pdev,
+				struct dw_dma *dw)
+{
+	int err;
+	struct resource *mem;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dw->regs = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(dw->regs)) {
+		err = PTR_ERR(dw->regs);
+		goto err_resource;
+	}
+
+	dma_writeq(dw, RESET, 1); /* reset sysDMA */
+
+	dw->irq = platform_get_irq(pdev, 0);
+	if (dw->irq < 0)
+		return -EINVAL;
+	err = devm_request_irq(dw->dev, dw->irq, dw_dma_interrupt,
+			       IRQF_SHARED, "dw_dmac", dw);
+	if (err)
+		return err;
+	spin_lock_init(&dw->lock);
+
+
+	err = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));
+	if (err)
+		goto err_resource;
+
+#ifndef DO_NOT_USE_TASK
+	tasklet_init(&dw->tasklet, dw_dma_tasklet, (unsigned long)dw);
+#endif
+
+	return 0;
+err_resource:
+	return err;
+}
+
+static bool dw_dma_filter(struct dma_chan *chan, void *param)
+{
+	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
+	struct dw_dma_slave *dws = param;
+
+	if (dws->dma_dev != chan->device->dev)
+		return false;
+
+	/* We have to copy data since dws can be temporary storage */
+	memcpy(&dwc->dws, dws, sizeof(struct dw_dma_slave));
+
+	return true;
+}
+
+static struct dma_chan *dw_dma_of_xlate(struct of_phandle_args *dma_spec,
+					struct of_dma *ofdma)
+{
+	struct dw_dma *dw = ofdma->of_dma_data;
+	struct dw_dma_slave slave = {
+		.dma_dev = dw->dma.dev,
+	};
+	dma_cap_mask_t cap;
+
+	if (dma_spec->args_count != 3)
+		return NULL;
+
+	slave.src_id = dma_spec->args[0];
+	slave.dst_id = dma_spec->args[0];
+	slave.m_master = dma_spec->args[1];
+	slave.p_master = dma_spec->args[2];
+
+	if (WARN_ON(slave.src_id >= DW_DMA_MAX_NR_REQUESTS ||
+		    slave.dst_id >= DW_DMA_MAX_NR_REQUESTS ||
+		    slave.m_master >= dw->nr_masters ||
+		    slave.p_master >= dw->nr_masters)) {
+		return NULL;
+	}
+	dma_cap_zero(cap);
+	dma_cap_set(DMA_SLAVE, cap);
+
+	/* TODO: there should be a simpler way to do this */
+	return dma_request_channel(cap, dw_dma_filter, &slave);
+}
+
+static ssize_t __show_status(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	return 0;
+}
+static DEVICE_ATTR(signal, 0644, __show_status, NULL);
+
+static struct attribute *dbg_attrs[] = {
+	&dev_attr_signal.attr,
+	NULL
+};
+
+static struct attribute_group dma_group_attrs = {
+	.name = "info",
+	.attrs = dbg_attrs
+};
+
+static int dma_proc_show(struct seq_file *m, void *v)
+{
+	struct dw_dma *dw = m->private;
+
+	if (!dma_readq(dw, CH_EN))
+		dwc_prepare_clk(dw);
+
+	seq_printf(m, "CFG: 0x%llx, CH_EN=0x%llx, INT_STATUS=0x%llx, COMM_INTSTATUS=0x%llx\n",
+		   dma_readq(dw, CFG), dma_readq(dw, CH_EN), dma_readq(dw, INTSTATUS),  dma_readq(dw, COMM_INTSTATUS));
+
+	if (!dma_readq(dw, CH_EN))
+		dwc_unprepare_clk(dw);
+
+	return 0;
+}
+
+static int seq_dma_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, dma_proc_show, PDE_DATA(inode));
+}
+
+static int ch_proc_show(struct seq_file *m, void *v)
+{
+	struct dw_dma *dw = m->private;
+	int i;
+
+	if (!dma_readq(dw, CH_EN))
+		dwc_prepare_clk(dw);
+
+	for (i = 0; i < dw->nr_channels; i++) {
+		struct dw_dma_chan *dwc = &dw->chan[i];
+
+		seq_printf(m, "Ch%d - SAR:0x%llx DAR:0x%llx ch_status:0x%llx int_status:0x%llx hw_pos:%d intc:%d\n", i,
+			   channel_readq(dwc, SAR), channel_readq(dwc, DAR),
+			   channel_readq(dwc, STATUS), channel_readq(dwc, INTSTATUS),
+			   dwc->hw_pos, dwc->interrupt_count);
+	}
+
+	if (!dma_readq(dw, CH_EN))
+		dwc_unprepare_clk(dw);
+
+	return 0;
+}
+
+static int seq_ch_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ch_proc_show, PDE_DATA(inode));
+}
+
+static int log_proc_show(struct seq_file *m, void *v)
+{
+	struct dw_dma *dw = m->private;
+
+	seq_printf(m, "sysDMA log is %s\n", dw->log_on ? "on" : "off");
+
+	return 0;
+}
+
+static int seq_log_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, log_proc_show, PDE_DATA(inode));
+}
+
+static ssize_t log_level_write(struct file *file, const char __user *data, size_t len, loff_t *off)
+{
+	struct dw_dma *dw = PDE_DATA(file_inode(file));
+	char buf[3];
+
+	if (data && !copy_from_user(buf, data, len)) {
+		buf[len - 1] = '\0';
+		if (buf[0] == '1')
+			dw->log_on = 1;
+		else if (buf[0] == '0')
+			dw->log_on = 0;
+		else
+			dev_dbg(dw->dev, "Incorrect input for /proc/sysDMA/log_level\n");
+	}
+
+	return len;
+}
+
+static const struct proc_ops dma_proc_ops = {
+	.proc_open = seq_dma_open,
+	.proc_read = seq_read,
+	.proc_release = single_release,
+};
+
+static const struct proc_ops ch_proc_ops = {
+	.proc_open = seq_ch_open,
+	.proc_read = seq_read,
+	.proc_release = single_release,
+};
+
+static const struct proc_ops log_proc_ops = {
+	.proc_open = seq_log_open,
+	.proc_read = seq_read,
+	.proc_write = log_level_write,
+	.proc_release = single_release,
+};
+
+static int dw_dma_probe(struct platform_device *pdev)
+{
+	int err;
+	struct dw_dma *dw;
+	struct device *dev = &pdev->dev;
+	struct proc_dir_entry *proc_dma_folder;
+	struct proc_dir_entry *proc_dma;
+	struct proc_dir_entry *proc_ch;
+	struct proc_dir_entry *proc_log;
+
+	dw = devm_kzalloc(dev, sizeof(*dw), GFP_KERNEL);
+	if (!dw)
+		return -ENOMEM;
+
+	dw->dev = dev;
+	err = dw_dma_resource_init(pdev, dw);
+	if (err) {
+		dev_err(dev,
+			"CVITEK DMA resource init error %d\n", err);
+		goto err_resource;
+	}
+
+	err = dw_dma_parse_dt(pdev, dw);
+	if (err) {
+		dev_err(dev,
+			"CVITEK DMA parse devicetree error %d\n", err);
+		goto err_dt;
+	}
+
+	pm_runtime_enable(dev);
+	pm_runtime_get_sync(dev);
+
+	dw_dma_off(dw);
+
+	err = dw_dma_channel_init(pdev, dw);
+	if (err) {
+		dev_err(dev,
+			"CVITEK DMA channel init error %d\n", err);
+		goto err_chan;
+	}
+
+	err = dma_async_device_register(&dw->dma);
+	if (err)
+		goto err_dma_register;
+
+	pm_runtime_put_sync_suspend(dev);
+
+
+	dw->clk = devm_clk_get(dw->dev, "clk_sdma_axi");
+	if (IS_ERR(dw->clk)) {
+		dev_err(dev, "CVITEK DMA get clk_dma_axi failed\n");
+		return PTR_ERR(dw->clk);
+	}
+
+	err = clk_prepare(dw->clk);
+	dw->clk_count = 0;
+
+	if (err)
+		return err;
+
+	platform_set_drvdata(pdev, dw);
+
+	if (pdev->dev.of_node) {
+		err = of_dma_controller_register(pdev->dev.of_node,
+						 dw_dma_of_xlate, dw);
+		if (err) {
+			dev_err(&pdev->dev,
+				"could not register of_dma_controller\n");
+			goto err_of_dma;
+		}
+	}
+
+	if (sysfs_create_group(&pdev->dev.kobj, &dma_group_attrs))
+		dev_err(&pdev->dev, "Could not register attrs for dma\n");
+
+	dev_info(dev, "CVITEK DMA Controller, %d channels, probe done!\n",
+		 dw->nr_channels);
+
+	proc_dma_folder = proc_mkdir("sysDMA", NULL);
+	if (!proc_dma_folder)
+		dev_err(&pdev->dev, "Error creating sysDMA proc folder entry\n");
+
+	proc_dma = proc_create_data("dma_status", 0664, proc_dma_folder, &dma_proc_ops, dw);
+	if (!proc_dma)
+		dev_err(&pdev->dev, "Create sysDMA status proc failed!\n");
+
+	proc_ch = proc_create_data("ch_status", 0664, proc_dma_folder, &ch_proc_ops, dw);
+	if (!proc_ch)
+		dev_err(&pdev->dev, "Create sysDMA channel proc failed!\n");
+
+	proc_log = proc_create_data("log_level", 0664, proc_dma_folder, &log_proc_ops, dw);
+	if (!proc_log)
+		dev_err(&pdev->dev, "Create sysDMA log level proc failed!\n");
+
+	dw->log_on = false;
+	return 0;
+
+err_resource:
+err_dt:
+	return err;
+err_chan:
+err_dma_register:
+err_of_dma:
+	pm_runtime_disable(&pdev->dev);
+	return err;
+}
+
+static int __dw_dma_remove(struct dw_dma *dw)
+{
+	struct dw_dma_chan *dwc, *_dwc;
+
+	pm_runtime_get_sync(dw->dev);
+
+	dw_dma_off(dw);
+	dma_async_device_unregister(&dw->dma);
+
+	free_irq(dw->irq, dw);
+	tasklet_kill(&dw->tasklet);
+
+	list_for_each_entry_safe(dwc, _dwc, &dw->dma.channels,
+				 chan.device_node) {
+		list_del(&dwc->chan.device_node);
+		dma_clear_bit(dw, CH_EN, dwc->mask);
+	}
+
+	pm_runtime_put_sync_suspend(dw->dev);
+	return 0;
+}
+
+static int dw_dma_remove(struct platform_device *pdev)
+{
+	struct dw_dma *dw = platform_get_drvdata(pdev);
+
+	if (pdev->dev.of_node)
+		of_dma_controller_free(pdev->dev.of_node);
+
+	__dw_dma_remove(dw);
+	pm_runtime_disable(&pdev->dev);
+	clk_unprepare(dw->clk);
+
+	return 0;
+}
+
+static void dw_dma_shutdown(struct platform_device *pdev)
+{
+	struct dw_dma *dw = platform_get_drvdata(pdev);
+	/*
+	 * We have to call dw_dma_disable() to stop any ongoing transfer. On
+	 * some platforms we can't do that since DMA device is powered off.
+	 * Moreover we have no possibility to check if the platform is affected
+	 * or not. That's why we call pm_runtime_get_sync() / pm_runtime_put()
+	 * unconditionally. On the other hand we can't use
+	 * pm_runtime_suspended() because runtime PM framework is not fully
+	 * used by the driver.
+	 */
+	pm_runtime_get_sync(dw->dev);
+	dw_dma_off(dw);
+	pm_runtime_put_sync_suspend(dw->dev);
+
+}
+
+static const struct of_device_id dw_dma_of_id_table[] = {
+	{ .compatible = "snps,dmac-bm" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, dw_dma_of_id_table);
+
+#ifdef CONFIG_PM_SLEEP
+static int dw_dma_suspend_late(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dw_dma *dw = platform_get_drvdata(pdev);
+
+	dw_dma_off(dw);
+
+	return 0;
+}
+
+static int dw_dma_resume_early(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dw_dma *dw = platform_get_drvdata(pdev);
+
+	clk_prepare_enable(dw->clk);
+	dma_writeq(dw, CH_EN, 0xFF00);
+	dw_dma_on(dw);
+
+	return 0;
+}
+#else
+#define dw_dma_suspend_late	NULL
+#define dw_dma_resume_early	NULL
+#endif /* CONFIG_PM_SLEEP */
+
+static const struct dev_pm_ops dw_dev_pm_ops = {
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(dw_dma_suspend_late, dw_dma_resume_early)
+};
+
+static struct platform_driver dw_dma_driver = {
+	.probe = dw_dma_probe,
+	.remove = dw_dma_remove,
+	.shutdown = dw_dma_shutdown,
+	.driver = {
+		.name = DRV_NAME,
+		.pm = &dw_dev_pm_ops,
+		.of_match_table = of_match_ptr(dw_dma_of_id_table),
+	},
+};
+
+static int __init dw_dma_init(void)
+{
+	return platform_driver_register(&dw_dma_driver);
+}
+subsys_initcall(dw_dma_init);
+
+static void __exit dw_dma_exit(void)
+{
+	platform_driver_unregister(&dw_dma_driver);
+}
+module_exit(dw_dma_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("CVITEK DMA Controller platform driver");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/drivers/dma/cvitek/cvitek-dma.h b/drivers/dma/cvitek/cvitek-dma.h
new file mode 100644
index 000000000000..c808dc28757f
--- /dev/null
+++ b/drivers/dma/cvitek/cvitek-dma.h
@@ -0,0 +1,497 @@
+#ifndef __CV_DMA_H__
+#define __CV_DMA_H__
+
+#if defined(CONFIG_ARM)
+/* Bitfields in CTL */
+#define DWC_CTL_SMS(n)		((n & 0x1)<<0)	/* src master select */
+#define DWC_CTL_DMS(n)		((n & 0x1)<<2)	/* dst master select */
+#define DWC_CTL_SRC_INC		(0<<4)	/* Source Address Increment update*/
+#define DWC_CTL_SRC_FIX		(1<<4)	/* Source Address Increment not*/
+#define DWC_CTL_DST_INC		(0<<6)	/* Destination Address Increment update*/
+#define DWC_CTL_DST_FIX		(1<<6)	/* Destination Address Increment not*/
+#define DWC_CTL_SRC_WIDTH(n)	((n & 0x7)<<8)	/* Source Transfer Width */
+#define DWC_CTL_DST_WIDTH(n)	((n & 0x7)<<11)	/* Destination Transfer Width */
+#define DWC_CTL_SRC_MSIZE(n)	((n & 0xf)<<14)	/* SRC Burst Transaction Length, data items */
+#define DWC_CTL_DST_MSIZE(n)	((n & 0xf)<<18)	/* DST Burst Transaction Length, data items */
+#define DWC_CTL_AR_CACHE(n)	((n & 0xf)<<22)
+#define DWC_CTL_AW_CACHE(n)	((n & 0xf)<<26)
+#define DWC_CTL_N_LAST_W_EN	(1<<30)	/* last write posted write enable/disable*/
+#define DWC_CTL_N_LAST_W_DIS	(0<<30)	/* last write posted wrtie enable/disable*/
+#define DWC_CTL_ARLEN_DIS	(0ULL<<38) /* Source Burst Length Disable */
+#define DWC_CTL_ARLEN_EN	(1ULL<<38) /* Source Burst Length Enable */
+#define DWC_CTL_ARLEN(n)	((n & 0xffULL)<<39)
+#define DWC_CTL_AWLEN_DIS	(0ULL<<47) /* DST Burst Length Enable */
+#define DWC_CTL_AWLEN_EN	(1ULL<<47)
+#define DWC_CTL_AWLEN(n)	((n & 0xffULL)<<48)
+#define DWC_CTL_SRC_STA_DIS	(0ULL<<56)
+#define DWC_CTL_SRC_STA_EN	(1ULL<<56)
+#define DWC_CTL_DST_STA_DIS	(0ULL<<57)
+#define DWC_CTL_DST_STA_EN	(1ULL<<57)
+#define DWC_CTL_IOC_BLT_DIS	(0ULL<<58)	/* Interrupt On completion of Block Transfer */
+#define DWC_CTL_IOC_BLT_EN	(1ULL<<58)
+#define DWC_CTL_SHADOWREG_OR_LLI_LAST	(1ULL<<62)	/* Last Shadow Register/Linked List Item */
+#define DWC_CTL_SHADOWREG_OR_LLI_VALID	(1ULL<<63)	/* Shadow Register content/Linked List Item valid */
+
+#define DWC_BLOCK_TS_MASK	0x3FFFFF
+
+#define DWC_CFG_SRC_MULTBLK_TYPE(x)	((x & 0x7) << 0)
+#define DWC_CFG_DST_MULTBLK_TYPE(x)	((x & 0x7) << 2)
+#define DWC_CFG_TT_FC(x)		((x & 0x7ULL) << 32)
+#define DWC_CFG_HS_SEL_SRC_HW	(0ULL<<35)
+#define DWC_CFG_HS_SEL_SRC_SW	(1ULL<<35)
+#define DWC_CFG_HS_SEL_DST_HW	(0ULL<<36)
+#define DWC_CFG_HS_SEL_DST_SW	(1ULL<<36)
+#define DWC_CFG_SRC_HWHS_POL_H	(0ULL << 37)
+#define DWC_CFG_SRC_HWHS_POL_L	(1ULL << 37)
+#define DWC_CFG_DST_HWHS_POL_H	(0ULL << 38)
+#define DWC_CFG_DST_HWHS_POL_L	(1ULL << 38)
+#define DWC_CFG_SRC_PER(x)	((x & 0xffULL) << 39)
+#define DWC_CFG_DST_PER(x)	((x & 0xffULL) << 44)
+
+#define DWC_CFG_CH_PRIOR_MASK	(0x7ULL << 49)	/* priority mask */
+#define DWC_CFG_CH_PRIOR(x)	(((x) & 0x7ULL) << 49)	/* priority */
+#define DWC_CFG_SRC_OSR_LMT(x)	(((x) & 0xfULL) << 55) /* max request x + 1 <= 16 */
+#define DWC_CFG_DST_OSR_LMT(x)	(((x) & 0xfULL) << 59)
+
+#define DWC_CFG_GET_TT_FC(x)		((x >> 32ULL) & 0x7)
+
+#else
+
+/* Bitfields in CTL */
+#define DWC_CTL_SMS(n)		((n & 0x1)<<0)	/* src master select */
+#define DWC_CTL_DMS(n)		((n & 0x1)<<2)	/* dst master select */
+#define DWC_CTL_SRC_INC		(0<<4)	/* Source Address Increment update*/
+#define DWC_CTL_SRC_FIX		(1<<4)	/* Source Address Increment not*/
+#define DWC_CTL_DST_INC		(0<<6)	/* Destination Address Increment update*/
+#define DWC_CTL_DST_FIX		(1<<6)	/* Destination Address Increment not*/
+#define DWC_CTL_SRC_WIDTH(n)	((n & 0x7)<<8)	/* Source Transfer Width */
+#define DWC_CTL_DST_WIDTH(n)	((n & 0x7)<<11)	/* Destination Transfer Width */
+#define DWC_CTL_SRC_MSIZE(n)	((n & 0xf)<<14)	/* SRC Burst Transaction Length, data items */
+#define DWC_CTL_DST_MSIZE(n)	((n & 0xf)<<18)	/* DST Burst Transaction Length, data items */
+#define DWC_CTL_AR_CACHE(n)	((n & 0xf)<<22)
+#define DWC_CTL_AW_CACHE(n)	((n & 0xf)<<26)
+#define DWC_CTL_N_LAST_W_EN	(1<<30)	/* last write posted write enable/disable*/
+#define DWC_CTL_N_LAST_W_DIS	(0<<30)	/* last write posted wrtie enable/disable*/
+#define DWC_CTL_ARLEN_DIS	(0UL<<38) /* Source Burst Length Disable */
+#define DWC_CTL_ARLEN_EN	(1UL<<38) /* Source Burst Length Enable */
+#define DWC_CTL_ARLEN(n)	((n & 0xff)<<39)
+#define DWC_CTL_AWLEN_DIS	(0UL<<47) /* DST Burst Length Enable */
+#define DWC_CTL_AWLEN_EN	(1UL<<47)
+#define DWC_CTL_AWLEN(n)	((n & 0xff)<<48)
+#define DWC_CTL_SRC_STA_DIS	(0UL<<56)
+#define DWC_CTL_SRC_STA_EN	(1UL<<56)
+#define DWC_CTL_DST_STA_DIS	(0UL<<57)
+#define DWC_CTL_DST_STA_EN	(1UL<<57)
+#define DWC_CTL_IOC_BLT_DIS	(0UL<<58)	/* Interrupt On completion of Block Transfer */
+#define DWC_CTL_IOC_BLT_EN	(1UL<<58)
+#define DWC_CTL_SHADOWREG_OR_LLI_LAST	(1UL<<62)	/* Last Shadow Register/Linked List Item */
+#define DWC_CTL_SHADOWREG_OR_LLI_VALID	(1UL<<63)	/* Shadow Register content/Linked List Item valid */
+
+#define DWC_BLOCK_TS_MASK	0x3FFFFF
+
+#define DWC_CFG_SRC_MULTBLK_TYPE(x)	((x & 0x7) << 0)
+#define DWC_CFG_DST_MULTBLK_TYPE(x)	((x & 0x7) << 2)
+#define DWC_CFG_TT_FC(x)		((x & 0x7) << 32)
+#define DWC_CFG_HS_SEL_SRC_HW	(0UL<<35)
+#define DWC_CFG_HS_SEL_SRC_SW	(1UL<<35)
+#define DWC_CFG_HS_SEL_DST_HW	(0UL<<36)
+#define DWC_CFG_HS_SEL_DST_SW	(1UL<<36)
+#define DWC_CFG_SRC_HWHS_POL_H	(0UL << 37)
+#define DWC_CFG_SRC_HWHS_POL_L	(1UL << 37)
+#define DWC_CFG_DST_HWHS_POL_H	(0UL << 38)
+#define DWC_CFG_DST_HWHS_POL_L	(1UL << 38)
+#define DWC_CFG_SRC_PER(x)	((x & 0xff) << 39)
+#define DWC_CFG_DST_PER(x)	((x & 0xff) << 44)
+
+#define DWC_CFG_CH_PRIOR_MASK	(0x7UL << 49)	/* priority mask */
+#define DWC_CFG_CH_PRIOR(x)	((x & 0x7) << 49)	/* priority */
+#define DWC_CFG_SRC_OSR_LMT(x)	(((x) & 0xf) << 55) /* max request x + 1 <= 16 */
+#define DWC_CFG_DST_OSR_LMT(x)	(((x) & 0xf) << 59)
+
+#define DWC_CFG_GET_TT_FC(x)		((x >> 32) & 0x7)
+
+#endif
+
+#define DWC_CH_INTSTA_DMA_TFR_DONE	(1<<1)
+#define DWC_CH_INTSTA_BLOCK_TFR_DONE	(1<<0)
+#define DWC_CH_INTSTA_SRC_TFR_COMP_EN	(1<<3)
+#define DWC_CH_INTSTA_DST_TFR_COMP_EN	(1<<4)
+#define DWC_CH_INTSTA_SRC_DEC_ERR_EN	(1<<5)
+#define DWC_CH_INTSTA_DST_DEC_ERR_EN	(1<<6)
+#define DWC_CH_INTSTA_SRC_SLV_ERR_EN	(1<<7)
+#define DWC_CH_INTSTA_SRC_DST_ERR_EN	(1<<8)
+#define DWC_CH_INTSTA_LLI_RD_DEV_ERR_EN	(1<<9)
+#define DWC_CH_INTSTA_LLI_WD_DEV_ERR_EN	(1<<10)
+#define DWC_CH_INTSTA_LLI_RD_SLV_ERR_EN	(1<<11)
+#define DWC_CH_INTSTA_LLI_WD_SLV_ERR_EN	(1<<12)
+#define DWC_CH_INTSTA_SHDW_LLI_INVALID_ERR_EN	(1<<13)
+#define DWC_CH_INTSTA_SLVIF_MULTBLK_TYPE_ERR_EN	(1<<14)
+#define DWC_CH_INTSTA_SLVIF_DEC_ERR_EN	(1<<16)
+#define DWC_CH_INTSTA_CH_ABORTED_EN	(1<<31)
+#define DWC_CH_SUSPENDED		(1 << 29)
+
+#define DWC_CH_INTSIG_BLK_TRA_DONE	(1 << 0)
+#define DWC_CH_INTSIG_DMA_TRA_DONE	(1 << 1)
+#define DWC_CH_INTSIG_SRC_COMP_DONE	(1 << 3)
+#define DWC_CH_INTSIG_DST_COMP_DONE	(1 << 4)
+
+/* Bitfields in LLP */
+#define DWC_LLP_LMS(x)		((x) & 1)	/* list master select */
+#define DWC_LLP_LOC(x)		(((x) & ~0x3f))	/* next lli */
+
+#define DW_DMAC_CH_PAUSE_EN_OFFSET	24
+#define DW_DMAC_CH_PAUSE_OFFSET		16
+#define DW_DMAC_CH_EN_WE_OFFSET		8
+#define DW_DMAC_CH_ABORT_WE_OFFSET	40
+#define DW_DMAC_CH_ABORT_OFFSET	32
+
+
+#define DW_CFG_DMA_EN		(1 << 0)
+#define DW_CFG_DMA_INT_EN	(1 << 1)
+
+#define DW_DMA_MAX_NR_MASTERS	2
+#define DW_DMA_MAX_NR_CHANNELS	8
+#define DW_DMA_MAX_NR_REQUESTS	16
+#define DW_DMA_CHAN_MASK	((1 << DW_DMA_MAX_NR_CHANNELS) - 1)
+#define DW_DWC_MAX_BLOCK_TS	32
+
+/* The set of bus widths supported by the DMA controller */
+#define DW_DMA_BUSWIDTHS			  \
+			(BIT(DMA_SLAVE_BUSWIDTH_UNDEFINED)	| \
+			BIT(DMA_SLAVE_BUSWIDTH_1_BYTE)		| \
+			BIT(DMA_SLAVE_BUSWIDTH_2_BYTES)		| \
+			BIT(DMA_SLAVE_BUSWIDTH_4_BYTES))
+
+#define BM_DMA_PERIOD_LEN 64 //The maxmium LLI data length of BM sysDMA
+
+#ifdef CONFIG_DW_DMAC_BIG_ENDIAN_IO
+typedef __be32 __dw32;
+typedef __be64 __dw64;
+#else
+typedef __le32 __dw32;
+typedef __le64 __dw64;
+#endif
+
+enum dwc_multblk_type {
+	CONTIGUOUS,
+	RELOAD,
+	SHADOW_REGISTER,
+	LINK_LIST
+};
+
+/* flow controller */
+enum dw_dma_fc {
+	DW_DMA_FC_D_M2M, /* FlowControl is DMAC, mem to mem */
+	DW_DMA_FC_D_M2P, /* FlowControl is DMAC, mem to perip */
+	DW_DMA_FC_D_P2M,
+	DW_DMA_FC_D_P2P,
+	DW_DMA_FC_SP_P2M, /* FlowControl is Source periph, periph to mem */
+	DW_DMA_FC_SP_P2P,
+	DW_DMA_FC_DP_M2P, /* FlowControl is Dst periph, periph to mem */
+	DW_DMA_FC_DP_P2P,
+};
+
+enum dwc_tr_width {
+	BITS_WIDTH_UNDEFINED = 0,
+	BITS_WIDTH_8_BITS,
+	BITS_WIDTH_16_BITS,
+	BITS_WIDTH_32_BITS,
+	BITS_WIDTH_64_BITS,
+	BITS_WIDTH_128_BITS,
+	BITS_WIDTH_256_BITS,
+	BITS_WIDTH_512_BITS,
+};
+
+/* chan intstatus*/
+enum dw_dmac_flags {
+	DW_DMA_IS_CYCLIC = 0,
+	DW_DMA_IS_SOFT_LLP = 1,
+	DW_DMA_IS_PAUSED = 2,
+	DW_DMA_IS_INITIALIZED = 3,
+};
+
+/* bursts size */
+enum dw_dma_msize {
+	DW_DMA_MSIZE_1,
+	DW_DMA_MSIZE_4,
+	DW_DMA_MSIZE_8,
+	DW_DMA_MSIZE_16,
+	DW_DMA_MSIZE_32,
+	DW_DMA_MSIZE_64,
+	DW_DMA_MSIZE_128,
+	DW_DMA_MSIZE_256,
+};
+
+/*
+ * Redefine this macro to handle differences between 32- and 64-bit
+ * addressing, big vs. little endian, etc.
+ */
+#define DW_REG(name)	u64 name
+
+/* Hardware register definitions. */
+struct dw_dma_chan_regs {
+	DW_REG(SAR);		/* Source Address Register */
+	DW_REG(DAR);		/* Destination Address Register */
+	DW_REG(BLOCK_TS);		/* Block transfer size */
+	DW_REG(CTL);	/* Contorl dma transer */
+	DW_REG(CFG);	/* Configure dma transer */
+	DW_REG(LLP);		/* Linked List Pointer */
+	DW_REG(STATUS);		/* Status of dma transer */
+	DW_REG(SWHSSRCREG);		/* SW handshake source register */
+	DW_REG(SWHSDSTREG);	/* SW handshake Destination register */
+	DW_REG(BLK_TFR_RESUMEREQREG);	/* Block transfer resume request */
+	DW_REG(AXI_IDREG);	/* AXI ID register */
+	DW_REG(AXI_QOSREG);	/* AXI QoS register */
+	DW_REG(SSTAT);
+	DW_REG(DSTAT);
+	DW_REG(SSTATAR);
+	DW_REG(DSTATAR);
+	DW_REG(INTSTATUS_ENABLEREG);
+	DW_REG(INTSTATUS);
+	DW_REG(INTSIGNAL_ENABLEREG);
+	DW_REG(INTCLEARREG);
+	u64 __reserved1[12];
+};
+
+struct dw_dma_regs {
+	/* Common Registers */
+	DW_REG(ID);
+	DW_REG(COMPVER);
+	DW_REG(CFG);
+	DW_REG(CH_EN);
+	u64 __reserved0[2];
+
+	DW_REG(INTSTATUS);
+	DW_REG(COMM_INTCLEAR);
+	DW_REG(COMM_INTSTATUS_EN);
+	DW_REG(COMM_INTSIGNAL_EN);
+	DW_REG(COMM_INTSTATUS);
+	DW_REG(RESET);
+
+	u64 __reserved1[20];
+	/* channel regs */
+	struct dw_dma_chan_regs	CHAN[DW_DMA_MAX_NR_CHANNELS];
+};
+
+/**
+ * struct dw_dma_slave - Controller-specific information about a slave
+ *
+ * @dma_dev:	required DMA master device
+ * @src_id:	src request line
+ * @dst_id:	dst request line
+ * @m_master:	memory master for transfers on allocated channel
+ * @p_master:	peripheral master for transfers on allocated channel
+ * @hs_polarity:set active low polarity of handshake interface
+ */
+struct dw_dma_slave {
+	struct device *dma_dev;
+	u8 src_id;
+	u8 dst_id;
+	u8 m_master;
+	u8 p_master;
+	bool hs_polarity;
+};
+
+struct dbg_fix_buf {
+	int id;
+	void *cpu_addr;
+	dma_addr_t dma_hanle;
+	unsigned int size;
+	unsigned int state;
+};
+struct dbg_fix_sg {
+	int count;
+	struct dbg_fix_buf *fix_buf;
+};
+
+struct dw_cyclic_desc {
+	struct dw_desc **desc;
+	unsigned long periods;
+	size_t period_len;
+	unsigned int last_sent;
+	void (*period_callback)(void *param);
+	void *period_callback_param;
+};
+
+struct dw_dma_chan {
+	struct dma_chan chan;
+	void __iomem *ch_regs;
+	u64 mask;
+	u64 priority;
+	enum dma_transfer_direction direction;
+
+	spinlock_t lock;
+
+	/* these other elements are all protected by lock */
+	unsigned long flags;
+	struct list_head active_list;
+	struct list_head queue;
+	struct dw_cyclic_desc *cdesc;
+
+	unsigned int descs_allocated;
+
+	/* hardware configuration */
+	unsigned int axi_tr_width;
+	unsigned int block_size;
+	unsigned int block_ts;
+
+	/* custom slave configuration */
+	struct dw_dma_slave dws;
+
+	/* configuration passed via .device_config */
+	struct dma_slave_config dma_sconfig;
+
+	/* fix bug sysdma */
+	struct dbg_fix_sg *bug_info;
+	struct dma_pool *bug_fix_dma_pool;
+	u32 hw_pos;
+	u32 interrupt_count;
+};
+
+/* LLI == Linked List Item; a.k.a. DMA block descriptor */
+struct dw_lli {
+	/* values that are not changed by hardware */
+	__dw64 sar;
+	__dw64 dar;
+	__dw64 block_ts;
+	__dw64 llp;	/* chain to next lli */
+	__dw64 ctl;
+
+	/* sstat and dstat can snapshot peripheral register state.
+	 * silicon config may discard either or both...
+	 */
+	__dw32 sstat;
+	__dw32 dstat;
+	__dw64 llp_status;
+	__dw64 reserved;
+};
+
+struct dw_desc {
+	/* FIRST values the hardware uses */
+	struct dw_lli lli;
+
+#ifdef CONFIG_DW_DMAC_BIG_ENDIAN_IO
+#define lli_set(d, reg, v)		((d)->lli.reg |= cpu_to_be64(v))
+#define lli_clear(d, reg, v)		((d)->lli.reg &= ~cpu_to_be64(v))
+#define lli_read(d, reg)		be64_to_cpu((d)->lli.reg)
+#define lli_write(d, reg, v)		((d)->lli.reg = cpu_to_be64(v))
+#else
+#define lli_set(d, reg, v)		((d)->lli.reg |= cpu_to_le64(v))
+#define lli_clear(d, reg, v)		((d)->lli.reg &= ~cpu_to_le64(v))
+#define lli_read(d, reg)		le64_to_cpu((d)->lli.reg)
+#define lli_write(d, reg, v)		((d)->lli.reg = cpu_to_le64(v))
+#endif
+
+	/* THEN values for driver housekeeping */
+	struct list_head desc_node;
+	struct list_head tx_list;
+	struct dma_async_tx_descriptor txd;
+	size_t len;
+	size_t total_len;
+	u32 residue;
+	u32 hw_pos;
+};
+
+#ifdef CONFIG_PM_SLEEP
+struct dw_dma_pm_chan_regs {
+	DW_REG(SAR);		/* Source Address Register */
+	DW_REG(DAR);		/* Destination Address Register */
+	DW_REG(BLOCK_TS);		/* Block transfer size */
+	DW_REG(CTL);	/* Contorl dma transer */
+	DW_REG(CFG);	/* Configure dma transer */
+	DW_REG(LLP);		/* Linked List Pointer */
+	DW_REG(INTSTATUS_ENABLEREG);
+	DW_REG(INTSIGNAL_ENABLEREG);
+};
+struct dw_dma_reg_context {
+	u64 cfg;
+	u64 chen;
+	struct dw_dma_pm_chan_regs	chan[DW_DMA_MAX_NR_CHANNELS];
+};
+#endif
+
+struct dw_dma {
+	struct device *dev;
+	void __iomem *regs;
+	struct dma_pool *desc_pool;
+	struct dma_device dma;
+	struct clk *clk;
+	struct tasklet_struct tasklet;
+
+	/* dma configs */
+	unsigned char nr_channels;
+	bool is_private;
+	bool is_memcpy;
+#define CHAN_ALLOCATION_ASCENDING	0	/* zero to seven */
+#define CHAN_ALLOCATION_DESCENDING	1	/* seven to zero */
+	unsigned char chan_allocation_order;
+#define CHAN_PRIORITY_ASCENDING		0	/* chan0 highest */
+#define CHAN_PRIORITY_DESCENDING	1	/* chan7 highest */
+	unsigned char chan_priority;
+	unsigned int axi_tr_width;
+	unsigned int block_size;
+	unsigned int block_ts;
+	unsigned char nr_masters;
+	unsigned char data_width[DW_DMA_MAX_NR_MASTERS];
+
+	/* channels */
+	struct dw_dma_chan *chan;
+	u8 in_use;
+	u8 clk_count;
+	u8 log_on;
+
+	/* interrupt*/
+	int irq;
+	spinlock_t lock;
+#ifdef CONFIG_PM_SLEEP
+	struct dw_dma_reg_context *reg_ctx;
+#endif
+};
+
+#ifdef CONFIG_DW_DMAC_BIG_ENDIAN_IO
+#define dma_readl_native	ioread32be
+#define dma_writel_native	iowrite32be
+#else
+#define dma_readl_native	readl
+#define dma_writel_native	writel
+#ifdef readq
+#define dma_readq_native	readq
+#else
+#define dma_readq_native(__reg)	(*(volatile u64 __force *)(__reg))
+#endif
+#ifdef writeq
+#define dma_writeq_native	writeq
+#else
+#define dma_writeq_native(__value,__reg)	\
+	(*(volatile u64 __force *)(__reg) = (__value))
+#endif
+#endif
+
+#define dma_readq(dw, name) \
+		dma_readq_native(&(__dw_regs(dw)->name))
+
+#define dma_writeq(dw, name, val) \
+		dma_writeq_native((val), &(__dw_regs(dw)->name))
+
+#define channel_readq(dwc, name) \
+		dma_readq_native(&(__dwc_regs(dwc)->name))
+
+#define channel_writeq(dwc, name, val) \
+		dma_writeq_native((val), &(__dwc_regs(dwc)->name))
+
+#define dma_set_bit(dw, name, mask) \
+		dma_writeq_native(((mask) | dma_readq_native(&(__dw_regs(dw)->name))) \
+			, &(__dw_regs(dw)->name))
+
+#define dma_clear_bit(dw, name, mask) \
+		dma_writeq_native((~mask & dma_readq_native(&(__dw_regs(dw)->name))) \
+			, &(__dw_regs(dw)->name))
+
+#define channel_set_bit(dwc, name, mask) \
+		dma_writeq_native((mask | dma_readq_native(&(__dwc_regs(dwc)->name))), \
+			&(__dwc_regs(dwc)->name))
+
+#define channel_clear_bit(dwc, name, mask) \
+	dma_writeq_native((~mask & dma_readq_native(&(__dwc_regs(dwc)->name))), \
+		&(__dwc_regs(dwc)->name))
+#endif
diff --git a/drivers/firmware/efi/libstub/efi-stub.c b/drivers/firmware/efi/libstub/efi-stub.c
index 0ab439c53eee..3e176f254daf 100644
--- a/drivers/firmware/efi/libstub/efi-stub.c
+++ b/drivers/firmware/efi/libstub/efi-stub.c
@@ -38,7 +38,7 @@
 #define EFI_RT_VIRTUAL_BASE	SZ_512M
 #define EFI_RT_VIRTUAL_SIZE	SZ_512M
 
-#ifdef CONFIG_ARM64
+#if defined(CONFIG_ARM64) || defined(CONFIG_RISCV)
 # define EFI_RT_VIRTUAL_LIMIT	DEFAULT_MAP_WINDOW_64
 #else
 # define EFI_RT_VIRTUAL_LIMIT	TASK_SIZE
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index ea474b16e3aa..00c38c43dcc1 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -577,6 +577,11 @@ config I2C_DESIGNWARE_PCI
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-designware-pci.
 
+config I2C_DESIGNWARE_ICE
+	bool "Synopsys DesignWare for ICE"
+	depends on OF
+	default n
+
 config I2C_DIGICOLOR
 	tristate "Conexant Digicolor I2C driver"
 	depends on ARCH_DIGICOLOR || COMPILE_TEST
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 683c49faca05..1db3a4f705bc 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -57,6 +57,7 @@ i2c-designware-platform-y 				:= i2c-designware-platdrv.o
 i2c-designware-platform-$(CONFIG_I2C_DESIGNWARE_BAYTRAIL) += i2c-designware-baytrail.o
 obj-$(CONFIG_I2C_DESIGNWARE_PCI)			+= i2c-designware-pci.o
 i2c-designware-pci-y					:= i2c-designware-pcidrv.o
+obj-$(CONFIG_I2C_DESIGNWARE_ICE)			+= i2c-designware-ice.o
 obj-$(CONFIG_I2C_DIGICOLOR)	+= i2c-digicolor.o
 obj-$(CONFIG_I2C_EFM32)		+= i2c-efm32.o
 obj-$(CONFIG_I2C_EG20T)		+= i2c-eg20t.o
diff --git a/drivers/i2c/busses/i2c-designware-core.h b/drivers/i2c/busses/i2c-designware-core.h
index eb5ef4d0f463..6970be22ff34 100644
--- a/drivers/i2c/busses/i2c-designware-core.h
+++ b/drivers/i2c/busses/i2c-designware-core.h
@@ -286,6 +286,7 @@ struct dw_i2c_dev {
 	int			mode;
 	struct i2c_bus_recovery_info rinfo;
 	bool			suspended;
+	int			use_interstop;
 };
 
 #define ACCESS_INTR_MASK	0x00000001
diff --git a/drivers/i2c/busses/i2c-designware-ice.c b/drivers/i2c/busses/i2c-designware-ice.c
new file mode 100644
index 000000000000..b6476778f3bd
--- /dev/null
+++ b/drivers/i2c/busses/i2c-designware-ice.c
@@ -0,0 +1,746 @@
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/clk.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/property.h>
+#include <linux/reset.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+
+#define DW_IC_MAX_I2C_DEV     ( 6 )
+
+#define I2C_CLK     (24*1000*1000)
+
+#define I2C_SPEED   (400*1000)
+
+#define I2C_BUF_DEP ( 128 )
+
+#define I2C_FIFO_DATA_CNT ( 4 )
+
+#define DW_IC_CON                   (0x00)
+#define DW_IC_TAR                   (0x04)
+#define DW_IC_DATA_CMD              (0x10)
+#define DW_IC_SS_SCL_HCNT           (0x14)
+#define DW_IC_SS_SCL_LCNT           (0x18)
+#define DW_IC_FS_SCL_HCNT           (0x1c)
+#define DW_IC_FS_SCL_LCNT           (0x20)
+#define DW_IC_HS_SCL_HCNT           (0x24)
+#define DW_IC_HS_SCL_LCNT           (0x28)
+#define DW_IC_INTR_STAT             (0x2c)
+#define DW_IC_INTR_MASK             (0x30)
+#define DW_IC_RAW_INTSTATUS         (0x34)
+#define DW_IC_RX_TL                 (0x38)
+#define DW_IC_TX_TL                 (0x3c)
+#define DW_IC_CLR_INTR              (0x40)
+#define DW_IC_CLR_RX_UNDER          (0x44)
+#define DW_IC_CLR_RX_OVER           (0x48)
+#define DW_IC_CLR_TX_OVER           (0x4c)
+#define DW_IC_CLR_RD_REQ            (0x50)
+#define DW_IC_CLR_TX_ABRT           (0x54)
+#define DW_IC_CLR_RX_DONE           (0x58)
+#define DW_IC_CLR_ACTIVITY          (0x5c)
+#define DW_IC_CLR_STOP_DET          (0x60)
+#define DW_IC_CLR_START_DET         (0x64)
+#define DW_IC_ENABLE                (0x6c)
+#define DW_IC_STATUS                (0x70)
+#define DW_IC_TXFLR                 (0x74)
+#define DW_IC_RXFLR                 (0x78)
+#define DW_IC_TX_ABRT_SOURCE        (0x80)
+#define DW_IC_DMA_CR                (0x88)
+#define DW_IC_DMA_TDLR              (0x8c)
+#define DW_IC_DMA_RDLR              (0x90)
+#define DW_IC_ENABLE_STATUS         (0x9c)
+#define DW_IC_START                 (0xa0)
+
+#define DW_IC_BIT_INT_STOP            BIT(9)
+#define DW_IC_BIT_INT_FREE            BIT(8)
+#define DW_IC_BIT_INT_TX_ABRT         BIT(6)
+
+#define I2C_ENABLES     (1)
+#define I2C_DISABLES    (0)
+#define I2C_START       (1)
+#define I2C_STOP        (0)
+
+/* IC_CON */
+#define DW_IC_BIT_MASTER_MODE         BIT(0)
+#define DW_IC_BIT_SPDMD_FAST          BIT(2)
+#define DW_IC_BIT_10_ADDR             BIT(4)
+#define DW_IC_BIT_RESTART_EN          BIT(5)
+
+#define DW_IC_BITSHF_SPDMODE          (0x01)
+#define DW_IC_BITMASK_SPDMODE         (~0x06)
+
+/* IC_STATUS */
+#define DW_IC_BITMASK_ACTIVITY        (0x01)
+#define DW_IC_BIT_ACTIVITY            (0x01)
+#define DW_IC_BIT_TFE                 BIT(2)
+#define DW_IC_BIT_RFNE                BIT(3)
+
+/* IC_DATA_CMD */
+#define DW_IC_BIT_CDM_READ            BIT(8)
+
+#define I2C_GROUP_CMD_CNT        (256)
+
+#define DW_IC_I2C_SPD_STANDARD    (100 * 1000)
+#define DW_IC_I2C_SPD_FAST        (400 * 1000)
+#define DW_IC_I2C_SPD_HIGH        (3400 * 1000)
+
+typedef enum {
+	DW_IC_I2C_SPDMODE_REV = 0,
+	DW_IC_I2C_SPDMODE_STD,
+	DW_IC_I2C_SPDMODE_FAST,
+	DW_IC_I2C_SPDMODE_HIGH,
+} DW_IC_I2C_SPDMODE_E;
+
+typedef enum
+{
+	STATUS_IDLE      = 0,
+	STATUS_HANDLING  = 1,
+	STATUS_DONE      = 2,
+	STATUS_ERROR     = 3,
+	STATUS_BUTT   = 4,
+}DW_IC_I2C_GROUP_STATUS_E;
+
+typedef struct
+{
+	int devid;
+	int reg_addr;
+	int nofifo;
+	int cmd_cnt;
+	int cmd_pos;
+	unsigned short cmdBuf[I2C_GROUP_CMD_CNT];
+}DW_IC_I2C_GROUP_CMD_S;
+
+#define DW_IC_I2C_CMD_BUF_DEP	(I2C_BUF_DEP * 2)
+struct dw_i2c_dev
+{
+	void __iomem    *base;
+	int             irq;
+
+	struct mutex    lock;
+	wait_queue_head_t   wait;
+	int            complete;
+	int             abort;
+	struct i2c_adapter  adapter;
+
+	unsigned short cmdBuf[DW_IC_I2C_CMD_BUF_DEP]; /* cmds for RD and WR */
+};
+
+void dw_misc_reg_write(unsigned int value,void *base,unsigned int offset)
+{
+	writel((value), base + offset);
+}
+
+unsigned int dw_misc_getreg(void *base,int offset)
+{
+	return readl(base + offset);
+}
+
+static unsigned int dw_ic_spd_mode;
+static long i2c_base_addr[DW_IC_MAX_I2C_DEV];
+
+DW_IC_I2C_GROUP_STATUS_E dw_group_status[DW_IC_MAX_I2C_DEV];
+struct mutex    lock[DW_IC_MAX_I2C_DEV];
+DW_IC_I2C_GROUP_CMD_S dw_group_cmd[DW_IC_MAX_I2C_DEV];
+
+
+int dw_i2c_enable(void *base,unsigned int enabel)
+{
+	dw_misc_reg_write( enabel,base,DW_IC_ENABLE);
+	return 0;
+}
+
+int dw_i2c_interrupt_init(void *base)
+{
+	unsigned int intr = 0;
+
+	dw_misc_getreg(base,DW_IC_CLR_INTR);
+	intr |= (DW_IC_BIT_INT_FREE | DW_IC_BIT_INT_TX_ABRT);
+	dw_misc_reg_write( intr,base,DW_IC_INTR_MASK);
+	return 0;
+}
+
+int dw_i2c_clk_config(void *base, unsigned int bus_clk, unsigned int clk)
+{
+	unsigned short cnt_hi,cnt_lo;
+	unsigned int local_spd_mode,tmp;
+
+	if (clk > DW_IC_I2C_SPD_FAST) {
+		local_spd_mode = DW_IC_I2C_SPDMODE_HIGH;
+	} else if (clk > DW_IC_I2C_SPD_STANDARD) {
+		local_spd_mode = DW_IC_I2C_SPDMODE_FAST;
+	} else {
+		local_spd_mode = DW_IC_I2C_SPDMODE_STD;
+	}
+
+	if (dw_ic_spd_mode != local_spd_mode) {
+		tmp = dw_misc_getreg(base, DW_IC_CON);
+		tmp &= DW_IC_BITMASK_SPDMODE;
+		tmp |= (local_spd_mode << DW_IC_BITSHF_SPDMODE);
+		dw_misc_reg_write(tmp, base, DW_IC_CON);
+
+		dw_ic_spd_mode = local_spd_mode;
+	}
+
+	cnt_hi = (bus_clk / clk) >> 1;
+	cnt_lo = (bus_clk / clk) - cnt_hi;
+
+	if (local_spd_mode == DW_IC_I2C_SPDMODE_HIGH) {
+		dw_misc_reg_write( cnt_hi - 8,base,DW_IC_HS_SCL_HCNT);
+		dw_misc_reg_write( cnt_lo - 1,base,DW_IC_HS_SCL_LCNT);
+	} else if (local_spd_mode == DW_IC_I2C_SPDMODE_FAST) {
+		dw_misc_reg_write( cnt_hi - 8,base,DW_IC_FS_SCL_HCNT);
+		dw_misc_reg_write( cnt_lo - 1,base,DW_IC_FS_SCL_LCNT);
+	} else {
+		dw_misc_reg_write( cnt_hi - 8,base,DW_IC_SS_SCL_HCNT);
+		dw_misc_reg_write( cnt_lo - 1,base,DW_IC_SS_SCL_LCNT);
+	}
+
+	return 0;
+}
+
+int dw_i2c_config_set(void *base)
+{
+	unsigned int cfg;
+
+	cfg = DW_IC_BIT_MASTER_MODE | DW_IC_BIT_SPDMD_FAST | (1 << 6) \
+		  | DW_IC_BIT_RESTART_EN;
+	dw_misc_reg_write(cfg, base, DW_IC_CON);
+
+	return 0;
+}
+
+
+int dw_i2c_SetSlaveAddr(void *base,unsigned int addr)
+{
+	dw_misc_reg_write( addr,base,DW_IC_TAR);
+	return 0;
+}
+
+int dw_i2c_WaitTransmitOver(void *base,unsigned int fifoFlag)
+{
+	int i;
+	unsigned int tmp;
+
+	for (i = 0; i < 0xffff; i++) {
+		tmp = dw_misc_getreg(base,DW_IC_STATUS);
+		if ( DW_IC_BIT_ACTIVITY != (tmp & DW_IC_BITMASK_ACTIVITY)
+				&& (tmp & fifoFlag )) {
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+int  dw_i2c_SetStart(void *base,unsigned int u32Enable)
+{
+	dw_misc_reg_write(u32Enable, base, DW_IC_START);
+
+	return 0;
+}
+
+
+unsigned int dw_i2c_GetIntStatus(void *base)
+{
+	return dw_misc_getreg(base,DW_IC_INTR_STAT);
+}
+
+unsigned int dw_i2c_GetRecFifoCnt(void *base)
+{
+	return dw_misc_getreg(base,DW_IC_RXFLR);
+}
+
+int dw_i2c_SetGroupSendStatus(unsigned int i2c_ctl_index,DW_IC_I2C_GROUP_STATUS_E status)
+{
+	if(i2c_ctl_index > DW_IC_MAX_I2C_DEV - 1) {
+		return -1;
+	}
+
+	dw_group_status[i2c_ctl_index] = status;
+
+	return 0;
+}
+
+DW_IC_I2C_GROUP_STATUS_E dw_i2c_GetGroupSendStatus(unsigned int i2c_ctl_index)
+{
+	if(i2c_ctl_index > DW_IC_MAX_I2C_DEV - 1) {
+		return -1;
+	}
+
+	return dw_group_status[i2c_ctl_index];
+}
+
+int dw_i2c_WriteFifo(unsigned int i2c_ctl_index,unsigned int hardgroup)
+{
+	int total_cnt;
+	unsigned short cmd;
+	unsigned int reg_addr,start = 0;
+	void *lpRegBase;
+
+	if (i2c_base_addr[i2c_ctl_index] != 0) {
+		lpRegBase = (void *)i2c_base_addr[i2c_ctl_index];
+	} else {
+		return -1;
+	}
+
+	if (dw_group_cmd[i2c_ctl_index].nofifo == 1) {
+		reg_addr = dw_group_cmd[i2c_ctl_index].reg_addr;
+		if((reg_addr & 0xff00) != 0) {
+			dw_misc_reg_write( ((reg_addr & 0xff00) >> 8) | (1 << 9) ,lpRegBase,DW_IC_DATA_CMD);
+			dw_misc_reg_write( reg_addr & 0xff ,lpRegBase,DW_IC_DATA_CMD);
+		} else {
+			dw_misc_reg_write( (reg_addr & 0xff) | (1 << 9) ,lpRegBase,DW_IC_DATA_CMD);
+		}
+
+		dw_group_cmd[i2c_ctl_index].nofifo = 0;
+	}
+
+	while(1) {
+		cmd = dw_group_cmd[i2c_ctl_index].cmdBuf[dw_group_cmd[i2c_ctl_index].cmd_pos];
+		if((cmd & (1 << 9)) != 0) {
+			if(hardgroup == 0) {
+				if(start != 0)
+					break;
+				else
+					start = 1;
+			}
+			total_cnt = dw_misc_getreg(lpRegBase,DW_IC_TXFLR);
+
+			if(I2C_BUF_DEP - total_cnt < 4) {
+				break;
+			}
+
+			dw_group_cmd[i2c_ctl_index].reg_addr = cmd;
+			dw_misc_reg_write( cmd ,lpRegBase,DW_IC_DATA_CMD);
+			dw_group_cmd[i2c_ctl_index].cmd_pos++;
+			dw_group_cmd[i2c_ctl_index].cmd_cnt--;
+			cmd = dw_group_cmd[i2c_ctl_index].cmdBuf[dw_group_cmd[i2c_ctl_index].cmd_pos];
+
+			if((cmd & (1 << 9)) != 0) {
+				dw_group_cmd[i2c_ctl_index].reg_addr <<= 8;
+				dw_group_cmd[i2c_ctl_index].reg_addr += cmd & 0xff;
+				dw_misc_reg_write( cmd & 0xff ,lpRegBase,DW_IC_DATA_CMD);
+				dw_group_cmd[i2c_ctl_index].cmd_pos++;
+				dw_group_cmd[i2c_ctl_index].cmd_cnt--;
+			}
+		} else {
+			dw_misc_reg_write( cmd ,lpRegBase,DW_IC_DATA_CMD);
+			dw_group_cmd[i2c_ctl_index].cmd_pos++;
+			dw_group_cmd[i2c_ctl_index].cmd_cnt--;
+			dw_group_cmd[i2c_ctl_index].reg_addr++;
+		}
+
+		if (dw_group_cmd[i2c_ctl_index].cmd_cnt <= 0) {
+			break;
+		}
+
+		total_cnt = dw_misc_getreg(lpRegBase,DW_IC_TXFLR);
+		if (total_cnt >= I2C_BUF_DEP) {
+			cmd = dw_group_cmd[i2c_ctl_index].cmdBuf[dw_group_cmd[i2c_ctl_index].cmd_pos];
+			if ((cmd & (1 << 9)) == 0) {
+				dw_group_cmd[i2c_ctl_index].nofifo = 1;
+			}
+			break;
+		}
+
+	}
+	return 0;
+}
+
+void dw_i2c_handle_irq(void *dev_id)
+{
+	unsigned int status;
+	DW_IC_I2C_GROUP_STATUS_E groupStatus;
+	struct dw_i2c_dev *dev = dev_id;
+	groupStatus = dw_i2c_GetGroupSendStatus(dev->adapter.nr);
+	status = dw_i2c_GetIntStatus(dev->base);
+
+	if(groupStatus == STATUS_HANDLING) {
+		if(status & DW_IC_BIT_INT_TX_ABRT) {
+			dw_i2c_SetGroupSendStatus(dev->adapter.nr,STATUS_ERROR);
+			dw_i2c_SetStart(dev->base,I2C_STOP);
+			dw_i2c_enable(dev->base,I2C_DISABLES);
+			return;
+		}
+
+		if(dw_group_cmd[dev->adapter.nr].cmd_cnt > 0) {
+			dw_i2c_enable(dev->base,I2C_DISABLES);
+			dw_i2c_interrupt_init(dev->base);
+			dw_i2c_SetSlaveAddr(dev->base,dw_group_cmd[dev->adapter.nr].devid >> 1);
+			dw_i2c_enable(dev->base,I2C_ENABLES);
+			dw_i2c_WriteFifo( dev->adapter.nr ,1);
+			dw_i2c_SetStart(dev->base,I2C_START);
+		} else {
+			dw_i2c_SetGroupSendStatus(dev->adapter.nr,STATUS_DONE);
+			dw_i2c_SetStart(dev->base,I2C_STOP);
+			dw_i2c_enable(dev->base,I2C_DISABLES);
+		}
+
+	} else {
+		if(status & DW_IC_BIT_INT_TX_ABRT) {
+			dev->abort = true;
+		}
+		dev->complete = true;
+		dw_i2c_interrupt_init(dev->base);
+		wake_up(&dev->wait);
+	}
+}
+
+int dw_i2c_SendMsgs(struct dw_i2c_dev *dev, struct i2c_msg *msgs, int num )
+{
+	unsigned int timeout,i;
+	int ret = num;
+	unsigned short *cmd_dat_ptr = dev->cmdBuf;
+
+	if(num != 1 || msgs->len > I2C_BUF_DEP)
+		return -1;
+
+	for(i = 0; i < msgs->len; i++)
+		cmd_dat_ptr[i] = msgs->buf[i];
+	dev->complete = false;
+	dev->abort    = false;
+	dw_i2c_enable(dev->base,I2C_DISABLES);
+	dw_i2c_interrupt_init(dev->base);
+	dw_i2c_SetSlaveAddr(dev->base,msgs->addr);
+	dw_i2c_enable(dev->base,I2C_ENABLES);
+
+	for(i = 0; i < msgs->len; i++ )
+		dw_misc_reg_write( cmd_dat_ptr[i],dev->base,DW_IC_DATA_CMD);
+
+	dw_i2c_SetStart(dev->base,I2C_START);
+
+	timeout = wait_event_timeout(dev->wait, dev->complete == true, HZ * 3);
+
+	if(0 == timeout || dw_i2c_WaitTransmitOver(dev->base,DW_IC_BIT_TFE))
+		ret = 0;
+	else if(dev->abort == true)
+		ret = 0;
+	else if(dev->complete != true)
+		ret = 0;
+
+	dw_i2c_SetStart(dev->base,I2C_STOP);
+	dw_i2c_enable(dev->base,I2C_DISABLES);
+	return ret;
+}
+
+int dw_i2c_ReceiveMsgs(struct dw_i2c_dev *dev, struct i2c_msg *msgs, int num)
+{
+	unsigned int max_cnt,timeout,i,j;
+	int ret = num;
+	unsigned short *cmd_dat_ptr;
+	struct i2c_msg *read_msg,*write_msg;
+	write_msg = msgs;
+	read_msg = msgs + 1;
+	cmd_dat_ptr = dev->cmdBuf;
+	max_cnt = read_msg->len + write_msg->len;
+
+	if (max_cnt > DW_IC_I2C_CMD_BUF_DEP) {
+		printk("i2c read cnt %d,and write cnt %d,bigger than fifo dep %d\n",
+				read_msg->len, write_msg->len, DW_IC_I2C_CMD_BUF_DEP);
+		return -1;
+	}
+
+	for (i = 0; i < write_msg->len; i++) {
+		cmd_dat_ptr[i] = write_msg->buf[i];
+		cmd_dat_ptr[i] &= ~(DW_IC_BIT_CDM_READ);
+	}
+
+	for( j = 0; j < read_msg->len; j++, i++ ) {
+		cmd_dat_ptr[i] = 0;
+		cmd_dat_ptr[i] |= DW_IC_BIT_CDM_READ;
+	}
+
+	dev->complete = false;
+	dev->abort = false;
+
+	dw_i2c_enable(dev->base,I2C_DISABLES);
+	dw_i2c_interrupt_init(dev->base);
+	dw_i2c_SetSlaveAddr(dev->base,msgs->addr);
+	dw_i2c_enable(dev->base,I2C_ENABLES);
+
+	for(j = 0; j < i; j++ )
+		dw_misc_reg_write( cmd_dat_ptr[j],dev->base,DW_IC_DATA_CMD);
+
+	dw_i2c_SetStart(dev->base,I2C_START);
+
+	timeout = wait_event_timeout(dev->wait, dev->complete == true, HZ * 3);
+
+	if(0 == timeout || dw_i2c_WaitTransmitOver(dev->base,DW_IC_BIT_RFNE))
+		ret = 0;
+	else if(dev->abort == true)
+		ret = 0;
+	else if((dev->complete != true))
+		ret = 0;
+
+	max_cnt = dw_i2c_GetRecFifoCnt(dev->base);
+
+	for(i = 0; i < max_cnt; i++)
+		read_msg->buf[i] = dw_misc_getreg(dev->base,DW_IC_DATA_CMD);
+
+	dw_i2c_SetStart(dev->base,I2C_STOP);
+	dw_i2c_enable(dev->base,I2C_DISABLES);
+	return ret;
+}
+
+int dw_i2c_initCmdBuf(unsigned int i2c_ctl_index)
+{
+	dw_group_cmd[i2c_ctl_index].devid = 0;
+	dw_group_cmd[i2c_ctl_index].reg_addr = 0;
+	dw_group_cmd[i2c_ctl_index].cmd_cnt = 0;
+	dw_group_cmd[i2c_ctl_index].cmd_pos = 0;
+	dw_group_cmd[i2c_ctl_index].nofifo = 0;
+	return 0;
+}
+
+int dw_i2c_initLock(unsigned int i2c_ctl_index)
+{
+	mutex_init(&lock[i2c_ctl_index]);
+	return 0;
+}
+
+int dw_i2c_get_lock(unsigned int i2c_ctl_index)
+{
+	if(dw_group_status[i2c_ctl_index] != STATUS_IDLE)
+	{
+		return -1;
+	}
+	mutex_lock(&lock[i2c_ctl_index]);
+	return 0;
+}
+
+int dw_i2c_FreeLock(unsigned int i2c_ctl_index)
+{
+	mutex_unlock(&lock[i2c_ctl_index]);
+	return 0;
+}
+
+int dw_i2c_uninit(void *base, unsigned int i2c_ctl_index)
+{
+	i2c_base_addr[i2c_ctl_index] = 0;
+
+	return 0;
+}
+
+int dw_i2c_init(void *base, unsigned int bus_clk, unsigned int clk, unsigned int i2c_ctl_index)
+{
+	dw_ic_spd_mode = DW_IC_I2C_SPDMODE_REV;
+	dw_i2c_enable(base, I2C_DISABLES);
+	dw_i2c_interrupt_init(base);
+	dw_i2c_config_set(base);
+	dw_i2c_clk_config(base, bus_clk, clk);
+
+	i2c_base_addr[i2c_ctl_index] = (long)base;
+
+	return 0;
+}
+
+static unsigned int dw_i2c_id_index;
+
+static irqreturn_t dw_i2c_irq(int irq, void *dev_id)
+{
+	dw_i2c_handle_irq(dev_id);
+
+	return IRQ_HANDLED;
+}
+
+int dw_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
+{
+	int ret;
+	struct dw_i2c_dev *dev = i2c_get_adapdata(adap);
+	dw_i2c_get_lock(adap->nr);
+
+	if (num > 1 && !(msgs->flags & I2C_M_RD)) {
+		ret = dw_i2c_ReceiveMsgs(dev, msgs,  num);
+	} else {
+		ret = dw_i2c_SendMsgs(dev, msgs,  num);
+	}
+
+	dw_i2c_FreeLock(adap->nr);
+	return ret;
+}
+
+static unsigned int dw_i2c_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_PROTOCOL_MANGLING;
+}
+
+static struct i2c_algorithm dw_i2c_algorithm = {
+	.master_xfer    = dw_i2c_xfer,
+	.functionality  = dw_i2c_func,
+};
+
+static int dw_i2c_probe(struct platform_device *pdev)
+{
+	struct resource *mem,*ioarea;
+	int ret,irq;
+	struct dw_i2c_dev *dev;
+	struct i2c_adapter *adap;
+	struct clk *bus_clk;
+	unsigned int freq, bus_hz;
+
+	pdev->id = dw_i2c_id_index;
+	dw_i2c_id_index++;
+
+	/* map the registers */
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (mem == NULL)
+	{
+		dev_err(&pdev->dev, "no mem resource\n");
+		return -EINVAL;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+	{
+		dev_err(&pdev->dev, "cannot find IRQ\n");
+		return irq; /* -ENXIO */
+	}
+
+	ioarea = request_mem_region(mem->start, resource_size(mem),pdev->name);
+	if (ioarea == NULL)
+	{
+		dev_err(&pdev->dev, "I2C region already claimed\n");
+		return -EBUSY;
+	}
+
+	dev = kzalloc(sizeof(struct dw_i2c_dev), GFP_KERNEL);
+	if (!dev)
+	{
+		ret = -ENOMEM;
+		goto err_release_region;
+	}
+
+	dev->irq = irq;
+	platform_set_drvdata(pdev, dev);
+
+	dev->base = ioremap(mem->start, resource_size(mem));
+	if (dev->base == NULL)
+	{
+		dev_err(&pdev->dev, "failure mapping io resources\n");
+		ret = -EBUSY;
+		goto err_free_mem;
+	}
+
+	init_waitqueue_head(&dev->wait);
+
+	ret = request_irq(dev->irq, dw_i2c_irq, 0,dev_name(&pdev->dev), dev);
+	if (ret != 0)
+	{
+		dev_err(&pdev->dev, "cannot claim IRQ %d\n", dev->irq);
+		goto err_iounmap;
+	}
+
+	bus_clk = devm_clk_get(&(pdev->dev), NULL);
+	if (IS_ERR(bus_clk)) {
+		bus_hz = I2C_CLK;
+	} else {
+		bus_hz = clk_get_rate(bus_clk);
+	}
+	printk("i2c bus %dHz\n", bus_hz);
+
+	if (device_property_read_u32(&(pdev->dev), "clock-frequency", &freq)) {
+		freq = I2C_SPEED;
+	} else {
+		printk("get freq=%d\n", freq);
+	}
+
+	dw_i2c_init(dev->base, bus_hz, freq, pdev->id);
+	dw_i2c_initLock(pdev->id);
+	dw_i2c_initCmdBuf(pdev->id);
+	dw_i2c_SetGroupSendStatus(pdev->id, STATUS_IDLE );
+	adap = &dev->adapter;
+	i2c_set_adapdata(adap, dev);
+	adap->owner   = THIS_MODULE;
+	adap->algo    = &dw_i2c_algorithm;
+	adap->class   = I2C_CLASS_HWMON | I2C_CLASS_SPD;
+	adap->dev.of_node = pdev->dev.of_node;
+	strlcpy(adap->name, "Synopsys DesignWare I2C adapter", sizeof(adap->name));
+	adap->dev.parent = &pdev->dev;
+	adap->nr = pdev->id;
+	ret = i2c_add_numbered_adapter(adap);
+	if (ret < 0)
+	{
+		dev_err(&pdev->dev, "failed to add bus to i2c core\n");
+		goto err_free_irq;
+	}
+
+	return 0;
+
+err_free_irq:
+	free_irq(dev->irq, dev);
+	dw_i2c_uninit(dev->base, pdev->id);
+
+err_iounmap:
+	iounmap(dev->base);
+err_free_mem:
+	platform_set_drvdata(pdev, NULL);
+	kfree(dev);
+
+err_release_region:
+	release_mem_region(mem->start, resource_size(mem));
+
+	return ret;
+
+}
+
+static int   dw_i2c_remove(struct platform_device *pdev)
+{
+	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
+	struct resource *mem;
+	dw_i2c_uninit(dev->base, pdev->id);
+	platform_set_drvdata(pdev, NULL);
+	i2c_del_adapter(&dev->adapter);
+
+	free_irq(dev->irq, dev);
+	iounmap(dev->base);
+	kfree(dev);
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(mem->start, resource_size(mem));
+
+	return 0;
+}
+
+static const struct of_device_id dh_i2c_of_match[] = {
+	{ .compatible = "snps,designware-i2c-ice"},
+};
+MODULE_DEVICE_TABLE(of, dh_i2c_of_match);
+
+
+static struct platform_driver dw_i2c_driver = {
+	.probe  = dw_i2c_probe,
+	.remove = dw_i2c_remove,
+	.driver = {
+		.name   = "dw_i2c",
+		.of_match_table  = dh_i2c_of_match,
+	},
+};
+
+static int __init dw_i2c_bus_ice_init(void)
+{
+	int s32Ret;
+
+	s32Ret = platform_driver_register(&dw_i2c_driver);
+	if(s32Ret < 0)
+	{
+		return s32Ret;
+	}
+
+	return 0;
+}
+
+static void __exit dw_i2c_bus_ice_exit(void)
+{
+	platform_driver_unregister(&dw_i2c_driver);
+}
+
+module_init(dw_i2c_bus_ice_init);
+module_exit(dw_i2c_bus_ice_exit);
diff --git a/drivers/i2c/busses/i2c-designware-master.c b/drivers/i2c/busses/i2c-designware-master.c
index 106080b25e81..6bff988f91ea 100644
--- a/drivers/i2c/busses/i2c-designware-master.c
+++ b/drivers/i2c/busses/i2c-designware-master.c
@@ -206,6 +206,8 @@ static int i2c_dw_init_master(struct dw_i2c_dev *dev)
 	}
 
 	/* Write SDA hold time if supported */
+	dev->sda_hold_time = 0x1E;
+
 	if (dev->sda_hold_time)
 		regmap_write(dev->map, DW_IC_SDA_HOLD, dev->sda_hold_time);
 
@@ -331,9 +333,12 @@ i2c_dw_xfer_msg(struct dw_i2c_dev *dev)
 			 * be adjusted when receiving the first byte.
 			 * Thus we can't stop the transaction here.
 			 */
-			if (dev->msg_write_idx == dev->msgs_num - 1 &&
-			    buf_len == 1 && !(flags & I2C_M_RECV_LEN))
+			if (((dev->msg_write_idx == dev->msgs_num - 1) || (flags & I2C_M_WRSTOP)) &&
+			    buf_len == 1 && !(flags & I2C_M_RECV_LEN)) {
 				cmd |= BIT(9);
+				if (flags & I2C_M_WRSTOP)
+					dev->use_interstop = 1;
+			}
 
 			if (need_restart) {
 				cmd |= BIT(10);
@@ -519,7 +524,10 @@ i2c_dw_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
 	 * additional interrupts are a hardware bug or this driver doesn't
 	 * handle them correctly yet.
 	 */
-	__i2c_dw_disable_nowait(dev);
+	if (!dev->use_interstop)
+		__i2c_dw_disable_nowait(dev);
+
+	dev->use_interstop = 0;
 
 	if (dev->msg_err) {
 		ret = dev->msg_err;
diff --git a/drivers/i2c/i2c-dev.c b/drivers/i2c/i2c-dev.c
index dafad891998e..b6a908ed488f 100644
--- a/drivers/i2c/i2c-dev.c
+++ b/drivers/i2c/i2c-dev.c
@@ -29,6 +29,14 @@
 #include <linux/slab.h>
 #include <linux/uaccess.h>
 
+#if defined(CONFIG_ARCH_CVITEK)
+#define I2C0 "i2c@04000000"
+#define I2C1 "i2c@04010000"
+#define I2C2 "i2c@04020000"
+#define I2C3 "i2c@04030000"
+#define I2C4 "i2c@04040000"
+#endif
+
 /*
  * An i2c_dev represents an i2c_adapter ... an I2C or SMBus master, not a
  * slave (i2c_client) with which messages will be exchanged.  It's coupled
@@ -669,7 +677,24 @@ static int i2cdev_attach_adapter(struct device *dev, void *dummy)
 	i2c_dev->dev.class = i2c_dev_class;
 	i2c_dev->dev.parent = &adap->dev;
 	i2c_dev->dev.release = i2cdev_dev_release;
+
+#if defined(CONFIG_ARCH_CVITEK)
+	if (!strcmp(adap->dev.of_node->full_name, I2C0))
+		adap->i2c_idx = 0;
+	if (!strcmp(adap->dev.of_node->full_name, I2C1))
+		adap->i2c_idx = 1;
+	if (!strcmp(adap->dev.of_node->full_name, I2C2))
+		adap->i2c_idx = 2;
+	if (!strcmp(adap->dev.of_node->full_name, I2C3))
+		adap->i2c_idx = 3;
+	if (!strcmp(adap->dev.of_node->full_name, I2C4))
+		adap->i2c_idx = 4;
+
+	dev_set_name(&i2c_dev->dev, "i2c-%d", adap->i2c_idx);
+#else
 	dev_set_name(&i2c_dev->dev, "i2c-%d", adap->nr);
+#endif
+
 
 	res = cdev_device_add(&i2c_dev->cdev, &i2c_dev->dev);
 	if (res) {
diff --git a/drivers/irqchip/irq-sifive-plic.c b/drivers/irqchip/irq-sifive-plic.c
index bd99ee0ae433..ba75f6d6f7cc 100644
--- a/drivers/irqchip/irq-sifive-plic.c
+++ b/drivers/irqchip/irq-sifive-plic.c
@@ -173,7 +173,7 @@ static void plic_irq_eoi(struct irq_data *d)
 }
 
 static struct irq_chip plic_chip = {
-	.name		= "SiFive PLIC",
+	.name		= "T-Head PLIC",
 	.irq_mask	= plic_irq_mask,
 	.irq_unmask	= plic_irq_unmask,
 	.irq_eoi	= plic_irq_eoi,
diff --git a/drivers/media/platform/Kconfig b/drivers/media/platform/Kconfig
index 7e152bbb4fa6..3a5efd89f45f 100644
--- a/drivers/media/platform/Kconfig
+++ b/drivers/media/platform/Kconfig
@@ -535,6 +535,8 @@ config VIDEO_SUN8I_ROTATE
 	   Support for the Allwinner DE2 rotation unit.
 	   To compile this driver as a module choose m here.
 
+source "drivers/media/platform/cvitek/Kconfig"
+
 endif # V4L_MEM2MEM_DRIVERS
 
 # TI VIDEO PORT Helper Modules
diff --git a/drivers/media/platform/cvitek/Kconfig b/drivers/media/platform/cvitek/Kconfig
new file mode 100644
index 000000000000..1529de6f82b6
--- /dev/null
+++ b/drivers/media/platform/cvitek/Kconfig
@@ -0,0 +1,19 @@
+config VIDEO_CVITEK_CIF
+	tristate "CVITEK CIF driver"
+	depends on HAS_DMA
+	default y
+	help
+	  This is a V4L2 driver for the CVITEK camera interface.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called mipi_rx.
+
+config VIDEO_CVITEK_SNS_I2C
+	tristate "CVITEK Sensor I2C driver"
+	depends on HAS_DMA
+	default y
+	help
+	This is a V4L2 driver for the CVITEK Sensor I2C Wrapper.
+
+	To compile this driver as a module, choose M here: the
+	module will be called sensor_i2c.
\ No newline at end of file
diff --git a/drivers/mmc/core/card.h b/drivers/mmc/core/card.h
index 5c6986131faf..125c56747820 100644
--- a/drivers/mmc/core/card.h
+++ b/drivers/mmc/core/card.h
@@ -213,6 +213,11 @@ static inline int mmc_card_long_read_time(const struct mmc_card *c)
 	return c->quirks & MMC_QUIRK_LONG_READ_TIME;
 }
 
+static inline int mmc_card_extra_long_read_time(const struct mmc_card *c)
+{
+	return c->quirks & MMC_QUIRK_EXTRA_LONG_READ_TIME;
+}
+
 static inline int mmc_card_broken_irq_polling(const struct mmc_card *c)
 {
 	return c->quirks & MMC_QUIRK_BROKEN_IRQ_POLLING;
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 8f2465394253..07830fc28b1c 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -244,6 +244,16 @@ static void __mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 		}
 	}
 
+	/*
+	 * Block all CMD except for CMD0 once CARD ever unplugged
+	 */
+	if (host->ever_unplugged && mrq->cmd->opcode != 0) {
+		mrq->cmd->error = -EBUSY;
+		mmc_complete_cmd(mrq);
+		complete(&mrq->completion);
+		return;
+	}
+
 	if (mrq->cap_cmd_during_tfr) {
 		host->ongoing_mrq = mrq;
 		/*
@@ -343,6 +353,16 @@ int mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 	if (mmc_card_removed(host->card))
 		return -ENOMEDIUM;
 
+	/*
+	 * Block all CMD except for CMD0 once CARD ever unplugged
+	 */
+	if (host->ever_unplugged) {
+		if (mrq->cmd->opcode == 0)
+			host->ever_unplugged = false;
+		else
+			return -ENOMEDIUM;
+	}
+
 	mmc_mrq_pr_debug(host, mrq, false);
 
 	WARN_ON(!host->claimed);
@@ -721,6 +741,16 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 		data->timeout_clks = 0;
 	}
 
+	/*
+	 * For Micron eMMC (MTFC4GACAJCN 8GB), when boot after power loss,
+	 * it might take very long time (longer than 500ms). Per Micron's
+	 * suggestion to extend the read data timeout velue.
+	 */
+	if (mmc_card_extra_long_read_time(card) && data->flags & MMC_DATA_READ) {
+		data->timeout_ns = 0x7fffffff;
+		data->timeout_clks = 0;
+	}
+
 	/*
 	 * Some cards need very high timeouts if driven in SPI mode.
 	 * The worst observed timeout was 900ms after writing a
@@ -2103,9 +2133,11 @@ int mmc_hw_reset(struct mmc_host *host)
 	ret = host->bus_ops->hw_reset(host);
 	mmc_bus_put(host);
 
-	if (ret < 0)
-		pr_warn("%s: tried to HW reset card, got error %d\n",
+	if (ret < 0) {
+		host->ever_unplugged = true;
+		pr_err("%s: tried to HW reset card, got error %d\n",
 			mmc_hostname(host), ret);
+	}
 
 	return ret;
 }
diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
index 1f46694b2e53..c0796b1aeba0 100644
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -253,6 +253,9 @@ int mmc_of_parse(struct mmc_host *host)
 	/* f_max is obtained from the optional "max-frequency" property */
 	device_property_read_u32(dev, "max-frequency", &host->f_max);
 
+	/* f_src is obtained from the optional "src-frequency" property */
+	device_property_read_u32(dev, "src-frequency", &host->f_src);
+
 	/*
 	 * Configure CD and WP pins. They are both by default active low to
 	 * match the SDHCI spec. If GPIOs are provided for CD and / or WP, the
diff --git a/drivers/mmc/core/quirks.h b/drivers/mmc/core/quirks.h
index afe8d8c5fa8a..67af41a86f3b 100644
--- a/drivers/mmc/core/quirks.h
+++ b/drivers/mmc/core/quirks.h
@@ -65,6 +65,8 @@ static const struct mmc_fixup __maybe_unused mmc_blk_fixups[] = {
 	 */
 	MMC_FIXUP(CID_NAME_ANY, CID_MANFID_MICRON, 0x200, add_quirk_mmc,
 		  MMC_QUIRK_LONG_READ_TIME),
+	MMC_FIXUP("Q2J55L", CID_MANFID_MICRON, 0x14e, add_quirk_mmc,
+		  MMC_QUIRK_EXTRA_LONG_READ_TIME),
 	MMC_FIXUP("008GE0", CID_MANFID_TOSHIBA, CID_OEMID_ANY, add_quirk_mmc,
 		  MMC_QUIRK_LONG_READ_TIME),
 
diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index 85c2947ed45e..253134b43e4a 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -1314,3 +1314,42 @@ int mmc_attach_sdio(struct mmc_host *host)
 	return err;
 }
 
+int sdio_reset_comm(struct mmc_card *card)
+{
+	struct mmc_host *host = card->host;
+	u32 ocr;
+	u32 rocr;
+	int err;
+
+	mmc_claim_host(host);
+	mmc_retune_disable(host);
+	mmc_go_idle(host);
+	mmc_set_clock(host, host->f_min);
+	err = mmc_send_io_op_cond(host, 0, &ocr);
+
+	if (err)
+		goto err;
+
+	rocr = mmc_select_voltage(host, ocr);
+
+	if (!rocr) {
+		err = -EINVAL;
+		goto err;
+	}
+
+	err = mmc_sdio_init_card(host, rocr, card);
+
+	if (err)
+		goto err;
+
+	mmc_release_host(host);
+	return 0;
+
+err:
+	pr_err("%s: Error resetting SDIO communications (%d)\n",
+		mmc_hostname(host), err);
+	mmc_release_host(host);
+	return err;
+}
+EXPORT_SYMBOL(sdio_reset_comm);
+
diff --git a/drivers/mmc/core/slot-gpio.c b/drivers/mmc/core/slot-gpio.c
index 05e907451df9..43f631a822eb 100644
--- a/drivers/mmc/core/slot-gpio.c
+++ b/drivers/mmc/core/slot-gpio.c
@@ -16,15 +16,6 @@
 
 #include "slot-gpio.h"
 
-struct mmc_gpio {
-	struct gpio_desc *ro_gpio;
-	struct gpio_desc *cd_gpio;
-	irqreturn_t (*cd_gpio_isr)(int irq, void *dev_id);
-	char *ro_label;
-	char *cd_label;
-	u32 cd_debounce_delay_ms;
-};
-
 static irqreturn_t mmc_gpio_cd_irqt(int irq, void *dev_id)
 {
 	/* Schedule a card detection after a debounce timeout */
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index a5b2bf0e40cc..b4bb0e099c98 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -213,6 +213,17 @@ config MMC_SDHCI_OF_DWCMSHC
 	  If you have a controller with this interface, say Y or M here.
 	  If unsure, say N.
 
+config MMC_SDHCI_OF_LIGHT_MPW
+	tristate "SDHCI OF support for the Synopsys DWC MSHC of Light MPW"
+	depends on MMC_SDHCI_PLTFM
+	depends on OF
+	depends on COMMON_CLK
+	help
+	  This selects Synopsys DesignWare Cores Mobile Storage Controller
+	  support.
+	  If you have a controller with this interface, say Y or M here.
+	  If unsure, say N.
+
 config MMC_SDHCI_OF_SPARX5
 	tristate "SDHCI OF support for the MCHP Sparx5 SoC"
 	depends on MMC_SDHCI_PLTFM
@@ -554,6 +565,18 @@ config MMC_SDHCI_MSM
 
 	  If unsure, say N.
 
+config MMC_SDHCI_CVI
+    tristate "CVITEK SDHCI Controller Support"
+    depends on MMC_SDHCI_PLTFM
+    help
+      This selects the Secure Digital Host Controller Interface (SDHCI)
+      support present in Cvitek SOCs. The controller supports
+      SD/MMC/SDIO devices.
+
+      If you have a controller with this interface, say Y or M here.
+
+      If unsure, say N.
+
 config MMC_MXC
 	tristate "Freescale i.MX21/27/31 or MPC512x Multimedia Card support"
 	depends on ARCH_MXC || PPC_MPC512x
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index 451c25fc2c69..88815b0a2ff1 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -94,6 +94,7 @@ obj-$(CONFIG_MMC_SDHCI_OF_AT91)		+= sdhci-of-at91.o
 obj-$(CONFIG_MMC_SDHCI_OF_ESDHC)	+= sdhci-of-esdhc.o
 obj-$(CONFIG_MMC_SDHCI_OF_HLWD)		+= sdhci-of-hlwd.o
 obj-$(CONFIG_MMC_SDHCI_OF_DWCMSHC)	+= sdhci-of-dwcmshc.o
+obj-$(CONFIG_MMC_SDHCI_OF_LIGHT_MPW)	+= sdhci-of-light-mpw.o
 obj-$(CONFIG_MMC_SDHCI_OF_SPARX5)	+= sdhci-of-sparx5.o
 obj-$(CONFIG_MMC_SDHCI_BCM_KONA)	+= sdhci-bcm-kona.o
 obj-$(CONFIG_MMC_SDHCI_IPROC)		+= sdhci-iproc.o
@@ -104,6 +105,7 @@ obj-$(CONFIG_MMC_SDHCI_BRCMSTB)		+= sdhci-brcmstb.o
 obj-$(CONFIG_MMC_SDHCI_OMAP)		+= sdhci-omap.o
 obj-$(CONFIG_MMC_SDHCI_SPRD)		+= sdhci-sprd.o
 obj-$(CONFIG_MMC_CQHCI)			+= cqhci.o
+obj-$(CONFIG_MMC_SDHCI_CVI)		+= cvitek/
 obj-$(CONFIG_MMC_HSQ)			+= mmc_hsq.o
 
 ifeq ($(CONFIG_CB710_DEBUG),y)
diff --git a/drivers/mmc/host/cvitek/Makefile b/drivers/mmc/host/cvitek/Makefile
new file mode 100644
index 000000000000..ef2f8f8ef990
--- /dev/null
+++ b/drivers/mmc/host/cvitek/Makefile
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for Cvitek MMC/SD host controller drivers
+#
+
+obj-$(CONFIG_MMC_SDHCI_CVI)		+= sdhci-cvi.o
+sdhci-cvi-$(CONFIG_ARCH_CV183X)		+= sdhci-cv183x.o
+sdhci-cvi-$(CONFIG_ARCH_CV182X)		+= sdhci-cv182x.o
+sdhci-cvi-$(CONFIG_ARCH_CV181X)		+= sdhci-cv181x.o
+sdhci-cvi-$(CONFIG_ARCH_CV180X)		+= sdhci-cv180x.o
diff --git a/drivers/mmc/host/cvitek/sdhci-cv180x.c b/drivers/mmc/host/cvitek/sdhci-cv180x.c
new file mode 100644
index 000000000000..ed81eb3c4264
--- /dev/null
+++ b/drivers/mmc/host/cvitek/sdhci-cv180x.c
@@ -0,0 +1,1422 @@
+/*
+ * drivers/mmc/host/sdhci-cv.c - CVITEK SDHCI Platform driver
+ *
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/slab.h>
+#include <linux/reset.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/device.h>
+#include <linux/export.h>
+#include <linux/io.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/of_gpio.h>
+#include <linux/mmc/slot-gpio.h>
+#include <linux/ktime.h>
+
+#include "../../core/card.h"
+#include "../sdhci-pltfm.h"
+#include "sdhci-cv180x.h"
+
+#define DRIVER_NAME "cvi"
+#define SDHCI_DUMP(f, x...) \
+	pr_err("%s: " DRIVER_NAME ": " f, mmc_hostname(host->mmc), ## x)
+
+#define MAX_CARD_TYPE 4
+#define MAX_SPEED_MODE 5
+
+#define CVI_PARENT "cvi"
+#define CVI_STATS_PROC "cvi_info"
+#define MAX_CLOCK_SCALE (4)
+
+#define UNSTUFF_BITS(resp, start, size)                 \
+	({                                                      \
+	const int __size = size;                                \
+	const u32 __mask = (__size < 32 ? 1 << __size : 0) - 1; \
+	const int __off = 3 - ((start) / 32);                   \
+	const int __shft = (start) & 31;                        \
+	u32 __res;                                              \
+	__res = resp[__off] >> __shft;                          \
+	if (__size + __shft > 32)                               \
+		__res |= resp[__off - 1] << ((32 - __shft) % 32);   \
+	__res & __mask;                                         \
+	})
+
+static struct proc_dir_entry *proc_cvi_dir;
+
+static char *card_type[MAX_CARD_TYPE + 1] = {
+	"MMC card", "SD card", "SDIO card", "SD combo (IO+mem) card", "unknown"
+};
+
+static char *cvi_get_card_type(unsigned int sd_type)
+{
+	if (sd_type >= MAX_CARD_TYPE)
+		return card_type[MAX_CARD_TYPE];
+	else
+		return card_type[sd_type];
+}
+
+static inline int is_card_uhs(unsigned char timing)
+{
+	return timing >= MMC_TIMING_UHS_SDR12 && timing <= MMC_TIMING_UHS_DDR50;
+};
+
+static inline int is_card_hs(unsigned char timing)
+{
+	return timing == MMC_TIMING_SD_HS || timing == MMC_TIMING_MMC_HS;
+};
+
+static void cvi_stats_seq_printout(struct seq_file *s)
+{
+	const char *type = NULL;
+	unsigned int present;
+	unsigned char timing;
+	struct sdhci_cvi_host *cvi_host = NULL;
+	struct mmc_host *mmc = NULL;
+	struct mmc_card *card = NULL;
+	const char *uhs_bus_speed_mode = "";
+	u32 speed_class, grade_speed_uhs;
+	static const char *const uhs_speeds[] = {
+		[UHS_SDR12_BUS_SPEED] = "SDR12 ", [UHS_SDR25_BUS_SPEED] = "SDR25 ",
+		[UHS_SDR50_BUS_SPEED] = "SDR50 ", [UHS_SDR104_BUS_SPEED] = "SDR104 ",
+		[UHS_DDR50_BUS_SPEED] = "DDR50 ",
+	};
+	cvi_host = (struct sdhci_cvi_host *)s->private;
+
+	if (!cvi_host || !cvi_host->mmc) {
+		seq_printf(s, "cvi s : %p: s->private %p\n", s, s->private);
+		return;
+	}
+
+	seq_printf(s, "cvi.%d", cvi_host->mmc->index);
+
+	mmc = cvi_host->mmc;
+	present = mmc->ops->get_cd(mmc);
+
+	if (present) {
+		seq_puts(s, ": plugged");
+	} else {
+		seq_puts(s, ": unplugged");
+	}
+
+	card = mmc->card;
+
+	if (!card) {
+		seq_puts(s, "_disconnected\n");
+	} else {
+		seq_puts(s, "_connected\n");
+		seq_printf(s, "\tType: %s", cvi_get_card_type(card->type));
+
+		//if (card->state & MMC_STATE_BLOCKADDR) {
+		if (mmc_card_blockaddr(card)) {
+			if (card->state & MMC_CARD_SDXC)
+				type = "SDXC";
+			else
+				type = "SDHC";
+			seq_printf(s, "(%s)\n", type);
+		}
+
+		timing = mmc->ios.timing;
+
+		if (is_card_uhs(mmc->ios.timing) &&
+		    card->sd_bus_speed < ARRAY_SIZE(uhs_speeds))
+			uhs_bus_speed_mode = uhs_speeds[card->sd_bus_speed];
+
+		seq_printf(s, "\tMode: %s%s%s%s\n",
+			   is_card_uhs(timing) ? "UHS "
+			   : (is_card_hs(timing) ? "HS " : ""),
+			   timing == MMC_TIMING_MMC_HS400
+			   ? "HS400 "
+			   : (timing == MMC_TIMING_MMC_HS200 ? "HS200 " : ""),
+			   timing == MMC_TIMING_MMC_DDR52 ? "DDR " : "",
+			   uhs_bus_speed_mode);
+
+		speed_class = UNSTUFF_BITS(card->raw_ssr, 440 - 384, 8);
+		grade_speed_uhs = UNSTUFF_BITS(card->raw_ssr, 396 - 384, 4);
+		seq_printf(s, "\tSpeed Class: Class %s\n",
+			   (speed_class == 0x00)
+			   ? "0"
+			   : (speed_class == 0x01)
+			   ? "2"
+			   : (speed_class == 0x02)
+			   ? "4"
+			   : (speed_class == 0x03)
+			   ? "6"
+			   : (speed_class == 0x04)
+			   ? "10"
+			   : "Reserved");
+		seq_printf(s, "\tUhs Speed Grade: %s\n",
+			   (grade_speed_uhs == 0x00)
+			   ? "Less than 10MB/sec(0h)"
+			   : (grade_speed_uhs == 0x01)
+			   ? "10MB/sec and above(1h)"
+			   : "Reserved");
+	}
+}
+
+/* proc interface setup */
+static void *cvi_seq_start(struct seq_file *s, loff_t *pos)
+{
+	/*   counter is used to tracking multi proc interfaces
+	 *  We have only one interface so return zero
+	 *  pointer to start the sequence.
+	 */
+	static unsigned long counter;
+
+	if (*pos == 0) {
+		return &counter;
+	}
+
+	*pos = 0;
+	return NULL;
+}
+
+/* define parameters where showed in proc file */
+static int cvi_stats_seq_show(struct seq_file *s, void *v)
+{
+	cvi_stats_seq_printout(s);
+	return 0;
+}
+
+/* proc interface stop */
+static void cvi_seq_stop(struct seq_file *s, void *v) {}
+
+/* proc interface operation */
+static const struct seq_operations cvi_stats_seq_ops = {
+	.start = cvi_seq_start,
+	.stop = cvi_seq_stop,
+	.show = cvi_stats_seq_show
+};
+
+/* proc file open*/
+static int cvi_stats_proc_open(struct inode *inode, struct file *file)
+{
+//	return seq_open(file, &cvi_stats_seq_ops);
+	return single_open(file, cvi_stats_seq_show, PDE_DATA(inode));
+};
+
+/* proc file operation */
+static const struct proc_ops cvi_stats_proc_ops = {
+	.proc_open = cvi_stats_proc_open,
+	.proc_read = seq_read,
+	.proc_release = single_release,
+};
+
+int cvi_proc_init(struct sdhci_cvi_host *cvi_host)
+{
+	struct proc_dir_entry *proc_stats_entry;
+
+	pr_info("%s cvi_host 0x%p\n", __func__, cvi_host);
+
+	proc_cvi_dir = proc_mkdir(CVI_PARENT, NULL);
+
+	if (!proc_cvi_dir) {
+		pr_err("%s: failed to create proc file %s\n", __func__, CVI_PARENT);
+		return 1;
+	}
+
+	proc_stats_entry = proc_create_data(CVI_STATS_PROC, 0400, proc_cvi_dir, &cvi_stats_proc_ops,
+					    (void *)cvi_host);
+
+	if (!proc_stats_entry) {
+		pr_err("%s: failed to create proc file %s\n", __func__, CVI_STATS_PROC);
+		return 1;
+	}
+
+	return 0;
+}
+
+int cvi_proc_shutdown(struct sdhci_cvi_host *cvi_host)
+{
+	pr_info("%s\n", __func__);
+
+	if (proc_cvi_dir) {
+		remove_proc_entry(CVI_STATS_PROC, proc_cvi_dir);
+		remove_proc_entry(CVI_PARENT, NULL);
+		proc_cvi_dir = NULL;
+	}
+
+	return 0;
+}
+
+static void sdhci_cv180x_emmc_setup_pad(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	/* Name              Offset
+	 * PAD_EMMC_RSTN     0x48
+	 * PAD_EMMC_CLK      0x50
+	 * PAD_EMMC_CMD      0x5C
+	 * PAD_EMMC_DAT0     0x54
+	 * PAD_EMMC_DAT1     0x60
+	 * PAD_EMMC_DAT2     0x4C
+	 * PAD_EMMC_DAT3     0x58
+
+	 */
+
+	u8 val = 0x0;
+
+	writeb(val, cvi_host->pinmuxbase + 0x48);
+	writeb(val, cvi_host->pinmuxbase + 0x50);
+	writeb(val, cvi_host->pinmuxbase + 0x5C);
+	writeb(val, cvi_host->pinmuxbase + 0x54);
+	writeb(val, cvi_host->pinmuxbase + 0x60);
+	writeb(val, cvi_host->pinmuxbase + 0x4C);
+	writeb(val, cvi_host->pinmuxbase + 0x58);
+}
+
+static void sdhci_cv180x_sd_setup_pad(struct sdhci_host *host, bool bunplug)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	/* Name              Offset unplug plug
+	 * PAD_SDIO0_CD      0x18   SDIO0  SDIO0
+	 * PAD_SDIO0_PWR_EN  0x1C   SDIO0  SDIO0
+	 * PAD_SDIO0_CLK     0x00   XGPIO  SDIO0
+	 * PAD_SDIO0_CMD     0x04   XGPIO  SDIO0
+	 * PAD_SDIO0_D0      0x08   XGPIO  SDIO0
+	 * PAD_SDIO0_D1      0x0C   XGPIO  SDIO0
+	 * PAD_SDIO0_D2      0x10   XGPIO  SDIO0
+	 * PAD_SDIO0_D3      0x14   XGPIO  SDIO0
+	 * 0x0: SDIO0 function
+	 * 0x3: XGPIO function
+	 */
+
+	u8 val = (bunplug) ? 0x3 : 0x0;
+
+	if (cvi_host->cvi_gpio && cvi_host->cvi_gpio->cd_gpio)
+		writeb(0x3, cvi_host->pinmuxbase + 0x18);
+	else
+		writeb(0x0, cvi_host->pinmuxbase + 0x18);
+
+	writeb(0x0, cvi_host->pinmuxbase + 0x1C);
+	writeb(val, cvi_host->pinmuxbase + 0x00);
+	writeb(val, cvi_host->pinmuxbase + 0x04);
+	writeb(val, cvi_host->pinmuxbase + 0x08);
+	writeb(val, cvi_host->pinmuxbase + 0x0C);
+	writeb(val, cvi_host->pinmuxbase + 0x10);
+	writeb(val, cvi_host->pinmuxbase + 0x14);
+}
+
+static void sdhci_cv180x_sd_setup_io(struct sdhci_host *host, bool reset)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	/*
+	 * Name              Offset reset sd0
+	 * REG_SDIO0_CD      0x900  PU    PU
+	 * REG_SDIO0_PWR_EN  0x904  PD    PD
+	 * REG_SDIO0_CLK     0xA00  PD    PD
+	 * REG_SDIO0_CMD     0xA04  PD    PU
+	 * REG_SDIO0_D0      0xA08  PD    PU
+	 * REG_SDIO0_D1      0xA0C  PD    PU
+	 * REG_SDIO0_D2      0xA10  PD    PU
+	 * REG_SDIO0_D3      0xA14  PD    PU
+	 * BIT(2) : PU   enable(1)/disable(0)
+	 * BIT(3) : PD   enable(1)/disable(0)
+	 */
+
+	u8 raise_bit = (reset) ?  BIT(3) : BIT(2);
+	u8 down_bit  = (reset) ?  BIT(2) : BIT(3);
+
+	writeb(((readb(cvi_host->pinmuxbase + 0x900) | BIT(2)) & ~(BIT(3))),
+		cvi_host->pinmuxbase + 0x900);
+	writeb(((readb(cvi_host->pinmuxbase + 0x904) | BIT(3)) & ~(BIT(2))),
+		cvi_host->pinmuxbase + 0x904);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA00) | BIT(3)) & ~(BIT(2))),
+		cvi_host->pinmuxbase + 0xA00);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA04) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA04);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA08) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA08);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA0C) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA0C);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA10) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA10);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA14) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA14);
+}
+
+static void sdhci_cvi_reset_helper(struct sdhci_host *host, u8 mask)
+{
+	// disable Intr before reset
+	sdhci_writel(host, 0, SDHCI_INT_ENABLE);
+	sdhci_writel(host, 0, SDHCI_SIGNAL_ENABLE);
+
+	sdhci_reset(host, mask);
+
+	sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
+	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
+}
+
+static void reset_after_tuning_pass(struct sdhci_host *host)
+{
+	pr_debug("tuning pass\n");
+
+	/* Clear BUF_RD_READY intr */
+	sdhci_writew(host, sdhci_readw(host, SDHCI_INT_STATUS) & (~(0x1 << 5)),
+		     SDHCI_INT_STATUS);
+
+	/* Set SDHCI_SOFTWARE_RESET.SW_RST_DAT = 1 to clear buffered tuning block */
+	sdhci_writeb(host, sdhci_readb(host, SDHCI_SOFTWARE_RESET) | (0x1 << 2), SDHCI_SOFTWARE_RESET);
+
+	/* Set SDHCI_SOFTWARE_RESET.SW_RST_CMD = 1	*/
+	sdhci_writeb(host, sdhci_readb(host, SDHCI_SOFTWARE_RESET) | (0x1 << 1), SDHCI_SOFTWARE_RESET);
+
+	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & 0x3)
+		;
+}
+
+static inline uint32_t CHECK_MASK_BIT(void *_mask, uint32_t bit)
+{
+	uint32_t w = bit / 8;
+	uint32_t off = bit % 8;
+
+	return ((uint8_t *)_mask)[w] & (1 << off);
+}
+
+static inline void SET_MASK_BIT(void *_mask, uint32_t bit)
+{
+	uint32_t byte = bit / 8;
+	uint32_t offset = bit % 8;
+	((uint8_t *)_mask)[byte] |= (1 << offset);
+}
+
+static int sdhci_cv180x_general_select_drive_strength(struct sdhci_host *host,
+		struct mmc_card *card, unsigned int max_dtr, int host_drv,
+		int card_drv, int *drv_type)
+{
+	return MMC_SET_DRIVER_TYPE_A;
+}
+
+static void sdhci_cvi_general_set_uhs_signaling(struct sdhci_host *host, unsigned int uhs)
+{
+	struct mmc_host *mmc = host->mmc;
+	u16 ctrl_2;
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	/* Select Bus Speed Mode for host */
+	ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
+	switch (uhs) {
+	case MMC_TIMING_UHS_SDR12:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR12;
+		break;
+	case MMC_TIMING_UHS_SDR25:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR25;
+		break;
+	case MMC_TIMING_UHS_SDR50:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR50;
+		break;
+	case MMC_TIMING_MMC_HS200:
+	case MMC_TIMING_UHS_SDR104:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR104;
+		break;
+	case MMC_TIMING_UHS_DDR50:
+	case MMC_TIMING_MMC_DDR52:
+		ctrl_2 |= SDHCI_CTRL_UHS_DDR50;
+		break;
+	}
+
+	/*
+	 * When clock frequency is less than 100MHz, the feedback clock must be
+	 * provided and DLL must not be used so that tuning can be skipped. To
+	 * provide feedback clock, the mode selection can be any value less
+	 * than 3'b011 in bits [2:0] of HOST CONTROL2 register.
+	 */
+	if (host->clock <= 100000000 &&
+	    (uhs == MMC_TIMING_MMC_HS400 ||
+	     uhs == MMC_TIMING_MMC_HS200 ||
+	     uhs == MMC_TIMING_UHS_SDR104))
+		ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
+
+	dev_dbg(mmc_dev(mmc), "%s: clock=%u uhs=%u ctrl_2=0x%x\n",
+		mmc_hostname(host->mmc), host->clock, uhs, ctrl_2);
+	sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
+}
+
+static unsigned int sdhci_cvi_general_get_max_clock(struct sdhci_host *host)
+{
+	pr_debug(DRIVER_NAME ":%s : %d\n", __func__, host->mmc->f_src);
+	return host->mmc->f_src;
+}
+
+/* Used for wifi driver due if no SD card detect pin implemented */
+static struct mmc_host *wifi_mmc;
+
+int cvi_sdio_rescan(void)
+{
+
+	if (!wifi_mmc) {
+		pr_err("invalid wifi mmc, please check the argument\n");
+		return -EINVAL;
+	}
+
+	mmc_detect_change(wifi_mmc, 0);
+
+	wifi_mmc->rescan_entered = 0;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(cvi_sdio_rescan);
+
+
+void sdhci_cvi_emmc_voltage_switch(struct sdhci_host *host)
+{
+}
+
+static void sdhci_cvi_cv180x_set_tap(struct sdhci_host *host, unsigned int tap)
+{
+	pr_debug("%s %d\n", __func__, tap);
+	// Set sd_clk_en(0x2c[2]) to 0
+	sdhci_writew(host, sdhci_readw(host, SDHCI_CLOCK_CONTROL) & (~(0x1 << 2)), SDHCI_CLOCK_CONTROL);
+	sdhci_writel(host,
+		sdhci_readl(host, CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R) & (~(BIT(1))),
+		CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R);
+	sdhci_writel(host, BIT(8) | tap << 16,
+		     CVI_CV180X_SDHCI_PHY_TX_RX_DLY);
+	sdhci_writel(host, 0, CVI_CV180X_SDHCI_PHY_CONFIG);
+	// Set sd_clk_en(0x2c[2]) to 1
+	sdhci_writew(host, sdhci_readw(host, SDHCI_CLOCK_CONTROL) | (0x1 << 2), SDHCI_CLOCK_CONTROL);
+	mdelay(1);
+}
+
+static int sdhci_cv180x_general_execute_tuning(struct sdhci_host *host, u32 opcode)
+{
+	u16 min = 0;
+	u32 k = 0;
+	s32 ret;
+	u32 retry_cnt = 0;
+
+	u32 tuning_result[4] = {0, 0, 0, 0};
+	u32 rx_lead_lag_result[4] = {0, 0, 0, 0};
+	char tuning_graph[TUNE_MAX_PHCODE+1];
+	char rx_lead_lag_graph[TUNE_MAX_PHCODE+1];
+
+	u32 reg = 0;
+	u32 reg_rx_lead_lag = 0;
+	s32 max_lead_lag_idx = -1;
+	s32 max_window_idx = -1;
+	s32 cur_window_idx = -1;
+	u16 max_lead_lag_size = 0;
+	u16 max_window_size = 0;
+	u16 cur_window_size = 0;
+	s32 rx_lead_lag_phase = -1;
+	s32 final_tap = -1;
+	u32 rate = 0;
+
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	reg = sdhci_readw(host, SDHCI_ERR_INT_STATUS);
+	pr_debug("%s : SDHCI_ERR_INT_STATUS 0x%x\n", mmc_hostname(host->mmc),
+		 reg);
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("%s : host ctrl2 0x%x\n", mmc_hostname(host->mmc), reg);
+	/* Set Host_CTRL2_R.SAMPLE_CLK_SEL=0 */
+	sdhci_writew(host,
+			 sdhci_readw(host, SDHCI_HOST_CONTROL2) & (~(0x1 << 7)),
+			 SDHCI_HOST_CONTROL2);
+	sdhci_writew(host,
+			 sdhci_readw(host, SDHCI_HOST_CONTROL2) & (~(0x3 << 4)),
+			 SDHCI_HOST_CONTROL2);
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("%s : host ctrl2 0x%x\n", mmc_hostname(host->mmc), reg);
+
+	while (min < TUNE_MAX_PHCODE) {
+		retry_cnt = 0;
+		sdhci_cvi_cv180x_set_tap(host, min);
+		reg_rx_lead_lag = sdhci_readw(host, CVI_CV180X_SDHCI_PHY_DLY_STS) & BIT(1);
+
+retry_tuning:
+		ret = mmc_send_tuning(host->mmc, opcode, NULL);
+
+		if (!ret && retry_cnt < MAX_TUNING_CMD_RETRY_COUNT) {
+			retry_cnt++;
+			goto retry_tuning;
+		}
+
+		if (ret) {
+			SET_MASK_BIT(tuning_result, min);
+		}
+
+		if (reg_rx_lead_lag) {
+			SET_MASK_BIT(rx_lead_lag_result, min);
+		}
+
+		min++;
+	}
+
+	reset_after_tuning_pass(host);
+
+	pr_debug("tuning result:      0x%08x 0x%08x 0x%08x 0x%08x\n",
+		tuning_result[0], tuning_result[1], tuning_result[2], tuning_result[3]);
+	pr_debug("rx_lead_lag result: 0x%08x 0x%08x 0x%08x 0x%08x\n",
+		rx_lead_lag_result[0], rx_lead_lag_result[1], rx_lead_lag_result[2], rx_lead_lag_result[3]);
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(tuning_result, k) == 0)
+			tuning_graph[k] = '-';
+		else
+			tuning_graph[k] = 'x';
+		if (CHECK_MASK_BIT(rx_lead_lag_result, k) == 0)
+			rx_lead_lag_graph[k] = '0';
+		else
+			rx_lead_lag_graph[k] = '1';
+	}
+	tuning_graph[TUNE_MAX_PHCODE] = '\0';
+	rx_lead_lag_graph[TUNE_MAX_PHCODE] = '\0';
+
+	pr_debug("tuning graph:      %s\n", tuning_graph);
+	pr_debug("rx_lead_lag graph: %s\n", rx_lead_lag_graph);
+
+	// Find a final tap as median of maximum window
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(tuning_result, k) == 0) {
+			if (-1 == cur_window_idx) {
+				cur_window_idx = k;
+			}
+			cur_window_size++;
+
+			if (cur_window_size > max_window_size) {
+				max_window_size = cur_window_size;
+				max_window_idx = cur_window_idx;
+				if (max_window_size >= TAP_WINDOW_THLD)
+					final_tap = cur_window_idx + (max_window_size/2);
+			}
+		} else {
+			cur_window_idx = -1;
+			cur_window_size = 0;
+		}
+	}
+
+	cur_window_idx = -1;
+	cur_window_size = 0;
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(rx_lead_lag_result, k) == 0) {
+			//from 1 to 0 and window_size already computed.
+			if ((rx_lead_lag_phase == 1) && (cur_window_size > 0)) {
+				max_lead_lag_idx = cur_window_idx;
+				max_lead_lag_size = cur_window_size;
+				break;
+			}
+			if (cur_window_idx == -1) {
+				cur_window_idx = k;
+			}
+			cur_window_size++;
+			rx_lead_lag_phase = 0;
+		} else {
+			rx_lead_lag_phase = 1;
+			if ((cur_window_idx != -1) && (cur_window_size > 0)) {
+				cur_window_size++;
+				max_lead_lag_idx = cur_window_idx;
+				max_lead_lag_size = cur_window_size;
+			} else {
+				cur_window_size = 0;
+			}
+		}
+	}
+	rate = max_window_size * 100 / max_lead_lag_size;
+	pr_debug("MaxWindow[Idx, Width]:[%d,%u] Tuning Tap: %d\n", max_window_idx, max_window_size, final_tap);
+	pr_debug("RX_LeadLag[Idx, Width]:[%d,%u] rate = %d\n", max_lead_lag_idx, max_lead_lag_size, rate);
+
+	sdhci_cvi_cv180x_set_tap(host, final_tap);
+	cvi_host->final_tap = final_tap;
+	pr_debug("%s finished tuning, code:%d\n", __func__, final_tap);
+
+	return mmc_send_tuning(host->mmc, opcode, NULL);
+}
+
+static void sdhci_cv180x_emmc_reset(struct sdhci_host *host, u8 mask)
+{
+	u16 ctrl_2;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s mask = 0x%x\n", __func__, mask);
+	sdhci_cvi_reset_helper(host, mask);
+
+	//reg_0x200[0] = 1 for mmc
+	sdhci_writel(host,
+			 sdhci_readl(host, CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(0),
+			 CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R);
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctrl_2 &= SDHCI_CTRL_UHS_MASK;
+	if (ctrl_2 == SDHCI_CTRL_UHS_SDR104) {
+		//reg_0x200[1] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R) & ~(BIT(1)),
+			CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV180X_SDHCI_PHY_CONFIG) & ~(BIT(0)),
+			CVI_CV180X_SDHCI_PHY_CONFIG);
+		//reg_0x240[22:16] = tap reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host,
+			(BIT(8) | ((cvi_host->final_tap & 0x7F) << 16)),
+			CVI_CV180X_SDHCI_PHY_TX_RX_DLY);
+	} else {
+		//Reset as DS/HS setting.
+		//reg_0x200[1] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(1),
+			CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV180X_SDHCI_PHY_CONFIG) | BIT(0),
+			CVI_CV180X_SDHCI_PHY_CONFIG);
+		//reg_0x240[25:24] = 1 reg_0x240[22:16] = 0 reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host, 0x1000100, CVI_CV180X_SDHCI_PHY_TX_RX_DLY);
+	}
+}
+
+static void sdhci_cv180x_sd_reset(struct sdhci_host *host, u8 mask)
+{
+	u16 ctrl_2;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s mask = 0x%x\n", __func__, mask);
+	sdhci_cvi_reset_helper(host, mask);
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctrl_2 &= SDHCI_CTRL_UHS_MASK;
+	if (ctrl_2 == SDHCI_CTRL_UHS_SDR104) {
+		//reg_0x200[1] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R) & ~(BIT(1)),
+			CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV180X_SDHCI_PHY_CONFIG) & ~(BIT(0)),
+			CVI_CV180X_SDHCI_PHY_CONFIG);
+		//reg_0x240[22:16] = tap reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host,
+			(BIT(8) | ((cvi_host->final_tap & 0x7F) << 16)),
+			CVI_CV180X_SDHCI_PHY_TX_RX_DLY);
+	} else {
+		//Reset as DS/HS setting.
+		//reg_0x200[1] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(1),
+			CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV180X_SDHCI_PHY_CONFIG) | BIT(0),
+			CVI_CV180X_SDHCI_PHY_CONFIG);
+		//reg_0x240[25:24] = 1 reg_0x240[22:16] = 0 reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host, 0x1000100, CVI_CV180X_SDHCI_PHY_TX_RX_DLY);
+	}
+}
+
+static void sdhci_cv180x_sdio_reset(struct sdhci_host *host, u8 mask)
+{
+	u16 ctrl_2;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s mask = 0x%x\n", __func__, mask);
+	sdhci_cvi_reset_helper(host, mask);
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctrl_2 &= SDHCI_CTRL_UHS_MASK;
+	if (ctrl_2 == SDHCI_CTRL_UHS_SDR104) {
+		//reg_0x200[1] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R) & ~(BIT(1)),
+			CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x200[16] = 1 for sd1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(16),
+			CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV180X_SDHCI_PHY_CONFIG) & ~(BIT(0)),
+			CVI_CV180X_SDHCI_PHY_CONFIG);
+		//reg_0x240[22:16] = tap reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host,
+			(BIT(8) | ((cvi_host->final_tap & 0x7F) << 16)),
+			CVI_CV180X_SDHCI_PHY_TX_RX_DLY);
+	} else {
+		//Reset as DS/HS setting.
+		//reg_0x200[1] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(1),
+			CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x200[16] = 1 for sd1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(16),
+			CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV180X_SDHCI_PHY_CONFIG) | BIT(0),
+			CVI_CV180X_SDHCI_PHY_CONFIG);
+		//reg_0x240[25:24] = 1 reg_0x240[22:16] = 0 reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host, 0x1000100, CVI_CV180X_SDHCI_PHY_TX_RX_DLY);
+	}
+}
+
+void sdhci_cv180x_sd_voltage_switch(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s\n", __func__);
+
+	// enable SDIO0_CLK[7:5] to set CLK max strengh
+	writeb((readb(cvi_host->pinmuxbase + 0xA00) | BIT(7) | BIT(6) | BIT(5)),
+		cvi_host->pinmuxbase + 0xA00);
+
+	//Voltage switching flow (1.8v)
+	//reg_pwrsw_auto=1, reg_pwrsw_disc=0, pwrsw_vsel=1(1.8v), reg_en_pwrsw=1
+	writel(0xB | (readl(cvi_host->topbase + OFFSET_SD_PWRSW_CTRL) & 0xFFFFFFF0),
+		cvi_host->topbase + OFFSET_SD_PWRSW_CTRL);
+	pr_debug("sd PWRSW 0x%x\n", readl(cvi_host->topbase + OFFSET_SD_PWRSW_CTRL));
+	cvi_host->sdio0_voltage_1_8_v = 1;
+
+	mdelay(1);
+}
+
+void sdhci_cv180x_sd_voltage_restore(struct sdhci_host *host, bool bunplug)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s\n", __func__);
+
+	if (bunplug) {
+		//Voltage close flow
+		//(reg_pwrsw_auto=1, reg_pwrsw_disc=1, reg_pwrsw_vsel=1(1.8v), reg_en_pwrsw=0)
+		writel(0xE | (readl(cvi_host->topbase + OFFSET_SD_PWRSW_CTRL) & 0xFFFFFFF0),
+			cvi_host->topbase + OFFSET_SD_PWRSW_CTRL);
+		cvi_host->sdio0_voltage_1_8_v = 0;
+	} else {
+		if (!cvi_host->sdio0_voltage_1_8_v) {
+			//Voltage switching flow (3.3)
+			//(reg_pwrsw_auto=1, reg_pwrsw_disc=0, reg_pwrsw_vsel=0(3.0v), reg_en_pwrsw=1)
+			writel(0x9 | (readl(cvi_host->topbase + OFFSET_SD_PWRSW_CTRL) & 0xFFFFFFF0),
+				cvi_host->topbase + OFFSET_SD_PWRSW_CTRL);
+		}
+	}
+
+	//wait 1ms
+	mdelay(1);
+
+	// restore to DS/HS setting
+	sdhci_writel(host,
+		sdhci_readl(host, CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(1) | BIT(8) | BIT(9),
+		CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R);
+	sdhci_writel(host, 0x1000100, CVI_CV180X_SDHCI_PHY_TX_RX_DLY);
+	sdhci_writel(host, 1, CVI_CV180X_SDHCI_PHY_CONFIG);
+
+	mdelay(1);
+}
+
+static void sdhci_cv180x_sd_set_power(struct sdhci_host *host, unsigned char mode,
+				unsigned short vdd)
+{
+	struct mmc_host *mmc = host->mmc;
+
+	pr_debug("%s:mode %u, vdd %u\n", __func__, mode, vdd);
+
+	if (mode == MMC_POWER_ON && mmc->ops->get_cd(mmc)) {
+		sdhci_set_power_noreg(host, mode, vdd);
+		sdhci_cv180x_sd_voltage_restore(host, false);
+		sdhci_cv180x_sd_setup_pad(host, false);
+		sdhci_cv180x_sd_setup_io(host, false);
+		mdelay(5);
+	} else if (mode == MMC_POWER_OFF) {
+		sdhci_cv180x_sd_setup_pad(host, true);
+		sdhci_cv180x_sd_setup_io(host, true);
+		sdhci_cv180x_sd_voltage_restore(host, true);
+		sdhci_set_power_noreg(host, mode, vdd);
+		mdelay(30);
+	}
+}
+
+static void sdhci_cv180x_emmc_dump_vendor_regs(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+	u8 clk_source_select = 0;
+	u8 PAD_EMMC_RSTN = 0;
+	u8 PAD_EMMC_CLK  = 0;
+	u8 PAD_EMMC_CMD  = 0;
+	u8 PAD_EMMC_DAT0 = 0;
+	u8 PAD_EMMC_DAT1 = 0;
+	u8 PAD_EMMC_DAT2 = 0;
+	u8 PAD_EMMC_DAT3 = 0;
+	u8 REG_EMMC_RSTN = 0;
+	u8 REG_EMMC_CLK  = 0;
+	u8 REG_EMMC_CMD  = 0;
+	u8 REG_EMMC_DAT0 = 0;
+	u8 REG_EMMC_DAT1 = 0;
+	u8 REG_EMMC_DAT2 = 0;
+	u8 REG_EMMC_DAT3 = 0;
+
+	SDHCI_DUMP(": Reg_200:   0x%08x | Reg_240:  0x%08x\n",
+		   sdhci_readl(host, CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R),
+		   sdhci_readl(host, CVI_CV180X_SDHCI_PHY_TX_RX_DLY));
+	SDHCI_DUMP(": Reg_244:   0x%08x | Reg_248:  0x%08x\n",
+		   sdhci_readl(host, CVI_CV180X_SDHCI_PHY_DS_DLY),
+		   sdhci_readw(host, CVI_CV180X_SDHCI_PHY_DLY_STS));
+	SDHCI_DUMP(": Reg_24C:   0x%08x\n",
+		   sdhci_readl(host, CVI_CV180X_SDHCI_PHY_CONFIG));
+
+	PAD_EMMC_RSTN = readb(cvi_host->pinmuxbase + 0x48) & 0x07;
+	PAD_EMMC_CLK  = readb(cvi_host->pinmuxbase + 0x50) & 0x07;
+	PAD_EMMC_CMD  = readb(cvi_host->pinmuxbase + 0x5C) & 0x07;
+	PAD_EMMC_DAT0 = readb(cvi_host->pinmuxbase + 0x54) & 0x07;
+	PAD_EMMC_DAT1 = readb(cvi_host->pinmuxbase + 0x60) & 0x07;
+	PAD_EMMC_DAT2 = readb(cvi_host->pinmuxbase + 0x4C) & 0x07;
+	PAD_EMMC_DAT3 = readb(cvi_host->pinmuxbase + 0x58) & 0x07;
+	REG_EMMC_RSTN = readb(cvi_host->pinmuxbase + 0x914);
+	REG_EMMC_CLK  = readb(cvi_host->pinmuxbase + 0x91D);
+	REG_EMMC_CMD  = readb(cvi_host->pinmuxbase + 0x928);
+	REG_EMMC_DAT0 = readb(cvi_host->pinmuxbase + 0x920);
+	REG_EMMC_DAT1 = readb(cvi_host->pinmuxbase + 0x92D);
+	REG_EMMC_DAT2 = readb(cvi_host->pinmuxbase + 0x918);
+	REG_EMMC_DAT3 = readb(cvi_host->pinmuxbase + 0x924);
+
+	SDHCI_DUMP(": PAD_EMMC_RSTN:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_RSTN, (REG_EMMC_RSTN & 0x04)>>2, (REG_EMMC_RSTN & 0x08)>>3,
+		(REG_EMMC_RSTN & 0x80)>>7, (REG_EMMC_RSTN & 0x40)>>6, (REG_EMMC_RSTN & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_CLK:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_CLK, (REG_EMMC_CLK & 0x04)>>2, (REG_EMMC_CLK & 0x08)>>3,
+		(REG_EMMC_CLK & 0x80)>>7, (REG_EMMC_CLK & 0x40)>>6, (REG_EMMC_CLK & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_CMD:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_CMD, (REG_EMMC_CMD & 0x04)>>2, (REG_EMMC_CMD & 0x08)>>3,
+		(REG_EMMC_CMD & 0x80)>>7, (REG_EMMC_CMD & 0x40)>>6, (REG_EMMC_CMD & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_DAT0:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_DAT0, (REG_EMMC_DAT0 & 0x04)>>2, (REG_EMMC_DAT0 & 0x08)>>3,
+		(REG_EMMC_DAT0 & 0x80)>>7, (REG_EMMC_DAT0 & 0x40)>>6, (REG_EMMC_DAT0 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_DAT1:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_DAT1, (REG_EMMC_DAT1 & 0x04)>>2, (REG_EMMC_DAT1 & 0x08)>>3,
+		(REG_EMMC_DAT1 & 0x80)>>7, (REG_EMMC_DAT1 & 0x40)>>6, (REG_EMMC_DAT1 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_DAT2:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_DAT2, (REG_EMMC_DAT2 & 0x04)>>2, (REG_EMMC_DAT2 & 0x08)>>3,
+		(REG_EMMC_DAT2 & 0x80)>>7, (REG_EMMC_DAT2 & 0x40)>>6, (REG_EMMC_DAT2 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_DAT3:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_DAT3, (REG_EMMC_DAT3 & 0x04)>>2, (REG_EMMC_DAT3 & 0x08)>>3,
+		(REG_EMMC_DAT3 & 0x80)>>7, (REG_EMMC_DAT3 & 0x40)>>6, (REG_EMMC_DAT3 & 0x20)>>5);
+
+	clk_source_select = (readb(cvi_host->clkgenbase + 0x20) & 0x20) >> 5;
+
+	SDHCI_DUMP(": clk_emmc enable[16]:0x%08x\n", readl(cvi_host->clkgenbase));
+	SDHCI_DUMP(": clk_emmc source_select:%u\n", clk_source_select);
+	if (clk_source_select == 0) {
+		SDHCI_DUMP(": clk_emmc REG:0x03002068 = 0x%08x\n",
+		readl(cvi_host->clkgenbase + 0x68));
+		if (readl(cvi_host->clkgenbase + 0x68) == 0x00000001)
+			SDHCI_DUMP(": clk_emmc %d MHz\n", DISPPLL_MHZ/12);
+	} else if (clk_source_select == 1) {
+		SDHCI_DUMP(": clk_emmc REG:0x03002064 = 0x%08x\n",
+		readl(cvi_host->clkgenbase + 0x64));
+		if (readl(cvi_host->clkgenbase + 0x64) == 0x00040009)
+			SDHCI_DUMP(": clk_emmc %d MHz\n", FPLL_MHZ/4);
+	}
+}
+
+static void sdhci_cv180x_sd_dump_vendor_regs(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+	u8 PAD_SDIO0_PWR_EN = 0;
+	u8 PAD_SDIO0_CD  = 0;
+	u8 PAD_SDIO0_CLK = 0;
+	u8 PAD_SDIO0_CMD = 0;
+	u8 PAD_SDIO0_D0  = 0;
+	u8 PAD_SDIO0_D1  = 0;
+	u8 PAD_SDIO0_D2  = 0;
+	u8 PAD_SDIO0_D3  = 0;
+	u8 REG_SDIO0_PWR_EN = 0;
+	u8 REG_SDIO0_CD  = 0;
+	u8 REG_SDIO0_CLK = 0;
+	u8 REG_SDIO0_CMD = 0;
+	u8 REG_SDIO0_D0  = 0;
+	u8 REG_SDIO0_D1  = 0;
+	u8 REG_SDIO0_D2  = 0;
+	u8 REG_SDIO0_D3  = 0;
+
+	SDHCI_DUMP(": Reg_200:   0x%08x | Reg_240:  0x%08x\n",
+		   sdhci_readl(host, CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R),
+		   sdhci_readl(host, CVI_CV180X_SDHCI_PHY_TX_RX_DLY));
+	SDHCI_DUMP(": Reg_244:   0x%08x | Reg_248:  0x%08x\n",
+		   sdhci_readl(host, CVI_CV180X_SDHCI_PHY_DS_DLY),
+		   sdhci_readw(host, CVI_CV180X_SDHCI_PHY_DLY_STS));
+	SDHCI_DUMP(": Reg_24C:   0x%08x | unplugg:  0x%08x\n",
+		   sdhci_readl(host, CVI_CV180X_SDHCI_PHY_CONFIG),
+		   host->mmc->ever_unplugged);
+
+	PAD_SDIO0_PWR_EN = readb(cvi_host->pinmuxbase + 0x1C) & 0x07;
+	PAD_SDIO0_CD  = readb(cvi_host->pinmuxbase + 0x18) & 0x07;
+	PAD_SDIO0_CLK = readb(cvi_host->pinmuxbase + 0x00) & 0x07;
+	PAD_SDIO0_CMD = readb(cvi_host->pinmuxbase + 0x04) & 0x07;
+	PAD_SDIO0_D0  = readb(cvi_host->pinmuxbase + 0x08) & 0x07;
+	PAD_SDIO0_D1  = readb(cvi_host->pinmuxbase + 0x0C) & 0x07;
+	PAD_SDIO0_D2  = readb(cvi_host->pinmuxbase + 0x10) & 0x07;
+	PAD_SDIO0_D3  = readb(cvi_host->pinmuxbase + 0x14) & 0x07;
+	REG_SDIO0_PWR_EN = readb(cvi_host->pinmuxbase + 0x904);
+	REG_SDIO0_CD  = readb(cvi_host->pinmuxbase + 0x900);
+	REG_SDIO0_CLK = readb(cvi_host->pinmuxbase + 0xA00);
+	REG_SDIO0_CMD = readb(cvi_host->pinmuxbase + 0xA04);
+	REG_SDIO0_D0  = readb(cvi_host->pinmuxbase + 0xA08);
+	REG_SDIO0_D1  = readb(cvi_host->pinmuxbase + 0xA0C);
+	REG_SDIO0_D2  = readb(cvi_host->pinmuxbase + 0xA10);
+	REG_SDIO0_D3  = readb(cvi_host->pinmuxbase + 0xA14);
+
+	SDHCI_DUMP(": PAD_SDIO0_PWR_EN:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_PWR_EN, (REG_SDIO0_PWR_EN & 0x04)>>2, (REG_SDIO0_PWR_EN & 0x08)>>3,
+		(REG_SDIO0_PWR_EN & 0x80)>>7, (REG_SDIO0_PWR_EN & 0x40)>>6, (REG_SDIO0_PWR_EN & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_CD:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_CD, (REG_SDIO0_CD & 0x04)>>2, (REG_SDIO0_CD & 0x08)>>3,
+		(REG_SDIO0_CD & 0x80)>>7, (REG_SDIO0_CD & 0x40)>>6, (REG_SDIO0_CD & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_CLK:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_CLK, (REG_SDIO0_CLK & 0x04)>>2, (REG_SDIO0_CLK & 0x08)>>3,
+		(REG_SDIO0_CLK & 0x80)>>7, (REG_SDIO0_CLK & 0x40)>>6, (REG_SDIO0_CLK & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_CMD:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_CMD, (REG_SDIO0_CMD & 0x04)>>2, (REG_SDIO0_CMD & 0x08)>>3,
+		(REG_SDIO0_CMD & 0x80)>>7, (REG_SDIO0_CMD & 0x40)>>6, (REG_SDIO0_CMD & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_D0:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_D0, (REG_SDIO0_D0 & 0x04)>>2, (REG_SDIO0_D0 & 0x08)>>3,
+		(REG_SDIO0_D0 & 0x80)>>7, (REG_SDIO0_D0 & 0x40)>>6, (REG_SDIO0_D0 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_D1:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_D1, (REG_SDIO0_D1 & 0x04)>>2, (REG_SDIO0_D1 & 0x08)>>3,
+		(REG_SDIO0_D1 & 0x80)>>7, (REG_SDIO0_D1 & 0x40)>>6, (REG_SDIO0_D1 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_D2:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_D2, (REG_SDIO0_D2 & 0x04)>>2, (REG_SDIO0_D2 & 0x08)>>3,
+		(REG_SDIO0_D2 & 0x80)>>7, (REG_SDIO0_D2 & 0x40)>>6, (REG_SDIO0_D2 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_D3:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_D3, (REG_SDIO0_D3 & 0x04)>>2, (REG_SDIO0_D3 & 0x08)>>3,
+		(REG_SDIO0_D3 & 0x80)>>7, (REG_SDIO0_D3 & 0x40)>>6, (REG_SDIO0_D3 & 0x20)>>5);
+
+	SDHCI_DUMP(": clk_sd0 enable[19]:0x%08x\n", readl(cvi_host->clkgenbase));
+	SDHCI_DUMP(": clk_sd0 REG:0x03002070 = 0x%08x\n", readl(cvi_host->clkgenbase + 0x70));
+	if (readl(cvi_host->clkgenbase + 0x70) == 0x00040009)
+		SDHCI_DUMP(": clk_sd0 %d MHz\n", FPLL_MHZ/4);
+}
+
+static const struct sdhci_ops sdhci_cv180x_emmc_ops = {
+	.reset = sdhci_cv180x_emmc_reset,
+	.set_clock = sdhci_set_clock,
+	.set_bus_width = sdhci_set_bus_width,
+	.get_max_clock = sdhci_cvi_general_get_max_clock,
+	.voltage_switch = sdhci_cvi_emmc_voltage_switch,
+	.set_uhs_signaling = sdhci_cvi_general_set_uhs_signaling,
+	.platform_execute_tuning = sdhci_cv180x_general_execute_tuning,
+	.select_drive_strength = sdhci_cv180x_general_select_drive_strength,
+	.dump_vendor_regs = sdhci_cv180x_emmc_dump_vendor_regs,
+};
+
+static const struct sdhci_ops sdhci_cv180x_sd_ops = {
+	.reset = sdhci_cv180x_sd_reset,
+	.set_clock = sdhci_set_clock,
+	.set_power = sdhci_cv180x_sd_set_power,
+	.set_bus_width = sdhci_set_bus_width,
+	.get_max_clock = sdhci_cvi_general_get_max_clock,
+	.voltage_switch = sdhci_cv180x_sd_voltage_switch,
+	.set_uhs_signaling = sdhci_cvi_general_set_uhs_signaling,
+	.platform_execute_tuning = sdhci_cv180x_general_execute_tuning,
+	.select_drive_strength = sdhci_cv180x_general_select_drive_strength,
+	.dump_vendor_regs = sdhci_cv180x_sd_dump_vendor_regs,
+};
+
+static const struct sdhci_ops sdhci_cv180x_sdio_ops = {
+	.reset = sdhci_cv180x_sdio_reset,
+	.set_clock = sdhci_set_clock,
+	.set_bus_width = sdhci_set_bus_width,
+	.get_max_clock = sdhci_cvi_general_get_max_clock,
+	.voltage_switch = sdhci_cv180x_sd_voltage_switch,
+	.set_uhs_signaling = sdhci_cvi_general_set_uhs_signaling,
+	.select_drive_strength = sdhci_cv180x_general_select_drive_strength,
+	.platform_execute_tuning = sdhci_cv180x_general_execute_tuning,
+};
+
+static const struct sdhci_ops sdhci_cv180x_fpga_emmc_ops = {
+	.reset = sdhci_cv180x_sd_reset,
+	.set_clock = sdhci_set_clock,
+	.set_bus_width = sdhci_set_bus_width,
+	.get_max_clock = sdhci_cvi_general_get_max_clock,
+	.voltage_switch = sdhci_cvi_emmc_voltage_switch,
+	.set_uhs_signaling = sdhci_cvi_general_set_uhs_signaling,
+	.platform_execute_tuning = sdhci_cv180x_general_execute_tuning,
+	.select_drive_strength = sdhci_cv180x_general_select_drive_strength,
+	.dump_vendor_regs = sdhci_cv180x_emmc_dump_vendor_regs,
+};
+
+static const struct sdhci_ops sdhci_cv180x_fpga_sd_ops = {
+	.reset = sdhci_cv180x_sd_reset,
+	.set_clock = sdhci_set_clock,
+	.set_power = sdhci_cv180x_sd_set_power,
+	.set_bus_width = sdhci_set_bus_width,
+	.get_max_clock = sdhci_cvi_general_get_max_clock,
+	.voltage_switch = sdhci_cv180x_sd_voltage_switch,
+	.set_uhs_signaling = sdhci_cvi_general_set_uhs_signaling,
+	.platform_execute_tuning = sdhci_cv180x_general_execute_tuning,
+	.select_drive_strength = sdhci_cv180x_general_select_drive_strength,
+	.dump_vendor_regs = sdhci_cv180x_sd_dump_vendor_regs,
+};
+
+static const struct sdhci_pltfm_data sdhci_cv180x_emmc_pdata = {
+	.ops = &sdhci_cv180x_emmc_ops,
+	.quirks = SDHCI_QUIRK_INVERTED_WRITE_PROTECT | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
+};
+
+static const struct sdhci_pltfm_data sdhci_cv180x_sd_pdata = {
+	.ops = &sdhci_cv180x_sd_ops,
+	.quirks = SDHCI_QUIRK_INVERTED_WRITE_PROTECT | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
+};
+
+static const struct sdhci_pltfm_data sdhci_cv180x_sdio_pdata = {
+	.ops = &sdhci_cv180x_sdio_ops,
+	.quirks = SDHCI_QUIRK_INVERTED_WRITE_PROTECT | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN | SDHCI_QUIRK2_NO_1_8_V,
+};
+
+static const struct sdhci_pltfm_data sdhci_cv180x_fpga_emmc_pdata = {
+	.ops = &sdhci_cv180x_fpga_emmc_ops,
+	.quirks = SDHCI_QUIRK_INVERTED_WRITE_PROTECT | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN | SDHCI_QUIRK2_BROKEN_HS200,
+};
+
+static const struct sdhci_pltfm_data sdhci_cv180x_fpga_sd_pdata = {
+	.ops = &sdhci_cv180x_fpga_sd_ops,
+	.quirks = SDHCI_QUIRK_INVERTED_WRITE_PROTECT | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN | SDHCI_QUIRK2_NO_1_8_V,
+};
+
+static const struct of_device_id sdhci_cvi_dt_match[] = {
+	{.compatible = "cvitek,cv180x-fpga-emmc", .data = &sdhci_cv180x_fpga_emmc_pdata},
+	{.compatible = "cvitek,cv180x-fpga-sd", .data = &sdhci_cv180x_fpga_sd_pdata},
+	{.compatible = "cvitek,cv180x-emmc", .data = &sdhci_cv180x_emmc_pdata},
+	{.compatible = "cvitek,cv180x-sd", .data = &sdhci_cv180x_sd_pdata},
+	{.compatible = "cvitek,cv180x-sdio", .data = &sdhci_cv180x_sdio_pdata},
+
+	{ /* sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(of, sdhci_cvi_dt_match);
+
+static unsigned long sdhci_get_time_ms(void)
+{
+	ktime_t cur;
+
+	cur = ktime_get();
+	// Get milliseconds
+	return ktime_to_ms(cur);
+}
+
+static void sdhci_cvi_cd_debounce_work(struct work_struct *work)
+{
+	struct sdhci_cvi_host *cvi_host = container_of(work, struct sdhci_cvi_host,
+						  cd_debounce_work.work);
+	struct mmc_host *host = cvi_host->mmc;
+	unsigned long start_time = sdhci_get_time_ms();
+	int pre_gpio_cd;
+	unsigned long flag;
+
+	spin_lock_irqsave(&cvi_host->cd_debounce_lock, flag);
+	pre_gpio_cd = cvi_host->pre_gpio_cd;
+	cvi_host->is_debounce_work_running = true;
+	spin_unlock_irqrestore(&cvi_host->cd_debounce_lock, flag);
+
+	while (1) {
+		if ((sdhci_get_time_ms() - start_time) >= SDHCI_GPIO_CD_DEBOUNCE_TIME) {
+			if (pre_gpio_cd == mmc_gpio_get_cd(host)) {
+				host->ops->card_event(host);
+				mmc_detect_change(host, msecs_to_jiffies(SDHCI_GPIO_CD_DEBOUNCE_DELAY_TIME));
+				break;
+			}
+			pre_gpio_cd = mmc_gpio_get_cd(host);
+			start_time = sdhci_get_time_ms();
+		}
+	}
+
+	spin_lock_irqsave(&cvi_host->cd_debounce_lock, flag);
+	cvi_host->is_debounce_work_running = false;
+	spin_unlock_irqrestore(&cvi_host->cd_debounce_lock, flag);
+}
+
+static irqreturn_t sdhci_cvi_cd_handler(int irq, void *dev_id)
+{
+	/* Schedule a card detection after a debounce timeout */
+	struct mmc_host *host = dev_id;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(mmc_priv(host));
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+	unsigned long flag;
+
+	spin_lock_irqsave(&cvi_host->cd_debounce_lock, flag);
+	cvi_host->pre_gpio_cd = mmc_gpio_get_cd(host);
+	if (!cvi_host->pre_gpio_cd)
+		host->ever_unplugged = true;
+	if (!cvi_host->is_debounce_work_running) {
+		cancel_delayed_work(&cvi_host->cd_debounce_work);
+		schedule_delayed_work(&cvi_host->cd_debounce_work, 0);
+	}
+	spin_unlock_irqrestore(&cvi_host->cd_debounce_lock, flag);
+
+	return IRQ_HANDLED;
+}
+
+static int sdhci_cvi_probe(struct platform_device *pdev)
+{
+	struct sdhci_host *host;
+	struct sdhci_pltfm_host *pltfm_host;
+	struct sdhci_cvi_host *cvi_host;
+	const struct of_device_id *match;
+	const struct sdhci_pltfm_data *pdata;
+	int ret;
+	int gpio_cd = -EINVAL;
+
+	pr_info(DRIVER_NAME ":%s\n", __func__);
+
+	match = of_match_device(sdhci_cvi_dt_match, &pdev->dev);
+	if (!match)
+		return -EINVAL;
+
+	pdata = match->data;
+
+	host = sdhci_pltfm_init(pdev, pdata, sizeof(*cvi_host));
+	if (IS_ERR(host))
+		return PTR_ERR(host);
+
+	pltfm_host = sdhci_priv(host);
+	cvi_host = sdhci_pltfm_priv(pltfm_host);
+	cvi_host->host = host;
+	cvi_host->mmc = host->mmc;
+	cvi_host->pdev = pdev;
+	cvi_host->core_mem = host->ioaddr;
+	cvi_host->topbase = ioremap(TOP_BASE, 0x2000);
+	cvi_host->pinmuxbase = ioremap(PINMUX_BASE, 0x1000);
+	cvi_host->clkgenbase = ioremap(CLKGEN_BASE, 0x100);
+
+	sdhci_cv180x_sd_voltage_restore(host, false);
+
+	ret = mmc_of_parse(host->mmc);
+	if (ret)
+		goto pltfm_free;
+
+	sdhci_get_of_property(pdev);
+
+	if (pdata->ops->hw_reset) {
+		cvi_host->reset = devm_reset_control_get(&pdev->dev, "sdio");
+		if (IS_ERR(cvi_host->reset)) {
+			ret = PTR_ERR(cvi_host->reset);
+			goto pltfm_free;
+		}
+	}
+
+	if (pdev->dev.of_node) {
+		gpio_cd = of_get_named_gpio(pdev->dev.of_node, "cvi-cd-gpios", 0);
+	}
+
+	if (gpio_is_valid(gpio_cd)) {
+		cvi_host->cvi_gpio = devm_kzalloc(&cvi_host->pdev->dev,
+					sizeof(struct mmc_gpio), GFP_KERNEL);
+		if (cvi_host->cvi_gpio) {
+			cvi_host->cvi_gpio->cd_gpio_isr = sdhci_cvi_cd_handler;
+			cvi_host->cvi_gpio->cd_debounce_delay_ms = SDHCI_GPIO_CD_DEBOUNCE_DELAY_TIME;
+			cvi_host->cvi_gpio->cd_label = devm_kzalloc(&cvi_host->pdev->dev,
+						strlen("cd-gpio-irq") + 1, GFP_KERNEL);
+			strcpy(cvi_host->cvi_gpio->cd_label, "cd-gpio-irq");
+			host->mmc->slot.handler_priv = cvi_host->cvi_gpio;
+			ret = mmc_gpiod_request_cd(host->mmc, "cvi-cd",
+					0, false, SDHCI_GPIO_CD_DEBOUNCE_TIME);
+			if (ret) {
+				pr_err("card detect request cd failed: %d\n", ret);
+			} else {
+				writeb(0x3, cvi_host->pinmuxbase + 0x18);
+				INIT_DELAYED_WORK(&cvi_host->cd_debounce_work, sdhci_cvi_cd_debounce_work);
+				spin_lock_init(&cvi_host->cd_debounce_lock);
+				mmc_gpiod_request_cd_irq(host->mmc);
+			}
+		}
+	}
+
+	ret = sdhci_add_host(host);
+	if (ret)
+		goto err_add_host;
+
+	platform_set_drvdata(pdev, cvi_host);
+
+	if (strstr(dev_name(mmc_dev(host->mmc)), "wifi-sd"))
+		wifi_mmc = host->mmc;
+	else
+		wifi_mmc = NULL;
+
+	/* device proc entry */
+	if ((!proc_cvi_dir) &&
+		(strstr(dev_name(mmc_dev(host->mmc)), "cv-sd"))) {
+		ret = cvi_proc_init(cvi_host);
+		if (ret)
+			pr_err("device proc init is failed!");
+	}
+
+	if (strstr(dev_name(mmc_dev(host->mmc)), "cv-emmc"))
+		sdhci_cv180x_emmc_setup_pad(host);
+
+	return 0;
+
+err_add_host:
+pltfm_free:
+	sdhci_pltfm_free(pdev);
+	return ret;
+}
+
+static int sdhci_cvi_remove(struct platform_device *pdev)
+{
+	struct sdhci_host *host = platform_get_drvdata(pdev);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+	int dead = (readl_relaxed(host->ioaddr + SDHCI_INT_STATUS) == 0xffffffff);
+
+	sdhci_remove_host(host, dead);
+	sdhci_pltfm_free(pdev);
+
+	cvi_proc_shutdown(cvi_host);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_ARCH_CV180X_ASIC
+
+static int save_rtc_reg(struct sdhci_cvi_host *cvi_host)
+{
+	void __iomem *topbase;
+	void __iomem *rtcbase;
+
+	topbase = ioremap(TOP_BASE, 0x250);
+	rtcbase = ioremap(RTC_CTRL_BASE, 0x80);
+
+	if (!cvi_host->rtc_reg_ctx) {
+		cvi_host->rtc_reg_ctx = devm_kzalloc(&cvi_host->pdev->dev,
+								sizeof(struct cvi_rtc_sdhci_reg_context), GFP_KERNEL);
+		if (!cvi_host->rtc_reg_ctx)
+			return -ENOMEM;
+	}
+	cvi_host->rtc_reg_ctx->rtcsys_clkmux = readl(rtcbase + RTCSYS_CLKMUX);
+	cvi_host->rtc_reg_ctx->rtcsys_clkbyp = readl(rtcbase + RTCSYS_CLKBYP);
+	cvi_host->rtc_reg_ctx->rtcsys_mcu51_ictrl1 = readl(rtcbase + RTCSYS_MCU51_ICTRL1);
+	cvi_host->rtc_reg_ctx->rtcsys_ctrl = readl(topbase + RTCSYS_CTRL);
+
+	iounmap(topbase);
+	iounmap(rtcbase);
+
+	return 0;
+}
+
+static void restore_rtc_reg(struct sdhci_cvi_host *cvi_host)
+{
+	void __iomem *topbase;
+	void __iomem *rtcbase;
+
+	topbase = ioremap(TOP_BASE, 0x250);
+	rtcbase = ioremap(RTC_CTRL_BASE, 0x80);
+
+	writel(cvi_host->rtc_reg_ctx->rtcsys_clkmux, rtcbase + RTCSYS_CLKMUX);
+	writel(cvi_host->rtc_reg_ctx->rtcsys_clkbyp, rtcbase + RTCSYS_CLKBYP);
+	writel(cvi_host->rtc_reg_ctx->rtcsys_mcu51_ictrl1, rtcbase + RTCSYS_MCU51_ICTRL1);
+	writel(cvi_host->rtc_reg_ctx->rtcsys_ctrl, topbase + RTCSYS_CTRL);
+
+	iounmap(topbase);
+	iounmap(rtcbase);
+}
+#else
+static int save_rtc_reg(struct sdhci_cvi_host *cvi_host)
+{
+	return 0;
+}
+static void restore_rtc_reg(struct sdhci_cvi_host *cvi_host) {}
+#endif
+
+static void save_reg(struct sdhci_host *host, struct sdhci_cvi_host *cvi_host)
+{
+	save_rtc_reg(cvi_host);
+	cvi_host->reg_ctrl2 = sdhci_readl(host, SDHCI_HOST_CONTROL2);
+	cvi_host->reg_clk_ctrl = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
+	cvi_host->reg_host_ctrl = sdhci_readl(host, SDHCI_HOST_CONTROL);
+}
+
+static void restore_reg(struct sdhci_host *host, struct sdhci_cvi_host *cvi_host)
+{
+	restore_rtc_reg(cvi_host);
+	sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
+	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
+	sdhci_writel(host, cvi_host->reg_ctrl2, SDHCI_HOST_CONTROL2);
+	sdhci_writel(host, cvi_host->reg_clk_ctrl, SDHCI_CLOCK_CONTROL);
+	sdhci_writel(host, cvi_host->reg_host_ctrl, SDHCI_HOST_CONTROL);
+}
+
+static int sdhci_cvi_suspend(struct device *dev)
+{
+	struct sdhci_cvi_host *cvi_host = dev_get_drvdata(dev);
+	struct sdhci_host *host = cvi_host->host;
+
+	if (!host)
+		return 0;
+
+	save_reg(host, cvi_host);
+
+	return 0;
+}
+
+static int sdhci_cvi_resume(struct device *dev)
+{
+	struct sdhci_cvi_host *cvi_host = dev_get_drvdata(dev);
+	struct sdhci_host *host = cvi_host->host;
+
+	if (!host)
+		return 0;
+
+	restore_reg(host, cvi_host);
+
+	return 0;
+}
+
+#endif
+
+static const struct dev_pm_ops sdhci_cvi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(sdhci_cvi_suspend, sdhci_cvi_resume)
+};
+
+static struct platform_driver sdhci_cvi_driver = {
+	.probe = sdhci_cvi_probe,
+	.remove = sdhci_cvi_remove,
+	.driver = {
+		.name = DRIVER_NAME,
+		.pm = &sdhci_cvi_pm_ops,
+		.of_match_table = sdhci_cvi_dt_match,
+	},
+};
+
+module_platform_driver(sdhci_cvi_driver);
+
+MODULE_DESCRIPTION("Cvitek Secure Digital Host Controller Interface driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mmc/host/cvitek/sdhci-cv180x.h b/drivers/mmc/host/cvitek/sdhci-cv180x.h
new file mode 100644
index 000000000000..5af957aad6a9
--- /dev/null
+++ b/drivers/mmc/host/cvitek/sdhci-cv180x.h
@@ -0,0 +1,104 @@
+/*
+ * drivers/mmc/host/sdhci-cvi.c - CVITEK SDHCI Platform driver
+ *
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __SDHCI_CV_H
+#define __SDHCI_CV_H
+
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/delay.h>
+#include <linux/mmc/mmc.h>
+#include <linux/slab.h>
+
+#define MAX_TUNING_CMD_RETRY_COUNT 50
+#define TUNE_MAX_PHCODE	128
+#define TAP_WINDOW_THLD 20
+#define DISPPLL_MHZ 1188
+#define FPLL_MHZ 1500
+
+#define TOP_BASE	0x03000000
+#define OFFSET_SD_PWRSW_CTRL	0x1F4
+
+#define PINMUX_BASE 0x03001000
+#define CLKGEN_BASE 0x03002000
+
+
+#define CVI_CV180X_SDHCI_VENDOR_OFFSET		0x200
+#define CVI_CV180X_SDHCI_VENDOR_MSHC_CTRL_R	(CVI_CV180X_SDHCI_VENDOR_OFFSET + 0x0)
+#define CVI_CV180X_SDHCI_PHY_TX_RX_DLY		(CVI_CV180X_SDHCI_VENDOR_OFFSET + 0x40)
+#define CVI_CV180X_SDHCI_PHY_DS_DLY			(CVI_CV180X_SDHCI_VENDOR_OFFSET + 0x44)
+#define CVI_CV180X_SDHCI_PHY_DLY_STS			(CVI_CV180X_SDHCI_VENDOR_OFFSET + 0x48)
+#define CVI_CV180X_SDHCI_PHY_CONFIG			(CVI_CV180X_SDHCI_VENDOR_OFFSET + 0x4C)
+
+#define SDHCI_GPIO_CD_DEBOUNCE_TIME	10
+#define SDHCI_GPIO_CD_DEBOUNCE_DELAY_TIME	200
+
+#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_ARCH_CVCV180X_ASIC
+
+#define RTC_CTRL_BASE		0x5025000
+#define RTCSYS_CLKMUX	0x1C
+#define RTCSYS_CLKBYP	0x30
+#define RTCSYS_MCU51_ICTRL1	0x7C
+
+#define RTCSYS_CTRL		0x248
+
+struct cvi_rtc_sdhci_reg_context {
+	u32 rtcsys_clkmux;
+	u32 rtcsys_clkbyp;
+	u32 rtcsys_mcu51_ictrl1;
+	u32 rtcsys_ctrl;
+};
+#else
+struct cvi_rtc_sdhci_reg_context {};
+#endif
+#endif
+
+struct sdhci_cvi_host {
+	struct sdhci_host *host;
+	struct platform_device *pdev;
+	void __iomem *core_mem; /* mmio address */
+	struct clk *clk;    /* main SD/MMC bus clock */
+	struct clk *clk100k;
+	struct clk *clkaxi;
+	struct mmc_host *mmc;
+	struct reset_control *reset;
+
+	struct reset_control *clk_rst_axi_emmc_ctrl;
+	struct reset_control *clk_rst_emmc_ctrl;
+	struct reset_control *clk_rst_100k_emmc_ctrl;
+
+	void __iomem *topbase;
+	void __iomem *pinmuxbase;
+	void __iomem *clkgenbase;
+
+	u32 reg_ctrl2;
+	u32 reg_clk_ctrl;
+	u32 reg_host_ctrl;
+	u8 final_tap;
+	u8 sdio0_voltage_1_8_v;
+	int sd_save_count;
+	struct mmc_gpio *cvi_gpio;
+	struct delayed_work cd_debounce_work;
+	spinlock_t cd_debounce_lock;
+	int pre_gpio_cd;
+	bool is_debounce_work_running;
+#ifdef CONFIG_PM_SLEEP
+	struct cvi_rtc_sdhci_reg_context *rtc_reg_ctx;
+#endif
+
+};
+#endif
diff --git a/drivers/mmc/host/cvitek/sdhci-cv181x.c b/drivers/mmc/host/cvitek/sdhci-cv181x.c
new file mode 100644
index 000000000000..f171a17b5164
--- /dev/null
+++ b/drivers/mmc/host/cvitek/sdhci-cv181x.c
@@ -0,0 +1,1434 @@
+/*
+ * drivers/mmc/host/sdhci-cv.c - CVITEK SDHCI Platform driver
+ *
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/slab.h>
+#include <linux/reset.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/device.h>
+#include <linux/export.h>
+#include <linux/io.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/of_gpio.h>
+#include <linux/mmc/slot-gpio.h>
+#include <linux/ktime.h>
+
+#include "../../core/card.h"
+#include "../sdhci-pltfm.h"
+#include "sdhci-cv181x.h"
+
+#define DRIVER_NAME "cvi"
+#define SDHCI_DUMP(f, x...) \
+	pr_err("%s: " DRIVER_NAME ": " f, mmc_hostname(host->mmc), ## x)
+
+#define MAX_CARD_TYPE 4
+#define MAX_SPEED_MODE 5
+
+#define CVI_PARENT "cvi"
+#define CVI_STATS_PROC "cvi_info"
+#define MAX_CLOCK_SCALE (4)
+
+#define UNSTUFF_BITS(resp, start, size)                 \
+	({                                                      \
+	const int __size = size;                                \
+	const u32 __mask = (__size < 32 ? 1 << __size : 0) - 1; \
+	const int __off = 3 - ((start) / 32);                   \
+	const int __shft = (start) & 31;                        \
+	u32 __res;                                              \
+	__res = resp[__off] >> __shft;                          \
+	if (__size + __shft > 32)                               \
+		__res |= resp[__off - 1] << ((32 - __shft) % 32);   \
+	__res & __mask;                                         \
+	})
+
+static struct proc_dir_entry *proc_cvi_dir;
+
+static char *card_type[MAX_CARD_TYPE + 1] = {
+	"MMC card", "SD card", "SDIO card", "SD combo (IO+mem) card", "unknown"
+};
+
+static char *cvi_get_card_type(unsigned int sd_type)
+{
+	if (sd_type >= MAX_CARD_TYPE)
+		return card_type[MAX_CARD_TYPE];
+	else
+		return card_type[sd_type];
+}
+
+static inline int is_card_uhs(unsigned char timing)
+{
+	return timing >= MMC_TIMING_UHS_SDR12 && timing <= MMC_TIMING_UHS_DDR50;
+};
+
+static inline int is_card_hs(unsigned char timing)
+{
+	return timing == MMC_TIMING_SD_HS || timing == MMC_TIMING_MMC_HS;
+};
+
+static void cvi_stats_seq_printout(struct seq_file *s)
+{
+	const char *type = NULL;
+	unsigned int present;
+	unsigned char timing;
+	struct sdhci_cvi_host *cvi_host = NULL;
+	struct mmc_host *mmc = NULL;
+	struct mmc_card *card = NULL;
+	const char *uhs_bus_speed_mode = "";
+	u32 speed_class, grade_speed_uhs;
+	static const char *const uhs_speeds[] = {
+		[UHS_SDR12_BUS_SPEED] = "SDR12 ", [UHS_SDR25_BUS_SPEED] = "SDR25 ",
+		[UHS_SDR50_BUS_SPEED] = "SDR50 ", [UHS_SDR104_BUS_SPEED] = "SDR104 ",
+		[UHS_DDR50_BUS_SPEED] = "DDR50 ",
+	};
+	cvi_host = (struct sdhci_cvi_host *)s->private;
+
+	if (!cvi_host || !cvi_host->mmc) {
+		seq_printf(s, "cvi s : %p: s->private %p\n", s, s->private);
+		return;
+	}
+
+	seq_printf(s, "cvi.%d", cvi_host->mmc->index);
+
+	mmc = cvi_host->mmc;
+	present = mmc->ops->get_cd(mmc);
+
+	if (present) {
+		seq_puts(s, ": plugged");
+	} else {
+		seq_puts(s, ": unplugged");
+	}
+
+	card = mmc->card;
+
+	if (!card) {
+		seq_puts(s, "_disconnected\n");
+	} else {
+		seq_puts(s, "_connected\n");
+		seq_printf(s, "\tType: %s", cvi_get_card_type(card->type));
+
+		//if (card->state & MMC_STATE_BLOCKADDR) {
+		if (mmc_card_blockaddr(card)) {
+			if (card->state & MMC_CARD_SDXC)
+				type = "SDXC";
+			else
+				type = "SDHC";
+			seq_printf(s, "(%s)\n", type);
+		}
+
+		timing = mmc->ios.timing;
+
+		if (is_card_uhs(mmc->ios.timing) &&
+		    card->sd_bus_speed < ARRAY_SIZE(uhs_speeds))
+			uhs_bus_speed_mode = uhs_speeds[card->sd_bus_speed];
+
+		seq_printf(s, "\tMode: %s%s%s%s\n",
+			   is_card_uhs(timing) ? "UHS "
+			   : (is_card_hs(timing) ? "HS " : ""),
+			   timing == MMC_TIMING_MMC_HS400
+			   ? "HS400 "
+			   : (timing == MMC_TIMING_MMC_HS200 ? "HS200 " : ""),
+			   timing == MMC_TIMING_MMC_DDR52 ? "DDR " : "",
+			   uhs_bus_speed_mode);
+
+		speed_class = UNSTUFF_BITS(card->raw_ssr, 440 - 384, 8);
+		grade_speed_uhs = UNSTUFF_BITS(card->raw_ssr, 396 - 384, 4);
+		seq_printf(s, "\tSpeed Class: Class %s\n",
+			   (speed_class == 0x00)
+			   ? "0"
+			   : (speed_class == 0x01)
+			   ? "2"
+			   : (speed_class == 0x02)
+			   ? "4"
+			   : (speed_class == 0x03)
+			   ? "6"
+			   : (speed_class == 0x04)
+			   ? "10"
+			   : "Reserved");
+		seq_printf(s, "\tUhs Speed Grade: %s\n",
+			   (grade_speed_uhs == 0x00)
+			   ? "Less than 10MB/sec(0h)"
+			   : (grade_speed_uhs == 0x01)
+			   ? "10MB/sec and above(1h)"
+			   : "Reserved");
+	}
+}
+
+/* proc interface setup */
+static void *cvi_seq_start(struct seq_file *s, loff_t *pos)
+{
+	/*   counter is used to tracking multi proc interfaces
+	 *  We have only one interface so return zero
+	 *  pointer to start the sequence.
+	 */
+	static unsigned long counter;
+
+	if (*pos == 0) {
+		return &counter;
+	}
+
+	*pos = 0;
+	return NULL;
+}
+
+/* define parameters where showed in proc file */
+static int cvi_stats_seq_show(struct seq_file *s, void *v)
+{
+	cvi_stats_seq_printout(s);
+	return 0;
+}
+
+/* proc interface stop */
+static void cvi_seq_stop(struct seq_file *s, void *v) {}
+
+/* proc interface operation */
+static const struct seq_operations cvi_stats_seq_ops = {
+	.start = cvi_seq_start,
+	.stop = cvi_seq_stop,
+	.show = cvi_stats_seq_show
+};
+
+/* proc file open*/
+static int cvi_stats_proc_open(struct inode *inode, struct file *file)
+{
+//	return seq_open(file, &cvi_stats_seq_ops);
+	return single_open(file, cvi_stats_seq_show, PDE_DATA(inode));
+};
+
+/* proc file operation */
+static const struct proc_ops cvi_stats_proc_ops = {
+	.proc_open = cvi_stats_proc_open,
+	.proc_read = seq_read,
+	.proc_release = single_release,
+};
+
+int cvi_proc_init(struct sdhci_cvi_host *cvi_host)
+{
+	struct proc_dir_entry *proc_stats_entry;
+
+	pr_info("%s cvi_host 0x%p\n", __func__, cvi_host);
+
+	proc_cvi_dir = proc_mkdir(CVI_PARENT, NULL);
+
+	if (!proc_cvi_dir) {
+		pr_err("%s: failed to create proc file %s\n", __func__, CVI_PARENT);
+		return 1;
+	}
+
+	proc_stats_entry = proc_create_data(CVI_STATS_PROC, 0400, proc_cvi_dir, &cvi_stats_proc_ops,
+					    (void *)cvi_host);
+
+	if (!proc_stats_entry) {
+		pr_err("%s: failed to create proc file %s\n", __func__, CVI_STATS_PROC);
+		return 1;
+	}
+
+	return 0;
+}
+
+int cvi_proc_shutdown(struct sdhci_cvi_host *cvi_host)
+{
+	pr_info("%s\n", __func__);
+
+	if (proc_cvi_dir) {
+		remove_proc_entry(CVI_STATS_PROC, proc_cvi_dir);
+		remove_proc_entry(CVI_PARENT, NULL);
+		proc_cvi_dir = NULL;
+	}
+
+	return 0;
+}
+
+static void sdhci_cv181x_emmc_setup_pad(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	/* Name              Offset
+	 * PAD_EMMC_RSTN     0x48
+	 * PAD_EMMC_CLK      0x50
+	 * PAD_EMMC_CMD      0x5C
+	 * PAD_EMMC_DAT0     0x54
+	 * PAD_EMMC_DAT1     0x60
+	 * PAD_EMMC_DAT2     0x4C
+	 * PAD_EMMC_DAT3     0x58
+
+	 */
+
+	u8 val = 0x0;
+
+	writeb(val, cvi_host->pinmuxbase + 0x48);
+	writeb(val, cvi_host->pinmuxbase + 0x50);
+	writeb(val, cvi_host->pinmuxbase + 0x5C);
+	writeb(val, cvi_host->pinmuxbase + 0x54);
+	writeb(val, cvi_host->pinmuxbase + 0x60);
+	writeb(val, cvi_host->pinmuxbase + 0x4C);
+	writeb(val, cvi_host->pinmuxbase + 0x58);
+}
+
+static void sdhci_cv181x_sd_setup_pad(struct sdhci_host *host, bool bunplug)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	/* Name              Offset unplug plug
+	 * PAD_SDIO0_CD      0x34   SDIO0  SDIO0
+	 * PAD_SDIO0_PWR_EN  0x38   SDIO0  SDIO0
+	 * PAD_SDIO0_CLK     0x1C   XGPIO  SDIO0
+	 * PAD_SDIO0_CMD     0x20   XGPIO  SDIO0
+	 * PAD_SDIO0_D0      0x24   XGPIO  SDIO0
+	 * PAD_SDIO0_D1      0x28   XGPIO  SDIO0
+	 * PAD_SDIO0_D2      0x2C   XGPIO  SDIO0
+	 * PAD_SDIO0_D3      0x30   XGPIO  SDIO0
+	 * 0x0: SDIO0 function
+	 * 0x3: XGPIO function
+	 */
+
+	u8 val = (bunplug) ? 0x3 : 0x0;
+
+	if (cvi_host->cvi_gpio && cvi_host->cvi_gpio->cd_gpio)
+		writeb(0x3, cvi_host->pinmuxbase + 0x34);
+	else
+		writeb(0x0, cvi_host->pinmuxbase + 0x34);
+
+	writeb(0x0, cvi_host->pinmuxbase + 0x38);
+	writeb(val, cvi_host->pinmuxbase + 0x1C);
+	writeb(val, cvi_host->pinmuxbase + 0x20);
+	writeb(val, cvi_host->pinmuxbase + 0x24);
+	writeb(val, cvi_host->pinmuxbase + 0x28);
+	writeb(val, cvi_host->pinmuxbase + 0x2C);
+	writeb(val, cvi_host->pinmuxbase + 0x30);
+}
+
+static void sdhci_cv181x_sd_setup_io(struct sdhci_host *host, bool reset)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	/*
+	 * Name              Offset reset sd0
+	 * REG_SDIO0_CD      0x900  PU    PU
+	 * REG_SDIO0_PWR_EN  0x904  PD    PD
+	 * REG_SDIO0_CLK     0xA00  PD    PD
+	 * REG_SDIO0_CMD     0xA04  PD    PU
+	 * REG_SDIO0_D0      0xA08  PD    PU
+	 * REG_SDIO0_D1      0xA0C  PD    PU
+	 * REG_SDIO0_D2      0xA10  PD    PU
+	 * REG_SDIO0_D3      0xA14  PD    PU
+	 * BIT(2) : PU   enable(1)/disable(0)
+	 * BIT(3) : PD   enable(1)/disable(0)
+	 */
+
+	u8 raise_bit = (reset) ?  BIT(3) : BIT(2);
+	u8 down_bit  = (reset) ?  BIT(2) : BIT(3);
+
+	writeb(((readb(cvi_host->pinmuxbase + 0x900) | BIT(2)) & ~(BIT(3))),
+		cvi_host->pinmuxbase + 0x900);
+	writeb(((readb(cvi_host->pinmuxbase + 0x904) | BIT(3)) & ~(BIT(2))),
+		cvi_host->pinmuxbase + 0x904);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA00) | BIT(3)) & ~(BIT(2))),
+		cvi_host->pinmuxbase + 0xA00);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA04) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA04);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA08) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA08);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA0C) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA0C);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA10) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA10);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA14) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA14);
+}
+
+static void sdhci_cvi_reset_helper(struct sdhci_host *host, u8 mask)
+{
+	// disable Intr before reset
+	sdhci_writel(host, 0, SDHCI_INT_ENABLE);
+	sdhci_writel(host, 0, SDHCI_SIGNAL_ENABLE);
+
+	sdhci_reset(host, mask);
+
+	sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
+	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
+}
+
+static void reset_after_tuning_pass(struct sdhci_host *host)
+{
+	pr_debug("tuning pass\n");
+
+	/* Clear BUF_RD_READY intr */
+	sdhci_writew(host, sdhci_readw(host, SDHCI_INT_STATUS) & (~(0x1 << 5)),
+		     SDHCI_INT_STATUS);
+
+	/* Set SDHCI_SOFTWARE_RESET.SW_RST_DAT = 1 to clear buffered tuning block */
+	sdhci_writeb(host, sdhci_readb(host, SDHCI_SOFTWARE_RESET) | (0x1 << 2), SDHCI_SOFTWARE_RESET);
+
+	/* Set SDHCI_SOFTWARE_RESET.SW_RST_CMD = 1	*/
+	sdhci_writeb(host, sdhci_readb(host, SDHCI_SOFTWARE_RESET) | (0x1 << 1), SDHCI_SOFTWARE_RESET);
+
+	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & 0x3)
+		;
+}
+
+static inline uint32_t CHECK_MASK_BIT(void *_mask, uint32_t bit)
+{
+	uint32_t w = bit / 8;
+	uint32_t off = bit % 8;
+
+	return ((uint8_t *)_mask)[w] & (1 << off);
+}
+
+static inline void SET_MASK_BIT(void *_mask, uint32_t bit)
+{
+	uint32_t byte = bit / 8;
+	uint32_t offset = bit % 8;
+	((uint8_t *)_mask)[byte] |= (1 << offset);
+}
+
+static int sdhci_cv181x_general_select_drive_strength(struct sdhci_host *host,
+		struct mmc_card *card, unsigned int max_dtr, int host_drv,
+		int card_drv, int *drv_type)
+{
+	return MMC_SET_DRIVER_TYPE_A;
+}
+
+static void sdhci_cvi_general_set_uhs_signaling(struct sdhci_host *host, unsigned int uhs)
+{
+	struct mmc_host *mmc = host->mmc;
+	u16 ctrl_2;
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	/* Select Bus Speed Mode for host */
+	ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
+	switch (uhs) {
+	case MMC_TIMING_UHS_SDR12:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR12;
+		break;
+	case MMC_TIMING_UHS_SDR25:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR25;
+		break;
+	case MMC_TIMING_UHS_SDR50:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR50;
+		break;
+	case MMC_TIMING_MMC_HS200:
+	case MMC_TIMING_UHS_SDR104:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR104;
+		break;
+	case MMC_TIMING_UHS_DDR50:
+	case MMC_TIMING_MMC_DDR52:
+		ctrl_2 |= SDHCI_CTRL_UHS_DDR50;
+		break;
+	}
+
+	/*
+	 * When clock frequency is less than 100MHz, the feedback clock must be
+	 * provided and DLL must not be used so that tuning can be skipped. To
+	 * provide feedback clock, the mode selection can be any value less
+	 * than 3'b011 in bits [2:0] of HOST CONTROL2 register.
+	 */
+	if (host->clock <= 100000000 &&
+	    (uhs == MMC_TIMING_MMC_HS400 ||
+	     uhs == MMC_TIMING_MMC_HS200 ||
+	     uhs == MMC_TIMING_UHS_SDR104))
+		ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
+
+	dev_dbg(mmc_dev(mmc), "%s: clock=%u uhs=%u ctrl_2=0x%x\n",
+		mmc_hostname(host->mmc), host->clock, uhs, ctrl_2);
+	sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
+}
+
+static unsigned int sdhci_cvi_general_get_max_clock(struct sdhci_host *host)
+{
+	pr_debug(DRIVER_NAME ":%s : %d\n", __func__, host->mmc->f_src);
+	return host->mmc->f_src;
+}
+
+/* Used for wifi driver due if no SD card detect pin implemented */
+static struct mmc_host *wifi_mmc;
+
+int cvi_sdio_rescan(void)
+{
+
+	if (!wifi_mmc) {
+		pr_err("invalid wifi mmc, please check the argument\n");
+		return -EINVAL;
+	}
+
+	mmc_detect_change(wifi_mmc, 0);
+
+	wifi_mmc->rescan_entered = 0;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(cvi_sdio_rescan);
+
+
+void sdhci_cvi_emmc_voltage_switch(struct sdhci_host *host)
+{
+}
+
+static void sdhci_cvi_cv181x_set_tap(struct sdhci_host *host, unsigned int tap)
+{
+	pr_debug("%s %d\n", __func__, tap);
+	// Set sd_clk_en(0x2c[2]) to 0
+	sdhci_writew(host, sdhci_readw(host, SDHCI_CLOCK_CONTROL) & (~(0x1 << 2)), SDHCI_CLOCK_CONTROL);
+	sdhci_writel(host,
+		sdhci_readl(host, CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R) & (~(BIT(1))),
+		CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R);
+	sdhci_writel(host, BIT(8) | tap << 16,
+		     CVI_CV181X_SDHCI_PHY_TX_RX_DLY);
+	sdhci_writel(host, 0, CVI_CV181X_SDHCI_PHY_CONFIG);
+	// Set sd_clk_en(0x2c[2]) to 1
+	sdhci_writew(host, sdhci_readw(host, SDHCI_CLOCK_CONTROL) | (0x1 << 2), SDHCI_CLOCK_CONTROL);
+	mdelay(1);
+}
+
+static int sdhci_cv181x_general_execute_tuning(struct sdhci_host *host, u32 opcode)
+{
+	u16 min = 0;
+	u32 k = 0;
+	s32 ret;
+	u32 retry_cnt = 0;
+
+	u32 tuning_result[4] = {0, 0, 0, 0};
+	u32 rx_lead_lag_result[4] = {0, 0, 0, 0};
+	char tuning_graph[TUNE_MAX_PHCODE+1];
+	char rx_lead_lag_graph[TUNE_MAX_PHCODE+1];
+
+	u32 reg = 0;
+	u32 reg_rx_lead_lag = 0;
+	s32 max_lead_lag_idx = -1;
+	s32 max_window_idx = -1;
+	s32 cur_window_idx = -1;
+	u16 max_lead_lag_size = 0;
+	u16 max_window_size = 0;
+	u16 cur_window_size = 0;
+	s32 rx_lead_lag_phase = -1;
+	s32 final_tap = -1;
+	u32 rate = 0;
+
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	reg = sdhci_readw(host, SDHCI_ERR_INT_STATUS);
+	pr_debug("%s : SDHCI_ERR_INT_STATUS 0x%x\n", mmc_hostname(host->mmc),
+		 reg);
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("%s : host ctrl2 0x%x\n", mmc_hostname(host->mmc), reg);
+	/* Set Host_CTRL2_R.SAMPLE_CLK_SEL=0 */
+	sdhci_writew(host,
+			 sdhci_readw(host, SDHCI_HOST_CONTROL2) & (~(0x1 << 7)),
+			 SDHCI_HOST_CONTROL2);
+	sdhci_writew(host,
+			 sdhci_readw(host, SDHCI_HOST_CONTROL2) & (~(0x3 << 4)),
+			 SDHCI_HOST_CONTROL2);
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("%s : host ctrl2 0x%x\n", mmc_hostname(host->mmc), reg);
+
+	while (min < TUNE_MAX_PHCODE) {
+		retry_cnt = 0;
+		sdhci_cvi_cv181x_set_tap(host, min);
+		reg_rx_lead_lag = sdhci_readw(host, CVI_CV181X_SDHCI_PHY_DLY_STS) & BIT(1);
+
+retry_tuning:
+		ret = mmc_send_tuning(host->mmc, opcode, NULL);
+
+		if (!ret && retry_cnt < MAX_TUNING_CMD_RETRY_COUNT) {
+			retry_cnt++;
+			goto retry_tuning;
+		}
+
+		if (ret) {
+			SET_MASK_BIT(tuning_result, min);
+		}
+
+		if (reg_rx_lead_lag) {
+			SET_MASK_BIT(rx_lead_lag_result, min);
+		}
+
+		min++;
+	}
+
+	reset_after_tuning_pass(host);
+
+	pr_debug("tuning result:      0x%08x 0x%08x 0x%08x 0x%08x\n",
+		tuning_result[0], tuning_result[1], tuning_result[2], tuning_result[3]);
+	pr_debug("rx_lead_lag result: 0x%08x 0x%08x 0x%08x 0x%08x\n",
+		rx_lead_lag_result[0], rx_lead_lag_result[1], rx_lead_lag_result[2], rx_lead_lag_result[3]);
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(tuning_result, k) == 0)
+			tuning_graph[k] = '-';
+		else
+			tuning_graph[k] = 'x';
+		if (CHECK_MASK_BIT(rx_lead_lag_result, k) == 0)
+			rx_lead_lag_graph[k] = '0';
+		else
+			rx_lead_lag_graph[k] = '1';
+	}
+	tuning_graph[TUNE_MAX_PHCODE] = '\0';
+	rx_lead_lag_graph[TUNE_MAX_PHCODE] = '\0';
+
+	pr_debug("tuning graph:      %s\n", tuning_graph);
+	pr_debug("rx_lead_lag graph: %s\n", rx_lead_lag_graph);
+
+	// Find a final tap as median of maximum window
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(tuning_result, k) == 0) {
+			if (-1 == cur_window_idx) {
+				cur_window_idx = k;
+			}
+			cur_window_size++;
+
+			if (cur_window_size > max_window_size) {
+				max_window_size = cur_window_size;
+				max_window_idx = cur_window_idx;
+				if (max_window_size >= TAP_WINDOW_THLD)
+					final_tap = cur_window_idx + (max_window_size/2);
+			}
+		} else {
+			cur_window_idx = -1;
+			cur_window_size = 0;
+		}
+	}
+
+	cur_window_idx = -1;
+	cur_window_size = 0;
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(rx_lead_lag_result, k) == 0) {
+			//from 1 to 0 and window_size already computed.
+			if ((rx_lead_lag_phase == 1) && (cur_window_size > 0)) {
+				max_lead_lag_idx = cur_window_idx;
+				max_lead_lag_size = cur_window_size;
+				break;
+			}
+			if (cur_window_idx == -1) {
+				cur_window_idx = k;
+			}
+			cur_window_size++;
+			rx_lead_lag_phase = 0;
+		} else {
+			rx_lead_lag_phase = 1;
+			if ((cur_window_idx != -1) && (cur_window_size > 0)) {
+				cur_window_size++;
+				max_lead_lag_idx = cur_window_idx;
+				max_lead_lag_size = cur_window_size;
+			} else {
+				cur_window_size = 0;
+			}
+		}
+	}
+	rate = max_window_size * 100 / max_lead_lag_size;
+	pr_debug("MaxWindow[Idx, Width]:[%d,%u] Tuning Tap: %d\n", max_window_idx, max_window_size, final_tap);
+	pr_debug("RX_LeadLag[Idx, Width]:[%d,%u] rate = %d\n", max_lead_lag_idx, max_lead_lag_size, rate);
+
+	sdhci_cvi_cv181x_set_tap(host, final_tap);
+	cvi_host->final_tap = final_tap;
+	pr_debug("%s finished tuning, code:%d\n", __func__, final_tap);
+
+	return mmc_send_tuning(host->mmc, opcode, NULL);
+}
+
+static void sdhci_cv181x_emmc_reset(struct sdhci_host *host, u8 mask)
+{
+	u16 ctrl_2;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s mask = 0x%x\n", __func__, mask);
+	sdhci_cvi_reset_helper(host, mask);
+
+	//reg_0x200[0] = 1 for mmc
+	sdhci_writel(host,
+			 sdhci_readl(host, CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(0),
+			 CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R);
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctrl_2 &= SDHCI_CTRL_UHS_MASK;
+	if (ctrl_2 == SDHCI_CTRL_UHS_SDR104) {
+		//reg_0x200[1] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R) & ~(BIT(1)),
+			CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV181X_SDHCI_PHY_CONFIG) & ~(BIT(0)),
+			CVI_CV181X_SDHCI_PHY_CONFIG);
+		//reg_0x240[22:16] = tap reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host,
+			(BIT(8) | ((cvi_host->final_tap & 0x7F) << 16)),
+			CVI_CV181X_SDHCI_PHY_TX_RX_DLY);
+	} else {
+		//Reset as DS/HS setting.
+		//reg_0x200[1] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(1),
+			CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV181X_SDHCI_PHY_CONFIG) | BIT(0),
+			CVI_CV181X_SDHCI_PHY_CONFIG);
+		//reg_0x240[25:24] = 1 reg_0x240[22:16] = 0 reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host, 0x1000100, CVI_CV181X_SDHCI_PHY_TX_RX_DLY);
+	}
+}
+
+static void sdhci_cv181x_sd_reset(struct sdhci_host *host, u8 mask)
+{
+	u16 ctrl_2;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s mask = 0x%x\n", __func__, mask);
+	sdhci_cvi_reset_helper(host, mask);
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctrl_2 &= SDHCI_CTRL_UHS_MASK;
+	if (ctrl_2 == SDHCI_CTRL_UHS_SDR104) {
+		//reg_0x200[1] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R) & ~(BIT(1)),
+			CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV181X_SDHCI_PHY_CONFIG) & ~(BIT(0)),
+			CVI_CV181X_SDHCI_PHY_CONFIG);
+		//reg_0x240[22:16] = tap reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host,
+			(BIT(8) | ((cvi_host->final_tap & 0x7F) << 16)),
+			CVI_CV181X_SDHCI_PHY_TX_RX_DLY);
+	} else {
+		//Reset as DS/HS setting.
+		//reg_0x200[1] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(1),
+			CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV181X_SDHCI_PHY_CONFIG) | BIT(0),
+			CVI_CV181X_SDHCI_PHY_CONFIG);
+		//reg_0x240[25:24] = 1 reg_0x240[22:16] = 0 reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host, 0x1000100, CVI_CV181X_SDHCI_PHY_TX_RX_DLY);
+	}
+}
+
+static void sdhci_cv181x_sdio_reset(struct sdhci_host *host, u8 mask)
+{
+	u16 ctrl_2;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s mask = 0x%x\n", __func__, mask);
+	sdhci_cvi_reset_helper(host, mask);
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctrl_2 &= SDHCI_CTRL_UHS_MASK;
+	if (ctrl_2 == SDHCI_CTRL_UHS_SDR104) {
+		//reg_0x200[1] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R) & ~(BIT(1)),
+			CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x200[16] = 1 for sd1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(16),
+			CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV181X_SDHCI_PHY_CONFIG) & ~(BIT(0)),
+			CVI_CV181X_SDHCI_PHY_CONFIG);
+		//reg_0x240[22:16] = tap reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host,
+			(BIT(8) | ((cvi_host->final_tap & 0x7F) << 16)),
+			CVI_CV181X_SDHCI_PHY_TX_RX_DLY);
+	} else {
+		//Reset as DS/HS setting.
+		//reg_0x200[1] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(1),
+			CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x200[16] = 1 for sd1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(16),
+			CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_CV181X_SDHCI_PHY_CONFIG) | BIT(0),
+			CVI_CV181X_SDHCI_PHY_CONFIG);
+		//reg_0x240[25:24] = 1 reg_0x240[22:16] = 0 reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host, 0x1000100, CVI_CV181X_SDHCI_PHY_TX_RX_DLY);
+	}
+}
+
+void sdhci_cv181x_sd_voltage_switch(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s\n", __func__);
+
+	// enable SDIO0_CLK[7:5] to set CLK max strengh
+	writeb((readb(cvi_host->pinmuxbase + 0xA00) | BIT(7) | BIT(6) | BIT(5)),
+		cvi_host->pinmuxbase + 0xA00);
+
+	//Voltage switching flow (1.8v)
+	//reg_pwrsw_auto=1, reg_pwrsw_disc=0, pwrsw_vsel=1(1.8v), reg_en_pwrsw=1
+	writel(0xB | (readl(cvi_host->topbase + OFFSET_SD_PWRSW_CTRL) & 0xFFFFFFF0),
+		cvi_host->topbase + OFFSET_SD_PWRSW_CTRL);
+	pr_debug("sd PWRSW 0x%x\n", readl(cvi_host->topbase + OFFSET_SD_PWRSW_CTRL));
+	cvi_host->sdio0_voltage_1_8_v = 1;
+
+	mdelay(1);
+}
+
+void sdhci_cv181x_sd_voltage_restore(struct sdhci_host *host, bool bunplug)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s\n", __func__);
+
+	if (bunplug) {
+		//Voltage close flow
+		//(reg_pwrsw_auto=1, reg_pwrsw_disc=1, reg_pwrsw_vsel=1(1.8v), reg_en_pwrsw=0)
+		writel(0xE | (readl(cvi_host->topbase + OFFSET_SD_PWRSW_CTRL) & 0xFFFFFFF0),
+			cvi_host->topbase + OFFSET_SD_PWRSW_CTRL);
+		cvi_host->sdio0_voltage_1_8_v = 0;
+	} else {
+		if (!cvi_host->sdio0_voltage_1_8_v) {
+			//Voltage switching flow (3.3)
+			//(reg_pwrsw_auto=1, reg_pwrsw_disc=0, reg_pwrsw_vsel=0(3.0v), reg_en_pwrsw=1)
+			writel(0x9 | (readl(cvi_host->topbase + OFFSET_SD_PWRSW_CTRL) & 0xFFFFFFF0),
+				cvi_host->topbase + OFFSET_SD_PWRSW_CTRL);
+		}
+	}
+
+	//wait 1ms
+	mdelay(1);
+
+	// restore to DS/HS setting
+	sdhci_writel(host,
+		sdhci_readl(host, CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(1) | BIT(8) | BIT(9),
+		CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R);
+	sdhci_writel(host, 0x1000100, CVI_CV181X_SDHCI_PHY_TX_RX_DLY);
+	sdhci_writel(host, 1, CVI_CV181X_SDHCI_PHY_CONFIG);
+
+	mdelay(1);
+}
+
+static void sdhci_cv181x_sd_set_power(struct sdhci_host *host, unsigned char mode,
+				unsigned short vdd)
+{
+	struct mmc_host *mmc = host->mmc;
+
+	pr_debug("%s:mode %u, vdd %u\n", __func__, mode, vdd);
+
+	if (mode == MMC_POWER_ON && mmc->ops->get_cd(mmc)) {
+		sdhci_set_power_noreg(host, mode, vdd);
+		sdhci_cv181x_sd_voltage_restore(host, false);
+		sdhci_cv181x_sd_setup_pad(host, false);
+		sdhci_cv181x_sd_setup_io(host, false);
+		mdelay(5);
+	} else if (mode == MMC_POWER_OFF) {
+		sdhci_cv181x_sd_setup_pad(host, true);
+		sdhci_cv181x_sd_setup_io(host, true);
+		sdhci_cv181x_sd_voltage_restore(host, true);
+		sdhci_set_power_noreg(host, mode, vdd);
+		mdelay(30);
+	}
+}
+
+static void sdhci_cv181x_emmc_dump_vendor_regs(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+	u8 clk_source_select = 0;
+	u8 PAD_EMMC_RSTN = 0;
+	u8 PAD_EMMC_CLK  = 0;
+	u8 PAD_EMMC_CMD  = 0;
+	u8 PAD_EMMC_DAT0 = 0;
+	u8 PAD_EMMC_DAT1 = 0;
+	u8 PAD_EMMC_DAT2 = 0;
+	u8 PAD_EMMC_DAT3 = 0;
+	u8 REG_EMMC_RSTN = 0;
+	u8 REG_EMMC_CLK  = 0;
+	u8 REG_EMMC_CMD  = 0;
+	u8 REG_EMMC_DAT0 = 0;
+	u8 REG_EMMC_DAT1 = 0;
+	u8 REG_EMMC_DAT2 = 0;
+	u8 REG_EMMC_DAT3 = 0;
+
+	SDHCI_DUMP(": Reg_200:   0x%08x | Reg_240:  0x%08x\n",
+		   sdhci_readl(host, CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R),
+		   sdhci_readl(host, CVI_CV181X_SDHCI_PHY_TX_RX_DLY));
+	SDHCI_DUMP(": Reg_244:   0x%08x | Reg_248:  0x%08x\n",
+		   sdhci_readl(host, CVI_CV181X_SDHCI_PHY_DS_DLY),
+		   sdhci_readw(host, CVI_CV181X_SDHCI_PHY_DLY_STS));
+	SDHCI_DUMP(": Reg_24C:   0x%08x\n",
+		   sdhci_readl(host, CVI_CV181X_SDHCI_PHY_CONFIG));
+
+	PAD_EMMC_RSTN = readb(cvi_host->pinmuxbase + 0x48) & 0x07;
+	PAD_EMMC_CLK  = readb(cvi_host->pinmuxbase + 0x50) & 0x07;
+	PAD_EMMC_CMD  = readb(cvi_host->pinmuxbase + 0x5C) & 0x07;
+	PAD_EMMC_DAT0 = readb(cvi_host->pinmuxbase + 0x54) & 0x07;
+	PAD_EMMC_DAT1 = readb(cvi_host->pinmuxbase + 0x60) & 0x07;
+	PAD_EMMC_DAT2 = readb(cvi_host->pinmuxbase + 0x4C) & 0x07;
+	PAD_EMMC_DAT3 = readb(cvi_host->pinmuxbase + 0x58) & 0x07;
+	REG_EMMC_RSTN = readb(cvi_host->pinmuxbase + 0x914);
+	REG_EMMC_CLK  = readb(cvi_host->pinmuxbase + 0x91D);
+	REG_EMMC_CMD  = readb(cvi_host->pinmuxbase + 0x928);
+	REG_EMMC_DAT0 = readb(cvi_host->pinmuxbase + 0x920);
+	REG_EMMC_DAT1 = readb(cvi_host->pinmuxbase + 0x92D);
+	REG_EMMC_DAT2 = readb(cvi_host->pinmuxbase + 0x918);
+	REG_EMMC_DAT3 = readb(cvi_host->pinmuxbase + 0x924);
+
+	SDHCI_DUMP(": PAD_EMMC_RSTN:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_RSTN, (REG_EMMC_RSTN & 0x04)>>2, (REG_EMMC_RSTN & 0x08)>>3,
+		(REG_EMMC_RSTN & 0x80)>>7, (REG_EMMC_RSTN & 0x40)>>6, (REG_EMMC_RSTN & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_CLK:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_CLK, (REG_EMMC_CLK & 0x04)>>2, (REG_EMMC_CLK & 0x08)>>3,
+		(REG_EMMC_CLK & 0x80)>>7, (REG_EMMC_CLK & 0x40)>>6, (REG_EMMC_CLK & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_CMD:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_CMD, (REG_EMMC_CMD & 0x04)>>2, (REG_EMMC_CMD & 0x08)>>3,
+		(REG_EMMC_CMD & 0x80)>>7, (REG_EMMC_CMD & 0x40)>>6, (REG_EMMC_CMD & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_DAT0:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_DAT0, (REG_EMMC_DAT0 & 0x04)>>2, (REG_EMMC_DAT0 & 0x08)>>3,
+		(REG_EMMC_DAT0 & 0x80)>>7, (REG_EMMC_DAT0 & 0x40)>>6, (REG_EMMC_DAT0 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_DAT1:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_DAT1, (REG_EMMC_DAT1 & 0x04)>>2, (REG_EMMC_DAT1 & 0x08)>>3,
+		(REG_EMMC_DAT1 & 0x80)>>7, (REG_EMMC_DAT1 & 0x40)>>6, (REG_EMMC_DAT1 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_DAT2:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_DAT2, (REG_EMMC_DAT2 & 0x04)>>2, (REG_EMMC_DAT2 & 0x08)>>3,
+		(REG_EMMC_DAT2 & 0x80)>>7, (REG_EMMC_DAT2 & 0x40)>>6, (REG_EMMC_DAT2 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_DAT3:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_DAT3, (REG_EMMC_DAT3 & 0x04)>>2, (REG_EMMC_DAT3 & 0x08)>>3,
+		(REG_EMMC_DAT3 & 0x80)>>7, (REG_EMMC_DAT3 & 0x40)>>6, (REG_EMMC_DAT3 & 0x20)>>5);
+
+	clk_source_select = (readb(cvi_host->clkgenbase + 0x20) & 0x20) >> 5;
+
+	SDHCI_DUMP(": clk_emmc enable[16]:0x%08x\n", readl(cvi_host->clkgenbase));
+	SDHCI_DUMP(": clk_emmc source_select:%u\n", clk_source_select);
+	if (clk_source_select == 0) {
+		SDHCI_DUMP(": clk_emmc REG:0x03002068 = 0x%08x\n",
+		readl(cvi_host->clkgenbase + 0x68));
+		if (readl(cvi_host->clkgenbase + 0x68) == 0x00000001)
+			SDHCI_DUMP(": clk_emmc %d MHz\n", DISPPLL_MHZ/12);
+	} else if (clk_source_select == 1) {
+		SDHCI_DUMP(": clk_emmc REG:0x03002064 = 0x%08x\n",
+		readl(cvi_host->clkgenbase + 0x64));
+		if (readl(cvi_host->clkgenbase + 0x64) == 0x00040009)
+			SDHCI_DUMP(": clk_emmc %d MHz\n", FPLL_MHZ/4);
+	}
+}
+
+static void sdhci_cv181x_sd_dump_vendor_regs(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+	u8 clk_source_select = 0;
+	u8 PAD_SDIO0_PWR_EN = 0;
+	u8 PAD_SDIO0_CD  = 0;
+	u8 PAD_SDIO0_CLK = 0;
+	u8 PAD_SDIO0_CMD = 0;
+	u8 PAD_SDIO0_D0  = 0;
+	u8 PAD_SDIO0_D1  = 0;
+	u8 PAD_SDIO0_D2  = 0;
+	u8 PAD_SDIO0_D3  = 0;
+	u8 REG_SDIO0_PWR_EN = 0;
+	u8 REG_SDIO0_CD  = 0;
+	u8 REG_SDIO0_CLK = 0;
+	u8 REG_SDIO0_CMD = 0;
+	u8 REG_SDIO0_D0  = 0;
+	u8 REG_SDIO0_D1  = 0;
+	u8 REG_SDIO0_D2  = 0;
+	u8 REG_SDIO0_D3  = 0;
+
+	SDHCI_DUMP(": Reg_200:   0x%08x | Reg_240:  0x%08x\n",
+		   sdhci_readl(host, CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R),
+		   sdhci_readl(host, CVI_CV181X_SDHCI_PHY_TX_RX_DLY));
+	SDHCI_DUMP(": Reg_244:   0x%08x | Reg_248:  0x%08x\n",
+		   sdhci_readl(host, CVI_CV181X_SDHCI_PHY_DS_DLY),
+		   sdhci_readw(host, CVI_CV181X_SDHCI_PHY_DLY_STS));
+	SDHCI_DUMP(": Reg_24C:   0x%08x | unplugg:  0x%08x\n",
+		   sdhci_readl(host, CVI_CV181X_SDHCI_PHY_CONFIG),
+		   host->mmc->ever_unplugged);
+
+	PAD_SDIO0_PWR_EN = readb(cvi_host->pinmuxbase + 0x38) & 0x07;
+	PAD_SDIO0_CD  = readb(cvi_host->pinmuxbase + 0x34) & 0x07;
+	PAD_SDIO0_CLK = readb(cvi_host->pinmuxbase + 0x1C) & 0x07;
+	PAD_SDIO0_CMD = readb(cvi_host->pinmuxbase + 0x20) & 0x07;
+	PAD_SDIO0_D0  = readb(cvi_host->pinmuxbase + 0x24) & 0x07;
+	PAD_SDIO0_D1  = readb(cvi_host->pinmuxbase + 0x28) & 0x07;
+	PAD_SDIO0_D2  = readb(cvi_host->pinmuxbase + 0x2C) & 0x07;
+	PAD_SDIO0_D3  = readb(cvi_host->pinmuxbase + 0x30) & 0x07;
+	REG_SDIO0_PWR_EN = readb(cvi_host->pinmuxbase + 0x904);
+	REG_SDIO0_CD  = readb(cvi_host->pinmuxbase + 0x900);
+	REG_SDIO0_CLK = readb(cvi_host->pinmuxbase + 0xA00);
+	REG_SDIO0_CMD = readb(cvi_host->pinmuxbase + 0xA04);
+	REG_SDIO0_D0  = readb(cvi_host->pinmuxbase + 0xA08);
+	REG_SDIO0_D1  = readb(cvi_host->pinmuxbase + 0xA0C);
+	REG_SDIO0_D2  = readb(cvi_host->pinmuxbase + 0xA10);
+	REG_SDIO0_D3  = readb(cvi_host->pinmuxbase + 0xA14);
+
+	SDHCI_DUMP(": PAD_SDIO0_PWR_EN:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_PWR_EN, (REG_SDIO0_PWR_EN & 0x04)>>2, (REG_SDIO0_PWR_EN & 0x08)>>3,
+		(REG_SDIO0_PWR_EN & 0x80)>>7, (REG_SDIO0_PWR_EN & 0x40)>>6, (REG_SDIO0_PWR_EN & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_CD:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_CD, (REG_SDIO0_CD & 0x04)>>2, (REG_SDIO0_CD & 0x08)>>3,
+		(REG_SDIO0_CD & 0x80)>>7, (REG_SDIO0_CD & 0x40)>>6, (REG_SDIO0_CD & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_CLK:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_CLK, (REG_SDIO0_CLK & 0x04)>>2, (REG_SDIO0_CLK & 0x08)>>3,
+		(REG_SDIO0_CLK & 0x80)>>7, (REG_SDIO0_CLK & 0x40)>>6, (REG_SDIO0_CLK & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_CMD:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_CMD, (REG_SDIO0_CMD & 0x04)>>2, (REG_SDIO0_CMD & 0x08)>>3,
+		(REG_SDIO0_CMD & 0x80)>>7, (REG_SDIO0_CMD & 0x40)>>6, (REG_SDIO0_CMD & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_D0:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_D0, (REG_SDIO0_D0 & 0x04)>>2, (REG_SDIO0_D0 & 0x08)>>3,
+		(REG_SDIO0_D0 & 0x80)>>7, (REG_SDIO0_D0 & 0x40)>>6, (REG_SDIO0_D0 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_D1:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_D1, (REG_SDIO0_D1 & 0x04)>>2, (REG_SDIO0_D1 & 0x08)>>3,
+		(REG_SDIO0_D1 & 0x80)>>7, (REG_SDIO0_D1 & 0x40)>>6, (REG_SDIO0_D1 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_D2:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_D2, (REG_SDIO0_D2 & 0x04)>>2, (REG_SDIO0_D2 & 0x08)>>3,
+		(REG_SDIO0_D2 & 0x80)>>7, (REG_SDIO0_D2 & 0x40)>>6, (REG_SDIO0_D2 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_D3:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_D3, (REG_SDIO0_D3 & 0x04)>>2, (REG_SDIO0_D3 & 0x08)>>3,
+		(REG_SDIO0_D3 & 0x80)>>7, (REG_SDIO0_D3 & 0x40)>>6, (REG_SDIO0_D3 & 0x20)>>5);
+
+	clk_source_select = (readb(cvi_host->clkgenbase + 0x20) & 0x40) >> 6;
+
+	SDHCI_DUMP(": clk_sd0 enable[19]:0x%08x\n", readl(cvi_host->clkgenbase));
+	SDHCI_DUMP(": clk_sd0 source_select:%u\n", clk_source_select);
+	if (clk_source_select == 0) {
+		SDHCI_DUMP(": clk_sd0 REG:0x03002074 = 0x%08x\n",
+		readl(cvi_host->clkgenbase + 0x74));
+		if (readl(cvi_host->clkgenbase + 0x74) == 0x00000001)
+			SDHCI_DUMP(": clk_sd0 %d MHz\n", DISPPLL_MHZ/12);
+	} else if (clk_source_select == 1) {
+		SDHCI_DUMP(": clk_sd0 REG:0x03002070 = 0x%08x\n",
+		readl(cvi_host->clkgenbase + 0x70));
+		if (readl(cvi_host->clkgenbase + 0x70) == 0x00040009)
+			SDHCI_DUMP(": clk_sd0 %d MHz\n", FPLL_MHZ/4);
+	}
+}
+
+static const struct sdhci_ops sdhci_cv181x_emmc_ops = {
+	.reset = sdhci_cv181x_emmc_reset,
+	.set_clock = sdhci_set_clock,
+	.set_bus_width = sdhci_set_bus_width,
+	.get_max_clock = sdhci_cvi_general_get_max_clock,
+	.voltage_switch = sdhci_cvi_emmc_voltage_switch,
+	.set_uhs_signaling = sdhci_cvi_general_set_uhs_signaling,
+	.platform_execute_tuning = sdhci_cv181x_general_execute_tuning,
+	.select_drive_strength = sdhci_cv181x_general_select_drive_strength,
+	.dump_vendor_regs = sdhci_cv181x_emmc_dump_vendor_regs,
+};
+
+static const struct sdhci_ops sdhci_cv181x_sd_ops = {
+	.reset = sdhci_cv181x_sd_reset,
+	.set_clock = sdhci_set_clock,
+	.set_power = sdhci_cv181x_sd_set_power,
+	.set_bus_width = sdhci_set_bus_width,
+	.get_max_clock = sdhci_cvi_general_get_max_clock,
+	.voltage_switch = sdhci_cv181x_sd_voltage_switch,
+	.set_uhs_signaling = sdhci_cvi_general_set_uhs_signaling,
+	.platform_execute_tuning = sdhci_cv181x_general_execute_tuning,
+	.select_drive_strength = sdhci_cv181x_general_select_drive_strength,
+	.dump_vendor_regs = sdhci_cv181x_sd_dump_vendor_regs,
+};
+
+static const struct sdhci_ops sdhci_cv181x_sdio_ops = {
+	.reset = sdhci_cv181x_sdio_reset,
+	.set_clock = sdhci_set_clock,
+	.set_bus_width = sdhci_set_bus_width,
+	.get_max_clock = sdhci_cvi_general_get_max_clock,
+	.voltage_switch = sdhci_cv181x_sd_voltage_switch,
+	.set_uhs_signaling = sdhci_cvi_general_set_uhs_signaling,
+	.select_drive_strength = sdhci_cv181x_general_select_drive_strength,
+	.platform_execute_tuning = sdhci_cv181x_general_execute_tuning,
+};
+
+static const struct sdhci_ops sdhci_cv181x_fpga_emmc_ops = {
+	.reset = sdhci_cv181x_sd_reset,
+	.set_clock = sdhci_set_clock,
+	.set_bus_width = sdhci_set_bus_width,
+	.get_max_clock = sdhci_cvi_general_get_max_clock,
+	.voltage_switch = sdhci_cvi_emmc_voltage_switch,
+	.set_uhs_signaling = sdhci_cvi_general_set_uhs_signaling,
+	.platform_execute_tuning = sdhci_cv181x_general_execute_tuning,
+	.select_drive_strength = sdhci_cv181x_general_select_drive_strength,
+	.dump_vendor_regs = sdhci_cv181x_emmc_dump_vendor_regs,
+};
+
+static const struct sdhci_ops sdhci_cv181x_fpga_sd_ops = {
+	.reset = sdhci_cv181x_sd_reset,
+	.set_clock = sdhci_set_clock,
+	.set_power = sdhci_cv181x_sd_set_power,
+	.set_bus_width = sdhci_set_bus_width,
+	.get_max_clock = sdhci_cvi_general_get_max_clock,
+	.voltage_switch = sdhci_cv181x_sd_voltage_switch,
+	.set_uhs_signaling = sdhci_cvi_general_set_uhs_signaling,
+	.platform_execute_tuning = sdhci_cv181x_general_execute_tuning,
+	.select_drive_strength = sdhci_cv181x_general_select_drive_strength,
+	.dump_vendor_regs = sdhci_cv181x_sd_dump_vendor_regs,
+};
+
+static const struct sdhci_pltfm_data sdhci_cv181x_emmc_pdata = {
+	.ops = &sdhci_cv181x_emmc_ops,
+	.quirks = SDHCI_QUIRK_INVERTED_WRITE_PROTECT | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
+};
+
+static const struct sdhci_pltfm_data sdhci_cv181x_sd_pdata = {
+	.ops = &sdhci_cv181x_sd_ops,
+	.quirks = SDHCI_QUIRK_INVERTED_WRITE_PROTECT | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
+};
+
+static const struct sdhci_pltfm_data sdhci_cv181x_sdio_pdata = {
+	.ops = &sdhci_cv181x_sdio_ops,
+	.quirks = SDHCI_QUIRK_INVERTED_WRITE_PROTECT | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN | SDHCI_QUIRK2_NO_1_8_V,
+};
+
+static const struct sdhci_pltfm_data sdhci_cv181x_fpga_emmc_pdata = {
+	.ops = &sdhci_cv181x_fpga_emmc_ops,
+	.quirks = SDHCI_QUIRK_INVERTED_WRITE_PROTECT | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN | SDHCI_QUIRK2_BROKEN_HS200,
+};
+
+static const struct sdhci_pltfm_data sdhci_cv181x_fpga_sd_pdata = {
+	.ops = &sdhci_cv181x_fpga_sd_ops,
+	.quirks = SDHCI_QUIRK_INVERTED_WRITE_PROTECT | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN | SDHCI_QUIRK2_NO_1_8_V,
+};
+
+static const struct of_device_id sdhci_cvi_dt_match[] = {
+	{.compatible = "cvitek,cv181x-fpga-emmc", .data = &sdhci_cv181x_fpga_emmc_pdata},
+	{.compatible = "cvitek,cv181x-fpga-sd", .data = &sdhci_cv181x_fpga_sd_pdata},
+	{.compatible = "cvitek,cv181x-emmc", .data = &sdhci_cv181x_emmc_pdata},
+	{.compatible = "cvitek,cv181x-sd", .data = &sdhci_cv181x_sd_pdata},
+	{.compatible = "cvitek,cv181x-sdio", .data = &sdhci_cv181x_sdio_pdata},
+
+	{ /* sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(of, sdhci_cvi_dt_match);
+
+static unsigned long sdhci_get_time_ms(void)
+{
+	ktime_t cur;
+
+	cur = ktime_get();
+	// Get milliseconds
+	return ktime_to_ms(cur);
+}
+
+static void sdhci_cvi_cd_debounce_work(struct work_struct *work)
+{
+	struct sdhci_cvi_host *cvi_host = container_of(work, struct sdhci_cvi_host,
+						  cd_debounce_work.work);
+	struct mmc_host *host = cvi_host->mmc;
+	unsigned long start_time = sdhci_get_time_ms();
+	int pre_gpio_cd;
+	unsigned long flag;
+
+	spin_lock_irqsave(&cvi_host->cd_debounce_lock, flag);
+	pre_gpio_cd = cvi_host->pre_gpio_cd;
+	cvi_host->is_debounce_work_running = true;
+	spin_unlock_irqrestore(&cvi_host->cd_debounce_lock, flag);
+
+	while (1) {
+		if ((sdhci_get_time_ms() - start_time) >= SDHCI_GPIO_CD_DEBOUNCE_TIME) {
+			if (pre_gpio_cd == mmc_gpio_get_cd(host)) {
+				host->ops->card_event(host);
+				mmc_detect_change(host, msecs_to_jiffies(SDHCI_GPIO_CD_DEBOUNCE_DELAY_TIME));
+				break;
+			}
+			pre_gpio_cd = mmc_gpio_get_cd(host);
+			start_time = sdhci_get_time_ms();
+		}
+	}
+
+	spin_lock_irqsave(&cvi_host->cd_debounce_lock, flag);
+	cvi_host->is_debounce_work_running = false;
+	spin_unlock_irqrestore(&cvi_host->cd_debounce_lock, flag);
+}
+
+static irqreturn_t sdhci_cvi_cd_handler(int irq, void *dev_id)
+{
+	/* Schedule a card detection after a debounce timeout */
+	struct mmc_host *host = dev_id;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(mmc_priv(host));
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+	unsigned long flag;
+
+	spin_lock_irqsave(&cvi_host->cd_debounce_lock, flag);
+	cvi_host->pre_gpio_cd = mmc_gpio_get_cd(host);
+	if (!cvi_host->pre_gpio_cd)
+		host->ever_unplugged = true;
+	if (!cvi_host->is_debounce_work_running) {
+		cancel_delayed_work(&cvi_host->cd_debounce_work);
+		schedule_delayed_work(&cvi_host->cd_debounce_work, 0);
+	}
+	spin_unlock_irqrestore(&cvi_host->cd_debounce_lock, flag);
+
+	return IRQ_HANDLED;
+}
+
+static int sdhci_cvi_probe(struct platform_device *pdev)
+{
+	struct sdhci_host *host;
+	struct sdhci_pltfm_host *pltfm_host;
+	struct sdhci_cvi_host *cvi_host;
+	const struct of_device_id *match;
+	const struct sdhci_pltfm_data *pdata;
+	int ret;
+	int gpio_cd = -EINVAL;
+
+	pr_info(DRIVER_NAME ":%s\n", __func__);
+
+	match = of_match_device(sdhci_cvi_dt_match, &pdev->dev);
+	if (!match)
+		return -EINVAL;
+
+	pdata = match->data;
+
+	host = sdhci_pltfm_init(pdev, pdata, sizeof(*cvi_host));
+	if (IS_ERR(host))
+		return PTR_ERR(host);
+
+	pltfm_host = sdhci_priv(host);
+	cvi_host = sdhci_pltfm_priv(pltfm_host);
+	cvi_host->host = host;
+	cvi_host->mmc = host->mmc;
+	cvi_host->pdev = pdev;
+	cvi_host->core_mem = host->ioaddr;
+	cvi_host->topbase = ioremap(TOP_BASE, 0x2000);
+	cvi_host->pinmuxbase = ioremap(PINMUX_BASE, 0x1000);
+	cvi_host->clkgenbase = ioremap(CLKGEN_BASE, 0x100);
+
+	sdhci_cv181x_sd_voltage_restore(host, false);
+
+	ret = mmc_of_parse(host->mmc);
+	if (ret)
+		goto pltfm_free;
+
+	sdhci_get_of_property(pdev);
+
+	if (pdata->ops->hw_reset) {
+		cvi_host->reset = devm_reset_control_get(&pdev->dev, "sdio");
+		if (IS_ERR(cvi_host->reset)) {
+			ret = PTR_ERR(cvi_host->reset);
+			goto pltfm_free;
+		}
+	}
+
+	if (pdev->dev.of_node) {
+		gpio_cd = of_get_named_gpio(pdev->dev.of_node, "cvi-cd-gpios", 0);
+	}
+
+	if (gpio_is_valid(gpio_cd)) {
+		cvi_host->cvi_gpio = devm_kzalloc(&cvi_host->pdev->dev,
+					sizeof(struct mmc_gpio), GFP_KERNEL);
+		if (cvi_host->cvi_gpio) {
+			cvi_host->cvi_gpio->cd_gpio_isr = sdhci_cvi_cd_handler;
+			cvi_host->cvi_gpio->cd_debounce_delay_ms = SDHCI_GPIO_CD_DEBOUNCE_DELAY_TIME;
+			cvi_host->cvi_gpio->cd_label = devm_kzalloc(&cvi_host->pdev->dev,
+						strlen("cd-gpio-irq") + 1, GFP_KERNEL);
+			strcpy(cvi_host->cvi_gpio->cd_label, "cd-gpio-irq");
+			host->mmc->slot.handler_priv = cvi_host->cvi_gpio;
+			ret = mmc_gpiod_request_cd(host->mmc, "cvi-cd",
+					0, false, SDHCI_GPIO_CD_DEBOUNCE_TIME);
+			if (ret) {
+				pr_err("card detect request cd failed: %d\n", ret);
+			} else {
+				writeb(0x3, cvi_host->pinmuxbase + 0x34);
+				INIT_DELAYED_WORK(&cvi_host->cd_debounce_work, sdhci_cvi_cd_debounce_work);
+				spin_lock_init(&cvi_host->cd_debounce_lock);
+				mmc_gpiod_request_cd_irq(host->mmc);
+			}
+		}
+	}
+
+	ret = sdhci_add_host(host);
+	if (ret)
+		goto err_add_host;
+
+	platform_set_drvdata(pdev, cvi_host);
+
+	if (strstr(dev_name(mmc_dev(host->mmc)), "wifi-sd"))
+		wifi_mmc = host->mmc;
+	else
+		wifi_mmc = NULL;
+
+	/* device proc entry */
+	if ((!proc_cvi_dir) &&
+		(strstr(dev_name(mmc_dev(host->mmc)), "cv-sd"))) {
+		ret = cvi_proc_init(cvi_host);
+		if (ret)
+			pr_err("device proc init is failed!");
+	}
+
+	if (strstr(dev_name(mmc_dev(host->mmc)), "cv-emmc"))
+		sdhci_cv181x_emmc_setup_pad(host);
+
+	return 0;
+
+err_add_host:
+pltfm_free:
+	sdhci_pltfm_free(pdev);
+	return ret;
+}
+
+static int sdhci_cvi_remove(struct platform_device *pdev)
+{
+	struct sdhci_host *host = platform_get_drvdata(pdev);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+	int dead = (readl_relaxed(host->ioaddr + SDHCI_INT_STATUS) == 0xffffffff);
+
+	sdhci_remove_host(host, dead);
+	sdhci_pltfm_free(pdev);
+
+	cvi_proc_shutdown(cvi_host);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_ARCH_CV181X_ASIC
+
+static int save_rtc_reg(struct sdhci_cvi_host *cvi_host)
+{
+	void __iomem *topbase;
+	void __iomem *rtcbase;
+
+	topbase = ioremap(TOP_BASE, 0x250);
+	rtcbase = ioremap(RTC_CTRL_BASE, 0x80);
+
+	if (!cvi_host->rtc_reg_ctx) {
+		cvi_host->rtc_reg_ctx = devm_kzalloc(&cvi_host->pdev->dev,
+								sizeof(struct cvi_rtc_sdhci_reg_context), GFP_KERNEL);
+		if (!cvi_host->rtc_reg_ctx)
+			return -ENOMEM;
+	}
+	cvi_host->rtc_reg_ctx->rtcsys_clkmux = readl(rtcbase + RTCSYS_CLKMUX);
+	cvi_host->rtc_reg_ctx->rtcsys_clkbyp = readl(rtcbase + RTCSYS_CLKBYP);
+	cvi_host->rtc_reg_ctx->rtcsys_mcu51_ictrl1 = readl(rtcbase + RTCSYS_MCU51_ICTRL1);
+	cvi_host->rtc_reg_ctx->rtcsys_ctrl = readl(topbase + RTCSYS_CTRL);
+
+	iounmap(topbase);
+	iounmap(rtcbase);
+
+	return 0;
+}
+
+static void restore_rtc_reg(struct sdhci_cvi_host *cvi_host)
+{
+	void __iomem *topbase;
+	void __iomem *rtcbase;
+
+	topbase = ioremap(TOP_BASE, 0x250);
+	rtcbase = ioremap(RTC_CTRL_BASE, 0x80);
+
+	writel(cvi_host->rtc_reg_ctx->rtcsys_clkmux, rtcbase + RTCSYS_CLKMUX);
+	writel(cvi_host->rtc_reg_ctx->rtcsys_clkbyp, rtcbase + RTCSYS_CLKBYP);
+	writel(cvi_host->rtc_reg_ctx->rtcsys_mcu51_ictrl1, rtcbase + RTCSYS_MCU51_ICTRL1);
+	writel(cvi_host->rtc_reg_ctx->rtcsys_ctrl, topbase + RTCSYS_CTRL);
+
+	iounmap(topbase);
+	iounmap(rtcbase);
+}
+#else
+static int save_rtc_reg(struct sdhci_cvi_host *cvi_host)
+{
+	return 0;
+}
+static void restore_rtc_reg(struct sdhci_cvi_host *cvi_host) {}
+#endif
+
+static void save_reg(struct sdhci_host *host, struct sdhci_cvi_host *cvi_host)
+{
+	save_rtc_reg(cvi_host);
+	cvi_host->reg_ctrl2 = sdhci_readl(host, SDHCI_HOST_CONTROL2);
+	cvi_host->reg_clk_ctrl = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
+	cvi_host->reg_host_ctrl = sdhci_readl(host, SDHCI_HOST_CONTROL);
+}
+
+static void restore_reg(struct sdhci_host *host, struct sdhci_cvi_host *cvi_host)
+{
+	restore_rtc_reg(cvi_host);
+	sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
+	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
+	sdhci_writel(host, cvi_host->reg_ctrl2, SDHCI_HOST_CONTROL2);
+	sdhci_writel(host, cvi_host->reg_clk_ctrl, SDHCI_CLOCK_CONTROL);
+	sdhci_writel(host, cvi_host->reg_host_ctrl, SDHCI_HOST_CONTROL);
+}
+
+static int sdhci_cvi_suspend(struct device *dev)
+{
+	struct sdhci_cvi_host *cvi_host = dev_get_drvdata(dev);
+	struct sdhci_host *host = cvi_host->host;
+
+	if (!host)
+		return 0;
+
+	save_reg(host, cvi_host);
+
+	return 0;
+}
+
+static int sdhci_cvi_resume(struct device *dev)
+{
+	struct sdhci_cvi_host *cvi_host = dev_get_drvdata(dev);
+	struct sdhci_host *host = cvi_host->host;
+
+	if (!host)
+		return 0;
+
+	restore_reg(host, cvi_host);
+
+	return 0;
+}
+
+#endif
+
+static const struct dev_pm_ops sdhci_cvi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(sdhci_cvi_suspend, sdhci_cvi_resume)
+};
+
+static struct platform_driver sdhci_cvi_driver = {
+	.probe = sdhci_cvi_probe,
+	.remove = sdhci_cvi_remove,
+	.driver = {
+		.name = DRIVER_NAME,
+		.pm = &sdhci_cvi_pm_ops,
+		.of_match_table = sdhci_cvi_dt_match,
+	},
+};
+
+module_platform_driver(sdhci_cvi_driver);
+
+MODULE_DESCRIPTION("Cvitek Secure Digital Host Controller Interface driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mmc/host/cvitek/sdhci-cv181x.h b/drivers/mmc/host/cvitek/sdhci-cv181x.h
new file mode 100644
index 000000000000..d7524e3e531b
--- /dev/null
+++ b/drivers/mmc/host/cvitek/sdhci-cv181x.h
@@ -0,0 +1,104 @@
+/*
+ * drivers/mmc/host/sdhci-cvi.c - CVITEK SDHCI Platform driver
+ *
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __SDHCI_CV_H
+#define __SDHCI_CV_H
+
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/delay.h>
+#include <linux/mmc/mmc.h>
+#include <linux/slab.h>
+
+#define MAX_TUNING_CMD_RETRY_COUNT 50
+#define TUNE_MAX_PHCODE	128
+#define TAP_WINDOW_THLD 20
+#define DISPPLL_MHZ 1188
+#define FPLL_MHZ 1500
+
+#define TOP_BASE	0x03000000
+#define OFFSET_SD_PWRSW_CTRL	0x1F4
+
+#define PINMUX_BASE 0x03001000
+#define CLKGEN_BASE 0x03002000
+
+
+#define CVI_CV181X_SDHCI_VENDOR_OFFSET		0x200
+#define CVI_CV181X_SDHCI_VENDOR_MSHC_CTRL_R	(CVI_CV181X_SDHCI_VENDOR_OFFSET + 0x0)
+#define CVI_CV181X_SDHCI_PHY_TX_RX_DLY		(CVI_CV181X_SDHCI_VENDOR_OFFSET + 0x40)
+#define CVI_CV181X_SDHCI_PHY_DS_DLY			(CVI_CV181X_SDHCI_VENDOR_OFFSET + 0x44)
+#define CVI_CV181X_SDHCI_PHY_DLY_STS		(CVI_CV181X_SDHCI_VENDOR_OFFSET + 0x48)
+#define CVI_CV181X_SDHCI_PHY_CONFIG			(CVI_CV181X_SDHCI_VENDOR_OFFSET + 0x4C)
+
+#define SDHCI_GPIO_CD_DEBOUNCE_TIME	10
+#define SDHCI_GPIO_CD_DEBOUNCE_DELAY_TIME	200
+
+#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_ARCH_CVCV181X_ASIC
+
+#define RTC_CTRL_BASE		0x5025000
+#define RTCSYS_CLKMUX	0x1C
+#define RTCSYS_CLKBYP	0x30
+#define RTCSYS_MCU51_ICTRL1	0x7C
+
+#define RTCSYS_CTRL		0x248
+
+struct cvi_rtc_sdhci_reg_context {
+	u32 rtcsys_clkmux;
+	u32 rtcsys_clkbyp;
+	u32 rtcsys_mcu51_ictrl1;
+	u32 rtcsys_ctrl;
+};
+#else
+struct cvi_rtc_sdhci_reg_context {};
+#endif
+#endif
+
+struct sdhci_cvi_host {
+	struct sdhci_host *host;
+	struct platform_device *pdev;
+	void __iomem *core_mem; /* mmio address */
+	struct clk *clk;    /* main SD/MMC bus clock */
+	struct clk *clk100k;
+	struct clk *clkaxi;
+	struct mmc_host *mmc;
+	struct reset_control *reset;
+
+	struct reset_control *clk_rst_axi_emmc_ctrl;
+	struct reset_control *clk_rst_emmc_ctrl;
+	struct reset_control *clk_rst_100k_emmc_ctrl;
+
+	void __iomem *topbase;
+	void __iomem *pinmuxbase;
+	void __iomem *clkgenbase;
+
+	u32 reg_ctrl2;
+	u32 reg_clk_ctrl;
+	u32 reg_host_ctrl;
+	u8 final_tap;
+	u8 sdio0_voltage_1_8_v;
+	int sd_save_count;
+	struct mmc_gpio *cvi_gpio;
+	struct delayed_work cd_debounce_work;
+	spinlock_t cd_debounce_lock;
+	int pre_gpio_cd;
+	bool is_debounce_work_running;
+#ifdef CONFIG_PM_SLEEP
+	struct cvi_rtc_sdhci_reg_context *rtc_reg_ctx;
+#endif
+
+};
+#endif
diff --git a/drivers/mmc/host/cvitek/sdhci-cv182x.c b/drivers/mmc/host/cvitek/sdhci-cv182x.c
new file mode 100644
index 000000000000..8dcb5c90a940
--- /dev/null
+++ b/drivers/mmc/host/cvitek/sdhci-cv182x.c
@@ -0,0 +1,1353 @@
+/*
+ * drivers/mmc/host/sdhci-cv.c - CVITEK SDHCI Platform driver
+ *
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/slab.h>
+#include <linux/reset.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/device.h>
+#include <linux/export.h>
+#include <linux/io.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/of_gpio.h>
+#include <linux/mmc/slot-gpio.h>
+
+#include "../../core/card.h"
+#include "../sdhci-pltfm.h"
+#include "sdhci-cv182x.h"
+
+#define DRIVER_NAME "cvi"
+#define SDHCI_DUMP(f, x...) \
+	pr_err("%s: " DRIVER_NAME ": " f, mmc_hostname(host->mmc), ## x)
+
+#define MAX_CARD_TYPE 4
+#define MAX_SPEED_MODE 5
+
+#define CVI_PARENT "cvi"
+#define CVI_STATS_PROC "cvi_info"
+#define MAX_CLOCK_SCALE (4)
+
+#define UNSTUFF_BITS(resp, start, size)                 \
+	({                                                      \
+	const int __size = size;                                \
+	const u32 __mask = (__size < 32 ? 1 << __size : 0) - 1; \
+	const int __off = 3 - ((start) / 32);                   \
+	const int __shft = (start) & 31;                        \
+	u32 __res;                                              \
+	__res = resp[__off] >> __shft;                          \
+	if (__size + __shft > 32)                               \
+		__res |= resp[__off - 1] << ((32 - __shft) % 32);   \
+	__res & __mask;                                         \
+	})
+
+static struct proc_dir_entry *proc_cvi_dir;
+
+static char *card_type[MAX_CARD_TYPE + 1] = {
+	"MMC card", "SD card", "SDIO card", "SD combo (IO+mem) card", "unknown"
+};
+
+static char *cvi_get_card_type(unsigned int sd_type)
+{
+	if (sd_type >= MAX_CARD_TYPE)
+		return card_type[MAX_CARD_TYPE];
+	else
+		return card_type[sd_type];
+}
+
+static inline int is_card_uhs(unsigned char timing)
+{
+	return timing >= MMC_TIMING_UHS_SDR12 && timing <= MMC_TIMING_UHS_DDR50;
+};
+
+static inline int is_card_hs(unsigned char timing)
+{
+	return timing == MMC_TIMING_SD_HS || timing == MMC_TIMING_MMC_HS;
+};
+
+static void cvi_stats_seq_printout(struct seq_file *s)
+{
+	const char *type = NULL;
+	unsigned int present;
+	unsigned char timing;
+	struct sdhci_cvi_host *cvi_host = NULL;
+	struct mmc_host *mmc = NULL;
+	struct mmc_card *card = NULL;
+	const char *uhs_bus_speed_mode = "";
+	u32 speed_class, grade_speed_uhs;
+	static const char *const uhs_speeds[] = {
+		[UHS_SDR12_BUS_SPEED] = "SDR12 ", [UHS_SDR25_BUS_SPEED] = "SDR25 ",
+		[UHS_SDR50_BUS_SPEED] = "SDR50 ", [UHS_SDR104_BUS_SPEED] = "SDR104 ",
+		[UHS_DDR50_BUS_SPEED] = "DDR50 ",
+	};
+	cvi_host = (struct sdhci_cvi_host *)s->private;
+
+	if (!cvi_host || !cvi_host->mmc) {
+		seq_printf(s, "cvi s : %p: s->private %p\n", s, s->private);
+		return;
+	}
+
+	seq_printf(s, "cvi.%d", cvi_host->mmc->index);
+
+	mmc = cvi_host->mmc;
+	present = mmc->ops->get_cd(mmc);
+
+	if (present) {
+		seq_puts(s, ": plugged");
+	} else {
+		seq_puts(s, ": unplugged");
+	}
+
+	card = mmc->card;
+
+	if (!card) {
+		seq_puts(s, "_disconnected\n");
+	} else {
+		seq_puts(s, "_connected\n");
+		seq_printf(s, "\tType: %s", cvi_get_card_type(card->type));
+
+		//if (card->state & MMC_STATE_BLOCKADDR) {
+		if (mmc_card_blockaddr(card)) {
+			if (card->state & MMC_CARD_SDXC)
+				type = "SDXC";
+			else
+				type = "SDHC";
+			seq_printf(s, "(%s)\n", type);
+		}
+
+		timing = mmc->ios.timing;
+
+		if (is_card_uhs(mmc->ios.timing) &&
+		    card->sd_bus_speed < ARRAY_SIZE(uhs_speeds))
+			uhs_bus_speed_mode = uhs_speeds[card->sd_bus_speed];
+
+		seq_printf(s, "\tMode: %s%s%s%s\n",
+			   is_card_uhs(timing) ? "UHS "
+			   : (is_card_hs(timing) ? "HS " : ""),
+			   timing == MMC_TIMING_MMC_HS400
+			   ? "HS400 "
+			   : (timing == MMC_TIMING_MMC_HS200 ? "HS200 " : ""),
+			   timing == MMC_TIMING_MMC_DDR52 ? "DDR " : "",
+			   uhs_bus_speed_mode);
+
+		speed_class = UNSTUFF_BITS(card->raw_ssr, 440 - 384, 8);
+		grade_speed_uhs = UNSTUFF_BITS(card->raw_ssr, 396 - 384, 4);
+		seq_printf(s, "\tSpeed Class: Class %s\n",
+			   (speed_class == 0x00)
+			   ? "0"
+			   : (speed_class == 0x01)
+			   ? "2"
+			   : (speed_class == 0x02)
+			   ? "4"
+			   : (speed_class == 0x03)
+			   ? "6"
+			   : (speed_class == 0x04)
+			   ? "10"
+			   : "Reserved");
+		seq_printf(s, "\tUhs Speed Grade: %s\n",
+			   (grade_speed_uhs == 0x00)
+			   ? "Less than 10MB/sec(0h)"
+			   : (grade_speed_uhs == 0x01)
+			   ? "10MB/sec and above(1h)"
+			   : "Reserved");
+	}
+}
+
+/* proc interface setup */
+static void *cvi_seq_start(struct seq_file *s, loff_t *pos)
+{
+	/*   counter is used to tracking multi proc interfaces
+	 *  We have only one interface so return zero
+	 *  pointer to start the sequence.
+	 */
+	static unsigned long counter;
+
+	if (*pos == 0) {
+		return &counter;
+	}
+
+	*pos = 0;
+	return NULL;
+}
+
+/* define parameters where showed in proc file */
+static int cvi_stats_seq_show(struct seq_file *s, void *v)
+{
+	cvi_stats_seq_printout(s);
+	return 0;
+}
+
+/* proc interface stop */
+static void cvi_seq_stop(struct seq_file *s, void *v) {}
+
+/* proc interface operation */
+static const struct seq_operations cvi_stats_seq_ops = {
+	.start = cvi_seq_start,
+	.stop = cvi_seq_stop,
+	.show = cvi_stats_seq_show
+};
+
+/* proc file open*/
+static int cvi_stats_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, cvi_stats_seq_show, PDE_DATA(inode));
+};
+
+/* proc file operation */
+static const struct proc_ops cvi_stats_proc_ops = {
+	.proc_open = cvi_stats_proc_open,
+	.proc_read = seq_read,
+	.proc_release = single_release
+};
+
+int cvi_proc_init(struct sdhci_cvi_host *cvi_host)
+{
+	struct proc_dir_entry *proc_stats_entry;
+
+	pr_info("%s cvi_host 0x%p\n", __func__, cvi_host);
+
+	proc_cvi_dir = proc_mkdir(CVI_PARENT, NULL);
+
+	if (!proc_cvi_dir) {
+		pr_err("%s: failed to create proc file %s\n", __func__, CVI_PARENT);
+		return 1;
+	}
+
+	proc_stats_entry = proc_create_data(CVI_STATS_PROC, 0400, proc_cvi_dir, &cvi_stats_proc_ops,
+					    (void *)cvi_host);
+
+	if (!proc_stats_entry) {
+		pr_err("%s: failed to create proc file %s\n", __func__, CVI_STATS_PROC);
+		return 1;
+	}
+
+	return 0;
+}
+
+int cvi_proc_shutdown(struct sdhci_cvi_host *cvi_host)
+{
+	pr_info("%s\n", __func__);
+
+	if (proc_cvi_dir) {
+		remove_proc_entry(CVI_STATS_PROC, proc_cvi_dir);
+		remove_proc_entry(CVI_PARENT, NULL);
+		proc_cvi_dir = NULL;
+	}
+
+	return 0;
+}
+
+static void sdhci_cv182x_emmc_setup_pad(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	/* Name              Offset
+	 * PAD_EMMC_RSTN     0x48
+	 * PAD_EMMC_CLK      0x50
+	 * PAD_EMMC_CMD      0x5C
+	 * PAD_EMMC_DAT0     0x54
+	 * PAD_EMMC_DAT1     0x60
+	 * PAD_EMMC_DAT2     0x4C
+	 * PAD_EMMC_DAT3     0x58
+
+	 */
+
+	u8 val = 0x0;
+
+	writeb(val, cvi_host->pinmuxbase + 0x48);
+	writeb(val, cvi_host->pinmuxbase + 0x50);
+	writeb(val, cvi_host->pinmuxbase + 0x5C);
+	writeb(val, cvi_host->pinmuxbase + 0x54);
+	writeb(val, cvi_host->pinmuxbase + 0x60);
+	writeb(val, cvi_host->pinmuxbase + 0x4C);
+	writeb(val, cvi_host->pinmuxbase + 0x58);
+}
+
+static void sdhci_cv182x_sd_setup_pad(struct sdhci_host *host, bool bunplug)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	/* Name              Offset unplug plug
+	 * PAD_SDIO0_CD      0x34   SDIO0  SDIO0
+	 * PAD_SDIO0_PWR_EN  0x38   SDIO0  SDIO0
+	 * PAD_SDIO0_CLK     0x1C   XGPIO  SDIO0
+	 * PAD_SDIO0_CMD     0x20   XGPIO  SDIO0
+	 * PAD_SDIO0_D0      0x24   XGPIO  SDIO0
+	 * PAD_SDIO0_D1      0x28   XGPIO  SDIO0
+	 * PAD_SDIO0_D2      0x2C   XGPIO  SDIO0
+	 * PAD_SDIO0_D3      0x30   XGPIO  SDIO0
+	 * 0x0: SDIO0 function
+	 * 0x3: XGPIO function
+	 */
+
+	u8 val = (bunplug) ? 0x3 : 0x0;
+
+	if (cvi_host->cvi_gpio && cvi_host->cvi_gpio->cd_gpio)
+		writeb(0x3, cvi_host->pinmuxbase + 0x34);
+	else
+		writeb(0x0, cvi_host->pinmuxbase + 0x34);
+
+	writeb(0x0, cvi_host->pinmuxbase + 0x38);
+	writeb(val, cvi_host->pinmuxbase + 0x1C);
+	writeb(val, cvi_host->pinmuxbase + 0x20);
+	writeb(val, cvi_host->pinmuxbase + 0x24);
+	writeb(val, cvi_host->pinmuxbase + 0x28);
+	writeb(val, cvi_host->pinmuxbase + 0x2C);
+	writeb(val, cvi_host->pinmuxbase + 0x30);
+}
+
+static void sdhci_cv182x_sd_setup_io(struct sdhci_host *host, bool reset)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	/*
+	 * Name              Offset reset sd0
+	 * REG_SDIO0_CD      0x900  PU    PU
+	 * REG_SDIO0_PWR_EN  0x904  PD    PD
+	 * REG_SDIO0_CLK     0xA00  PD    PD
+	 * REG_SDIO0_CMD     0xA04  PD    PU
+	 * REG_SDIO0_D0      0xA08  PD    PU
+	 * REG_SDIO0_D1      0xA0C  PD    PU
+	 * REG_SDIO0_D2      0xA10  PD    PU
+	 * REG_SDIO0_D3      0xA14  PD    PU
+	 * BIT(2) : PU   enable(1)/disable(0)
+	 * BIT(3) : PD   enable(1)/disable(0)
+	 */
+
+	u8 raise_bit = (reset) ?  BIT(3) : BIT(2);
+	u8 down_bit  = (reset) ?  BIT(2) : BIT(3);
+
+	writeb(((readb(cvi_host->pinmuxbase + 0x900) | BIT(2)) & ~(BIT(3))),
+		cvi_host->pinmuxbase + 0x900);
+	writeb(((readb(cvi_host->pinmuxbase + 0x904) | BIT(3)) & ~(BIT(2))),
+		cvi_host->pinmuxbase + 0x904);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA00) | BIT(3)) & ~(BIT(2))),
+		cvi_host->pinmuxbase + 0xA00);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA04) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA04);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA08) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA08);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA0C) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA0C);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA10) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA10);
+	writeb(((readb(cvi_host->pinmuxbase + 0xA14) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xA14);
+}
+
+static void sdhci_cvi_reset_helper(struct sdhci_host *host, u8 mask)
+{
+	// disable Intr before reset
+	sdhci_writel(host, 0, SDHCI_INT_ENABLE);
+	sdhci_writel(host, 0, SDHCI_SIGNAL_ENABLE);
+
+	sdhci_reset(host, mask);
+
+	sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
+	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
+}
+
+static void reset_after_tuning_pass(struct sdhci_host *host)
+{
+	pr_debug("tuning pass\n");
+
+	/* Clear BUF_RD_READY intr */
+	sdhci_writew(host, sdhci_readw(host, SDHCI_INT_STATUS) & (~(0x1 << 5)),
+		     SDHCI_INT_STATUS);
+
+	/* Set SDHCI_SOFTWARE_RESET.SW_RST_DAT = 1 to clear buffered tuning block */
+	sdhci_writeb(host, sdhci_readb(host, SDHCI_SOFTWARE_RESET) | (0x1 << 2), SDHCI_SOFTWARE_RESET);
+
+	/* Set SDHCI_SOFTWARE_RESET.SW_RST_CMD = 1	*/
+	sdhci_writeb(host, sdhci_readb(host, SDHCI_SOFTWARE_RESET) | (0x1 << 1), SDHCI_SOFTWARE_RESET);
+
+	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & 0x3)
+		;
+}
+
+static inline uint32_t CHECK_MASK_BIT(void *_mask, uint32_t bit)
+{
+	uint32_t w = bit / 8;
+	uint32_t off = bit % 8;
+
+	return ((uint8_t *)_mask)[w] & (1 << off);
+}
+
+static inline void SET_MASK_BIT(void *_mask, uint32_t bit)
+{
+	uint32_t byte = bit / 8;
+	uint32_t offset = bit % 8;
+	((uint8_t *)_mask)[byte] |= (1 << offset);
+}
+
+static int sdhci_cv182x_general_select_drive_strength(struct sdhci_host *host,
+		struct mmc_card *card, unsigned int max_dtr, int host_drv,
+		int card_drv, int *drv_type)
+{
+	return MMC_SET_DRIVER_TYPE_A;
+}
+
+static void sdhci_cvi_general_set_uhs_signaling(struct sdhci_host *host, unsigned int uhs)
+{
+	struct mmc_host *mmc = host->mmc;
+	u16 ctrl_2;
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	/* Select Bus Speed Mode for host */
+	ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
+	switch (uhs) {
+	case MMC_TIMING_UHS_SDR12:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR12;
+		break;
+	case MMC_TIMING_UHS_SDR25:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR25;
+		break;
+	case MMC_TIMING_UHS_SDR50:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR50;
+		break;
+	case MMC_TIMING_MMC_HS200:
+	case MMC_TIMING_UHS_SDR104:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR104;
+		break;
+	case MMC_TIMING_UHS_DDR50:
+	case MMC_TIMING_MMC_DDR52:
+		ctrl_2 |= SDHCI_CTRL_UHS_DDR50;
+		break;
+	}
+
+	/*
+	 * When clock frequency is less than 100MHz, the feedback clock must be
+	 * provided and DLL must not be used so that tuning can be skipped. To
+	 * provide feedback clock, the mode selection can be any value less
+	 * than 3'b011 in bits [2:0] of HOST CONTROL2 register.
+	 */
+	if (host->clock <= 100000000 &&
+	    (uhs == MMC_TIMING_MMC_HS400 ||
+	     uhs == MMC_TIMING_MMC_HS200 ||
+	     uhs == MMC_TIMING_UHS_SDR104))
+		ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
+
+	dev_dbg(mmc_dev(mmc), "%s: clock=%u uhs=%u ctrl_2=0x%x\n",
+		mmc_hostname(host->mmc), host->clock, uhs, ctrl_2);
+	sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
+}
+
+static unsigned int sdhci_cvi_general_emmc_get_max_clock(struct sdhci_host *host)
+{
+	uint32_t clk = 375 * 1000 * 1000;
+
+	pr_debug(DRIVER_NAME ":%s : %d\n", __func__, clk);
+	return clk;
+}
+
+/* Used for wifi driver due if no SD card detect pin implemented */
+static struct mmc_host *wifi_mmc;
+
+int cvi_sdio_rescan(void)
+{
+
+	if (!wifi_mmc) {
+		pr_err("invalid wifi mmc, please check the argument\n");
+		return -EINVAL;
+	}
+
+	mmc_detect_change(wifi_mmc, 0);
+
+	wifi_mmc->rescan_entered = 0;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(cvi_sdio_rescan);
+
+
+void sdhci_cvi_emmc_voltage_switch(struct sdhci_host *host)
+{
+}
+
+static void sdhci_cvi_cv182x_set_tap(struct sdhci_host *host, unsigned int tap)
+{
+	pr_debug("%s %d\n", __func__, tap);
+	// Set sd_clk_en(0x2c[2]) to 0
+	sdhci_writew(host, sdhci_readw(host, SDHCI_CLOCK_CONTROL) & (~(0x1 << 2)), SDHCI_CLOCK_CONTROL);
+	sdhci_writel(host,
+		sdhci_readl(host, CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R) & (~(BIT(1))),
+		CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R);
+	sdhci_writel(host, BIT(8) | tap << 16,
+		     CVI_182X_SDHCI_PHY_TX_RX_DLY);
+	sdhci_writel(host, 0, CVI_182X_SDHCI_PHY_CONFIG);
+	// Set sd_clk_en(0x2c[2]) to 1
+	sdhci_writew(host, sdhci_readw(host, SDHCI_CLOCK_CONTROL) | (0x1 << 2), SDHCI_CLOCK_CONTROL);
+	mdelay(1);
+}
+
+static int sdhci_cv182x_general_execute_tuning(struct sdhci_host *host, u32 opcode)
+{
+	u16 min = 0;
+	u32 k = 0;
+	s32 ret;
+	u32 retry_cnt = 0;
+
+	u32 tuning_result[4] = {0, 0, 0, 0};
+	u32 rx_lead_lag_result[4] = {0, 0, 0, 0};
+	char tuning_graph[TUNE_MAX_PHCODE+1];
+	char rx_lead_lag_graph[TUNE_MAX_PHCODE+1];
+
+	u32 reg = 0;
+	u32 reg_rx_lead_lag = 0;
+	s32 max_lead_lag_idx = -1;
+	s32 max_window_idx = -1;
+	s32 cur_window_idx = -1;
+	u16 max_lead_lag_size = 0;
+	u16 max_window_size = 0;
+	u16 cur_window_size = 0;
+	s32 rx_lead_lag_phase = -1;
+	s32 final_tap = -1;
+	u32 rate = 0;
+
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	reg = sdhci_readw(host, SDHCI_ERR_INT_STATUS);
+	pr_debug("%s : SDHCI_ERR_INT_STATUS 0x%x\n", mmc_hostname(host->mmc),
+		 reg);
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("%s : host ctrl2 0x%x\n", mmc_hostname(host->mmc), reg);
+	/* Set Host_CTRL2_R.SAMPLE_CLK_SEL=0 */
+	sdhci_writew(host,
+			 sdhci_readw(host, SDHCI_HOST_CONTROL2) & (~(0x1 << 7)),
+			 SDHCI_HOST_CONTROL2);
+	sdhci_writew(host,
+			 sdhci_readw(host, SDHCI_HOST_CONTROL2) & (~(0x3 << 4)),
+			 SDHCI_HOST_CONTROL2);
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("%s : host ctrl2 0x%x\n", mmc_hostname(host->mmc), reg);
+
+	while (min < TUNE_MAX_PHCODE) {
+		retry_cnt = 0;
+		sdhci_cvi_cv182x_set_tap(host, min);
+		reg_rx_lead_lag = sdhci_readw(host, CVI_182X_SDHCI_PHY_DLY_STS) & BIT(1);
+
+retry_tuning:
+		ret = mmc_send_tuning(host->mmc, opcode, NULL);
+
+		if (!ret && retry_cnt < MAX_TUNING_CMD_RETRY_COUNT) {
+			retry_cnt++;
+			goto retry_tuning;
+		}
+
+		if (ret) {
+			SET_MASK_BIT(tuning_result, min);
+		}
+
+		if (reg_rx_lead_lag) {
+			SET_MASK_BIT(rx_lead_lag_result, min);
+		}
+
+		min++;
+	}
+
+	reset_after_tuning_pass(host);
+
+	pr_debug("tuning result:      0x%08x 0x%08x 0x%08x 0x%08x\n",
+		tuning_result[0], tuning_result[1], tuning_result[2], tuning_result[3]);
+	pr_debug("rx_lead_lag result: 0x%08x 0x%08x 0x%08x 0x%08x\n",
+		rx_lead_lag_result[0], rx_lead_lag_result[1], rx_lead_lag_result[2], rx_lead_lag_result[3]);
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(tuning_result, k) == 0)
+			tuning_graph[k] = '-';
+		else
+			tuning_graph[k] = 'x';
+		if (CHECK_MASK_BIT(rx_lead_lag_result, k) == 0)
+			rx_lead_lag_graph[k] = '0';
+		else
+			rx_lead_lag_graph[k] = '1';
+	}
+	tuning_graph[TUNE_MAX_PHCODE] = '\0';
+	rx_lead_lag_graph[TUNE_MAX_PHCODE] = '\0';
+
+	pr_debug("tuning graph:      %s\n", tuning_graph);
+	pr_debug("rx_lead_lag graph: %s\n", rx_lead_lag_graph);
+
+	// Find a final tap as median of maximum window
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(tuning_result, k) == 0) {
+			if (-1 == cur_window_idx) {
+				cur_window_idx = k;
+			}
+			cur_window_size++;
+
+			if (cur_window_size > max_window_size) {
+				max_window_size = cur_window_size;
+				max_window_idx = cur_window_idx;
+				if (max_window_size >= TAP_WINDOW_THLD)
+					final_tap = cur_window_idx + (max_window_size/2);
+			}
+		} else {
+			cur_window_idx = -1;
+			cur_window_size = 0;
+		}
+	}
+
+	cur_window_idx = -1;
+	cur_window_size = 0;
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(rx_lead_lag_result, k) == 0) {
+			//from 1 to 0 and window_size already computed.
+			if ((rx_lead_lag_phase == 1) && (cur_window_size > 0)) {
+				max_lead_lag_idx = cur_window_idx;
+				max_lead_lag_size = cur_window_size;
+				break;
+			}
+			if (cur_window_idx == -1) {
+				cur_window_idx = k;
+			}
+			cur_window_size++;
+			rx_lead_lag_phase = 0;
+		} else {
+			rx_lead_lag_phase = 1;
+			if ((cur_window_idx != -1) && (cur_window_size > 0)) {
+				cur_window_size++;
+				max_lead_lag_idx = cur_window_idx;
+				max_lead_lag_size = cur_window_size;
+			} else {
+				cur_window_size = 0;
+			}
+		}
+	}
+	rate = max_window_size * 100 / max_lead_lag_size;
+	pr_debug("MaxWindow[Idx, Width]:[%d,%u] Tuning Tap: %d\n", max_window_idx, max_window_size, final_tap);
+	pr_debug("RX_LeadLag[Idx, Width]:[%d,%u] rate = %d\n", max_lead_lag_idx, max_lead_lag_size, rate);
+
+	sdhci_cvi_cv182x_set_tap(host, final_tap);
+	cvi_host->final_tap = final_tap;
+	pr_debug("%s finished tuning, code:%d\n", __func__, final_tap);
+
+	return mmc_send_tuning(host->mmc, opcode, NULL);
+}
+
+static void sdhci_cv182x_emmc_reset(struct sdhci_host *host, u8 mask)
+{
+	u16 ctrl_2;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s mask = 0x%x\n", __func__, mask);
+	sdhci_cvi_reset_helper(host, mask);
+
+	//reg_0x200[0] = 1 for mmc
+	sdhci_writel(host,
+			 sdhci_readl(host, CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(0),
+			 CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R);
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctrl_2 &= SDHCI_CTRL_UHS_MASK;
+	if (ctrl_2 == SDHCI_CTRL_UHS_SDR104) {
+		//reg_0x200[1] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R) & ~(BIT(1)),
+			CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_182X_SDHCI_PHY_CONFIG) & ~(BIT(0)),
+			CVI_182X_SDHCI_PHY_CONFIG);
+		//reg_0x240[22:16] = tap reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host,
+			(BIT(8) | ((cvi_host->final_tap & 0x7F) << 16)),
+			CVI_182X_SDHCI_PHY_TX_RX_DLY);
+	} else {
+		//Reset as DS/HS setting.
+		//reg_0x200[1] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(1),
+			CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_182X_SDHCI_PHY_CONFIG) | BIT(0),
+			CVI_182X_SDHCI_PHY_CONFIG);
+		//reg_0x240[25:24] = 1 reg_0x240[22:16] = 0 reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host, 0x1000100, CVI_182X_SDHCI_PHY_TX_RX_DLY);
+	}
+}
+
+static void sdhci_cv182x_sd_reset(struct sdhci_host *host, u8 mask)
+{
+	u16 ctrl_2;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s mask = 0x%x\n", __func__, mask);
+	sdhci_cvi_reset_helper(host, mask);
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctrl_2 &= SDHCI_CTRL_UHS_MASK;
+	if (ctrl_2 == SDHCI_CTRL_UHS_SDR104) {
+		//reg_0x200[1] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R) & ~(BIT(1)),
+			CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_182X_SDHCI_PHY_CONFIG) & ~(BIT(0)),
+			CVI_182X_SDHCI_PHY_CONFIG);
+		//reg_0x240[22:16] = tap reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host,
+			(BIT(8) | ((cvi_host->final_tap & 0x7F) << 16)),
+			CVI_182X_SDHCI_PHY_TX_RX_DLY);
+	} else {
+		//Reset as DS/HS setting.
+		//reg_0x200[1] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(1),
+			CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_182X_SDHCI_PHY_CONFIG) | BIT(0),
+			CVI_182X_SDHCI_PHY_CONFIG);
+		//reg_0x240[25:24] = 1 reg_0x240[22:16] = 0 reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host, 0x1000100, CVI_182X_SDHCI_PHY_TX_RX_DLY);
+	}
+}
+
+static void sdhci_cv182x_sdio_reset(struct sdhci_host *host, u8 mask)
+{
+	u16 ctrl_2;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s mask = 0x%x\n", __func__, mask);
+	sdhci_cvi_reset_helper(host, mask);
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctrl_2 &= SDHCI_CTRL_UHS_MASK;
+	if (ctrl_2 == SDHCI_CTRL_UHS_SDR104) {
+		//reg_0x200[1] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R) & ~(BIT(1)),
+			CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x200[16] = 1 for sd1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(16),
+			CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_182X_SDHCI_PHY_CONFIG) & ~(BIT(0)),
+			CVI_182X_SDHCI_PHY_CONFIG);
+		//reg_0x240[22:16] = tap reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host,
+			(BIT(8) | ((cvi_host->final_tap & 0x7F) << 16)),
+			CVI_182X_SDHCI_PHY_TX_RX_DLY);
+	} else {
+		//Reset as DS/HS setting.
+		//reg_0x200[1] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(1),
+			CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x200[16] = 1 for sd1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(16),
+			CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x24c[0] = 1
+		sdhci_writel(host,
+			sdhci_readl(host, CVI_182X_SDHCI_PHY_CONFIG) | BIT(0),
+			CVI_182X_SDHCI_PHY_CONFIG);
+		//reg_0x240[25:24] = 1 reg_0x240[22:16] = 0 reg_0x240[9:8] = 1 reg_0x240[6:0] = 0
+		sdhci_writel(host, 0x1000100, CVI_182X_SDHCI_PHY_TX_RX_DLY);
+	}
+}
+
+static unsigned int sdhci_cv182x_sd_get_max_clock(struct sdhci_host *host)
+{
+	uint32_t clk = 375 * 1000 * 1000;
+
+	pr_debug(DRIVER_NAME ":%s : %d\n", __func__, clk);
+	return clk;
+}
+
+void sdhci_cv182x_sd_voltage_switch(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s\n", __func__);
+
+	// enable SDIO0_CLK[7:5] to set CLK max strengh
+	writeb((readb(cvi_host->pinmuxbase + 0xA00) | BIT(7) | BIT(6) | BIT(5)),
+		cvi_host->pinmuxbase + 0xA00);
+
+	//Voltage switching flow (1.8v)
+	//reg_pwrsw_auto=1, reg_pwrsw_disc=0, pwrsw_vsel=1(1.8v), reg_en_pwrsw=1
+	writel(0xB | (readl(cvi_host->topbase + OFFSET_SD_PWRSW_CTRL) & 0xFFFFFFF0),
+		cvi_host->topbase + OFFSET_SD_PWRSW_CTRL);
+	pr_debug("sd PWRSW 0x%x\n", readl(cvi_host->topbase + OFFSET_SD_PWRSW_CTRL));
+	cvi_host->sdio0_voltage_1_8_v = 1;
+
+	mdelay(1);
+}
+
+void sdhci_cv182x_sd_voltage_restore(struct sdhci_host *host, bool bunplug)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s\n", __func__);
+
+	if (bunplug) {
+		//Voltage close flow
+		//(reg_pwrsw_auto=1, reg_pwrsw_disc=1, reg_pwrsw_vsel=1(1.8v), reg_en_pwrsw=0)
+		writel(0xE | (readl(cvi_host->topbase + OFFSET_SD_PWRSW_CTRL) & 0xFFFFFFF0),
+			cvi_host->topbase + OFFSET_SD_PWRSW_CTRL);
+		cvi_host->sdio0_voltage_1_8_v = 0;
+	} else {
+		if (!cvi_host->sdio0_voltage_1_8_v) {
+			//Voltage switching flow (3.3)
+			//(reg_pwrsw_auto=1, reg_pwrsw_disc=0, reg_pwrsw_vsel=0(3.0v), reg_en_pwrsw=1)
+			writel(0x9 | (readl(cvi_host->topbase + OFFSET_SD_PWRSW_CTRL) & 0xFFFFFFF0),
+				cvi_host->topbase + OFFSET_SD_PWRSW_CTRL);
+		}
+	}
+
+	//wait 1ms
+	mdelay(1);
+
+	// restore to DS/HS setting
+	sdhci_writel(host,
+		sdhci_readl(host, CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(1) | BIT(8) | BIT(9),
+		CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R);
+	sdhci_writel(host, 0x1000100, CVI_182X_SDHCI_PHY_TX_RX_DLY);
+	sdhci_writel(host, 1, CVI_182X_SDHCI_PHY_CONFIG);
+
+	mdelay(1);
+}
+
+static void sdhci_cv182x_sd_set_power(struct sdhci_host *host, unsigned char mode,
+				unsigned short vdd)
+{
+	struct mmc_host *mmc = host->mmc;
+
+	pr_debug("%s:mode %u, vdd %u\n", __func__, mode, vdd);
+
+	if (mode == MMC_POWER_ON && mmc->ops->get_cd(mmc)) {
+		sdhci_set_power_noreg(host, mode, vdd);
+		sdhci_cv182x_sd_voltage_restore(host, false);
+		sdhci_cv182x_sd_setup_pad(host, false);
+		sdhci_cv182x_sd_setup_io(host, false);
+		mdelay(5);
+	} else if (mode == MMC_POWER_OFF) {
+		sdhci_cv182x_sd_setup_pad(host, true);
+		sdhci_cv182x_sd_setup_io(host, true);
+		sdhci_cv182x_sd_voltage_restore(host, true);
+		sdhci_set_power_noreg(host, mode, vdd);
+		mdelay(30);
+	}
+}
+
+static void sdhci_cv182x_emmc_dump_vendor_regs(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+	u8 clk_source_select = 0;
+	u8 PAD_EMMC_RSTN = 0;
+	u8 PAD_EMMC_CLK  = 0;
+	u8 PAD_EMMC_CMD  = 0;
+	u8 PAD_EMMC_DAT0 = 0;
+	u8 PAD_EMMC_DAT1 = 0;
+	u8 PAD_EMMC_DAT2 = 0;
+	u8 PAD_EMMC_DAT3 = 0;
+	u8 REG_EMMC_RSTN = 0;
+	u8 REG_EMMC_CLK  = 0;
+	u8 REG_EMMC_CMD  = 0;
+	u8 REG_EMMC_DAT0 = 0;
+	u8 REG_EMMC_DAT1 = 0;
+	u8 REG_EMMC_DAT2 = 0;
+	u8 REG_EMMC_DAT3 = 0;
+
+	SDHCI_DUMP(": Reg_200:   0x%08x | Reg_240:  0x%08x\n",
+		   sdhci_readl(host, CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R),
+		   sdhci_readl(host, CVI_182X_SDHCI_PHY_TX_RX_DLY));
+	SDHCI_DUMP(": Reg_244:   0x%08x | Reg_248:  0x%08x\n",
+		   sdhci_readl(host, CVI_182X_SDHCI_PHY_DS_DLY),
+		   sdhci_readw(host, CVI_182X_SDHCI_PHY_DLY_STS));
+	SDHCI_DUMP(": Reg_24C:   0x%08x\n", CVI_182X_SDHCI_PHY_CONFIG);
+
+	PAD_EMMC_RSTN = readb(cvi_host->pinmuxbase + 0x48) & 0x07;
+	PAD_EMMC_CLK  = readb(cvi_host->pinmuxbase + 0x50) & 0x07;
+	PAD_EMMC_CMD  = readb(cvi_host->pinmuxbase + 0x5C) & 0x07;
+	PAD_EMMC_DAT0 = readb(cvi_host->pinmuxbase + 0x54) & 0x07;
+	PAD_EMMC_DAT1 = readb(cvi_host->pinmuxbase + 0x60) & 0x07;
+	PAD_EMMC_DAT2 = readb(cvi_host->pinmuxbase + 0x4C) & 0x07;
+	PAD_EMMC_DAT3 = readb(cvi_host->pinmuxbase + 0x58) & 0x07;
+	REG_EMMC_RSTN = readb(cvi_host->pinmuxbase + 0x914);
+	REG_EMMC_CLK  = readb(cvi_host->pinmuxbase + 0x91D);
+	REG_EMMC_CMD  = readb(cvi_host->pinmuxbase + 0x928);
+	REG_EMMC_DAT0 = readb(cvi_host->pinmuxbase + 0x920);
+	REG_EMMC_DAT1 = readb(cvi_host->pinmuxbase + 0x92D);
+	REG_EMMC_DAT2 = readb(cvi_host->pinmuxbase + 0x918);
+	REG_EMMC_DAT3 = readb(cvi_host->pinmuxbase + 0x924);
+
+	SDHCI_DUMP(": PAD_EMMC_RSTN:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_RSTN, (REG_EMMC_RSTN & 0x04)>>2, (REG_EMMC_RSTN & 0x08)>>3,
+		(REG_EMMC_RSTN & 0x80)>>7, (REG_EMMC_RSTN & 0x40)>>6, (REG_EMMC_RSTN & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_CLK:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_CLK, (REG_EMMC_CLK & 0x04)>>2, (REG_EMMC_CLK & 0x08)>>3,
+		(REG_EMMC_CLK & 0x80)>>7, (REG_EMMC_CLK & 0x40)>>6, (REG_EMMC_CLK & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_CMD:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_CMD, (REG_EMMC_CMD & 0x04)>>2, (REG_EMMC_CMD & 0x08)>>3,
+		(REG_EMMC_CMD & 0x80)>>7, (REG_EMMC_CMD & 0x40)>>6, (REG_EMMC_CMD & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_DAT0:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_DAT0, (REG_EMMC_DAT0 & 0x04)>>2, (REG_EMMC_DAT0 & 0x08)>>3,
+		(REG_EMMC_DAT0 & 0x80)>>7, (REG_EMMC_DAT0 & 0x40)>>6, (REG_EMMC_DAT0 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_DAT1:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_DAT1, (REG_EMMC_DAT1 & 0x04)>>2, (REG_EMMC_DAT1 & 0x08)>>3,
+		(REG_EMMC_DAT1 & 0x80)>>7, (REG_EMMC_DAT1 & 0x40)>>6, (REG_EMMC_DAT1 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_DAT2:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_DAT2, (REG_EMMC_DAT2 & 0x04)>>2, (REG_EMMC_DAT2 & 0x08)>>3,
+		(REG_EMMC_DAT2 & 0x80)>>7, (REG_EMMC_DAT2 & 0x40)>>6, (REG_EMMC_DAT2 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_DAT3:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_DAT3, (REG_EMMC_DAT3 & 0x04)>>2, (REG_EMMC_DAT3 & 0x08)>>3,
+		(REG_EMMC_DAT3 & 0x80)>>7, (REG_EMMC_DAT3 & 0x40)>>6, (REG_EMMC_DAT3 & 0x20)>>5);
+
+	clk_source_select = (readb(cvi_host->clkgenbase + 0x20) & 0x20) >> 5;
+
+	SDHCI_DUMP(": clk_emmc enable[16]:0x%08x\n", readl(cvi_host->clkgenbase));
+	SDHCI_DUMP(": clk_emmc source_select:%u\n", clk_source_select);
+	if (clk_source_select == 0) {
+		SDHCI_DUMP(": clk_emmc REG:0x03002068 = 0x%08x\n",
+		readl(cvi_host->clkgenbase + 0x68));
+		if (readl(cvi_host->clkgenbase + 0x68) == 0x00000001)
+			SDHCI_DUMP(": clk_emmc %d MHz\n", DISPPLL_MHZ/12);
+	} else if (clk_source_select == 1) {
+		SDHCI_DUMP(": clk_emmc REG:0x03002064 = 0x%08x\n",
+		readl(cvi_host->clkgenbase + 0x64));
+		if (readl(cvi_host->clkgenbase + 0x64) == 0x00040009)
+			SDHCI_DUMP(": clk_emmc %d MHz\n", FPLL_MHZ/4);
+	}
+}
+
+static void sdhci_cv182x_sd_dump_vendor_regs(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+	u8 clk_source_select = 0;
+	u8 PAD_SDIO0_PWR_EN = 0;
+	u8 PAD_SDIO0_CD  = 0;
+	u8 PAD_SDIO0_CLK = 0;
+	u8 PAD_SDIO0_CMD = 0;
+	u8 PAD_SDIO0_D0  = 0;
+	u8 PAD_SDIO0_D1  = 0;
+	u8 PAD_SDIO0_D2  = 0;
+	u8 PAD_SDIO0_D3  = 0;
+	u8 REG_SDIO0_PWR_EN = 0;
+	u8 REG_SDIO0_CD  = 0;
+	u8 REG_SDIO0_CLK = 0;
+	u8 REG_SDIO0_CMD = 0;
+	u8 REG_SDIO0_D0  = 0;
+	u8 REG_SDIO0_D1  = 0;
+	u8 REG_SDIO0_D2  = 0;
+	u8 REG_SDIO0_D3  = 0;
+
+	SDHCI_DUMP(": Reg_200:   0x%08x | Reg_240:  0x%08x\n",
+		   sdhci_readl(host, CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R),
+		   sdhci_readl(host, CVI_182X_SDHCI_PHY_TX_RX_DLY));
+	SDHCI_DUMP(": Reg_244:   0x%08x | Reg_248:  0x%08x\n",
+		   sdhci_readl(host, CVI_182X_SDHCI_PHY_DS_DLY),
+		   sdhci_readw(host, CVI_182X_SDHCI_PHY_DLY_STS));
+	SDHCI_DUMP(": Reg_24C:   0x%08x\n", CVI_182X_SDHCI_PHY_CONFIG);
+
+	PAD_SDIO0_PWR_EN = readb(cvi_host->pinmuxbase + 0x38) & 0x07;
+	PAD_SDIO0_CD  = readb(cvi_host->pinmuxbase + 0x34) & 0x07;
+	PAD_SDIO0_CLK = readb(cvi_host->pinmuxbase + 0x1C) & 0x07;
+	PAD_SDIO0_CMD = readb(cvi_host->pinmuxbase + 0x20) & 0x07;
+	PAD_SDIO0_D0  = readb(cvi_host->pinmuxbase + 0x24) & 0x07;
+	PAD_SDIO0_D1  = readb(cvi_host->pinmuxbase + 0x28) & 0x07;
+	PAD_SDIO0_D2  = readb(cvi_host->pinmuxbase + 0x2C) & 0x07;
+	PAD_SDIO0_D3  = readb(cvi_host->pinmuxbase + 0x30) & 0x07;
+	REG_SDIO0_PWR_EN = readb(cvi_host->pinmuxbase + 0x904);
+	REG_SDIO0_CD  = readb(cvi_host->pinmuxbase + 0x900);
+	REG_SDIO0_CLK = readb(cvi_host->pinmuxbase + 0xA00);
+	REG_SDIO0_CMD = readb(cvi_host->pinmuxbase + 0xA04);
+	REG_SDIO0_D0  = readb(cvi_host->pinmuxbase + 0xA08);
+	REG_SDIO0_D1  = readb(cvi_host->pinmuxbase + 0xA0C);
+	REG_SDIO0_D2  = readb(cvi_host->pinmuxbase + 0xA10);
+	REG_SDIO0_D3  = readb(cvi_host->pinmuxbase + 0xA14);
+
+	SDHCI_DUMP(": PAD_SDIO0_PWR_EN:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_PWR_EN, (REG_SDIO0_PWR_EN & 0x04)>>2, (REG_SDIO0_PWR_EN & 0x08)>>3,
+		(REG_SDIO0_PWR_EN & 0x80)>>7, (REG_SDIO0_PWR_EN & 0x40)>>6, (REG_SDIO0_PWR_EN & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_CD:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_CD, (REG_SDIO0_CD & 0x04)>>2, (REG_SDIO0_CD & 0x08)>>3,
+		(REG_SDIO0_CD & 0x80)>>7, (REG_SDIO0_CD & 0x40)>>6, (REG_SDIO0_CD & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_CLK:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_CLK, (REG_SDIO0_CLK & 0x04)>>2, (REG_SDIO0_CLK & 0x08)>>3,
+		(REG_SDIO0_CLK & 0x80)>>7, (REG_SDIO0_CLK & 0x40)>>6, (REG_SDIO0_CLK & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_CMD:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_CMD, (REG_SDIO0_CMD & 0x04)>>2, (REG_SDIO0_CMD & 0x08)>>3,
+		(REG_SDIO0_CMD & 0x80)>>7, (REG_SDIO0_CMD & 0x40)>>6, (REG_SDIO0_CMD & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_D0:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_D0, (REG_SDIO0_D0 & 0x04)>>2, (REG_SDIO0_D0 & 0x08)>>3,
+		(REG_SDIO0_D0 & 0x80)>>7, (REG_SDIO0_D0 & 0x40)>>6, (REG_SDIO0_D0 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_D1:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_D1, (REG_SDIO0_D1 & 0x04)>>2, (REG_SDIO0_D1 & 0x08)>>3,
+		(REG_SDIO0_D1 & 0x80)>>7, (REG_SDIO0_D1 & 0x40)>>6, (REG_SDIO0_D1 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_D2:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_D2, (REG_SDIO0_D2 & 0x04)>>2, (REG_SDIO0_D2 & 0x08)>>3,
+		(REG_SDIO0_D2 & 0x80)>>7, (REG_SDIO0_D2 & 0x40)>>6, (REG_SDIO0_D2 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_D3:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_D3, (REG_SDIO0_D3 & 0x04)>>2, (REG_SDIO0_D3 & 0x08)>>3,
+		(REG_SDIO0_D3 & 0x80)>>7, (REG_SDIO0_D3 & 0x40)>>6, (REG_SDIO0_D3 & 0x20)>>5);
+
+	clk_source_select = (readb(cvi_host->clkgenbase + 0x20) & 0x40) >> 6;
+
+	SDHCI_DUMP(": clk_sd0 enable[19]:0x%08x\n", readl(cvi_host->clkgenbase));
+	SDHCI_DUMP(": clk_sd0 source_select:%u\n", clk_source_select);
+	if (clk_source_select == 0) {
+		SDHCI_DUMP(": clk_sd0 REG:0x03002074 = 0x%08x\n",
+		readl(cvi_host->clkgenbase + 0x74));
+		if (readl(cvi_host->clkgenbase + 0x74) == 0x00000001)
+			SDHCI_DUMP(": clk_sd0 %d MHz\n", DISPPLL_MHZ/12);
+	} else if (clk_source_select == 1) {
+		SDHCI_DUMP(": clk_sd0 REG:0x03002070 = 0x%08x\n",
+		readl(cvi_host->clkgenbase + 0x70));
+		if (readl(cvi_host->clkgenbase + 0x70) == 0x00040009)
+			SDHCI_DUMP(": clk_sd0 %d MHz\n", FPLL_MHZ/4);
+	}
+}
+
+static const struct sdhci_ops sdhci_cv182x_emmc_ops = {
+	.reset = sdhci_cv182x_emmc_reset,
+	.set_clock = sdhci_set_clock,
+	.set_bus_width = sdhci_set_bus_width,
+	.get_max_clock = sdhci_cvi_general_emmc_get_max_clock,
+	.voltage_switch = sdhci_cvi_emmc_voltage_switch,
+	.set_uhs_signaling = sdhci_cvi_general_set_uhs_signaling,
+	.platform_execute_tuning = sdhci_cv182x_general_execute_tuning,
+	.select_drive_strength = sdhci_cv182x_general_select_drive_strength,
+	.dump_vendor_regs = sdhci_cv182x_emmc_dump_vendor_regs,
+};
+
+static const struct sdhci_ops sdhci_cv182x_sd_ops = {
+	.reset = sdhci_cv182x_sd_reset,
+	.set_clock = sdhci_set_clock,
+	.set_power = sdhci_cv182x_sd_set_power,
+	.set_bus_width = sdhci_set_bus_width,
+	.get_max_clock = sdhci_cv182x_sd_get_max_clock,
+	.voltage_switch = sdhci_cv182x_sd_voltage_switch,
+	.set_uhs_signaling = sdhci_cvi_general_set_uhs_signaling,
+	.platform_execute_tuning = sdhci_cv182x_general_execute_tuning,
+	.select_drive_strength = sdhci_cv182x_general_select_drive_strength,
+	.dump_vendor_regs = sdhci_cv182x_sd_dump_vendor_regs,
+};
+
+static const struct sdhci_ops sdhci_cv182x_sdio_ops = {
+	.reset = sdhci_cv182x_sdio_reset,
+	.set_clock = sdhci_set_clock,
+	.set_bus_width = sdhci_set_bus_width,
+	.get_max_clock = sdhci_cv182x_sd_get_max_clock,
+	.voltage_switch = sdhci_cv182x_sd_voltage_switch,
+	.set_uhs_signaling = sdhci_cvi_general_set_uhs_signaling,
+	.select_drive_strength = sdhci_cv182x_general_select_drive_strength,
+	.platform_execute_tuning = sdhci_cv182x_general_execute_tuning,
+};
+
+static const struct sdhci_pltfm_data sdhci_cv182x_emmc_pdata = {
+	.ops = &sdhci_cv182x_emmc_ops,
+	.quirks = SDHCI_QUIRK_INVERTED_WRITE_PROTECT | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
+};
+
+static const struct sdhci_pltfm_data sdhci_cv182x_sd_pdata = {
+	.ops = &sdhci_cv182x_sd_ops,
+	.quirks = SDHCI_QUIRK_INVERTED_WRITE_PROTECT | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
+};
+
+static const struct sdhci_pltfm_data sdhci_cv182x_sdio_pdata = {
+	.ops = &sdhci_cv182x_sdio_ops,
+	.quirks = SDHCI_QUIRK_INVERTED_WRITE_PROTECT | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN | SDHCI_QUIRK2_NO_1_8_V,
+};
+
+static const struct of_device_id sdhci_cvi_dt_match[] = {
+	{.compatible = "cvitek,cv182x-emmc", .data = &sdhci_cv182x_emmc_pdata},
+	{.compatible = "cvitek,cv182x-sd", .data = &sdhci_cv182x_sd_pdata},
+	{.compatible = "cvitek,cv182x-sdio", .data = &sdhci_cv182x_sdio_pdata},
+
+	{ /* sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(of, sdhci_cvi_dt_match);
+
+static irqreturn_t sdhci_cvi_cd_handler(int irq, void *dev_id)
+{
+	/* Schedule a card detection after a debounce timeout */
+	struct mmc_host *host = dev_id;
+	struct mmc_gpio *ctx = host->slot.handler_priv;
+
+	pr_debug("%s-%d mmc_gpio_get_cd:%d\n",
+		__func__, __LINE__, mmc_gpio_get_cd(host));
+	host->trigger_card_event = true;
+	host->ops->card_event(host);
+	mmc_detect_change(host, msecs_to_jiffies(ctx->cd_debounce_delay_ms));
+
+	return IRQ_HANDLED;
+
+}
+
+static int sdhci_cvi_probe(struct platform_device *pdev)
+{
+	struct sdhci_host *host;
+	struct sdhci_pltfm_host *pltfm_host;
+	struct sdhci_cvi_host *cvi_host;
+	const struct of_device_id *match;
+	const struct sdhci_pltfm_data *pdata;
+	int ret;
+	int gpio_cd = -EINVAL;
+
+	pr_info(DRIVER_NAME ":%s\n", __func__);
+
+	match = of_match_device(sdhci_cvi_dt_match, &pdev->dev);
+	if (!match)
+		return -EINVAL;
+
+	pdata = match->data;
+
+	host = sdhci_pltfm_init(pdev, pdata, sizeof(*cvi_host));
+	if (IS_ERR(host))
+		return PTR_ERR(host);
+
+	pltfm_host = sdhci_priv(host);
+	cvi_host = sdhci_pltfm_priv(pltfm_host);
+	cvi_host->host = host;
+	cvi_host->mmc = host->mmc;
+	cvi_host->pdev = pdev;
+	cvi_host->core_mem = host->ioaddr;
+	cvi_host->topbase = ioremap(TOP_BASE, 0x2000);
+	cvi_host->pinmuxbase = ioremap(PINMUX_BASE, 0x1000);
+	cvi_host->clkgenbase = ioremap(CLKGEN_BASE, 0x100);
+
+	sdhci_cv182x_sd_voltage_restore(host, false);
+
+	ret = mmc_of_parse(host->mmc);
+	if (ret)
+		goto pltfm_free;
+
+	sdhci_get_of_property(pdev);
+
+	if (pdata->ops->hw_reset) {
+		cvi_host->reset = devm_reset_control_get(&pdev->dev, "sdio");
+		if (IS_ERR(cvi_host->reset)) {
+			ret = PTR_ERR(cvi_host->reset);
+			goto pltfm_free;
+		}
+	}
+
+	if (pdev->dev.of_node) {
+		gpio_cd = of_get_named_gpio(pdev->dev.of_node, "cvi-cd-gpios", 0);
+	}
+
+	if (gpio_is_valid(gpio_cd)) {
+		cvi_host->cvi_gpio = devm_kzalloc(&cvi_host->pdev->dev,
+					sizeof(struct mmc_gpio), GFP_KERNEL);
+		if (cvi_host->cvi_gpio) {
+			cvi_host->cvi_gpio->cd_gpio_isr = sdhci_cvi_cd_handler;
+			cvi_host->cvi_gpio->cd_debounce_delay_ms = SDHCI_GPIO_CD_DEBOUNCE_DELAY_TIME;
+			cvi_host->cvi_gpio->cd_label = devm_kzalloc(&cvi_host->pdev->dev,
+						strlen("cd-gpio-irq") + 1, GFP_KERNEL);
+			strcpy(cvi_host->cvi_gpio->cd_label, "cd-gpio-irq");
+			host->mmc->slot.handler_priv = cvi_host->cvi_gpio;
+			ret = mmc_gpiod_request_cd(host->mmc, "cvi-cd",
+					0, false, SDHCI_GPIO_CD_DEBOUNCE_TIME);
+			if (ret) {
+				pr_err("card detect request cd failed: %d\n", ret);
+			} else {
+				writeb(0x3, cvi_host->pinmuxbase + 0x34);
+				mmc_gpiod_request_cd_irq(host->mmc);
+			}
+		}
+	}
+
+	ret = sdhci_add_host(host);
+	if (ret)
+		goto err_add_host;
+
+	platform_set_drvdata(pdev, cvi_host);
+
+	if (strstr(dev_name(mmc_dev(host->mmc)), "wifi-sd"))
+		wifi_mmc = host->mmc;
+	else
+		wifi_mmc = NULL;
+
+	/* device proc entry */
+	if ((!proc_cvi_dir) &&
+		(strstr(dev_name(mmc_dev(host->mmc)), "cv-sd"))) {
+		ret = cvi_proc_init(cvi_host);
+		if (ret)
+			pr_err("device proc init is failed!");
+	}
+
+	if (strstr(dev_name(mmc_dev(host->mmc)), "cv-emmc"))
+		sdhci_cv182x_emmc_setup_pad(host);
+
+	return 0;
+
+err_add_host:
+pltfm_free:
+	sdhci_pltfm_free(pdev);
+	return ret;
+}
+
+static int sdhci_cvi_remove(struct platform_device *pdev)
+{
+	struct sdhci_host *host = platform_get_drvdata(pdev);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+	int dead = (readl_relaxed(host->ioaddr + SDHCI_INT_STATUS) == 0xffffffff);
+
+	sdhci_remove_host(host, dead);
+	sdhci_pltfm_free(pdev);
+
+	cvi_proc_shutdown(cvi_host);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_ARCH_CV182X_ASIC
+
+static int save_rtc_reg(struct sdhci_cvi_host *cvi_host)
+{
+	void __iomem *topbase;
+	void __iomem *rtcbase;
+
+	topbase = ioremap(TOP_BASE, 0x250);
+	rtcbase = ioremap(RTC_CTRL_BASE, 0x80);
+
+	if (!cvi_host->rtc_reg_ctx) {
+		cvi_host->rtc_reg_ctx = devm_kzalloc(&cvi_host->pdev->dev,
+								sizeof(struct cvi_rtc_sdhci_reg_context), GFP_KERNEL);
+		if (!cvi_host->rtc_reg_ctx)
+			return -ENOMEM;
+	}
+	cvi_host->rtc_reg_ctx->rtcsys_clkmux = readl(rtcbase + RTCSYS_CLKMUX);
+	cvi_host->rtc_reg_ctx->rtcsys_clkbyp = readl(rtcbase + RTCSYS_CLKBYP);
+	cvi_host->rtc_reg_ctx->rtcsys_mcu51_ictrl1 = readl(rtcbase + RTCSYS_MCU51_ICTRL1);
+	cvi_host->rtc_reg_ctx->rtcsys_ctrl = readl(topbase + RTCSYS_CTRL);
+
+	iounmap(topbase);
+	iounmap(rtcbase);
+
+	return 0;
+}
+
+static void restore_rtc_reg(struct sdhci_cvi_host *cvi_host)
+{
+	void __iomem *topbase;
+	void __iomem *rtcbase;
+
+	topbase = ioremap(TOP_BASE, 0x250);
+	rtcbase = ioremap(RTC_CTRL_BASE, 0x80);
+
+	writel(cvi_host->rtc_reg_ctx->rtcsys_clkmux, rtcbase + RTCSYS_CLKMUX);
+	writel(cvi_host->rtc_reg_ctx->rtcsys_clkbyp, rtcbase + RTCSYS_CLKBYP);
+	writel(cvi_host->rtc_reg_ctx->rtcsys_mcu51_ictrl1, rtcbase + RTCSYS_MCU51_ICTRL1);
+	writel(cvi_host->rtc_reg_ctx->rtcsys_ctrl, topbase + RTCSYS_CTRL);
+
+	iounmap(topbase);
+	iounmap(rtcbase);
+}
+#else
+static int save_rtc_reg(struct sdhci_cvi_host *cvi_host)
+{
+	return 0;
+}
+static void restore_rtc_reg(struct sdhci_cvi_host *cvi_host) {}
+#endif
+
+static void save_reg(struct sdhci_host *host, struct sdhci_cvi_host *cvi_host)
+{
+	save_rtc_reg(cvi_host);
+	cvi_host->reg_ctrl2 = sdhci_readl(host, SDHCI_HOST_CONTROL2);
+	cvi_host->reg_clk_ctrl = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
+	cvi_host->reg_host_ctrl = sdhci_readl(host, SDHCI_HOST_CONTROL);
+}
+
+static void restore_reg(struct sdhci_host *host, struct sdhci_cvi_host *cvi_host)
+{
+	restore_rtc_reg(cvi_host);
+	sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
+	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
+	sdhci_writel(host, cvi_host->reg_ctrl2, SDHCI_HOST_CONTROL2);
+	sdhci_writel(host, cvi_host->reg_clk_ctrl, SDHCI_CLOCK_CONTROL);
+	sdhci_writel(host, cvi_host->reg_host_ctrl, SDHCI_HOST_CONTROL);
+}
+
+static int sdhci_cvi_suspend(struct device *dev)
+{
+	struct sdhci_cvi_host *cvi_host = dev_get_drvdata(dev);
+	struct sdhci_host *host = cvi_host->host;
+
+	if (!host)
+		return 0;
+
+	save_reg(host, cvi_host);
+
+	return 0;
+}
+
+static int sdhci_cvi_resume(struct device *dev)
+{
+	struct sdhci_cvi_host *cvi_host = dev_get_drvdata(dev);
+	struct sdhci_host *host = cvi_host->host;
+
+	if (!host)
+		return 0;
+
+	restore_reg(host, cvi_host);
+
+	return 0;
+}
+
+#endif
+
+static const struct dev_pm_ops sdhci_cvi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(sdhci_cvi_suspend, sdhci_cvi_resume)
+};
+
+static struct platform_driver sdhci_cvi_driver = {
+	.probe = sdhci_cvi_probe,
+	.remove = sdhci_cvi_remove,
+	.driver = {
+		.name = DRIVER_NAME,
+		.pm = &sdhci_cvi_pm_ops,
+		.of_match_table = sdhci_cvi_dt_match,
+	},
+};
+
+module_platform_driver(sdhci_cvi_driver);
+
+MODULE_DESCRIPTION("Cvitek Secure Digital Host Controller Interface driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mmc/host/cvitek/sdhci-cv182x.h b/drivers/mmc/host/cvitek/sdhci-cv182x.h
new file mode 100644
index 000000000000..c59868cff06d
--- /dev/null
+++ b/drivers/mmc/host/cvitek/sdhci-cv182x.h
@@ -0,0 +1,103 @@
+/*
+ * drivers/mmc/host/sdhci-cvi.c - CVITEK SDHCI Platform driver
+ *
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __SDHCI_CV_H
+#define __SDHCI_CV_H
+
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/delay.h>
+#include <linux/mmc/mmc.h>
+#include <linux/slab.h>
+
+#define MAX_TUNING_CMD_RETRY_COUNT 50
+#define TUNE_MAX_PHCODE	128
+#define TAP_WINDOW_THLD 20
+#define DISPPLL_MHZ 1188
+#define FPLL_MHZ 1500
+
+#define TOP_BASE	0x03000000
+#define OFFSET_SD_PWRSW_CTRL	0x1F4
+
+#define PINMUX_BASE 0x03001000
+#define CLKGEN_BASE 0x03002000
+
+
+#define CVI_182X_SDHCI_VENDOR_OFFSET		0x200
+#define CVI_182X_SDHCI_VENDOR_MSHC_CTRL_R	(CVI_182X_SDHCI_VENDOR_OFFSET + 0x0)
+#define CVI_182X_SDHCI_PHY_TX_RX_DLY		(CVI_182X_SDHCI_VENDOR_OFFSET + 0x40)
+#define CVI_182X_SDHCI_PHY_DS_DLY			(CVI_182X_SDHCI_VENDOR_OFFSET + 0x44)
+#define CVI_182X_SDHCI_PHY_DLY_STS			(CVI_182X_SDHCI_VENDOR_OFFSET + 0x48)
+#define CVI_182X_SDHCI_PHY_CONFIG			(CVI_182X_SDHCI_VENDOR_OFFSET + 0x4C)
+
+#define SDHCI_GPIO_CD_DEBOUNCE_TIME	15
+#define SDHCI_GPIO_CD_DEBOUNCE_DELAY_TIME	200
+
+#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_ARCH_CV182X_ASIC
+
+#define RTC_CTRL_BASE		0x5025000
+#define RTCSYS_CLKMUX	0x1C
+#define RTCSYS_CLKBYP	0x30
+#define RTCSYS_MCU51_ICTRL1	0x7C
+
+#define RTCSYS_CTRL		0x248
+
+struct cvi_rtc_sdhci_reg_context {
+	u32 rtcsys_clkmux;
+	u32 rtcsys_clkbyp;
+	u32 rtcsys_mcu51_ictrl1;
+	u32 rtcsys_ctrl;
+};
+#else
+struct cvi_rtc_sdhci_reg_context {};
+#endif
+#endif
+
+struct sdhci_cvi_host {
+	struct sdhci_host *host;
+	struct platform_device *pdev;
+	void __iomem *core_mem; /* mmio address */
+	struct clk *clk;    /* main SD/MMC bus clock */
+	struct clk *clk100k;
+	struct clk *clkaxi;
+	struct mmc_host *mmc;
+	struct reset_control *reset;
+
+	struct reset_control *clk_rst_axi_emmc_ctrl;
+	struct reset_control *clk_rst_emmc_ctrl;
+	struct reset_control *clk_rst_100k_emmc_ctrl;
+
+	int gpio_card_cd;
+	int gpio_card_cd_active;
+
+	void __iomem *topbase;
+	void __iomem *pinmuxbase;
+	void __iomem *clkgenbase;
+
+	u32 reg_ctrl2;
+	u32 reg_clk_ctrl;
+	u32 reg_host_ctrl;
+	u8 final_tap;
+	u8 sdio0_voltage_1_8_v;
+	int sd_save_count;
+	struct mmc_gpio *cvi_gpio;
+#ifdef CONFIG_PM_SLEEP
+	struct cvi_rtc_sdhci_reg_context *rtc_reg_ctx;
+#endif
+
+};
+#endif
diff --git a/drivers/mmc/host/cvitek/sdhci-cv183x.c b/drivers/mmc/host/cvitek/sdhci-cv183x.c
new file mode 100644
index 000000000000..8bfd90629699
--- /dev/null
+++ b/drivers/mmc/host/cvitek/sdhci-cv183x.c
@@ -0,0 +1,1467 @@
+/*
+ * drivers/mmc/host/sdhci-cv.c - CVITEK SDHCI Platform driver
+ *
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/host.h>
+#include <linux/slab.h>
+#include <linux/reset.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/device.h>
+#include <linux/export.h>
+#include <linux/io.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/of_gpio.h>
+#include <linux/mmc/slot-gpio.h>
+
+#include "../../core/card.h"
+#include "../sdhci-pltfm.h"
+#include "sdhci-cv183x.h"
+
+#define DRIVER_NAME "cvi"
+#define SDHCI_DUMP(f, x...) \
+	pr_err("%s: " DRIVER_NAME ": " f, mmc_hostname(host->mmc), ## x)
+
+#define MAX_CARD_TYPE 4
+#define MAX_SPEED_MODE 5
+
+#define CVI_PARENT "cvi"
+#define CVI_STATS_PROC "cvi_info"
+#define MAX_CLOCK_SCALE (4)
+
+#define UNSTUFF_BITS(resp, start, size)                 \
+	({                                                      \
+	const int __size = size;                                \
+	const u32 __mask = (__size < 32 ? 1 << __size : 0) - 1; \
+	const int __off = 3 - ((start) / 32);                   \
+	const int __shft = (start) & 31;                        \
+	u32 __res;                                              \
+	__res = resp[__off] >> __shft;                          \
+	if (__size + __shft > 32)                               \
+		__res |= resp[__off - 1] << ((32 - __shft) % 32);   \
+	__res & __mask;                                         \
+	})
+
+static struct proc_dir_entry *proc_cvi_dir;
+
+static char *card_type[MAX_CARD_TYPE + 1] = {
+	"MMC card", "SD card", "SDIO card", "SD combo (IO+mem) card", "unknown"
+};
+
+static char *cvi_get_card_type(unsigned int sd_type)
+{
+	if (sd_type >= MAX_CARD_TYPE)
+		return card_type[MAX_CARD_TYPE];
+	else
+		return card_type[sd_type];
+}
+
+static inline int is_card_uhs(unsigned char timing)
+{
+	return timing >= MMC_TIMING_UHS_SDR12 && timing <= MMC_TIMING_UHS_DDR50;
+};
+
+static inline int is_card_hs(unsigned char timing)
+{
+	return timing == MMC_TIMING_SD_HS || timing == MMC_TIMING_MMC_HS;
+};
+
+static void cvi_stats_seq_printout(struct seq_file *s)
+{
+	const char *type = NULL;
+	unsigned int present;
+	unsigned char timing;
+	struct sdhci_cvi_host *cvi_host = NULL;
+	struct mmc_host *mmc = NULL;
+	struct mmc_card *card = NULL;
+	const char *uhs_bus_speed_mode = "";
+	u32 speed_class, grade_speed_uhs;
+	static const char *const uhs_speeds[] = {
+		[UHS_SDR12_BUS_SPEED] = "SDR12 ", [UHS_SDR25_BUS_SPEED] = "SDR25 ",
+		[UHS_SDR50_BUS_SPEED] = "SDR50 ", [UHS_SDR104_BUS_SPEED] = "SDR104 ",
+		[UHS_DDR50_BUS_SPEED] = "DDR50 ",
+	};
+	cvi_host = (struct sdhci_cvi_host *)s->private;
+
+	if (!cvi_host || !cvi_host->mmc) {
+		seq_printf(s, "cvi s : %p: s->private %p\n", s, s->private);
+		return;
+	}
+
+	seq_printf(s, "cvi.%d", cvi_host->mmc->index);
+
+	mmc = cvi_host->mmc;
+	present = mmc->ops->get_cd(mmc);
+
+	if (present) {
+		seq_puts(s, ": plugged");
+	} else {
+		seq_puts(s, ": unplugged");
+	}
+
+	card = mmc->card;
+
+	if (!card) {
+		seq_puts(s, "_disconnected\n");
+	} else {
+		seq_puts(s, "_connected\n");
+		seq_printf(s, "\tType: %s", cvi_get_card_type(card->type));
+
+		//if (card->state & MMC_STATE_BLOCKADDR) {
+		if (mmc_card_blockaddr(card)) {
+			if (card->state & MMC_CARD_SDXC)
+				type = "SDXC";
+			else
+				type = "SDHC";
+			seq_printf(s, "(%s)\n", type);
+		}
+
+		timing = mmc->ios.timing;
+
+		if (is_card_uhs(mmc->ios.timing) &&
+		    card->sd_bus_speed < ARRAY_SIZE(uhs_speeds))
+			uhs_bus_speed_mode = uhs_speeds[card->sd_bus_speed];
+
+		seq_printf(s, "\tMode: %s%s%s%s\n",
+			   is_card_uhs(timing) ? "UHS "
+			   : (is_card_hs(timing) ? "HS " : ""),
+			   timing == MMC_TIMING_MMC_HS400
+			   ? "HS400 "
+			   : (timing == MMC_TIMING_MMC_HS200 ? "HS200 " : ""),
+			   timing == MMC_TIMING_MMC_DDR52 ? "DDR " : "",
+			   uhs_bus_speed_mode);
+
+		speed_class = UNSTUFF_BITS(card->raw_ssr, 440 - 384, 8);
+		grade_speed_uhs = UNSTUFF_BITS(card->raw_ssr, 396 - 384, 4);
+		seq_printf(s, "\tSpeed Class: Class %s\n",
+			   (speed_class == 0x00)
+			   ? "0"
+			   : (speed_class == 0x01)
+			   ? "2"
+			   : (speed_class == 0x02)
+			   ? "4"
+			   : (speed_class == 0x03)
+			   ? "6"
+			   : (speed_class == 0x04)
+			   ? "10"
+			   : "Reserved");
+		seq_printf(s, "\tUhs Speed Grade: %s\n",
+			   (grade_speed_uhs == 0x00)
+			   ? "Less than 10MB/sec(0h)"
+			   : (grade_speed_uhs == 0x01)
+			   ? "10MB/sec and above(1h)"
+			   : "Reserved");
+	}
+}
+
+/* proc interface setup */
+static void *cvi_seq_start(struct seq_file *s, loff_t *pos)
+{
+	/*   counter is used to tracking multi proc interfaces
+	 *  We have only one interface so return zero
+	 *  pointer to start the sequence.
+	 */
+	static unsigned long counter;
+
+	if (*pos == 0) {
+		return &counter;
+	}
+
+	*pos = 0;
+	return NULL;
+}
+
+/* define parameters where showed in proc file */
+static int cvi_stats_seq_show(struct seq_file *s, void *v)
+{
+	cvi_stats_seq_printout(s);
+	return 0;
+}
+
+/* proc interface stop */
+static void cvi_seq_stop(struct seq_file *s, void *v) {}
+
+/* proc interface operation */
+static const struct seq_operations cvi_stats_seq_ops = {
+	.start = cvi_seq_start,
+	.stop = cvi_seq_stop,
+	.show = cvi_stats_seq_show
+};
+
+/* proc file open*/
+static int cvi_stats_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, cvi_stats_seq_show, PDE_DATA(inode));
+};
+
+/* proc file operation */
+static const struct proc_ops cvi_stats_proc_ops = {
+	.proc_open = cvi_stats_proc_open,
+	.proc_read = seq_read,
+	.proc_release = single_release
+};
+
+int cvi_proc_init(struct sdhci_cvi_host *cvi_host)
+{
+	struct proc_dir_entry *proc_stats_entry;
+
+	pr_info("%s cvi_host 0x%p\n", __func__, cvi_host);
+
+	proc_cvi_dir = proc_mkdir(CVI_PARENT, NULL);
+
+	if (!proc_cvi_dir) {
+		pr_err("%s: failed to create proc file %s\n", __func__, CVI_PARENT);
+		return 1;
+	}
+
+	proc_stats_entry = proc_create_data(CVI_STATS_PROC, 0400, proc_cvi_dir, &cvi_stats_proc_ops,
+					    (void *)cvi_host);
+
+	if (!proc_stats_entry) {
+		pr_err("%s: failed to create proc file %s\n", __func__, CVI_STATS_PROC);
+		return 1;
+	}
+
+	return 0;
+}
+
+int cvi_proc_shutdown(struct sdhci_cvi_host *cvi_host)
+{
+	pr_info("%s\n", __func__);
+
+	if (proc_cvi_dir) {
+		remove_proc_entry(CVI_STATS_PROC, proc_cvi_dir);
+		remove_proc_entry(CVI_PARENT, NULL);
+		proc_cvi_dir = NULL;
+	}
+
+	return 0;
+}
+
+static void sdhci_cv183x_emmc_setup_pad(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	/* Name              Offset
+	 * PAD_EMMC_RSTN     0x24
+	 * PAD_EMMC_CLK      0x20
+	 * PAD_EMMC_CMD      0x28
+	 * PAD_EMMC_DAT0     0x30
+	 * PAD_EMMC_DAT1     0x2C
+	 * PAD_EMMC_DAT2     0x34
+	 * PAD_EMMC_DAT3     0x38
+
+	 */
+
+	u8 val = 0x0;
+
+	writeb(val, cvi_host->pinmuxbase + 0x24);
+	writeb(val, cvi_host->pinmuxbase + 0x20);
+	writeb(val, cvi_host->pinmuxbase + 0x28);
+	writeb(val, cvi_host->pinmuxbase + 0x30);
+	writeb(val, cvi_host->pinmuxbase + 0x2C);
+	writeb(val, cvi_host->pinmuxbase + 0x34);
+	writeb(val, cvi_host->pinmuxbase + 0x38);
+}
+
+static void sdhci_cv1835_sd_setup_pad(struct sdhci_host *host, bool bunplug)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	/* Name              Offset unplug plug
+	 * PAD_SDIO0_CD      0x04   SDIO0  SDIO0
+	 * PAD_SDIO0_PWR_EN  0x14   SDIO0  SDIO0
+	 * PAD_SDIO0_CLK     0x40   XGPIO  SDIO0
+	 * PAD_SDIO0_CMD     0x3C   XGPIO  SDIO0
+	 * PAD_SDIO0_D0      0x44   XGPIO  SDIO0
+	 * PAD_SDIO0_D1      0x48   XGPIO  SDIO0
+	 * PAD_SDIO0_D2      0x4C   XGPIO  SDIO0
+	 * PAD_SDIO0_D3      0x50   XGPIO  SDIO0
+	 * 0x0: SDIO0 function
+	 * 0x3: XGPIO function
+	 */
+
+	u8 val = (bunplug) ? 0x3 : 0x0;
+
+	if (cvi_host->cvi_gpio && cvi_host->cvi_gpio->cd_gpio)
+		writeb(0x3, cvi_host->pinmuxbase + 0x04);
+	else
+		writeb(0x0, cvi_host->pinmuxbase + 0x04);
+
+	writeb(0x0, cvi_host->pinmuxbase + 0x14);
+	writeb(val, cvi_host->pinmuxbase + 0x40);
+	writeb(val, cvi_host->pinmuxbase + 0x3C);
+	writeb(val, cvi_host->pinmuxbase + 0x44);
+	writeb(val, cvi_host->pinmuxbase + 0x48);
+	writeb(val, cvi_host->pinmuxbase + 0x4C);
+	writeb(val, cvi_host->pinmuxbase + 0x50);
+}
+
+static void sdhci_cv1835_sd_setup_io(struct sdhci_host *host, bool reset)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	/*
+	 * Name              Offset reset sd0
+	 * REG_SDIO0_CD      0xC04  PU    PU
+	 * REG_SDIO0_CLK     0xB04  PD    PD
+	 * REG_SDIO0_CMD     0xB00  PD    PU
+	 * REG_SDIO0_D0      0xB08  PD    PU
+	 * REG_SDIO0_D1      0xB0C  PD    PU
+	 * REG_SDIO0_D2      0xB10  PD    PU
+	 * REG_SDIO0_D3      0xB14  PD    PU
+	 * BIT(2) : PU   enable(1)/disable(0)
+	 * BIT(3) : PD   enable(1)/disable(0)
+	 */
+
+	u8 raise_bit = (reset) ?  BIT(3) : BIT(2);
+	u8 down_bit  = (reset) ?  BIT(2) : BIT(3);
+
+	writeb(((readb(cvi_host->pinmuxbase + 0xC04) | BIT(2)) & ~(BIT(3))),
+		cvi_host->pinmuxbase + 0xC04);
+	writeb(((readb(cvi_host->pinmuxbase + 0xB04) | BIT(3)) & ~(BIT(2))),
+		cvi_host->pinmuxbase + 0xB04);
+	writeb(((readb(cvi_host->pinmuxbase + 0xB00) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xB00);
+	writeb(((readb(cvi_host->pinmuxbase + 0xB08) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xB08);
+	writeb(((readb(cvi_host->pinmuxbase + 0xB0C) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xB0C);
+	writeb(((readb(cvi_host->pinmuxbase + 0xB10) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xB10);
+	writeb(((readb(cvi_host->pinmuxbase + 0xB14) | raise_bit) & ~(down_bit)),
+		cvi_host->pinmuxbase + 0xB14);
+}
+
+static void sdhci_cvi_set_tap(struct sdhci_host *host, unsigned int tap)
+{
+	pr_debug("%s %d\n", __func__, tap);
+	sdhci_writel(host, 0x0, CVI_183X_SDHCI_VENDOR_MSHC_CTRL_R);
+	sdhci_writel(host, 0x18, CVI_183X_SDHCI_VENDOR_A_CTRL_R);
+	sdhci_writel(host, tap, CVI_183X_SDHCI_VENDOR_A_STAT_R);
+}
+
+static void sdhci_cvi_reset_helper(struct sdhci_host *host, u8 mask)
+{
+	// disable Intr before reset
+	sdhci_writel(host, 0, SDHCI_INT_ENABLE);
+	sdhci_writel(host, 0, SDHCI_SIGNAL_ENABLE);
+
+	sdhci_reset(host, mask);
+
+	sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
+	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
+}
+
+static void sdhci_cvi_cv1835_set_tap(struct sdhci_host *host, unsigned int tap)
+{
+	pr_debug("%s %d\n", __func__, tap);
+	// Set sd_clk_en(0x2c[2]) to 0
+	sdhci_writew(host, sdhci_readw(host, SDHCI_CLOCK_CONTROL) & (~(0x1 << 2)), SDHCI_CLOCK_CONTROL);
+	sdhci_writew(host, 0, CVI_183X_SDHCI_VENDOR_MSHC_CTRL_R);
+	sdhci_writew(host, 0x18, CVI_183X_SDHCI_VENDOR_A_CTRL_R);
+	sdhci_writel(host, sdhci_readl(host, SDHCI_RX_DELAY_LINE) | 0x300000, SDHCI_RX_DELAY_LINE);
+	sdhci_writew(host, tap, CVI_183X_SDHCI_VENDOR_A_STAT_R);
+	// Set sd_clk_en(0x2c[2]) to 1
+	sdhci_writew(host, sdhci_readw(host, SDHCI_CLOCK_CONTROL) | (0x1 << 2), SDHCI_CLOCK_CONTROL);
+}
+
+static void reset_after_tuning_pass(struct sdhci_host *host)
+{
+	pr_debug("tuning pass\n");
+
+	/* Clear BUF_RD_READY intr */
+	sdhci_writew(host, sdhci_readw(host, SDHCI_INT_STATUS) & (~(0x1 << 5)),
+		     SDHCI_INT_STATUS);
+
+	/* Set SDHCI_SOFTWARE_RESET.SW_RST_DAT = 1 to clear buffered tuning block */
+	sdhci_writeb(host, sdhci_readb(host, SDHCI_SOFTWARE_RESET) | (0x1 << 2), SDHCI_SOFTWARE_RESET);
+
+	/* Set SDHCI_SOFTWARE_RESET.SW_RST_CMD = 1	*/
+	sdhci_writeb(host, sdhci_readb(host, SDHCI_SOFTWARE_RESET) | (0x1 << 1), SDHCI_SOFTWARE_RESET);
+
+	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & 0x3)
+		;
+}
+
+static inline uint32_t CHECK_MASK_BIT(void *_mask, uint32_t bit)
+{
+	uint32_t w = bit / 8;
+	uint32_t off = bit % 8;
+
+	return ((uint8_t *)_mask)[w] & (1 << off);
+}
+
+static inline void SET_MASK_BIT(void *_mask, uint32_t bit)
+{
+	uint32_t byte = bit / 8;
+	uint32_t offset = bit % 8;
+	((uint8_t *)_mask)[byte] |= (1 << offset);
+}
+
+int sdhci_cv1835_general_execute_tuning(struct sdhci_host *host, u32 opcode)
+{
+	u16 min = 0;
+	u32 k = 0;
+	s32 ret;
+	u32 retry_cnt = 0;
+
+	u32 tuning_result[4] = {0, 0, 0, 0};
+	u32 rx_lead_lag_result[4] = {0, 0, 0, 0};
+	char tuning_graph[TUNE_MAX_PHCODE+1];
+	char rx_lead_lag_graph[TUNE_MAX_PHCODE+1];
+
+	u32 reg = 0;
+	u32 reg_rx_lead_lag = 0;
+	s32 max_lead_lag_idx = -1;
+	s32 max_window_idx = -1;
+	s32 cur_window_idx = -1;
+	u16 max_lead_lag_size = 0;
+	u16 max_window_size = 0;
+	u16 cur_window_size = 0;
+	s32 rx_lead_lag_phase = -1;
+	s32 final_tap = -1;
+	u32 rate = 0;
+
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	sdhci_writel(host, 0x0, CVI_183X_SDHCI_VENDOR_MSHC_CTRL_R);
+
+	reg = sdhci_readw(host, SDHCI_ERR_INT_STATUS);
+	pr_debug("%s : SDHCI_ERR_INT_STATUS 0x%x\n", mmc_hostname(host->mmc),
+		 reg);
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("%s : host ctrl2 0x%x\n", mmc_hostname(host->mmc), reg);
+	/* Set Host_CTRL2_R.SAMPLE_CLK_SEL=0 */
+	sdhci_writew(host,
+		sdhci_readw(host, SDHCI_HOST_CONTROL2) & (~(0x1 << 7)),
+		SDHCI_HOST_CONTROL2);
+	sdhci_writew(host,
+		sdhci_readw(host, SDHCI_HOST_CONTROL2) & (~(0x3 << 4)),
+		SDHCI_HOST_CONTROL2);
+
+	reg = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	pr_debug("%s : host ctrl2 0x%x\n", mmc_hostname(host->mmc), reg);
+
+	/* Set ATR_CTRL_R.SW_TNE_EN=1 */
+	reg = sdhci_readl(host, CVI_183X_SDHCI_VENDOR_A_CTRL_R);
+	pr_debug("%s : A ctrl 0x%x\n", mmc_hostname(host->mmc), reg);
+	sdhci_writel(host,
+		sdhci_readl(host, CVI_183X_SDHCI_VENDOR_A_CTRL_R) | (0x1<<4),
+		CVI_183X_SDHCI_VENDOR_A_CTRL_R);
+	reg = sdhci_readl(host, CVI_183X_SDHCI_VENDOR_A_CTRL_R);
+	pr_debug("%s : A ctrl 0x%x\n", mmc_hostname(host->mmc), reg);
+
+	while (min < TUNE_MAX_PHCODE) {
+		retry_cnt = 0;
+		sdhci_cvi_cv1835_set_tap(host, min);
+		reg_rx_lead_lag = sdhci_readw(host, SDHCI_LEAD_LAG_FLAG) & BIT(1);
+
+retry_tuning:
+		ret = mmc_send_tuning(host->mmc, opcode, NULL);
+
+		if (!ret && retry_cnt < MAX_TUNING_CMD_RETRY_COUNT) {
+			retry_cnt++;
+			goto retry_tuning;
+		}
+
+		if (ret) {
+			SET_MASK_BIT(tuning_result, min);
+		}
+
+		if (reg_rx_lead_lag) {
+			SET_MASK_BIT(rx_lead_lag_result, min);
+		}
+
+		min++;
+	}
+
+	reset_after_tuning_pass(host);
+
+	pr_debug("tuning result:      0x%08x 0x%08x 0x%08x 0x%08x\n",
+		tuning_result[0], tuning_result[1], tuning_result[2], tuning_result[3]);
+	pr_debug("rx_lead_lag result: 0x%08x 0x%08x 0x%08x 0x%08x\n",
+		rx_lead_lag_result[0], rx_lead_lag_result[1], rx_lead_lag_result[2], rx_lead_lag_result[3]);
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(tuning_result, k) == 0)
+			tuning_graph[k] = '-';
+		else
+			tuning_graph[k] = 'x';
+		if (CHECK_MASK_BIT(rx_lead_lag_result, k) == 0)
+			rx_lead_lag_graph[k] = '0';
+		else
+			rx_lead_lag_graph[k] = '1';
+	}
+	tuning_graph[TUNE_MAX_PHCODE] = '\0';
+	rx_lead_lag_graph[TUNE_MAX_PHCODE] = '\0';
+
+	pr_debug("tuning graph:      %s\n", tuning_graph);
+	pr_debug("rx_lead_lag graph: %s\n", rx_lead_lag_graph);
+
+	// Find a final tap as median of maximum window
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(tuning_result, k) == 0) {
+			if (-1 == cur_window_idx) {
+				cur_window_idx = k;
+			}
+			cur_window_size++;
+
+			if (cur_window_size > max_window_size) {
+				max_window_size = cur_window_size;
+				max_window_idx = cur_window_idx;
+				if (max_window_size >= TAP_WINDOW_THLD)
+					final_tap = cur_window_idx + (max_window_size/2);
+			}
+		} else {
+			cur_window_idx = -1;
+			cur_window_size = 0;
+		}
+	}
+
+	cur_window_idx = -1;
+	cur_window_size = 0;
+	for (k = 0; k < TUNE_MAX_PHCODE; k++) {
+		if (CHECK_MASK_BIT(rx_lead_lag_result, k) == 0) {
+			//from 1 to 0 and window_size already computed.
+			if ((rx_lead_lag_phase == 1) && (cur_window_size > 0)) {
+				max_lead_lag_idx = cur_window_idx;
+				max_lead_lag_size = cur_window_size;
+				break;
+			}
+			if (cur_window_idx == -1) {
+				cur_window_idx = k;
+			}
+			cur_window_size++;
+			rx_lead_lag_phase = 0;
+		} else {
+			rx_lead_lag_phase = 1;
+			if ((cur_window_idx != -1) && (cur_window_size > 0)) {
+				cur_window_size++;
+				max_lead_lag_idx = cur_window_idx;
+				max_lead_lag_size = cur_window_size;
+			} else {
+				cur_window_size = 0;
+			}
+		}
+	}
+	rate = max_window_size * 100 / max_lead_lag_size;
+	pr_debug("MaxWindow[Idx, Width]:[%d,%u] Tuning Tap: %d\n", max_window_idx, max_window_size, final_tap);
+	pr_debug("RX_LeadLag[Idx, Width]:[%d,%u] rate = %d\n", max_lead_lag_idx, max_lead_lag_size, rate);
+
+	sdhci_cvi_cv1835_set_tap(host, final_tap);
+	cvi_host->final_tap = final_tap;
+	pr_debug("%s finished tuning, code:%d\n", __func__, final_tap);
+
+	return mmc_send_tuning(host->mmc, opcode, NULL);
+}
+
+static int sdhci_cv1835_general_select_drive_strength(struct sdhci_host *host,
+		struct mmc_card *card, unsigned int max_dtr, int host_drv,
+		int card_drv, int *drv_type)
+{
+	int driver_type = 0;
+	uint32_t reg;
+
+	pr_debug(" max_dtr %d, host_drv %d, card_drv %d, drv_type %d\n",
+		max_dtr, host_drv, card_drv, *drv_type);
+
+	driver_type = MMC_SET_DRIVER_TYPE_A;
+	*drv_type = MMC_SET_DRIVER_TYPE_A;
+	reg = (1 << PHY_CNFG_PHY_PWRGOOD) | (0xe << PHY_CNFG_PAD_SP) |
+		(0xe << PHY_CNFG_PAD_SN) | (1 << PHY_CNFG_PHY_RSTN);
+	sdhci_writel(host, reg, SDHCI_P_PHY_CNFG);
+
+	return driver_type;
+}
+
+static void sdhci_cvi_general_set_uhs_signaling(struct sdhci_host *host, unsigned int uhs)
+{
+	struct mmc_host *mmc = host->mmc;
+	u16 ctrl_2;
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	/* Select Bus Speed Mode for host */
+	ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
+	switch (uhs) {
+	case MMC_TIMING_UHS_SDR12:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR12;
+		break;
+	case MMC_TIMING_UHS_SDR25:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR25;
+		break;
+	case MMC_TIMING_UHS_SDR50:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR50;
+		break;
+	case MMC_TIMING_MMC_HS200:
+	case MMC_TIMING_UHS_SDR104:
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR104;
+		break;
+	case MMC_TIMING_UHS_DDR50:
+	case MMC_TIMING_MMC_DDR52:
+		ctrl_2 |= SDHCI_CTRL_UHS_DDR50;
+		break;
+	}
+
+	/*
+	 * When clock frequency is less than 100MHz, the feedback clock must be
+	 * provided and DLL must not be used so that tuning can be skipped. To
+	 * provide feedback clock, the mode selection can be any value less
+	 * than 3'b011 in bits [2:0] of HOST CONTROL2 register.
+	 */
+	if (host->clock <= 100000000 &&
+	    (uhs == MMC_TIMING_MMC_HS400 ||
+	     uhs == MMC_TIMING_MMC_HS200 ||
+	     uhs == MMC_TIMING_UHS_SDR104))
+		ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
+
+	dev_dbg(mmc_dev(mmc), "%s: clock=%u uhs=%u ctrl_2=0x%x\n",
+		mmc_hostname(host->mmc), host->clock, uhs, ctrl_2);
+	sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
+}
+
+static int sdhci_cv1835_sdio_get_cd(struct mmc_host *mmc)
+{
+	struct sdhci_host *host = mmc_priv(mmc);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+	int gpio_on = 0;
+
+	pr_debug("%s(%d) mmc %p, host %p\n", __func__, __LINE__, mmc, host);
+
+	if (gpio_is_valid(cvi_host->gpio_card_cd)) {
+		pr_debug("host->gpio_card_cd %d\n", cvi_host->gpio_card_cd);
+		gpio_on = gpio_get_value(cvi_host->gpio_card_cd);
+
+		if (gpio_on)
+			return 1;
+	}
+
+	return 0;
+}
+
+static unsigned int sdhci_cvi_general_emmc_get_max_clock(struct sdhci_host *host)
+{
+	uint32_t clk = 375 * 1000 * 1000;
+
+	pr_debug(DRIVER_NAME ":%s : %d\n", __func__, clk);
+	return clk;
+}
+
+static unsigned int sdhci_cv1835_sd_get_max_clock(struct sdhci_host *host)
+{
+	uint32_t clk = 375 * 1000 * 1000;
+
+	pr_debug(DRIVER_NAME ":%s : %d\n", __func__, clk);
+	return clk;
+}
+
+static unsigned int sdhci_cvi_fpga_emmc_get_max_clock(struct sdhci_host *host)
+{
+	uint32_t clk = 25 * 1000 * 1000;
+
+	pr_debug(DRIVER_NAME ":%s : %d\n", __func__, clk);
+	return clk;
+}
+
+static unsigned int sdhci_cvi_fpga_sd_get_max_clock(struct sdhci_host *host)
+{
+	uint32_t clk = 25 * 1000 * 1000;
+
+	pr_debug(DRIVER_NAME ":%s : %d\n", __func__, clk);
+	return clk;
+}
+
+static void sdhci_cv1835_sd_reset(struct sdhci_host *host, u8 mask)
+{
+	u16 ctrl_2;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s mask = 0x%x\n", __func__, mask);
+	sdhci_cvi_reset_helper(host, mask);
+
+	if (mask & SDHCI_RESET_ALL) {
+		// revert tx
+		sdhci_writeb(host, 0x10, SDHCI_P_SDCLKDL_DC);
+		// revert rx
+		sdhci_cvi_set_tap(host, 0x00);
+	}
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctrl_2 &= SDHCI_CTRL_UHS_MASK;
+	if (ctrl_2 == SDHCI_CTRL_UHS_SDR104) {
+		//reg_0x508[0] = 0
+		sdhci_writew(host,
+			sdhci_readw(host, CVI_183X_SDHCI_VENDOR_MSHC_CTRL_R) & (~(BIT(0))),
+			CVI_183X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x30C[21:20] = 3
+		sdhci_writel(host,
+			sdhci_readl(host, SDHCI_RX_DELAY_LINE) | (BIT(21) | BIT(20)),
+			SDHCI_RX_DELAY_LINE);
+		//reg_0x31C[22:16] = 0, reg_0x31C[11:10] = 0
+		sdhci_writel(host, sdhci_readl(host, SDHCI_TX_DELAY_LINE) & (~(0x7F0C00)), SDHCI_TX_DELAY_LINE);
+		//reg_0x544[6:0] = tap
+		sdhci_writew(host, cvi_host->final_tap & 0x7F, CVI_183X_SDHCI_VENDOR_A_STAT_R);
+	} else {
+		//Reset as DS/HS setting.
+		//reg_0x508[0] = 1
+		sdhci_writew(host,
+			sdhci_readw(host, CVI_183X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(0),
+			CVI_183X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x30C[21:20] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, SDHCI_RX_DELAY_LINE) & (~(BIT(21) | BIT(20))),
+			SDHCI_RX_DELAY_LINE);
+		//reg_0x31C[22:16] = 0, reg_0x31C[11:10] = 0
+		sdhci_writel(host, sdhci_readl(host, SDHCI_TX_DELAY_LINE) & (~(0x7F0C00)), SDHCI_TX_DELAY_LINE);
+		//reg_0x544[6:0] = 0
+		sdhci_writew(host,
+			sdhci_readw(host, CVI_183X_SDHCI_VENDOR_A_STAT_R) & (~(0x7F)),
+			CVI_183X_SDHCI_VENDOR_A_STAT_R);
+	}
+}
+
+static void sdhci_cv1835_emmc_reset(struct sdhci_host *host, u8 mask)
+{
+	u16 ctrl_2;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s mask = 0x%x\n", __func__, mask);
+	sdhci_cvi_reset_helper(host, mask);
+
+	if (mask & SDHCI_RESET_ALL) {
+		// revert tx
+		sdhci_writeb(host, 0x10, SDHCI_P_SDCLKDL_DC);
+		// revert rx
+		sdhci_cvi_set_tap(host, 0x10);
+	}
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctrl_2 &= SDHCI_CTRL_UHS_MASK;
+	if (ctrl_2 == SDHCI_CTRL_UHS_SDR104) {
+		//Reset as HS200/SDR104 mode
+		//reg_0x508[0] = 0
+		sdhci_writew(host,
+			sdhci_readw(host, CVI_183X_SDHCI_VENDOR_MSHC_CTRL_R) & (~(BIT(0))),
+			CVI_183X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x30C[21:20] = 3
+		sdhci_writel(host,
+			sdhci_readl(host, SDHCI_RX_DELAY_LINE) | (BIT(21) | BIT(20)),
+			SDHCI_RX_DELAY_LINE);
+		//reg_0x31C[22:16] = 0, reg_0x31C[11:10] = 0
+		sdhci_writel(host, sdhci_readl(host, SDHCI_TX_DELAY_LINE) & (~(0x7F0C00)), SDHCI_TX_DELAY_LINE);
+		//reg_0x544[6:0] = tap
+		sdhci_writew(host, cvi_host->final_tap & 0x7F, CVI_183X_SDHCI_VENDOR_A_STAT_R);
+	} else {
+		//Reset as DS/HS setting.
+		//reg_0x508[0] = 1
+		sdhci_writew(host,
+			sdhci_readw(host, CVI_183X_SDHCI_VENDOR_MSHC_CTRL_R) | BIT(0),
+			CVI_183X_SDHCI_VENDOR_MSHC_CTRL_R);
+		//reg_0x30C[21:20] = 0
+		sdhci_writel(host,
+			sdhci_readl(host, SDHCI_RX_DELAY_LINE) & (~(BIT(21) | BIT(20))),
+			SDHCI_RX_DELAY_LINE);
+		//reg_0x31C[22:16] = 0, reg_0x31C[11:10] = 0
+		sdhci_writel(host, sdhci_readl(host, SDHCI_TX_DELAY_LINE) & (~(0x7F0C00)), SDHCI_TX_DELAY_LINE);
+		//reg_0x544[6:0] = 0
+		sdhci_writew(host,
+			sdhci_readw(host, CVI_183X_SDHCI_VENDOR_A_STAT_R) & (~(0x7F)),
+			CVI_183X_SDHCI_VENDOR_A_STAT_R);
+	}
+}
+
+
+/* Used for wifi driver due if no SD card detect pin implemented */
+static struct mmc_host *wifi_mmc;
+
+int cvi_sdio_rescan(void)
+{
+
+	if (!wifi_mmc) {
+		pr_err("invalid wifi mmc, please check the argument\n");
+		return -EINVAL;
+	}
+
+	mmc_detect_change(wifi_mmc, 0);
+
+	wifi_mmc->rescan_entered = 0;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(cvi_sdio_rescan);
+
+
+void sdhci_cvi_emmc_voltage_switch(struct sdhci_host *host)
+{
+}
+
+void sdhci_cv1835_sd_voltage_switch(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s\n", __func__);
+
+	// enable SDIO0_CLK[7:5] to set CLK max strengh
+	writeb((readb(cvi_host->pinmuxbase + 0xB04) | BIT(7) | BIT(6) | BIT(5)),
+		cvi_host->pinmuxbase + 0xB04);
+
+	//Voltage switching flow (1.8v)
+	//reg_pwrsw_auto=1, reg_pwrsw_disc=0, pwrsw_vsel=1(1.8v), reg_en_pwrsw=1
+	writel(0xB | (readl(cvi_host->topbase + OFFSET_SD_PWRSW_CTRL) & 0xFFFFFFF0),
+		cvi_host->topbase + OFFSET_SD_PWRSW_CTRL);
+	pr_debug("sd PWRSW 0x%x\n", readl(cvi_host->topbase + 0x1F4));
+	cvi_host->sdio0_voltage_1_8_v = 1;
+
+	//set SDIO0 PAD to 1.8V mode
+	//=>  0x03000018[5:4] = 2'b11  ,( reg_sd0_ms_ow=1. reg_sd0_ms_sw=0) => MS overwrite to 1 (1.8v mode)
+	writel(BIT(4) | BIT(5) | readl(cvi_host->topbase + 0x18), cvi_host->topbase + 0x18);
+	pr_debug("SDIO0 PAD 0x%x\n", readl(cvi_host->topbase + 0x18));
+
+	//wait 1ms
+	mdelay(1);
+}
+
+void sdhci_cv1835_sd_voltage_restore(struct sdhci_host *host, bool bunplug)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+
+	pr_debug("%s\n", __func__);
+
+
+	if (bunplug) {
+		// set SDIO0 PAD to 3.3V mode
+		// reg_sd0_ms_ow=1. reg_sd0_ms_sw=0) => MS overwrite to 0 (3.0v mode)
+		writel(BIT(4) | (readl(cvi_host->topbase + 0x18) & 0xFFFFFFCF), cvi_host->topbase + 0x18);
+		pr_debug("SDIO0 PAD 0x%x\n", readl(cvi_host->topbase + 0x18));
+
+		//Voltage close flow
+		//(reg_pwrsw_auto=1, reg_pwrsw_disc=1, reg_pwrsw_vsel=1(1.8v), reg_en_pwrsw=0)
+		writel(0xE | (readl(cvi_host->topbase + OFFSET_SD_PWRSW_CTRL) & 0xFFFFFFF0),
+			cvi_host->topbase + OFFSET_SD_PWRSW_CTRL);
+		cvi_host->sdio0_voltage_1_8_v = 0;
+	} else {
+		if (!cvi_host->sdio0_voltage_1_8_v) {
+
+			// set SDIO0 PAD to 3.3V mode
+			// reg_sd0_ms_ow=1. reg_sd0_ms_sw=0) => MS overwrite to 0 (3.0v mode)
+			writel(BIT(4) | (readl(cvi_host->topbase + 0x18) & 0xFFFFFFCF), cvi_host->topbase + 0x18);
+			pr_debug("SDIO0 PAD 0x%x\n", readl(cvi_host->topbase + 0x18));
+
+			//Voltage switching flow (3.3)
+			//(reg_pwrsw_auto=1, reg_pwrsw_disc=0, reg_pwrsw_vsel=0(3.0v), reg_en_pwrsw=1)
+			writel(0x9 | (readl(cvi_host->topbase + OFFSET_SD_PWRSW_CTRL) & 0xFFFFFFF0),
+				cvi_host->topbase + OFFSET_SD_PWRSW_CTRL);
+		}
+	}
+
+	//wait 1ms
+	mdelay(1);
+}
+
+static void sdhci_cv1835_sd_set_power(struct sdhci_host *host, unsigned char mode,
+		     unsigned short vdd)
+{
+	struct mmc_host *mmc = host->mmc;
+
+	pr_debug("%s:mode %d, vdd %d\n", __func__, mode, vdd);
+
+	if (mode == MMC_POWER_ON && mmc->ops->get_cd(mmc)) {
+		sdhci_set_power_noreg(host, mode, vdd);
+		sdhci_cv1835_sd_voltage_restore(host, false);
+		sdhci_cv1835_sd_setup_pad(host, false);
+		sdhci_cv1835_sd_setup_io(host, false);
+		mdelay(5);
+	} else if (mode == MMC_POWER_OFF) {
+		sdhci_cv1835_sd_setup_pad(host, true);
+		sdhci_cv1835_sd_setup_io(host, true);
+		sdhci_cv1835_sd_voltage_restore(host, true);
+		sdhci_set_power_noreg(host, mode, vdd);
+		mdelay(30);
+	}
+}
+
+static void sdhci_cv1835_emmc_dump_vendor_regs(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+	u8 clk_source_select = 0;
+	u8 PAD_EMMC_RSTN = 0;
+	u8 PAD_EMMC_CLK  = 0;
+	u8 PAD_EMMC_CMD  = 0;
+	u8 PAD_EMMC_DAT0 = 0;
+	u8 PAD_EMMC_DAT1 = 0;
+	u8 PAD_EMMC_DAT2 = 0;
+	u8 PAD_EMMC_DAT3 = 0;
+	u8 REG_EMMC_RSTN = 0;
+	u8 REG_EMMC_CLK  = 0;
+	u8 REG_EMMC_CMD  = 0;
+	u8 REG_EMMC_DAT0 = 0;
+	u8 REG_EMMC_DAT1 = 0;
+	u8 REG_EMMC_DAT2 = 0;
+	u8 REG_EMMC_DAT3 = 0;
+
+	SDHCI_DUMP(": Reg_544:   0x%08x | Reg_30C:  0x%08x\n",
+		   sdhci_readl(host, CVI_183X_SDHCI_VENDOR_A_STAT_R),
+		   sdhci_readl(host, SDHCI_RX_DELAY_LINE));
+	SDHCI_DUMP(": Reg_31C:   0x%08x | Reg_312:  0x%08x\n",
+		   sdhci_readl(host, SDHCI_TX_DELAY_LINE),
+		   sdhci_readw(host, SDHCI_LEAD_LAG_FLAG));
+
+	PAD_EMMC_RSTN = readb(cvi_host->pinmuxbase + 0x24) & 0x07;
+	PAD_EMMC_CLK  = readb(cvi_host->pinmuxbase + 0x20) & 0x07;
+	PAD_EMMC_CMD  = readb(cvi_host->pinmuxbase + 0x28) & 0x07;
+	PAD_EMMC_DAT0 = readb(cvi_host->pinmuxbase + 0x30) & 0x07;
+	PAD_EMMC_DAT1 = readb(cvi_host->pinmuxbase + 0x2C) & 0x07;
+	PAD_EMMC_DAT2 = readb(cvi_host->pinmuxbase + 0x34) & 0x07;
+	PAD_EMMC_DAT3 = readb(cvi_host->pinmuxbase + 0x38) & 0x07;
+	REG_EMMC_RSTN = readb(cvi_host->pinmuxbase + 0xC24);
+	REG_EMMC_CLK  = readb(cvi_host->pinmuxbase + 0xC20);
+	REG_EMMC_CMD  = readb(cvi_host->pinmuxbase + 0xC28);
+	REG_EMMC_DAT0 = readb(cvi_host->pinmuxbase + 0xC30);
+	REG_EMMC_DAT1 = readb(cvi_host->pinmuxbase + 0xC2C);
+	REG_EMMC_DAT2 = readb(cvi_host->pinmuxbase + 0xC34);
+	REG_EMMC_DAT3 = readb(cvi_host->pinmuxbase + 0xC38);
+
+	SDHCI_DUMP(": PAD_EMMC_RSTN:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_RSTN, (REG_EMMC_RSTN & 0x04)>>2, (REG_EMMC_RSTN & 0x08)>>3,
+		(REG_EMMC_RSTN & 0x80)>>7, (REG_EMMC_RSTN & 0x40)>>6, (REG_EMMC_RSTN & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_CLK:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_CLK, (REG_EMMC_CLK & 0x04)>>2, (REG_EMMC_CLK & 0x08)>>3,
+		(REG_EMMC_CLK & 0x80)>>7, (REG_EMMC_CLK & 0x40)>>6, (REG_EMMC_CLK & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_CMD:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_CMD, (REG_EMMC_CMD & 0x04)>>2, (REG_EMMC_CMD & 0x08)>>3,
+		(REG_EMMC_CMD & 0x80)>>7, (REG_EMMC_CMD & 0x40)>>6, (REG_EMMC_CMD & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_DAT0:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_DAT0, (REG_EMMC_DAT0 & 0x04)>>2, (REG_EMMC_DAT0 & 0x08)>>3,
+		(REG_EMMC_DAT0 & 0x80)>>7, (REG_EMMC_DAT0 & 0x40)>>6, (REG_EMMC_DAT0 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_DAT1:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_DAT1, (REG_EMMC_DAT1 & 0x04)>>2, (REG_EMMC_DAT1 & 0x08)>>3,
+		(REG_EMMC_DAT1 & 0x80)>>7, (REG_EMMC_DAT1 & 0x40)>>6, (REG_EMMC_DAT1 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_DAT2:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_DAT2, (REG_EMMC_DAT2 & 0x04)>>2, (REG_EMMC_DAT2 & 0x08)>>3,
+		(REG_EMMC_DAT2 & 0x80)>>7, (REG_EMMC_DAT2 & 0x40)>>6, (REG_EMMC_DAT2 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_EMMC_DAT3:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_EMMC_DAT3, (REG_EMMC_DAT3 & 0x04)>>2, (REG_EMMC_DAT3 & 0x08)>>3,
+		(REG_EMMC_DAT3 & 0x80)>>7, (REG_EMMC_DAT3 & 0x40)>>6, (REG_EMMC_DAT3 & 0x20)>>5);
+
+	clk_source_select = (readb(cvi_host->clkgenbase + 0x20) & 0x20) >> 5;
+
+	SDHCI_DUMP(": clk_emmc enable[16]:0x%08x\n", readl(cvi_host->clkgenbase));
+	SDHCI_DUMP(": clk_emmc source_select:%u\n", clk_source_select);
+	if (clk_source_select == 0) {
+		SDHCI_DUMP(": clk_emmc REG:0x03002068 = 0x%08x\n",
+		readl(cvi_host->clkgenbase + 0x68));
+		if (readl(cvi_host->clkgenbase + 0x68) == 0x00000001)
+			SDHCI_DUMP(": clk_emmc %d MHz\n", DISPPLL_MHZ/12);
+	} else if (clk_source_select == 1) {
+		SDHCI_DUMP(": clk_emmc REG:0x03002064 = 0x%08x\n",
+		readl(cvi_host->clkgenbase + 0x64));
+		if (readl(cvi_host->clkgenbase + 0x64) == 0x00040009)
+			SDHCI_DUMP(": clk_emmc %d MHz\n", FPLL_MHZ/4);
+	}
+}
+
+static void sdhci_cv1835_sd_dump_vendor_regs(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+	u8 clk_source_select = 0;
+	u8 PAD_SDIO0_PWR_EN = 0;
+	u8 PAD_SDIO0_CD  = 0;
+	u8 PAD_SDIO0_CLK = 0;
+	u8 PAD_SDIO0_CMD = 0;
+	u8 PAD_SDIO0_D0  = 0;
+	u8 PAD_SDIO0_D1  = 0;
+	u8 PAD_SDIO0_D2  = 0;
+	u8 PAD_SDIO0_D3  = 0;
+	u8 REG_SDIO0_CD  = 0;
+	u8 REG_SDIO0_CLK = 0;
+	u8 REG_SDIO0_CMD = 0;
+	u8 REG_SDIO0_D0  = 0;
+	u8 REG_SDIO0_D1  = 0;
+	u8 REG_SDIO0_D2  = 0;
+	u8 REG_SDIO0_D3  = 0;
+
+	SDHCI_DUMP(": Reg_544:   0x%08x | Reg_30C:  0x%08x\n",
+		   sdhci_readl(host, CVI_183X_SDHCI_VENDOR_A_STAT_R),
+		   sdhci_readl(host, SDHCI_RX_DELAY_LINE));
+	SDHCI_DUMP(": Reg_31C:   0x%08x | Reg_312:  0x%08x\n",
+		   sdhci_readl(host, SDHCI_TX_DELAY_LINE),
+		   sdhci_readw(host, SDHCI_LEAD_LAG_FLAG));
+
+	PAD_SDIO0_PWR_EN = readb(cvi_host->pinmuxbase + 0x14) & 0x07;
+	PAD_SDIO0_CD  = readb(cvi_host->pinmuxbase + 0x04) & 0x07;
+	PAD_SDIO0_CLK = readb(cvi_host->pinmuxbase + 0x40) & 0x07;
+	PAD_SDIO0_CMD = readb(cvi_host->pinmuxbase + 0x3C) & 0x07;
+	PAD_SDIO0_D0  = readb(cvi_host->pinmuxbase + 0x44) & 0x07;
+	PAD_SDIO0_D1  = readb(cvi_host->pinmuxbase + 0x48) & 0x07;
+	PAD_SDIO0_D2  = readb(cvi_host->pinmuxbase + 0x4C) & 0x07;
+	PAD_SDIO0_D3  = readb(cvi_host->pinmuxbase + 0x50) & 0x07;
+	REG_SDIO0_CD  = readb(cvi_host->pinmuxbase + 0xC04);
+	REG_SDIO0_CLK = readb(cvi_host->pinmuxbase + 0xB04);
+	REG_SDIO0_CMD = readb(cvi_host->pinmuxbase + 0xB00);
+	REG_SDIO0_D0  = readb(cvi_host->pinmuxbase + 0xB08);
+	REG_SDIO0_D1  = readb(cvi_host->pinmuxbase + 0xB0C);
+	REG_SDIO0_D2  = readb(cvi_host->pinmuxbase + 0xB10);
+	REG_SDIO0_D3  = readb(cvi_host->pinmuxbase + 0xB14);
+
+	SDHCI_DUMP(": PAD_SDIO0_PWR_EN:0x%02x\n", PAD_SDIO0_PWR_EN);
+	SDHCI_DUMP(": PAD_SDIO0_CD:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_CD, (REG_SDIO0_CD & 0x04)>>2, (REG_SDIO0_CD & 0x08)>>3,
+		(REG_SDIO0_CD & 0x80)>>7, (REG_SDIO0_CD & 0x40)>>6, (REG_SDIO0_CD & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_CLK:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_CLK, (REG_SDIO0_CLK & 0x04)>>2, (REG_SDIO0_CLK & 0x08)>>3,
+		(REG_SDIO0_CLK & 0x80)>>7, (REG_SDIO0_CLK & 0x40)>>6, (REG_SDIO0_CLK & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_CMD:0x%02x PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_CMD, (REG_SDIO0_CMD & 0x04)>>2, (REG_SDIO0_CMD & 0x08)>>3,
+		(REG_SDIO0_CMD & 0x80)>>7, (REG_SDIO0_CMD & 0x40)>>6, (REG_SDIO0_CMD & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_D0:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_D0, (REG_SDIO0_D0 & 0x04)>>2, (REG_SDIO0_D0 & 0x08)>>3,
+		(REG_SDIO0_D0 & 0x80)>>7, (REG_SDIO0_D0 & 0x40)>>6, (REG_SDIO0_D0 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_D1:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_D1, (REG_SDIO0_D1 & 0x04)>>2, (REG_SDIO0_D1 & 0x08)>>3,
+		(REG_SDIO0_D1 & 0x80)>>7, (REG_SDIO0_D1 & 0x40)>>6, (REG_SDIO0_D1 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_D2:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_D2, (REG_SDIO0_D2 & 0x04)>>2, (REG_SDIO0_D2 & 0x08)>>3,
+		(REG_SDIO0_D2 & 0x80)>>7, (REG_SDIO0_D2 & 0x40)>>6, (REG_SDIO0_D2 & 0x20)>>5);
+	SDHCI_DUMP(": PAD_SDIO0_D3:0x%02x  PU:%u PD:%u DS[2:0]:%u%u%u\n",
+		PAD_SDIO0_D3, (REG_SDIO0_D3 & 0x04)>>2, (REG_SDIO0_D3 & 0x08)>>3,
+		(REG_SDIO0_D3 & 0x80)>>7, (REG_SDIO0_D3 & 0x40)>>6, (REG_SDIO0_D3 & 0x20)>>5);
+
+	clk_source_select = (readb(cvi_host->clkgenbase + 0x20) & 0x40) >> 6;
+
+	SDHCI_DUMP(": clk_sd0 enable[19]:0x%08x\n", readl(cvi_host->clkgenbase));
+	SDHCI_DUMP(": clk_sd0 source_select:%u\n", clk_source_select);
+	if (clk_source_select == 0) {
+		SDHCI_DUMP(": clk_sd0 REG:0x03002074 = 0x%08x\n",
+		readl(cvi_host->clkgenbase + 0x74));
+		if (readl(cvi_host->clkgenbase + 0x74) == 0x00000001)
+			SDHCI_DUMP(": clk_sd0 %d MHz\n", DISPPLL_MHZ/12);
+	} else if (clk_source_select == 1) {
+		SDHCI_DUMP(": clk_sd0 REG:0x03002070 = 0x%08x\n",
+		readl(cvi_host->clkgenbase + 0x70));
+		if (readl(cvi_host->clkgenbase + 0x70) == 0x00040009)
+			SDHCI_DUMP(": clk_sd0 %d MHz\n", FPLL_MHZ/4);
+	}
+}
+
+static const struct sdhci_ops sdhci_cv1835_emmc_ops = {
+	.reset = sdhci_cv1835_emmc_reset,
+	.set_clock = sdhci_set_clock,
+	.set_bus_width = sdhci_set_bus_width,
+	.get_max_clock = sdhci_cvi_general_emmc_get_max_clock,
+	.voltage_switch = sdhci_cvi_emmc_voltage_switch,
+	.set_uhs_signaling = sdhci_cvi_general_set_uhs_signaling,
+	.platform_execute_tuning = sdhci_cv1835_general_execute_tuning,
+	.select_drive_strength = sdhci_cv1835_general_select_drive_strength,
+	.dump_vendor_regs = sdhci_cv1835_emmc_dump_vendor_regs,
+};
+
+static const struct sdhci_ops sdhci_cv1835_sd_ops = {
+	.reset = sdhci_cv1835_sd_reset,
+	.set_clock = sdhci_set_clock,
+	.set_power = sdhci_cv1835_sd_set_power,
+	.set_bus_width = sdhci_set_bus_width,
+	.get_max_clock = sdhci_cv1835_sd_get_max_clock,
+	.voltage_switch = sdhci_cv1835_sd_voltage_switch,
+	.set_uhs_signaling = sdhci_cvi_general_set_uhs_signaling,
+	.platform_execute_tuning = sdhci_cv1835_general_execute_tuning,
+	.select_drive_strength = sdhci_cv1835_general_select_drive_strength,
+	.dump_vendor_regs = sdhci_cv1835_sd_dump_vendor_regs,
+};
+
+static const struct sdhci_ops sdhci_cv1835_sdio_ops = {
+	.reset = sdhci_cv1835_sd_reset,
+	.set_clock = sdhci_set_clock,
+	.set_bus_width = sdhci_set_bus_width,
+	.get_max_clock = sdhci_cv1835_sd_get_max_clock,
+	.voltage_switch = sdhci_cv1835_sd_voltage_switch,
+	.set_uhs_signaling = sdhci_cvi_general_set_uhs_signaling,
+	.select_drive_strength = sdhci_cv1835_general_select_drive_strength,
+};
+
+static const struct sdhci_ops sdhci_cv1835_fpga_emmc_ops = {
+	.reset = sdhci_cv1835_emmc_reset,
+	.set_clock = sdhci_set_clock,
+	.set_bus_width = sdhci_set_bus_width,
+	.get_max_clock = sdhci_cvi_fpga_emmc_get_max_clock,
+	.voltage_switch = sdhci_cvi_emmc_voltage_switch,
+	.set_uhs_signaling = sdhci_cvi_general_set_uhs_signaling,
+	.platform_execute_tuning = sdhci_cv1835_general_execute_tuning,
+	.select_drive_strength = sdhci_cv1835_general_select_drive_strength,
+	.dump_vendor_regs = sdhci_cv1835_emmc_dump_vendor_regs,
+};
+
+static const struct sdhci_ops sdhci_cv1835_fpga_sd_ops = {
+	.reset = sdhci_cv1835_sd_reset,
+	.set_clock = sdhci_set_clock,
+	.set_bus_width = sdhci_set_bus_width,
+	.get_max_clock = sdhci_cvi_fpga_sd_get_max_clock,
+	.voltage_switch = sdhci_cv1835_sd_voltage_switch,
+	.set_uhs_signaling = sdhci_cvi_general_set_uhs_signaling,
+	.platform_execute_tuning = sdhci_cv1835_general_execute_tuning,
+	.select_drive_strength = sdhci_cv1835_general_select_drive_strength,
+	.dump_vendor_regs = sdhci_cv1835_sd_dump_vendor_regs,
+};
+
+static const struct sdhci_pltfm_data sdhci_cv1835_emmc_pdata = {
+	.ops = &sdhci_cv1835_emmc_ops,
+	.quirks = SDHCI_QUIRK_INVERTED_WRITE_PROTECT | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
+};
+
+static const struct sdhci_pltfm_data sdhci_cv1835_sd_pdata = {
+	.ops = &sdhci_cv1835_sd_ops,
+	.quirks = SDHCI_QUIRK_INVERTED_WRITE_PROTECT | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
+};
+
+static const struct sdhci_pltfm_data sdhci_cv1835_sdio_pdata = {
+	.ops = &sdhci_cv1835_sdio_ops,
+	.quirks = SDHCI_QUIRK_INVERTED_WRITE_PROTECT | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN | SDHCI_QUIRK2_NO_1_8_V,
+};
+
+static const struct sdhci_pltfm_data sdhci_cv1835_fpga_emmc_pdata = {
+	.ops = &sdhci_cv1835_fpga_emmc_ops,
+	.quirks = SDHCI_QUIRK_INVERTED_WRITE_PROTECT | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN | SDHCI_QUIRK2_BROKEN_HS200 | SDHCI_QUIRK2_NO_1_8_V,
+};
+
+static const struct sdhci_pltfm_data sdhci_cv1835_fpga_sd_pdata = {
+	.ops = &sdhci_cv1835_fpga_sd_ops,
+	.quirks = SDHCI_QUIRK_INVERTED_WRITE_PROTECT | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN | SDHCI_QUIRK2_NO_1_8_V,
+};
+
+static const struct of_device_id sdhci_cvi_dt_match[] = {
+	{.compatible = "cvitek,cv1835-fpga-emmc", .data = &sdhci_cv1835_fpga_emmc_pdata},
+	{.compatible = "cvitek,cv1835-fpga-sd", .data = &sdhci_cv1835_fpga_sd_pdata},
+	{.compatible = "cvitek,cv1835-emmc", .data = &sdhci_cv1835_emmc_pdata},
+	{.compatible = "cvitek,cv1835-sd", .data = &sdhci_cv1835_sd_pdata},
+	{.compatible = "cvitek,cv1835-sdio", .data = &sdhci_cv1835_sdio_pdata},
+
+	{ /* sentinel */ }
+};
+
+static void disable_mmc_clk(struct sdhci_cvi_host *cvi_host)
+{
+	struct mmc_host *mmc = cvi_host->mmc;
+
+	pr_debug("%s: disable_mmc_clk\n", mmc_hostname(mmc));
+	reset_control_assert(cvi_host->clk_rst_axi_emmc_ctrl);
+	reset_control_assert(cvi_host->clk_rst_emmc_ctrl);
+	reset_control_assert(cvi_host->clk_rst_100k_emmc_ctrl);
+}
+
+static int check_mmc_device_presence(struct sdhci_cvi_host *cvi_host)
+{
+	u32 pstate_reg = 0;
+	struct mmc_host *mmc = cvi_host->mmc;
+	int ret = 0;
+
+	pr_debug("%s: Check_mmc_device_presence:\n", mmc_hostname(mmc));
+
+	pstate_reg = readl_relaxed(cvi_host->core_mem + SDHCI_PRESENT_STATE);
+
+	if (!(pstate_reg & SDHCI_CARD_PRESENT)) {
+		// card not detected
+		pr_debug("%s: device not present\n", mmc_hostname(mmc));
+		disable_mmc_clk(cvi_host);
+		ret = -1;
+	} else {
+		pr_debug("%s: device is present\n", mmc_hostname(mmc));
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static int get_emmc_clk_control(struct sdhci_cvi_host *cvi_host)
+{
+	int ret;
+	struct mmc_host *mmc = cvi_host->mmc;
+
+	pr_debug("%s: get_emmc_clk_control\n", mmc_hostname(mmc));
+
+	cvi_host->clk_rst_axi_emmc_ctrl = devm_reset_control_get(&cvi_host->pdev->dev, "axi_emmc");
+	if (IS_ERR(cvi_host->clk_rst_axi_emmc_ctrl)) {
+		ret = PTR_ERR(cvi_host->clk_rst_axi_emmc_ctrl);
+		dev_err(&cvi_host->pdev->dev, "failed to retrieve axi_emmc clk reset");
+		return ret;
+	}
+
+	cvi_host->clk_rst_emmc_ctrl = devm_reset_control_get(&cvi_host->pdev->dev, "emmc");
+	if (IS_ERR(cvi_host->clk_rst_emmc_ctrl)) {
+		ret = PTR_ERR(cvi_host->clk_rst_emmc_ctrl);
+		dev_err(&cvi_host->pdev->dev, "failed to retrieve emmc clk reset");
+		return ret;
+	}
+
+	cvi_host->clk_rst_100k_emmc_ctrl = devm_reset_control_get(&cvi_host->pdev->dev, "100k_emmc");
+	if (IS_ERR(cvi_host->clk_rst_100k_emmc_ctrl)) {
+		ret = PTR_ERR(cvi_host->clk_rst_100k_emmc_ctrl);
+		dev_err(&cvi_host->pdev->dev, "failed to retrieve 100k_emmc clk reset");
+		return ret;
+	}
+
+	return 0;
+}
+
+MODULE_DEVICE_TABLE(of, sdhci_cvi_dt_match);
+
+static irqreturn_t sdhci_cvi_cd_handler(int irq, void *dev_id)
+{
+	/* Schedule a card detection after a debounce timeout */
+	struct mmc_host *host = dev_id;
+	struct mmc_gpio *ctx = host->slot.handler_priv;
+
+	pr_debug("%s-%d mmc_gpio_get_cd:%d\n",
+		__func__, __LINE__, mmc_gpio_get_cd(host));
+	host->trigger_card_event = true;
+	host->ops->card_event(host);
+	mmc_detect_change(host, msecs_to_jiffies(ctx->cd_debounce_delay_ms));
+
+	return IRQ_HANDLED;
+}
+
+static int sdhci_cvi_probe(struct platform_device *pdev)
+{
+	struct sdhci_host *host;
+	struct sdhci_pltfm_host *pltfm_host;
+	struct sdhci_cvi_host *cvi_host;
+	const struct of_device_id *match;
+	const struct sdhci_pltfm_data *pdata;
+	int ret;
+	int gpio_cd = -EINVAL;
+
+	pr_info(DRIVER_NAME ":%s\n", __func__);
+
+	match = of_match_device(sdhci_cvi_dt_match, &pdev->dev);
+	if (!match)
+		return -EINVAL;
+
+	pdata = match->data;
+
+	host = sdhci_pltfm_init(pdev, pdata, sizeof(*cvi_host));
+	if (IS_ERR(host))
+		return PTR_ERR(host);
+
+	pltfm_host = sdhci_priv(host);
+	cvi_host = sdhci_pltfm_priv(pltfm_host);
+	cvi_host->host = host;
+	cvi_host->mmc = host->mmc;
+	cvi_host->pdev = pdev;
+	cvi_host->core_mem = host->ioaddr;
+	cvi_host->topbase = ioremap(TOP_BASE, 0x2000);
+	cvi_host->pinmuxbase = ioremap(PINMUX_BASE, 0x1000);
+	cvi_host->clkgenbase = ioremap(CLKGEN_BASE, 0x100);
+
+	sdhci_cv1835_sd_voltage_restore(host, false);
+
+	ret = mmc_of_parse(host->mmc);
+	if (ret)
+		goto pltfm_free;
+
+	// if device use gpio as card detect pin, change its get_cd function.
+	if (host->mmc->caps & MMC_CAP_NEEDS_POLL) {
+		enum of_gpio_flags flags;
+
+		host->mmc_host_ops.get_cd = sdhci_cv1835_sdio_get_cd;
+		cvi_host->gpio_card_cd = of_get_named_gpio_flags(pdev->dev.of_node, "gpio-cd-sdio", 0, &flags);
+		cvi_host->gpio_card_cd_active = (flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+
+		pr_debug("gpio_card_cd %d gpio_card_cd_active %d\n",
+			 cvi_host->gpio_card_cd, cvi_host->gpio_card_cd_active);
+	}
+
+	sdhci_get_of_property(pdev);
+
+	if (host->quirks2 & SDHCI_QUIRK2_SUPPORT_DISABLE_CLK &&
+	    !(host->quirks & SDHCI_QUIRK_BROKEN_CARD_DETECTION)
+	) {
+		get_emmc_clk_control(cvi_host);
+		ret = check_mmc_device_presence(cvi_host);
+
+		if (ret)
+			goto err_add_host;
+	}
+
+	if (pdata->ops->hw_reset) {
+		cvi_host->reset = devm_reset_control_get(&pdev->dev, "sdio");
+		if (IS_ERR(cvi_host->reset)) {
+			ret = PTR_ERR(cvi_host->reset);
+			goto pltfm_free;
+		}
+	}
+
+	if (pdev->dev.of_node) {
+		gpio_cd = of_get_named_gpio(pdev->dev.of_node, "cvi-cd-gpios", 0);
+	}
+
+	if (gpio_is_valid(gpio_cd)) {
+		cvi_host->cvi_gpio = devm_kzalloc(&cvi_host->pdev->dev,
+					sizeof(struct mmc_gpio), GFP_KERNEL);
+		if (cvi_host->cvi_gpio) {
+			cvi_host->cvi_gpio->cd_gpio_isr = sdhci_cvi_cd_handler;
+			cvi_host->cvi_gpio->cd_debounce_delay_ms = SDHCI_GPIO_CD_DEBOUNCE_DELAY_TIME;
+			cvi_host->cvi_gpio->cd_label = devm_kzalloc(&cvi_host->pdev->dev,
+						strlen("cd-gpio-irq") + 1, GFP_KERNEL);
+			strcpy(cvi_host->cvi_gpio->cd_label, "cd-gpio-irq");
+			host->mmc->slot.handler_priv = cvi_host->cvi_gpio;
+			ret = mmc_gpiod_request_cd(host->mmc, "cvi-cd",
+					0, false, SDHCI_GPIO_CD_DEBOUNCE_TIME);
+			if (ret) {
+				pr_err("card detect request cd failed: %d\n", ret);
+			} else {
+				writeb(0x3, cvi_host->pinmuxbase + 0x34);
+				mmc_gpiod_request_cd_irq(host->mmc);
+			}
+		}
+	}
+
+	ret = sdhci_add_host(host);
+	if (ret)
+		goto err_add_host;
+
+	platform_set_drvdata(pdev, cvi_host);
+
+	if (strstr(dev_name(mmc_dev(host->mmc)), "wifi-sd"))
+		wifi_mmc = host->mmc;
+	else
+		wifi_mmc = NULL;
+
+	/* device proc entry */
+	if ((!proc_cvi_dir) &&
+		(strstr(dev_name(mmc_dev(host->mmc)), "cv-sd"))) {
+		ret = cvi_proc_init(cvi_host);
+		if (ret)
+			pr_err("device proc init is failed!");
+	}
+
+	if (strstr(dev_name(mmc_dev(host->mmc)), "cv-emmc"))
+		sdhci_cv183x_emmc_setup_pad(host);
+
+	return 0;
+
+err_add_host:
+pltfm_free:
+	sdhci_pltfm_free(pdev);
+	return ret;
+}
+
+static int sdhci_cvi_remove(struct platform_device *pdev)
+{
+	struct sdhci_host *host = platform_get_drvdata(pdev);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_cvi_host *cvi_host = sdhci_pltfm_priv(pltfm_host);
+	int dead = (readl_relaxed(host->ioaddr + SDHCI_INT_STATUS) == 0xffffffff);
+
+	sdhci_remove_host(host, dead);
+	sdhci_pltfm_free(pdev);
+
+	cvi_proc_shutdown(cvi_host);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int save_rtc_reg(struct sdhci_cvi_host *cvi_host)
+{
+	return 0;
+}
+
+static void restore_rtc_reg(struct sdhci_cvi_host *cvi_host) {}
+
+static void save_reg(struct sdhci_host *host, struct sdhci_cvi_host *cvi_host)
+{
+	save_rtc_reg(cvi_host);
+	cvi_host->reg_ctrl2 = sdhci_readl(host, SDHCI_HOST_CONTROL2);
+	cvi_host->reg_clk_ctrl = sdhci_readl(host, SDHCI_CLOCK_CONTROL);
+	cvi_host->reg_host_ctrl = sdhci_readl(host, SDHCI_HOST_CONTROL);
+}
+
+static void restore_reg(struct sdhci_host *host, struct sdhci_cvi_host *cvi_host)
+{
+	restore_rtc_reg(cvi_host);
+	sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
+	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
+	sdhci_writel(host, cvi_host->reg_ctrl2, SDHCI_HOST_CONTROL2);
+	sdhci_writel(host, cvi_host->reg_clk_ctrl, SDHCI_CLOCK_CONTROL);
+	sdhci_writel(host, cvi_host->reg_host_ctrl, SDHCI_HOST_CONTROL);
+}
+
+static int sdhci_cvi_suspend(struct device *dev)
+{
+	struct sdhci_cvi_host *cvi_host = dev_get_drvdata(dev);
+	struct sdhci_host *host = cvi_host->host;
+
+	if (!host)
+		return 0;
+
+	save_reg(host, cvi_host);
+
+	return 0;
+}
+
+static int sdhci_cvi_resume(struct device *dev)
+{
+	struct sdhci_cvi_host *cvi_host = dev_get_drvdata(dev);
+	struct sdhci_host *host = cvi_host->host;
+
+	if (!host)
+		return 0;
+
+	restore_reg(host, cvi_host);
+
+	return 0;
+}
+
+#endif
+
+static const struct dev_pm_ops sdhci_cvi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(sdhci_cvi_suspend, sdhci_cvi_resume)
+};
+
+static struct platform_driver sdhci_cvi_driver = {
+	.probe = sdhci_cvi_probe,
+	.remove = sdhci_cvi_remove,
+	.driver = {
+		.name = DRIVER_NAME,
+		.pm = &sdhci_cvi_pm_ops,
+		.of_match_table = sdhci_cvi_dt_match,
+	},
+};
+
+module_platform_driver(sdhci_cvi_driver);
+
+MODULE_DESCRIPTION("Cvitek Secure Digital Host Controller Interface driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mmc/host/cvitek/sdhci-cv183x.h b/drivers/mmc/host/cvitek/sdhci-cv183x.h
new file mode 100644
index 000000000000..916ed48198e9
--- /dev/null
+++ b/drivers/mmc/host/cvitek/sdhci-cv183x.h
@@ -0,0 +1,99 @@
+/*
+ * drivers/mmc/host/sdhci-cvi.c - CVITEK SDHCI Platform driver
+ *
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __SDHCI_CV_H
+#define __SDHCI_CV_H
+
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/delay.h>
+#include <linux/mmc/mmc.h>
+#include <linux/slab.h>
+
+#define MAX_TUNING_CMD_RETRY_COUNT 50
+#define TUNE_MAX_PHCODE	128
+#define TAP_WINDOW_THLD 20
+#define DISPPLL_MHZ 1188
+#define FPLL_MHZ 1500
+
+#define TOP_BASE	0x3000000
+#define OFFSET_SD_PWRSW_CTRL	0x1F4
+
+#define PINMUX_BASE 0x03001000
+#define CLKGEN_BASE 0x03002000
+
+#define CVI_183X_SDHCI_VENDOR_OFFSET		0x500
+#define CVI_183X_SDHCI_VENDOR_MSHC_CTRL_R	(CVI_183X_SDHCI_VENDOR_OFFSET + 0x08)
+#define CVI_183X_SDHCI_VENDOR_A_CTRL_R		(CVI_183X_SDHCI_VENDOR_OFFSET + 0x40)
+#define CVI_183X_SDHCI_VENDOR_A_STAT_R		(CVI_183X_SDHCI_VENDOR_OFFSET + 0x44)
+
+/* PHY register */
+#define SDHCI_PHY_R_OFFSET			0x300
+
+#define SDHCI_P_PHY_CNFG           (SDHCI_PHY_R_OFFSET + 0x00)
+#define SDHCI_RX_DELAY_LINE        (SDHCI_PHY_R_OFFSET + 0x0C)
+#define SDHCI_TX_DELAY_LINE        (SDHCI_PHY_R_OFFSET + 0x1C)
+#define SDHCI_P_SDCLKDL_DC         (SDHCI_PHY_R_OFFSET + 0x1E)
+#define SDHCI_LEAD_LAG_FLAG        (SDHCI_PHY_R_OFFSET + 0x12)
+
+#define PHY_CNFG_PHY_RSTN			0
+#define PHY_CNFG_PHY_PWRGOOD		1
+#define PHY_CNFG_PAD_SP				16
+#define PHY_CNFG_PAD_SP_MSK			0xf
+#define PHY_CNFG_PAD_SN				20
+#define PHY_CNFG_PAD_SN_MSK			0xf
+
+#define SDHCI_GPIO_CD_DEBOUNCE_TIME	15
+#define SDHCI_GPIO_CD_DEBOUNCE_DELAY_TIME	200
+
+#ifdef CONFIG_PM_SLEEP
+struct cvi_rtc_sdhci_reg_context {};
+#endif
+
+struct sdhci_cvi_host {
+	struct sdhci_host *host;
+	struct platform_device *pdev;
+	void __iomem *core_mem; /* mmio address */
+	struct clk *clk;    /* main SD/MMC bus clock */
+	struct clk *clk100k;
+	struct clk *clkaxi;
+	struct mmc_host *mmc;
+	struct reset_control *reset;
+
+	struct reset_control *clk_rst_axi_emmc_ctrl;
+	struct reset_control *clk_rst_emmc_ctrl;
+	struct reset_control *clk_rst_100k_emmc_ctrl;
+
+	int gpio_card_cd;
+	int gpio_card_cd_active;
+
+	void __iomem *topbase;
+	void __iomem *pinmuxbase;
+	void __iomem *clkgenbase;
+
+	u32 reg_ctrl2;
+	u32 reg_clk_ctrl;
+	u32 reg_host_ctrl;
+	u8 final_tap;
+	u8 sdio0_voltage_1_8_v;
+	int sd_save_count;
+	struct mmc_gpio *cvi_gpio;
+#ifdef CONFIG_PM_SLEEP
+	struct cvi_rtc_sdhci_reg_context *rtc_reg_ctx;
+#endif
+
+};
+#endif
diff --git a/drivers/mmc/host/sdhci-of-light-mpw.c b/drivers/mmc/host/sdhci-of-light-mpw.c
new file mode 100644
index 000000000000..92fa6d7aaada
--- /dev/null
+++ b/drivers/mmc/host/sdhci-of-light-mpw.c
@@ -0,0 +1,558 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/sizes.h>
+
+#include <linux/delay.h>
+
+#include "sdhci-pltfm.h"
+
+#define DWC_MSHC_PTR_PHY_R  0x300
+#define PHY_CNFG_R      (DWC_MSHC_PTR_PHY_R + 0x00) //32bit
+#define PHY_RSTN  0x0      //1bit
+#define PAD_SP    0x10     //4bit
+#define PAD_SN    0x14     //4bit
+
+#define PHY_CMDPAD_CNFG_R   (DWC_MSHC_PTR_PHY_R + 0x04) //16bit
+#define PHY_DATAPAD_CNFG_R  (DWC_MSHC_PTR_PHY_R + 0x06) //16bit
+#define PHY_CLKPAD_CNFG_R   (DWC_MSHC_PTR_PHY_R + 0x08) //16bit
+#define PHY_STBPAD_CNFG_R   (DWC_MSHC_PTR_PHY_R + 0x0a) //16bit
+#define PHY_RSTNPAD_CNFG_R  (DWC_MSHC_PTR_PHY_R + 0x0c) //16bit
+#define RXSEL 0x0         //3bit
+#define WEAKPULL_EN 0x3   //2bit
+#define TXSLEW_CTRL_P 0x5 //4bit
+#define TXSLEW_CTRL_N 0x9 //4bit
+
+#define PHY_PADTEST_CNFG_R  (DWC_MSHC_PTR_PHY_R + 0x0e)
+#define PHY_PADTEST_OUT_R   (DWC_MSHC_PTR_PHY_R + 0x10)
+#define PHY_PADTEST_IN_R    (DWC_MSHC_PTR_PHY_R + 0x12)
+#define PHY_PRBS_CNFG_R     (DWC_MSHC_PTR_PHY_R + 0x18)
+#define PHY_PHYLBK_CNFG_R   (DWC_MSHC_PTR_PHY_R + 0x1a)
+#define PHY_COMMDL_CNFG_R   (DWC_MSHC_PTR_PHY_R + 0x1c)
+
+#define PHY_SDCLKDL_CNFG_R  (DWC_MSHC_PTR_PHY_R + 0x1d) //8bit
+#define UPDATE_DC 0x4     //1bit
+
+#define PHY_SDCLKDL_DC_R    (DWC_MSHC_PTR_PHY_R + 0x1e)
+#define PHY_SMPLDL_CNFG_R   (DWC_MSHC_PTR_PHY_R + 0x20)
+#define PHY_ATDL_CNFG_R     (DWC_MSHC_PTR_PHY_R + 0x21)
+#define INPSEL_CNFG  2 //2bit
+
+#define PHY_DLL_CTRL_R      (DWC_MSHC_PTR_PHY_R + 0x24)
+#define DLL_EN  0x0 //1bit
+
+#define PHY_DLL_CNFG1_R     (DWC_MSHC_PTR_PHY_R + 0x25)
+#define PHY_DLLDL_CNFG_R    (DWC_MSHC_PTR_PHY_R + 0x28)
+#define SLV_INPSEL 0x5 //2bit
+
+#define PHY_DLL_OFFST_R     (DWC_MSHC_PTR_PHY_R + 0x29)
+#define PHY_DLLMST_TSTDC_R  (DWC_MSHC_PTR_PHY_R + 0x2a)
+#define PHY_DLLBT_CNFG_R    (DWC_MSHC_PTR_PHY_R + 0x2c)
+#define PHY_DLL_STATUS_R    (DWC_MSHC_PTR_PHY_R + 0x2e)
+#define PHY_DLLDBG_MLKDC_R  (DWC_MSHC_PTR_PHY_R + 0x30)
+#define PHY_DLLDBG_SLKDC_R  (DWC_MSHC_PTR_PHY_R + 0x32)
+
+#define SNPS_SDHCI_CTRL_HS400 0x7
+
+#define P_VENDOR_SPECIFIC_AREA 0x500
+#define EMMC_CTRL_R (P_VENDOR_SPECIFIC_AREA + 0x2c) //16bit
+#define CARD_IS_EMMC 0x0 //1bit
+
+#define AT_CTRL_R   (P_VENDOR_SPECIFIC_AREA + 0x40) // 32bit
+#define AT_EN 0x0             //1bit
+#define CI_SEL 0x1            //1bit
+#define SWIN_TH_EN 0x2        //1bit
+#define RPT_TUNE_ERR 0x3      //1bit
+#define SW_TUNE_EN 0x4        //1bit
+#define WIN_EDGE_SEL 0x8      //4bit
+#define TUNE_CLK_STOP_EN 0x10 //1bit
+#define PRE_CHANGE_DLY 0x11   //2bit
+#define POST_CHANGE_DLY 0x13  //2bit
+#define SWIN_TH_VAL 0x18      //9bit
+/* DWCMSHC specific Mode Select value */
+#define DWCMSHC_CTRL_HS400		0x7
+
+#define BOUNDARY_OK(addr, len) \
+	((addr | (SZ_128M - 1)) == ((addr + len - 1) | (SZ_128M - 1)))
+
+struct dwcmshc_priv {
+	struct clk	*bus_clk;
+	void __iomem *soc_base;
+	bool is_emmc_card;
+	bool pull_up_en;
+};
+
+#define DELAY_LANE 30
+
+static void sdhci_phy_1_8v_init_no_pull(struct sdhci_host *host)
+{
+	uint32_t val;
+
+	sdhci_writel(host, 1, DWC_MSHC_PTR_PHY_R);
+	sdhci_writeb(host, 1 << 4, PHY_SDCLKDL_CNFG_R);
+	sdhci_writeb(host, 0x40, PHY_SDCLKDL_DC_R);
+
+	val = sdhci_readb(host, PHY_SDCLKDL_CNFG_R);
+	val &= ~(1 << 4);
+	sdhci_writeb(host, val, PHY_SDCLKDL_CNFG_R);
+
+	val = sdhci_readw(host, PHY_CMDPAD_CNFG_R);
+	sdhci_writew(host, val | 1, PHY_CMDPAD_CNFG_R);
+
+	val = sdhci_readw(host, PHY_DATAPAD_CNFG_R);
+	sdhci_writew(host, val | 1, PHY_DATAPAD_CNFG_R);
+
+	val = sdhci_readw(host, PHY_RSTNPAD_CNFG_R);
+	sdhci_writew(host, val | 1, PHY_RSTNPAD_CNFG_R);
+
+	val = sdhci_readw(host, PHY_STBPAD_CNFG_R);
+	sdhci_writew(host, val | 1, PHY_STBPAD_CNFG_R);
+
+	val = sdhci_readb(host, PHY_DLL_CTRL_R);
+	sdhci_writeb(host, val | 1, PHY_DLL_CTRL_R);
+}
+
+static void sdhci_phy_3_3v_init_no_pull(struct sdhci_host *host)
+{
+	uint32_t val;
+
+	sdhci_writel(host, 1, DWC_MSHC_PTR_PHY_R);
+	sdhci_writeb(host, 1 << 4, PHY_SDCLKDL_CNFG_R);
+	sdhci_writeb(host, 0x40, PHY_SDCLKDL_DC_R);
+
+	val = sdhci_readb(host, PHY_SDCLKDL_CNFG_R);
+	val &= ~(1 << 4);
+	sdhci_writeb(host, val, PHY_SDCLKDL_CNFG_R);
+
+	val = sdhci_readw(host, PHY_CMDPAD_CNFG_R);
+	sdhci_writew(host, val | 2, PHY_CMDPAD_CNFG_R);
+
+	val = sdhci_readw(host, PHY_DATAPAD_CNFG_R);
+	sdhci_writew(host, val | 2, PHY_DATAPAD_CNFG_R);
+
+	val = sdhci_readw(host, PHY_RSTNPAD_CNFG_R);
+	sdhci_writew(host, val | 2, PHY_RSTNPAD_CNFG_R);
+
+	val = sdhci_readw(host, PHY_STBPAD_CNFG_R);
+	sdhci_writew(host, val | 2, PHY_STBPAD_CNFG_R);
+
+	val = sdhci_readb(host, PHY_DLL_CTRL_R);
+	sdhci_writeb(host, val | 1, PHY_DLL_CTRL_R);
+}
+
+static void snps_phy_1_8v_init(struct sdhci_host *host)
+{
+	u32 val;
+	struct sdhci_pltfm_host *pltfm_host;
+	struct dwcmshc_priv *priv;
+
+	pltfm_host = sdhci_priv(host);
+	priv = sdhci_pltfm_priv(pltfm_host);
+	if (priv->pull_up_en == 0) {
+		sdhci_phy_1_8v_init_no_pull(host);
+		return;
+	}
+
+	//set driving force
+	sdhci_writel(host, (1 << PHY_RSTN) | (0xc << PAD_SP) | (0xc << PAD_SN), PHY_CNFG_R);
+
+	//disable delay lane
+	sdhci_writeb(host, 1 << UPDATE_DC, PHY_SDCLKDL_CNFG_R);
+	//set delay lane
+	sdhci_writeb(host, DELAY_LANE, PHY_SDCLKDL_DC_R);
+	//enable delay lane
+	val = sdhci_readb(host, PHY_SDCLKDL_CNFG_R);
+	val &= ~(1 << UPDATE_DC);
+	sdhci_writeb(host, val, PHY_SDCLKDL_CNFG_R);
+
+	val = (1 << RXSEL) | (1 << WEAKPULL_EN) | (3 << TXSLEW_CTRL_P) | (3 << TXSLEW_CTRL_N);
+	sdhci_writew(host, val, PHY_CMDPAD_CNFG_R);
+	sdhci_writew(host, val, PHY_DATAPAD_CNFG_R);
+	sdhci_writew(host, val, PHY_RSTNPAD_CNFG_R);
+
+	val = (3 << TXSLEW_CTRL_P) | (3 << TXSLEW_CTRL_N);
+	sdhci_writew(host, val, PHY_CLKPAD_CNFG_R);
+
+	val = (1 << RXSEL) | (2 << WEAKPULL_EN) | (3 << TXSLEW_CTRL_P) | (3 << TXSLEW_CTRL_N);
+	sdhci_writew(host, val, PHY_STBPAD_CNFG_R);
+
+	sdhci_writeb(host, (1 << DLL_EN),  PHY_DLL_CTRL_R);
+}
+
+static void snps_phy_3_3v_init(struct sdhci_host *host)
+{
+	u32 val;
+	struct sdhci_pltfm_host *pltfm_host;
+	struct dwcmshc_priv *priv;
+
+	pltfm_host = sdhci_priv(host);
+	priv = sdhci_pltfm_priv(pltfm_host);
+	if (priv->pull_up_en == 0) {
+		sdhci_phy_3_3v_init_no_pull(host);
+		return;
+	}
+	//set driving force
+	sdhci_writel(host, (1 << PHY_RSTN) | (0xc << PAD_SP) | (0xc << PAD_SN), PHY_CNFG_R);
+
+	//disable delay lane
+	sdhci_writeb(host, 1 << UPDATE_DC, PHY_SDCLKDL_CNFG_R);
+	//set delay lane
+	sdhci_writeb(host, DELAY_LANE, PHY_SDCLKDL_DC_R);
+	//enable delay lane
+	val = sdhci_readb(host, PHY_SDCLKDL_CNFG_R);
+	val &= ~(1 << UPDATE_DC);
+	sdhci_writeb(host, val, PHY_SDCLKDL_CNFG_R);
+
+	val = (2 << RXSEL) | (1 << WEAKPULL_EN) | (3 << TXSLEW_CTRL_P) | (3 << TXSLEW_CTRL_N);
+	sdhci_writew(host, val, PHY_CMDPAD_CNFG_R);
+	sdhci_writew(host, val, PHY_DATAPAD_CNFG_R);
+	sdhci_writew(host, val, PHY_RSTNPAD_CNFG_R);
+
+	val = (3 << TXSLEW_CTRL_P) | (3 << TXSLEW_CTRL_N);
+	sdhci_writew(host, val, PHY_CLKPAD_CNFG_R);
+
+	val = (2 << RXSEL) | (2 << WEAKPULL_EN) | (3 << TXSLEW_CTRL_P) | (3 << TXSLEW_CTRL_N);
+	sdhci_writew(host, val, PHY_STBPAD_CNFG_R);
+
+	sdhci_writeb(host, (1 << DLL_EN),  PHY_DLL_CTRL_R);
+}
+
+static int __sdhci_execute_tuning(struct sdhci_host *host, u32 opcode)
+{
+	#define DW_SDHCI_TUNING_LOOP_COUNT 128
+	int i;
+	/*
+	 * Issue opcode repeatedly till Execute Tuning is set to 0 or the number
+	 * of loops reaches tuning loop count.
+	 */
+	for (i = 0; i < DW_SDHCI_TUNING_LOOP_COUNT; i++) {
+		u16 ctrl;
+
+		sdhci_send_tuning(host, opcode);
+
+		if (!host->tuning_done) {
+			pr_debug("%s: Tuning timeout, falling back to fixed sampling clock\n",
+					mmc_hostname(host->mmc));
+			sdhci_abort_tuning(host, opcode);
+			return -ETIMEDOUT;
+		}
+
+		/* Spec does not require a delay between tuning cycles */
+		if (host->tuning_delay > 0)
+			mdelay(host->tuning_delay);
+
+		ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+		if (!(ctrl & SDHCI_CTRL_EXEC_TUNING)) {
+			if (ctrl & SDHCI_CTRL_TUNED_CLK)
+				return 0; /* Success! */
+			break;
+		}
+	}
+
+	pr_info("%s: Tuning failed, falling back to fixed sampling clock\n",
+			mmc_hostname(host->mmc));
+	sdhci_reset_tuning(host);
+	return -EAGAIN;
+}
+
+static int snps_execute_tuning(struct sdhci_host *host, u32 opcode)
+{
+	u32 val = 0;
+
+	if (host->flags & SDHCI_HS400_TUNING)
+		return 0;
+
+	sdhci_writeb(host, 3 << INPSEL_CNFG, PHY_ATDL_CNFG_R);
+
+	val = sdhci_readl(host, AT_CTRL_R);
+
+	val &= ~((1 << CI_SEL) | (1 << RPT_TUNE_ERR)\
+		| (1 << SW_TUNE_EN) |(0xf << WIN_EDGE_SEL));
+	val |= (1 << AT_EN) | (1 << SWIN_TH_EN) | (1 << TUNE_CLK_STOP_EN)\
+		| (1 << PRE_CHANGE_DLY) | (3 << POST_CHANGE_DLY) | (9 << SWIN_TH_VAL);
+
+	sdhci_writel(host, val, AT_CTRL_R);
+	val = sdhci_readl(host, AT_CTRL_R);
+	if(!(val & (1 << AT_EN))) {
+		pr_err("*****Auto Tuning is NOT Enable!!!\n");
+		return -1;
+	}
+
+	val &= ~(1 << AT_EN);
+	sdhci_writel(host, val, AT_CTRL_R);
+
+	sdhci_start_tuning(host);
+
+	host->tuning_err = __sdhci_execute_tuning(host, opcode);
+	if (host->tuning_err) {
+		val &= ~(1 << AT_EN);
+		sdhci_writel(host, val, AT_CTRL_R);
+		return -1;
+	}
+
+	sdhci_end_tuning(host);
+
+	return 0;
+}
+
+static void snps_sdhci_set_uhs_signaling(struct sdhci_host *host, unsigned timing)
+{
+	u16 ctrl_2;
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	/* Select Bus Speed Mode for host */
+	ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
+	if ((timing == MMC_TIMING_MMC_HS200) ||
+		(timing == MMC_TIMING_UHS_SDR104)) {
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR104;
+	}
+	else if (timing == MMC_TIMING_UHS_SDR12)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR12;
+	else if (timing == MMC_TIMING_UHS_SDR25)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR25;
+	else if (timing == MMC_TIMING_UHS_SDR50)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR50;
+	else if ((timing == MMC_TIMING_UHS_DDR50) ||
+		(timing == MMC_TIMING_MMC_DDR52))
+		ctrl_2 |= SDHCI_CTRL_UHS_DDR50;
+	else if (timing == MMC_TIMING_MMC_HS400) {
+		ctrl_2 |= SNPS_SDHCI_CTRL_HS400; /* Non-standard */
+	}
+
+	sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
+	if (timing == MMC_TIMING_MMC_HS400) {
+		//disable auto tuning
+		u32 reg = sdhci_readl(host, AT_CTRL_R);
+		reg &= ~1;
+		sdhci_writel(host, reg, AT_CTRL_R);
+		//used ds clock
+		sdhci_writeb(host, 3 << SLV_INPSEL, PHY_DLLDL_CNFG_R);
+	} else {
+		sdhci_writeb(host, 0, PHY_DLLDL_CNFG_R);
+	}
+}
+
+static void snps_sdhci_reset(struct sdhci_host *host, u8 mask)
+{
+	struct sdhci_pltfm_host *pltfm_host;
+	struct dwcmshc_priv *priv;
+	u8 emmc_ctl;
+
+	pltfm_host = sdhci_priv(host);
+	priv = sdhci_pltfm_priv(pltfm_host);
+
+	/*host reset*/
+	sdhci_reset(host, mask);
+	/*fix host reset error*/
+	mdelay(100);
+
+	emmc_ctl = sdhci_readw(host, EMMC_CTRL_R);
+	if (priv->is_emmc_card) {
+		snps_phy_1_8v_init(host);
+		emmc_ctl |= (1 << CARD_IS_EMMC);
+	} else {
+		snps_phy_3_3v_init(host);
+		emmc_ctl &=~(1 << CARD_IS_EMMC);
+	}
+	sdhci_writeb(host, emmc_ctl, EMMC_CTRL_R);
+	/*set i wait*/
+	sdhci_writeb(host, 0x5, PHY_DLL_CNFG1_R);
+}
+
+/*
+ * If DMA addr spans 128MB boundary, we split the DMA transfer into two
+ * so that each DMA transfer doesn't exceed the boundary.
+ */
+static void dwcmshc_adma_write_desc(struct sdhci_host *host, void **desc,
+				    dma_addr_t addr, int len, unsigned int cmd)
+{
+	int tmplen, offset;
+
+	if (likely(!len || BOUNDARY_OK(addr, len))) {
+		sdhci_adma_write_desc(host, desc, addr, len, cmd);
+		return;
+	}
+
+	offset = addr & (SZ_128M - 1);
+	tmplen = SZ_128M - offset;
+	sdhci_adma_write_desc(host, desc, addr, tmplen, cmd);
+
+	addr += tmplen;
+	len -= tmplen;
+	sdhci_adma_write_desc(host, desc, addr, len, cmd);
+}
+
+static const struct sdhci_ops sdhci_dwcmshc_lw_ops = {
+	.set_clock		= sdhci_set_clock,
+	.set_bus_width		= sdhci_set_bus_width,
+	.set_uhs_signaling	= snps_sdhci_set_uhs_signaling,
+	.get_max_clock		= sdhci_pltfm_clk_get_max_clock,
+	.reset			= snps_sdhci_reset,
+	.adma_write_desc	= dwcmshc_adma_write_desc,
+	.voltage_switch     = snps_phy_1_8v_init,
+	.platform_execute_tuning = &snps_execute_tuning,
+};
+
+static const struct sdhci_pltfm_data sdhci_dwcmshc_lw_pdata = {
+	.ops = &sdhci_dwcmshc_lw_ops,
+	.quirks = SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+};
+
+static int dwcmshc_probe(struct platform_device *pdev)
+{
+	struct sdhci_pltfm_host *pltfm_host;
+	struct sdhci_host *host;
+	struct dwcmshc_priv *priv;
+	int err;
+	u32 extra;
+
+	host = sdhci_pltfm_init(pdev, &sdhci_dwcmshc_lw_pdata,
+				sizeof(struct dwcmshc_priv));
+	if (IS_ERR(host))
+		return PTR_ERR(host);
+
+	/*
+	 * extra adma table cnt for cross 128M boundary handling.
+	 */
+	extra = DIV_ROUND_UP_ULL(dma_get_required_mask(&pdev->dev), SZ_128M);
+	if (extra > SDHCI_MAX_SEGS)
+		extra = SDHCI_MAX_SEGS;
+	host->adma_table_cnt += extra;
+	host->v4_mode = true;
+
+	pltfm_host = sdhci_priv(host);
+	priv = sdhci_pltfm_priv(pltfm_host);
+
+        /*used fix sdhci reset error*/
+        priv->soc_base = devm_platform_ioremap_resource(pdev, 1);
+
+        if (device_property_present(&pdev->dev, "is_emmc")) {
+            priv->is_emmc_card = 1;
+        } else {
+            priv->is_emmc_card = 0;
+        }
+
+        if (device_property_present(&pdev->dev, "pull_up")) {
+            priv->pull_up_en = 1;
+        } else {
+            priv->pull_up_en = 0;
+        }
+
+        priv->pull_up_en = 0;
+
+	pltfm_host->clk = devm_clk_get(&pdev->dev, "core");
+	if (IS_ERR(pltfm_host->clk)) {
+		err = PTR_ERR(pltfm_host->clk);
+		dev_err(&pdev->dev, "failed to get core clk: %d\n", err);
+		goto free_pltfm;
+	}
+	err = clk_prepare_enable(pltfm_host->clk);
+	if (err)
+		goto free_pltfm;
+
+	priv->bus_clk = devm_clk_get(&pdev->dev, "bus");
+	if (!IS_ERR(priv->bus_clk))
+		clk_prepare_enable(priv->bus_clk);
+
+	err = mmc_of_parse(host->mmc);
+	if (err)
+		goto err_clk;
+
+	sdhci_get_of_property(pdev);
+
+	err = sdhci_add_host(host);
+	if (err)
+		goto err_clk;
+
+	return 0;
+
+err_clk:
+	clk_disable_unprepare(pltfm_host->clk);
+	clk_disable_unprepare(priv->bus_clk);
+free_pltfm:
+	sdhci_pltfm_free(pdev);
+	return err;
+}
+
+static int dwcmshc_remove(struct platform_device *pdev)
+{
+	struct sdhci_host *host = platform_get_drvdata(pdev);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct dwcmshc_priv *priv = sdhci_pltfm_priv(pltfm_host);
+
+	sdhci_remove_host(host, 0);
+
+	clk_disable_unprepare(pltfm_host->clk);
+	clk_disable_unprepare(priv->bus_clk);
+
+	sdhci_pltfm_free(pdev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int dwcmshc_suspend(struct device *dev)
+{
+	struct sdhci_host *host = dev_get_drvdata(dev);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct dwcmshc_priv *priv = sdhci_pltfm_priv(pltfm_host);
+	int ret;
+
+	ret = sdhci_suspend_host(host);
+	if (ret)
+		return ret;
+
+	clk_disable_unprepare(pltfm_host->clk);
+	if (!IS_ERR(priv->bus_clk))
+		clk_disable_unprepare(priv->bus_clk);
+
+	return ret;
+}
+
+static int dwcmshc_resume(struct device *dev)
+{
+	struct sdhci_host *host = dev_get_drvdata(dev);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct dwcmshc_priv *priv = sdhci_pltfm_priv(pltfm_host);
+	int ret;
+
+	ret = clk_prepare_enable(pltfm_host->clk);
+	if (ret)
+		return ret;
+
+	if (!IS_ERR(priv->bus_clk)) {
+		ret = clk_prepare_enable(priv->bus_clk);
+		if (ret)
+			return ret;
+	}
+
+	return sdhci_resume_host(host);
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(dwcmshc_pmops, dwcmshc_suspend, dwcmshc_resume);
+
+static const struct of_device_id sdhci_dwcmshc_lw_dt_ids[] = {
+	{ .compatible = "snps,dwcmshc-sdhci-light-mpw" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, sdhci_dwcmshc_lw_dt_ids);
+
+static struct platform_driver sdhci_dwcmshc_lw_driver = {
+	.driver	= {
+		.name	= "sdhci-dwcmshc-light-mpw",
+		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
+		.of_match_table = sdhci_dwcmshc_lw_dt_ids,
+		.pm = &dwcmshc_pmops,
+	},
+	.probe	= dwcmshc_probe,
+	.remove	= dwcmshc_remove,
+};
+module_platform_driver(sdhci_dwcmshc_lw_driver);
+
+MODULE_DESCRIPTION("SDHCI platform driver for Synopsys DWC MSHC light mpw");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mmc/host/sdhci-pltfm.c b/drivers/mmc/host/sdhci-pltfm.c
index 328b132bbe57..a56898803e5e 100644
--- a/drivers/mmc/host/sdhci-pltfm.c
+++ b/drivers/mmc/host/sdhci-pltfm.c
@@ -100,6 +100,9 @@ void sdhci_get_property(struct platform_device *pdev)
 	if (device_property_present(dev, "no-1-8-v"))
 		host->quirks2 |= SDHCI_QUIRK2_NO_1_8_V;
 
+	if (device_property_present(dev, "sw-clk-gating"))
+		host->quirks2 |= SDHCI_QUIRK2_SW_CLK_GATING_SUPPORT;
+
 	sdhci_get_compatibility(pdev);
 
 	device_property_read_u32(dev, "clock-frequency", &pltfm_host->clock);
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index bad01cc6823f..da69b69e16ce 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -45,6 +45,11 @@
 
 #define MAX_TUNING_LOOP 40
 
+//#define DEBUG_CMD_ONCE_ERROR_OCCUR
+#ifdef DEBUG_CMD_ONCE_ERROR_OCCUR
+static bool bForceDumpCMD;
+#endif
+
 static unsigned int debug_quirks = 0;
 static unsigned int debug_quirks2;
 
@@ -110,6 +115,9 @@ void sdhci_dumpregs(struct sdhci_host *host)
 				   sdhci_readl(host, SDHCI_ADMA_ADDRESS));
 		}
 	}
+#ifdef DEBUG_CMD_ONCE_ERROR_OCCUR
+	bForceDumpCMD = true;
+#endif
 
 	if (host->ops->dump_vendor_regs)
 		host->ops->dump_vendor_regs(host);
@@ -242,7 +250,8 @@ static void sdhci_do_reset(struct sdhci_host *host, u8 mask)
 			return;
 	}
 
-	host->ops->reset(host, mask);
+	if (host->ops->reset)
+		host->ops->reset(host, mask);
 
 	if (mask & SDHCI_RESET_ALL) {
 		if (host->flags & (SDHCI_USE_SDMA | SDHCI_USE_ADMA)) {
@@ -271,6 +280,12 @@ static void sdhci_set_default_irqs(struct sdhci_host *host)
 	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
 }
 
+/*register macro */
+#define P_VENDOR_SPECIFIC_AREA		0xE8
+#define P_VENDOR2_SPECIFIC_AREA		0xEA
+#define VENDOR_EMMC_CTRL		0x2C
+#define SDHCI_ERR_INT_STATUS_EN		0x36
+
 static void sdhci_config_dma(struct sdhci_host *host)
 {
 	u8 ctrl;
@@ -321,6 +336,7 @@ static void sdhci_init(struct sdhci_host *host, int soft)
 {
 	struct mmc_host *mmc = host->mmc;
 	unsigned long flags;
+	void *vendor_base = NULL;
 
 	if (soft)
 		sdhci_do_reset(host, SDHCI_RESET_CMD | SDHCI_RESET_DATA);
@@ -329,6 +345,13 @@ static void sdhci_init(struct sdhci_host *host, int soft)
 
 	if (host->v4_mode)
 		sdhci_do_enable_v4_mode(host);
+	vendor_base = host->ioaddr + (readl(host->ioaddr + P_VENDOR_SPECIFIC_AREA) & ((1<<12)-1));
+
+#ifdef CONFIG_ARCH_CV183X
+	writew(readw(vendor_base + VENDOR_EMMC_CTRL) | 0x1, vendor_base + VENDOR_EMMC_CTRL);
+#elif defined(CONFIG_ARCH_CV182X)
+//	writew(readw(vendor_base) | 0x1, vendor_base);
+#endif
 
 	spin_lock_irqsave(&host->lock, flags);
 	sdhci_set_default_irqs(host);
@@ -1948,6 +1971,9 @@ u16 sdhci_calc_clk(struct sdhci_host *host, unsigned int clock,
 	clk |= ((div & SDHCI_DIV_HI_MASK) >> SDHCI_DIV_MASK_LEN)
 		<< SDHCI_DIVIDER_HI_SHIFT;
 
+	pr_debug("host->max_clk %u, clock:%u, actual_clock:%u, real_div:%u\n",
+		 host->max_clk, clock, *actual_clock, real_div);
+
 	return clk;
 }
 EXPORT_SYMBOL_GPL(sdhci_calc_clk);
@@ -2155,6 +2181,12 @@ void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	unsigned long flags;
 	bool present;
 
+	if (host->quirks2 & SDHCI_QUIRK2_SW_CLK_GATING_SUPPORT) {
+		sdhci_writew(host,
+			sdhci_readw(host, SDHCI_CLOCK_CONTROL) | SDHCI_CLOCK_CARD_EN,
+			SDHCI_CLOCK_CONTROL);
+	}
+
 	/* Firstly check card presence */
 	present = mmc->ops->get_cd(mmc);
 
@@ -2923,6 +2955,18 @@ int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 }
 EXPORT_SYMBOL_GPL(sdhci_execute_tuning);
 
+static int sdhci_select_drive_strength(struct mmc_card *card,
+				       unsigned int max_dtr, int host_drv,
+				       int card_drv, int *drv_type)
+{
+	struct sdhci_host *host = mmc_priv(card->host);
+
+	if (!host->ops->select_drive_strength)
+		return 0;
+
+	return host->ops->select_drive_strength(host, card, max_dtr, host_drv,
+						card_drv, drv_type);
+}
 static void sdhci_enable_preset_value(struct sdhci_host *host, bool enable)
 {
 	/* Host Controller v3.00 defines preset value registers */
@@ -3005,6 +3049,11 @@ static void sdhci_card_event(struct mmc_host *mmc)
 
 	present = mmc->ops->get_cd(mmc);
 
+	/* Once REG_0x24[16] is 0, raise a flag. */
+	if (!present) {
+		mmc->ever_unplugged = true;
+	}
+
 	spin_lock_irqsave(&host->lock, flags);
 
 	/* Check sdhci_has_requests() first in case we are runtime suspended */
@@ -3036,6 +3085,7 @@ static const struct mmc_host_ops sdhci_ops = {
 	.start_signal_voltage_switch	= sdhci_start_signal_voltage_switch,
 	.prepare_hs400_tuning		= sdhci_prepare_hs400_tuning,
 	.execute_tuning			= sdhci_execute_tuning,
+	.select_drive_strength		= sdhci_select_drive_strength,
 	.card_event			= sdhci_card_event,
 	.card_busy	= sdhci_card_busy,
 };
@@ -3168,6 +3218,12 @@ static bool sdhci_request_done(struct sdhci_host *host)
 	else
 		mmc_request_done(host->mmc, mrq);
 
+	if (host->quirks2 & SDHCI_QUIRK2_SW_CLK_GATING_SUPPORT) {
+		sdhci_writew(host,
+			(sdhci_readw(host, SDHCI_CLOCK_CONTROL) & ~SDHCI_CLOCK_CARD_EN),
+			SDHCI_CLOCK_CONTROL);
+	}
+
 	return false;
 }
 
@@ -3514,6 +3570,8 @@ static irqreturn_t sdhci_irq(int irq, void *dev_id)
 			u32 present = sdhci_readl(host, SDHCI_PRESENT_STATE) &
 				      SDHCI_CARD_PRESENT;
 
+			if (intmask & SDHCI_INT_CARD_REMOVE)
+				host->mmc->ever_unplugged = true;
 			/*
 			 * There is a observation on i.mx esdhc.  INSERT
 			 * bit will be immediately set again when it gets
@@ -3540,6 +3598,54 @@ static irqreturn_t sdhci_irq(int irq, void *dev_id)
 			result = IRQ_WAKE_THREAD;
 		}
 
+#ifdef DEBUG_CMD_ONCE_ERROR_OCCUR
+		if ((intmask & SDHCI_INT_ERROR) && (bForceDumpCMD == false)) {
+#else
+		if (intmask & SDHCI_INT_ERROR) {
+#endif
+			//Ignore error of Tuning CMD.
+			//MMC - CMD21
+			//SD  - CMD19
+			if (host->cmd &&
+			(((host->cmd->opcode != 21) &&
+			(host->mmc->card) && (host->mmc->card->type == MMC_TYPE_MMC)) ||
+			((host->cmd->opcode != 19) &&
+			(host->mmc->card) && (host->mmc->card->type == MMC_TYPE_SD)))) {
+				pr_err("%s: host->mmc->card->type = %d\n", __func__, host->mmc->card->type);
+				pr_err("%s: err cmd %p\n", __func__, host->cmd);
+				pr_err("%s: err opcode %d\n", __func__, host->cmd->opcode);
+				pr_err("%s: err interrupt 0x%08x\n", __func__, intmask);
+				sdhci_dumpregs(host);
+#ifdef DEBUG_CMD_ONCE_ERROR_OCCUR
+				bForceDumpCMD = true;
+#endif
+			}
+		}
+
+#ifdef DEBUG_CMD_ONCE_ERROR_OCCUR
+		if (bForceDumpCMD) {
+			if (host->cmd) {
+				SDHCI_DUMP("%s: [DEBUG]err cmd %p\n", __func__, host->cmd);
+				SDHCI_DUMP("%s: [DEBUG]err opcode %d\n", __func__, host->cmd->opcode);
+			} else if (host->data_cmd) {
+				SDHCI_DUMP("%s: [DEBUG]err datacmd %p\n", __func__, host->data_cmd);
+				SDHCI_DUMP("%s: [DEBUG]err opcode %d\n", __func__, host->data_cmd->opcode);
+			}
+			SDHCI_DUMP("%s: [DEBUG]err interrupt 0x%08x\n", __func__, intmask);
+			SDHCI_DUMP("%s: [DEBUG]Argument: 0x%08x\n", __func__,
+					sdhci_readl(host, SDHCI_ARGUMENT));
+			SDHCI_DUMP("%s: [DEBUG]Resp[0]:   0x%08x | Resp[1]:  0x%08x\n", __func__,
+					sdhci_readl(host, SDHCI_RESPONSE),
+					sdhci_readl(host, SDHCI_RESPONSE + 4));
+			SDHCI_DUMP("%s: [DEBUG]Resp[2]:   0x%08x | Resp[3]:  0x%08x\n", __func__,
+					sdhci_readl(host, SDHCI_RESPONSE + 8),
+					sdhci_readl(host, SDHCI_RESPONSE + 12));
+			if (intmask & SDHCI_INT_ERROR) {
+				sdhci_dumpregs(host);
+			}
+		}
+#endif
+
 		if (intmask & SDHCI_INT_CMD_MASK)
 			sdhci_cmd_irq(host, intmask & SDHCI_INT_CMD_MASK, &intmask);
 
@@ -4213,7 +4319,7 @@ int sdhci_setup_host(struct sdhci_host *host)
 	override_timeout_clk = host->timeout_clk;
 
 	if (host->version > SDHCI_SPEC_420) {
-		pr_err("%s: Unknown controller version (%d). You may experience problems.\n",
+		pr_debug("%s: Host Controller version %d\n",
 		       mmc_hostname(mmc), host->version);
 	}
 
@@ -4478,7 +4584,10 @@ int sdhci_setup_host(struct sdhci_host *host)
 				mmc_hostname(mmc), ret);
 			mmc->supply.vqmmc = ERR_PTR(-EINVAL);
 		}
+	}
 
+	if (host->quirks2 & SDHCI_QUIRK2_NO_3_3_V) {
+		host->flags &= ~SDHCI_SIGNALING_330;
 	}
 
 	if (host->quirks2 & SDHCI_QUIRK2_NO_1_8_V) {
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index 4db57c3a8cd4..bd7f690d17eb 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -127,6 +127,7 @@
 #define  SDHCI_RESET_DATA	0x04
 
 #define SDHCI_INT_STATUS	0x30
+#define SDHCI_ERR_INT_STATUS	0x32
 #define SDHCI_INT_ENABLE	0x34
 #define SDHCI_SIGNAL_ENABLE	0x38
 #define  SDHCI_INT_RESPONSE	0x00000001
@@ -476,6 +477,17 @@ struct sdhci_host {
  */
 #define SDHCI_QUIRK2_USE_32BIT_BLK_CNT			(1<<18)
 
+/* To enhance power consumption,
+ * the sdio clk be disabled when CMD/DAT bus idle
+ */
+#define SDHCI_QUIRK2_SW_CLK_GATING_SUPPORT			(1<<29)
+/* The system physically doesn't support 3.3v, even if the host does */
+#define SDHCI_QUIRK2_NO_3_3_V               (1<<30)
+
+/* Support Disable when device is not present (EMMC only) */
+#define SDHCI_QUIRK2_SUPPORT_DISABLE_CLK        (1<<31)
+
+
 	int irq;		/* Device IRQ */
 	void __iomem *ioaddr;	/* Mapped address */
 	phys_addr_t mapbase;	/* physical address base */
@@ -656,6 +668,10 @@ struct sdhci_ops {
 					 unsigned int length);
 	void	(*request_done)(struct sdhci_host *host,
 				struct mmc_request *mrq);
+	int	(*select_drive_strength)(struct sdhci_host *host,
+					 struct mmc_card *card,
+					 unsigned int max_dtr, int host_drv,
+					 int card_drv, int *drv_type);
 	void    (*dump_vendor_regs)(struct sdhci_host *host);
 };
 
diff --git a/drivers/mtd/nand/raw/Kconfig b/drivers/mtd/nand/raw/Kconfig
index 6c46f25b57e2..4f2f73ece483 100644
--- a/drivers/mtd/nand/raw/Kconfig
+++ b/drivers/mtd/nand/raw/Kconfig
@@ -556,4 +556,13 @@ config MTD_NAND_DISKONCHIP_BBTWRITE
 	  load time (assuming you build diskonchip as a module) with the module
 	  parameter "inftl_bbt_write=1".
 
+config MTD_NAND_CVSNFC
+    tristate "Support SPINFC controller on CVITEK chips"
+    depends on HAS_DMA
+    help
+      Enable the driver for SPI NAND flash on platforms using a CVSNFC controller.
+      Thiscontroller is foudn on CV1835
+      Enable the driver for SPI NAND flash on platforms using a CVSNFC controller.
+      Thiscontroller is foudn on CV1835
+
 endif # MTD_RAW_NAND
diff --git a/drivers/mtd/nand/raw/Makefile b/drivers/mtd/nand/raw/Makefile
index 2930f5b9015d..d52c99bfefc3 100644
--- a/drivers/mtd/nand/raw/Makefile
+++ b/drivers/mtd/nand/raw/Makefile
@@ -58,6 +58,7 @@ obj-$(CONFIG_MTD_NAND_STM32_FMC2)	+= stm32_fmc2_nand.o
 obj-$(CONFIG_MTD_NAND_MESON)		+= meson_nand.o
 obj-$(CONFIG_MTD_NAND_CADENCE)		+= cadence-nand-controller.o
 obj-$(CONFIG_MTD_NAND_ARASAN)		+= arasan-nand-controller.o
+obj-$(CONFIG_MTD_NAND_CVSNFC)		+= cvitek/
 
 nand-objs := nand_base.o nand_legacy.o nand_bbt.o nand_timings.o nand_ids.o
 nand-objs += nand_onfi.o
diff --git a/drivers/mtd/nand/raw/cvitek/Makefile b/drivers/mtd/nand/raw/cvitek/Makefile
new file mode 100644
index 000000000000..358b7443b207
--- /dev/null
+++ b/drivers/mtd/nand/raw/cvitek/Makefile
@@ -0,0 +1,2 @@
+cvsvfc-y += cvsnfc.o cvsnfc_spi_ids.o cvsnfc_dt.o
+obj-$(CONFIG_MTD_NAND_CVSNFC)                += cvsvfc.o
diff --git a/drivers/mtd/nand/raw/cvitek/cvmc_common.h b/drivers/mtd/nand/raw/cvitek/cvmc_common.h
new file mode 100644
index 000000000000..ab9b35c20541
--- /dev/null
+++ b/drivers/mtd/nand/raw/cvitek/cvmc_common.h
@@ -0,0 +1,48 @@
+#ifndef __CVMC_COMMON_H__
+#define __CVMC_COMMON_H__
+
+/*****************************************************************************/
+#define _512B					(512)
+#define _1K					(1024)
+#define _2K					(2048)
+#define _4K					(4096)
+#define _8K					(8192)
+#define _16K					(16384)
+#define _32K					(32768)
+#define _64K					(0x10000UL)
+#define _128K					(0x20000UL)
+#define _256K					(0x40000UL)
+#define _512K					(0x80000UL)
+#define _1M					(0x100000UL)
+#define _2M					(0x200000UL)
+#define _4M					(0x400000UL)
+#define _8M					(0x800000UL)
+#define _16M					(0x1000000UL)
+#define _32M					(0x2000000UL)
+#define _64M					(0x4000000UL)
+#define _128M					(0x8000000UL)
+#define _256M					(0x10000000UL)
+#define _512M					(0x20000000UL)
+#define _1G					(0x40000000ULL)
+#define _2G					(0x80000000ULL)
+#define _4G					(0x100000000ULL)
+#define _8G					(0x200000000ULL)
+#define _16G					(0x400000000ULL)
+#define _64G					(0x1000000000ULL)
+
+#define ECC_TYPE_0BIT				0x0
+#define ECC_TYPE_8BIT				0x1
+#define ECC_TYPE_16BIT				0x2
+#define ECC_TYPE_24BIT				0x3
+#define ECC_TYPE_28BIT				0x4
+#define ECC_TYPE_40BIT				0x5
+#define ECC_TYPE_64BIT				0x6
+
+#define PAGE_SIZE_2KB				0x0
+#define PAGE_SIZE_4KB				0x1
+#define PAGE_SIZE_8KB				0x2
+#define PAGE_SIZE_16KB				0x3
+
+/*****************************************************************************/
+#endif /* End of __CVMC_COMMON_H__ */
+
diff --git a/drivers/mtd/nand/raw/cvitek/cvsnfc.c b/drivers/mtd/nand/raw/cvitek/cvsnfc.c
new file mode 100644
index 000000000000..a526a42b5113
--- /dev/null
+++ b/drivers/mtd/nand/raw/cvitek/cvsnfc.c
@@ -0,0 +1,1419 @@
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/wait.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/mtd/mtd.h>
+#include <linux/module.h>
+#include <linux/mtd/rawnand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/reset.h>
+
+#include "cvsnfc_common.h"
+#include "cvsnfc_spi_ids.h"
+#include "cvsnfc.h"
+extern struct nand_flash_dev nand_flash_cvitek_supported_ids[];
+#define NAND_NAME    "cvsnfc"
+
+#define PTR_INC(base, offset) (void *)((uint8_t *)(base) + (offset))
+
+static int cvsnfc_dev_ready(struct nand_chip *chip);
+static void cvsnfc_ctrl_ecc(struct mtd_info *mtd, bool enable);
+static void  cvsnfc_setup_intr(struct cvsnfc_host *host);
+static void cvsnfc_set_qe(struct cvsnfc_host *host, uint32_t enable);
+extern void cvsnfc_get_flash_info(struct nand_chip *chip, unsigned char *byte);
+
+static void cv_spi_nand_dump_reg(struct cvsnfc_host *host)
+{
+	uint32_t i = 0;
+	uint32_t reg = 0;
+
+	for (i = 0; i <= 0x58; i += 4) {
+		reg = cvsfc_read(host, i);
+		pr_info("0x%x: 0x%x\n", 0x4060000 + i, reg);
+	}
+}
+
+/*****************************************************************************/
+static void wait_for_irq(struct cvsnfc_host *host, struct cvsnfc_irq_status_t *irq_mask,
+		struct cvsnfc_irq_status_t *irq_status)
+{
+	unsigned long comp_res = 0;
+	unsigned long timeout = msecs_to_jiffies(10000);
+
+	do {
+		udelay(10);
+		comp_res =
+			wait_for_completion_timeout(&host->complete, timeout);
+		spin_lock_irq(&host->irq_lock);
+		*irq_status = host->irq_status;
+
+		if (irq_status->status & irq_mask->status) {
+			pr_debug("host->irq_status.status %x irq_mask->status %x\n",
+					host->irq_status.status, irq_mask->status);
+
+			host->irq_status.status &= ~irq_mask->status;
+			spin_unlock_irq(&host->irq_lock);
+			break;
+		}
+
+		/*
+		 * these are not the interrupts you are looking for; need to wait again
+		 */
+		spin_unlock_irq(&host->irq_lock);
+	} while (comp_res != 0);
+
+	if (comp_res == 0) {
+		/* timeout */
+		dev_err(host->dev, "timeout occurred:\t status = 0x%x, mask = 0x%x\n",
+				irq_status->status, irq_mask->status);
+
+		memset(irq_status, 0, sizeof(struct cvsnfc_irq_status_t));
+	}
+}
+
+
+/*****************************************************************************/
+/* Send set/get features command to SPI Nand flash */
+#define DEBUG_SPI_NAND_DRV 0
+
+void spi_feature_op(struct cvsnfc_host *host, int op, int fe, unsigned int *val)
+{
+	if (op == GET_OP) {
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, 1 << TRX_DATA_SIZE_SHIFT | 1 << TRX_CMD_CONT_SIZE_SHIFT);
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, 0);
+		cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, fe << 8 | SPI_NAND_CMD_GET_FEATURE);
+		cvsnfc_send_nondata_cmd_and_wait(host);
+
+		*val = cvsfc_read(host, REG_SPI_NAND_RX_DATA) & 0xff;
+
+		pr_debug("cvsnfc: get feature [%#x]<==[%#x]\n", fe, *val);
+	} else {
+		uint32_t fe_set = fe | (*val << 8);
+
+		pr_debug("cvsnfc: set feature [%#x] = [%#x]\n", fe, *val);
+
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, 2 << TRX_CMD_CONT_SIZE_SHIFT);
+		cvsfc_write(host,  REG_SPI_NAND_TRX_CTRL3, BIT_REG_TRX_RW);
+		cvsfc_write(host,  REG_SPI_NAND_TRX_CMD0, (fe_set << TRX_CMD_CONT0_SHIFT) | SPI_NAND_CMD_SET_FEATURE);
+		cvsnfc_send_nondata_cmd_and_wait(host);
+
+	}
+}
+
+/*****************************************************************************/
+static void cvsnfc_send_cmd_pageprog(struct cvsnfc_host *host)
+{
+
+}
+
+/*****************************************************************************/
+static void cvsnfc_send_cmd_readstart(struct cvsnfc_host *host)
+{
+
+}
+
+/*****************************************************************************/
+static void cvsnfc_send_cmd_erase(struct cvsnfc_host *host)
+{
+	unsigned int val;
+	uint32_t row_addr = host->addr_value[1];
+	struct cvsnfc_chip_info *spi_nand = &host->spi_nand;
+	struct spi_nand_driver *spi_driver = spi_nand->driver;
+	uint32_t r_row_addr = ((row_addr & 0xff0000) >> 16) | (row_addr & 0xff00) |
+		((row_addr & 0xff) << 16);
+
+	pr_debug("%s row_addr 0x%x\n", __func__, host->addr_value[1]);
+
+	if (spi_driver->select_die) {
+		unsigned int die_id =
+			row_addr / (host->diesize / host->pagesize);
+
+		spi_driver->select_die(host, die_id);
+	}
+
+	val = spi_driver->wait_ready(host);
+	if (val) {
+		pr_err("cvsnfc: erase wait ready fail! status[%#x]\n", val);
+		return;
+	}
+
+	if (spi_driver->write_enable(host)) {
+		pr_err("%s erase write enable failed\n", __func__);
+		return;
+	}
+
+	spi_feature_op(host, GET_OP, STATUS_ADDR, &val);
+	pr_debug("Get feature addr[0xC0], val[%#x]\n", val);
+
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, 3 << TRX_CMD_CONT_SIZE_SHIFT); // 3 bytes for 24-bit row address
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, 0x0);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, (r_row_addr << TRX_CMD_CONT0_SHIFT) | SPI_NAND_CMD_BLOCK_ERASE);
+
+	cvsnfc_send_nondata_cmd_and_wait(host);
+
+	val = spi_driver->wait_ready(host);
+	if (val & STATUS_E_FAIL_MASK)
+		pr_err("cvsnfc: erase failed! status[%#x]\n", val);
+}
+
+/*****************************************************************************/
+static void cvsnfc_send_cmd_status(struct cvsnfc_host *host)
+{
+	unsigned int regval, addr = 0;
+
+	if ((host->cmd_option.last_cmd == NAND_CMD_ERASE1)
+			|| (host->cmd_option.last_cmd == NAND_CMD_PAGEPROG))
+		addr = PROTECTION_ADDR;
+	else
+		addr = STATUS_ADDR;
+
+	spi_feature_op(host, GET_OP, addr, &regval);
+
+	pr_info("cvsnfc: %s get %#x status[%#x]\n",
+			((host->cmd_option.last_cmd == NAND_CMD_ERASE1)
+			 ? "erase" : "write"), addr, regval);
+}
+
+static void  cvsnfc_setup_intr(struct cvsnfc_host *host)
+{
+	cvsfc_write(host, REG_SPI_NAND_INT_EN, 0x1f1);
+	cvsfc_write(host, REG_SPI_NAND_INT_CLR, BITS_SPI_NAND_INT_CLR_ALL);
+	cvsfc_write(host, REG_SPI_NAND_INT_MASK, 0);
+}
+
+/* send non-data command and wait for finish */
+int cvsnfc_send_nondata_cmd_and_wait(struct cvsnfc_host *host)
+{
+	struct cvsnfc_irq_status_t irq_mask, irq_status;
+
+	irq_mask.status = BIT_REG_TRX_DONE_INT_CLR;
+	irq_status.status = 0;
+
+	cvsnfc_setup_intr(host);
+
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL0, cvsfc_read(host, REG_SPI_NAND_TRX_CTRL0) | BIT_REG_TRX_START);
+
+	wait_for_irq(host, &irq_mask, &irq_status);
+
+	if (irq_status.status == 0) {
+		u32 int_status = cvsfc_read(host, REG_SPI_NAND_INT);
+		dev_err(host->dev, "%s command timeout 0x%x\n", __func__, int_status);
+		cv_spi_nand_dump_reg(host);
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+/*****************************************************************************/
+static void cvsnfc_send_cmd_readid(struct cvsnfc_host *host)
+{
+	pr_debug("%s\n", __func__);
+
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, 0x00030001);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, 0);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, SPI_NAND_CMD_READ_ID);
+	//cvsfc_write(host, REG_SPI_NAND_BOOT_CTRL, BIT_REG_BOOT_PRD);
+
+	cvsnfc_send_nondata_cmd_and_wait(host);
+
+	pr_debug("%s exit\n", __func__);
+}
+
+/*****************************************************************************/
+static void cvsnfc_send_cmd_reset(struct cvsnfc_host *host)
+{
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, 0);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, 0);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, SPI_NAND_CMD_RESET);
+
+	cvsnfc_send_nondata_cmd_and_wait(host);
+}
+
+/*****************************************************************************/
+uint8_t cvsnfc_read_byte(struct nand_chip *chip)
+{
+	unsigned char value = 0;
+	static unsigned int data;
+	struct cvsnfc_host *host = chip->priv;
+
+	pr_debug("%s r %p\n", __func__, __builtin_return_address(0));
+
+	if ((host->offset % 4) == 0) {
+		data = cvsfc_read(host, REG_SPI_NAND_RX_DATA);
+		pr_debug("cvsnfc_read_byte read data 0x%x, offset %d\n", data, host->offset);
+	}
+
+	if (host->cmd_option.last_cmd == NAND_CMD_READID) {
+		unsigned char off = host->offset % 4;
+
+		value = (data & (0xff << (off * 8))) >> (off * 8);
+		pr_debug("read id off %d, value 0x%x\n", host->offset, value);
+
+		host->offset++;
+
+		if (host->cmd_option.date_num == host->offset) {
+			host->cmd_option.last_cmd = 0;
+			host->offset = 0;
+		}
+
+		return value;
+	}
+
+	if ((host->cmd_option.last_cmd == NAND_CMD_ERASE1)
+			|| (host->cmd_option.last_cmd == NAND_CMD_PAGEPROG)) {
+		return value;
+	}
+
+	if (host->cmd_option.last_cmd == NAND_CMD_ERASE2) {
+		return value;
+	}
+
+	if (host->cmd_option.command == NAND_CMD_STATUS) {
+		return value;
+	}
+
+	if (host->cmd_option.last_cmd == NAND_CMD_READOOB) {
+		return value;
+	}
+
+	host->offset++;
+
+	pr_debug("%s return\n", __func__);
+
+	return 0;// FIXME : readb(host->buffer + host->column + host->offset - 1);
+}
+
+/*****************************************************************************/
+
+/*****************************************************************************/
+static void cvsnfc_write_buf(struct nand_chip *chip,
+	const uint8_t *buf, int len)
+{
+}
+
+/*****************************************************************************/
+static void cvsnfc_read_buf(struct nand_chip *chip, uint8_t *buf, int len)
+{
+}
+
+/*****************************************************************************/
+static void cvsnfc_select_chip(struct nand_chip *chip, int chipselect)
+{
+}
+
+static void cvsnfc_cmdfunc(struct nand_chip *chip, unsigned int cmd, int col,
+						  int page)
+{
+	struct cvsnfc_host *host = nand_get_controller_data(chip);;
+
+	pr_debug("=> %s, r 0x%p\n", __func__, __builtin_return_address(0));
+
+	switch (cmd) {
+	case NAND_CMD_PAGEPROG:
+		break;
+	case NAND_CMD_STATUS:
+		host->offset = 0;
+
+		break;
+	case NAND_CMD_READID:
+		host->offset = 0;
+		host->cmd_option.last_cmd = cmd;
+		host->cmd_option.date_num = MAX_ID_LEN;
+		host->send_cmd_readid(host); // cvsnfc_send_cmd_readid
+		break;
+	case NAND_CMD_PARAM:
+
+		break;
+	case NAND_CMD_READ0:
+	case NAND_CMD_SEQIN:
+		break;
+	case NAND_CMD_RESET:
+		/* resets a specific device connected to the core */
+		host->cmd_option.last_cmd = cmd;
+		break;
+	case NAND_CMD_READOOB:
+		break;
+	case NAND_CMD_RNDOUT:
+		break;
+	case NAND_CMD_ERASE1:
+		host->addr_value[0] = 0;
+		host->addr_value[1] = page;
+		host->cmd_option.last_cmd = cmd;
+		host->send_cmd_erase(host); //cvsnfc_send_cmd_erase
+		break;
+	case NAND_CMD_ERASE2:
+		break;
+	default:
+		dev_warn(host->dev, "unsupported command received 0x%x\n", cmd);
+		break;
+	}
+
+	pr_debug("<= %s, exit\n", __func__);
+
+}
+
+/*****************************************************************************/
+static void cvsnfc_cmd_ctrl(struct nand_chip *chip, int dat, unsigned int ctrl)
+{
+	unsigned char cmd;
+	int is_cache_invalid = 1;
+	struct cvsnfc_host *host = chip->priv;
+
+	pr_debug("%s\n", __func__);
+
+	if (ctrl & NAND_ALE) {
+		unsigned int addr_value = 0;
+		unsigned int addr_offset = 0;
+
+		if (ctrl & NAND_CTRL_CHANGE) {
+			host->addr_cycle = 0x0;
+			host->addr_value[0] = 0x0;
+			host->addr_value[1] = 0x0;
+		}
+		addr_offset = host->addr_cycle << 3;
+
+		if (host->addr_cycle >= CVSNFC_ADDR_CYCLE_MASK) {
+			addr_offset = (host->addr_cycle -
+					CVSNFC_ADDR_CYCLE_MASK) << 3;
+			addr_value = 1;
+		}
+
+		host->addr_value[addr_value] |=
+			((dat & 0xff) << addr_offset);
+
+		host->addr_cycle++;
+	}
+
+	if ((ctrl & NAND_CLE) && (ctrl & NAND_CTRL_CHANGE)) {
+		cmd = dat & 0xff;
+		host->cmd_option.command = cmd;
+		switch (cmd) {
+		case NAND_CMD_PAGEPROG:
+			host->offset = 0;
+			host->send_cmd_pageprog(host);
+			break;
+
+		case NAND_CMD_READSTART:
+			is_cache_invalid = 0;
+			if (host->addr_value[0] == host->pagesize)
+				host->cmd_option.last_cmd = NAND_CMD_READOOB;
+			host->send_cmd_readstart(host);
+			break;
+
+		case NAND_CMD_ERASE2:
+			host->cmd_option.last_cmd = cmd;
+			host->send_cmd_erase(host);
+			break;
+
+		case NAND_CMD_READID:
+			memset((unsigned char *)(chip->legacy.IO_ADDR_R), 0,
+				MAX_ID_LEN);
+			host->cmd_option.last_cmd = cmd;
+			host->cmd_option.date_num = MAX_ID_LEN;
+			host->send_cmd_readid(host);
+			break;
+
+		case NAND_CMD_STATUS:
+			host->send_cmd_status(host);
+			break;
+
+		case NAND_CMD_SEQIN:
+			break;
+
+		case NAND_CMD_ERASE1:
+			break;
+
+		case NAND_CMD_READ0:
+			host->cmd_option.last_cmd = cmd;
+			break;
+
+		case NAND_CMD_RESET:
+			host->send_cmd_reset(host);
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	if ((dat == NAND_CMD_NONE) && host->addr_cycle) {
+		if (host->cmd_option.command == NAND_CMD_SEQIN
+		    || host->cmd_option.command == NAND_CMD_READ0
+		    || host->cmd_option.command == NAND_CMD_READID) {
+			host->offset = 0x0;
+			host->column = (host->addr_value[0] & 0xffff);
+		}
+	}
+
+	if (is_cache_invalid) {
+		host->cache_addr_value[0] = ~0;
+		host->cache_addr_value[1] = ~0;
+	}
+
+	pr_info("%s exit\n", __func__);
+
+}
+
+/*****************************************************************************/
+static int cvsnfc_waitfunc(struct nand_chip *chip)
+{
+	unsigned int regval;
+	unsigned int deadline = 0;
+	struct cvsnfc_host *host = nand_get_controller_data(chip);
+
+	pr_debug("=>%s\n", __func__);
+
+	do {
+		spi_feature_op(host, GET_OP, STATUS_ADDR, &regval);
+
+		if (!(regval & STATUS_OIP_MASK))
+			return NAND_STATUS_READY;
+
+		udelay(1);
+		/* maybe need to sure */
+	} while (deadline++ < (40 << 5));
+
+	pr_err("%s timeout.\n", __func__);
+
+	return NAND_STATUS_FAIL;
+}
+
+/*****************************************************************************/
+static int cvsnfc_dev_ready(struct nand_chip *chip)
+{
+	unsigned int regval;
+	unsigned int deadline = 0;
+	struct cvsnfc_host *host = chip->priv;
+
+	do {
+		spi_feature_op(host, GET_OP, STATUS_ADDR, &regval);
+		if (!(regval & STATUS_OIP_MASK))
+			return 1;
+		udelay(1);
+	} while (deadline++ < (40 << 5));
+
+	pr_err("%s timeout.\n", __func__);
+
+	return 0;
+}
+
+static int cvsnfc_ecc_probe(struct cvsnfc_host *host)
+{
+	struct nand_memory_organization *memorg;
+	struct nand_chip *chip = &host->nand;
+	struct nand_flash_dev *info = &host->spi_nand.nand_info;
+	struct mtd_info *mtd = nand_to_mtd(&(host->nand));
+
+	chip->ecc.size = info->ecc.step_ds;
+	chip->ecc.strength = info->ecc.strength_ds;
+	chip->ecc.steps = host->pagesize / chip->ecc.size;
+	chip->ecc.bytes = host->oobsize / chip->ecc.steps;
+
+	chip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;
+	chip->ecc.placement = NAND_ECC_PLACEMENT_INTERLEAVED;
+
+	if (chip->ecc.strength == 1)
+		chip->ecc.algo = NAND_ECC_ALGO_HAMMING;
+	else
+		chip->ecc.algo = NAND_ECC_ALGO_BCH;
+
+	mtd->bitflip_threshold = DIV_ROUND_UP(info->ecc.strength_ds * 3, 4);
+	pr_info("mtd->bitflip_threshold %u\n", mtd->bitflip_threshold);
+
+	memorg = nanddev_get_memorg(&(host->nand.base));
+	memorg->bits_per_cell = 1;
+	if (host->pagesize > SPI_NAND_MAX_PAGESIZE
+			|| host->oobsize > SPI_NAND_MAX_OOBSIZE) {
+		pr_err(ERSTR_DRIVER "Driver does not support this Nand Flash.\n");
+		pr_err(ERSTR_DRIVER "Please increase SPI_NAND_MAX_PAGESIZE and SPI_NAND_MAX_OOBSIZE.\n");
+	}
+
+	return 0;
+}
+
+static int spi_nand_send_read_page_cmd(struct cvsnfc_host *host, int page)
+{
+	int row_addr = page;
+	int r_row_addr = ((row_addr & 0xff0000) >> 16) | (row_addr & 0xff00) | ((row_addr & 0xff) << 16);
+
+	pr_debug("%s row_addr 0x%x, r_row_addr 0x%x\n", __func__, row_addr, r_row_addr);
+
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, 0 << TRX_DATA_SIZE_SHIFT | 3 << TRX_CMD_CONT_SIZE_SHIFT);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, 0);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, r_row_addr << TRX_CMD_CONT0_SHIFT | SPI_NAND_CMD_PAGE_READ_TO_CACHE);
+
+	cvsnfc_send_nondata_cmd_and_wait(host);
+
+	cvsnfc_dev_ready(&(host->nand));
+
+	return 0;
+}
+
+/*
+ * spi_nand user guide v0.3.docx
+ * 5.4 : Write Command with DMA Data
+ *
+ * DW_axi_dmac_databook(sysdma).pdf
+ *
+ * rw : 0 for read, 1 for write
+ */
+
+static void cvsnfc_dma_complete(void *arg)
+{
+	struct cvsnfc_host *host = (struct cvsnfc_host *) arg;
+
+	pr_debug("%s\n", __func__);
+
+	complete(&host->comp);
+
+}
+
+static void cvsnfc_ctrl_ecc(struct mtd_info *mtd, bool enable)
+{
+	unsigned int status = 0;
+	struct nand_chip *chip = mtd->priv;
+	struct cvsnfc_host *host = chip->priv;
+
+	pr_debug("%s %s ecc\n", __func__, (enable) ? "enable":"disable");
+
+	spi_feature_op(host, GET_OP, FEATURE_ADDR, &status);
+
+	if (enable == ENABLE_ECC) {
+		status = status | (SPI_NAND_FEATURE0_ECC_EN);
+		spi_feature_op(host, SET_OP, FEATURE_ADDR, &status);
+	} else {
+		status = status & ~(SPI_NAND_FEATURE0_ECC_EN);
+		spi_feature_op(host, SET_OP, FEATURE_ADDR, &status);
+	}
+}
+
+static void spi_nand_reset_ip(struct cvsnfc_host *host)
+{
+	uint32_t reg_0x4;
+	uint32_t reg_0x24;
+
+	// save 0x4 and 0x24 value
+	reg_0x4 = cvsfc_read(host, REG_SPI_NAND_TRX_CTRL1);
+	reg_0x24 = cvsfc_read(host, REG_SPI_NAND_BOOT_CTRL);
+
+	pr_info("org : 0x4 = 0x%x, 0x24 = 0x%x\n", reg_0x4, reg_0x24);
+
+	// reset and wait at least 1u
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL0, BIT_REG_TRX_SW_RST);
+	udelay(10);
+
+	// restore 0x4 and 0x24
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL1, reg_0x4);
+	cvsfc_write(host, REG_SPI_NAND_BOOT_CTRL, reg_0x24);
+
+	reg_0x4 = cvsfc_read(host, REG_SPI_NAND_TRX_CTRL1);
+	reg_0x24 = cvsfc_read(host, REG_SPI_NAND_BOOT_CTRL);
+
+	pr_info("after reset : 0x4 = 0x%x, 0x24 = 0x%x\n", reg_0x4, reg_0x24);
+}
+
+#define SYSDMA_TIMEOUT_MS (5 * 1000) // 5 seconds
+
+static int spi_nand_rw_dma_setup(struct cvsnfc_host *host, void *buf, int len, int rw)
+{
+	struct dma_async_tx_descriptor *desc;
+	unsigned long flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;
+	struct dma_slave_config conf;
+	struct dma_chan *chan = rw ? host->dma_chan_tx : host->dma_chan_rx;
+	unsigned long res = 0;
+	int ret = 0;
+
+	pr_debug("=>%s\n", __func__);
+
+	memset(&conf, 0, sizeof(conf));
+	if (rw) {
+		// write to device
+
+		/*
+		 * Set direction to a sensible value even if the dmaengine driver
+		 * should ignore it. With the default (DMA_MEM_TO_MEM), the amba-pl08x
+		 * driver criticizes it as "alien transfer direction".
+		 */
+		conf.direction = DMA_MEM_TO_DEV;
+		conf.src_addr = (host->dma_buffer);
+		conf.dst_addr = (host->io_base_phy + 0x800);
+	} else {
+		// read data from device
+		conf.direction = DMA_DEV_TO_MEM;
+		conf.src_addr = (host->io_base_phy + 0xC00);
+		conf.dst_addr = (host->dma_buffer);
+	}
+
+	/* DMA controller does flow control: */
+	conf.device_fc = false;
+	conf.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	conf.src_maxburst = 4;
+	conf.dst_maxburst = 4;
+
+	if (dmaengine_slave_config(chan, &conf)) {
+		dev_err(host->dev, "Failed to setup DMA slave\n");
+		return -EPERM;
+	}
+
+	sg_init_one(&host->sgl, buf, len);
+
+	res = dma_map_sg(host->dev, &host->sgl, 1, DMA_BIDIRECTIONAL);
+
+	if (res == 0) {
+		dev_err(host->dev, "Failed to map sg list. res=%lu\n", res);
+		return -ENXIO;
+	}
+
+	desc = dmaengine_prep_slave_sg(chan, &host->sgl, res, conf.direction, // dwc_prep_dma_slave_sg
+			flags);
+	init_completion(&host->comp);
+
+	desc->callback = cvsnfc_dma_complete;
+	desc->callback_param = (void *) host;
+
+	host->cookie = dmaengine_submit(desc); // dwc_tx_submit
+
+	dma_async_issue_pending(chan); // dwc_issue_pending
+
+	res = wait_for_completion_timeout(&host->comp, msecs_to_jiffies(SYSDMA_TIMEOUT_MS * 2));
+
+	if (res == 0) {
+		void __iomem *clk_reg;
+		void __iomem *sysdma_reg;
+		uint32_t i = 0;
+
+		cv_spi_nand_dump_reg(host);
+
+		spi_nand_reset_ip(host);
+
+		clk_reg = ioremap(0x3002000, 0x10);
+		sysdma_reg = ioremap(0x4330000, 0x800);
+
+		pr_err("%s timeout, 0x3002000=0x%x, 0x3002004=0x%x, ch0 sar=0x%x ch1 dar=0x%x\n",
+				__func__, readl(clk_reg), readl(clk_reg + 4), readl(sysdma_reg + 0x100),
+				readl(sysdma_reg + 0x208));
+
+		pr_err("CFG=0x%x, CHEN=0x%x, ch0 status=0x%x, ch1 status=0x%x, callback=%p\n",
+				readl(sysdma_reg+0x10), readl(sysdma_reg + 0x18), readl(sysdma_reg + 0x130),
+				readl(sysdma_reg + 0x230), desc->callback);
+
+		pr_err("ch_id=%d\n", chan->chan_id);
+
+		for (i = 0; i <= 0x40; i += 4) {
+			pr_info("0x%x: 0x%x\n", (0x0 + i), readl(sysdma_reg + i));
+		}
+		for (i = 0; i <= 0x40; i += 4) {
+			pr_info("0x%x: 0x%x\n", (0x100 + i), readl(sysdma_reg + 0x100 + i));
+		}
+		for (i = 0; i <= 0x40; i += 4) {
+			pr_info("0x%x: 0x%x\n", (0x200 + i), readl(sysdma_reg + 0x200 + i));
+		}
+
+		iounmap(clk_reg);
+		iounmap(sysdma_reg);
+
+		ret = -ETIMEDOUT;
+	}
+
+	dma_unmap_sg(chan->device->dev, &host->sgl, 1, DMA_BIDIRECTIONAL);
+
+	pr_debug("<=%s\n", __func__);
+
+	return ret;
+}
+
+static void spi_nand_set_read_from_cache_mode(struct cvsnfc_host *host, uint32_t mode, uint32_t r_col_addr)
+{
+	struct spi_nand_driver *spi_driver = host->spi_nand.driver;
+	switch (mode) {
+	case SPI_NAND_READ_FROM_CACHE_MODE_X1:
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, BIT_REG_TRX_DMA_EN |
+				BIT_REG_TRX_DUMMY_HIZ);
+		cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, r_col_addr << TRX_CMD_CONT0_SHIFT |
+				SPI_NAND_CMD_READ_FROM_CACHE);
+		break;
+	case SPI_NAND_READ_FROM_CACHE_MODE_X2:
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, BIT_REG_TRX_DMA_EN |
+				SPI_NAND_CTRL3_IO_TYPE_X2_MODE | BIT_REG_TRX_DUMMY_HIZ);
+		cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, r_col_addr << TRX_CMD_CONT0_SHIFT |
+				SPI_NAND_CMD_READ_FROM_CACHEX2);
+		break;
+	case SPI_NAND_READ_FROM_CACHE_MODE_X4:
+		cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, BIT_REG_TRX_DMA_EN |
+				SPI_NAND_CTRL3_IO_TYPE_X4_MODE | BIT_REG_TRX_DUMMY_HIZ);
+		cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, r_col_addr << TRX_CMD_CONT0_SHIFT |
+				SPI_NAND_CMD_READ_FROM_CACHEX4);
+
+		if (spi_driver->qe_enable)
+			spi_driver->qe_enable(host);
+		break;
+	default:
+		pr_err("unsupport mode!\n");
+		break;
+	}
+}
+
+static void spi_nand_read_eccsr(struct cvsnfc_host *host, uint8_t read_ecc_opcode, uint32_t *eccsr)
+{
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, 1 << TRX_DATA_SIZE_SHIFT | 1 << TRX_CMD_CONT_SIZE_SHIFT);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, 0);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, read_ecc_opcode);
+	cvsnfc_send_nondata_cmd_and_wait(host);
+
+	*eccsr = cvsfc_read(host, REG_SPI_NAND_RX_DATA) & 0xff;
+}
+
+static int parse_status_info(struct cvsnfc_host *host)
+{
+	struct cvsnfc_chip_info *spi_dev = &host->spi_nand;
+	struct nand_ecc_info *ecc_info = &spi_dev->ecc_info;
+	uint8_t *id = spi_dev->nand_info.id;
+	uint32_t ecc_status0, ecc_status1, status;
+	uint32_t mask, sr_mask;
+	uint32_t corr_bit = 0;
+
+	if (!ecc_info->ecc_sr_addr && !ecc_info->read_ecc_opcode) {
+		pr_err("can not get ecc status\n");
+		return -1;
+	}
+
+	/* read SR */
+	spi_feature_op(host, GET_OP, ecc_info->ecc_sr_addr, &ecc_status0);
+	if (((ecc_status0 & 0x30) >> 4) == 0)
+		return 0;
+
+	if (((ecc_status0 & 0x30) >> 4) == ecc_info->uncorr_val)
+		return -EBADMSG;
+
+	mask = GENMASK(ecc_info->ecc_bits - 1, 0);
+	status = (ecc_status0 >> ecc_info->ecc_bit_shift) & mask;
+
+	if (ecc_info->ecc_sr_addr && !ecc_info->read_ecc_opcode && !ecc_info->ecc_mbf_addr) {
+		if (ecc_info->remap) {
+			corr_bit = ecc_info->remap[status] != 0xff ? ecc_info->remap[status] : 0;
+		} else {
+			pr_info("ECC CORR, unknown bitflip so we guess it has corrected at least 1 bit\n");
+			corr_bit = 1;
+		}
+	}
+
+	/* only for GD */
+	if (ecc_info->ecc_mbf_addr && id[0] == 0xc8) {
+		spi_feature_op(host, GET_OP, ecc_info->ecc_mbf_addr, &ecc_status1);
+		status = ((ecc_status0 & 0x30) >> 2) | ((ecc_status1 & 0x30) >> 4);
+		corr_bit = ecc_info->remap[status] != 0xff ? ecc_info->remap[status] : 0;
+	}
+
+	if (ecc_info->ecc_mbf_addr && id[0] != 0xc8) {
+		spi_feature_op(host, GET_OP, ecc_info->ecc_mbf_addr, &ecc_status0);
+		corr_bit = (ecc_status0 >> ecc_info->ecc_bit_shift) & mask;
+	}
+
+	if (ecc_info->read_ecc_opcode) {
+		spi_nand_read_eccsr(host, ecc_info->read_ecc_opcode, &ecc_status0);
+		corr_bit = (ecc_status0 >> ecc_info->ecc_bit_shift) & mask;
+	}
+	pr_info("ECC CORR, correct bits %u\n", corr_bit);
+	return corr_bit;
+}
+
+static int spi_nand_read_from_cache(struct cvsnfc_host *host, struct mtd_info *mtd,
+		int col_addr, int len, void *buf)
+{
+	int r_col_addr = ((col_addr & 0xff00) >> 8) | ((col_addr & 0xff) << 8);
+	int ret = 0;
+	unsigned int max_bitflips = 0;
+	int retry = 3;
+
+RETRY_READ_CMD:
+
+	pr_debug("%s caddr 0x%x, r_raddr 0x%x, len %d\n", __func__, col_addr, r_col_addr, len);
+
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, len << TRX_DATA_SIZE_SHIFT | 3 << TRX_CMD_CONT_SIZE_SHIFT);
+
+	spi_nand_set_read_from_cache_mode(host, SPI_NAND_READ_FROM_CACHE_MODE_X2, r_col_addr);
+
+	cvsnfc_setup_intr(host);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL0,
+			cvsfc_read(host, REG_SPI_NAND_TRX_CTRL0) | BIT_REG_TRX_START);
+
+	ret = spi_nand_rw_dma_setup(host, buf, len, 0);
+
+	if (ret == 0) {
+		struct cvsnfc_irq_status_t irq_mask, irq_status;
+
+		irq_mask.status =
+			BIT_REG_DMA_DONE_INT_CLR | BIT_REG_TRX_DONE_INT_CLR;
+		irq_status.status = 0;
+
+		wait_for_irq(host, &irq_mask, &irq_status);
+
+		if (irq_status.status == 0) {
+			u32 int_status = cvsfc_read(host, REG_SPI_NAND_INT);
+			dev_err(host->dev, "%s command timeout 0x%x\n", __func__, int_status);
+			ret = -ETIMEDOUT;
+		}
+	} else if (ret == -ETIMEDOUT) {
+		if (--retry) {
+			pr_err("retry read cmd\n");
+			goto RETRY_READ_CMD;
+		} else {
+			pr_err("retry read failed\n");
+		}
+	} else {
+		pr_err("rw dma setup error %d\n", ret);
+	}
+
+	ret = parse_status_info(host);
+	if (ret < 0) {
+		mtd->ecc_stats.failed++;
+		pr_info("%s caddr 0x%x, r_raddr 0x%x, len %d\n", __func__, col_addr, r_col_addr, len);
+	} else {
+		mtd->ecc_stats.corrected += ret;
+		max_bitflips = max_t(unsigned int, max_bitflips, ret);
+	}
+
+	return max_bitflips;
+}
+
+	__attribute__((unused))
+static void cvsnfc_set_qe(struct cvsnfc_host *host, uint32_t enable)
+{
+	unsigned int status = 0;
+
+	if (enable) {
+		spi_feature_op(host, GET_OP, FEATURE_ADDR, &status);
+		status |= SPI_NAND_FEATURE0_QE;
+		spi_feature_op(host, SET_OP, FEATURE_ADDR, &status);
+		spi_feature_op(host, GET_OP, FEATURE_ADDR, &status);
+	} else {
+
+		spi_feature_op(host, GET_OP, FEATURE_ADDR, &status);
+		status &= ~SPI_NAND_FEATURE0_QE;
+		spi_feature_op(host, SET_OP, FEATURE_ADDR, &status);
+		spi_feature_op(host, GET_OP, FEATURE_ADDR, &status);
+	}
+}
+
+static int cvsnfc_read_page(struct nand_chip *chip,
+		uint8_t *buf, int bytes, int row_addr)
+{
+	int ret = 0;
+	uint32_t col_addr = 0;
+
+	struct cvsnfc_host *host = chip->priv;
+	uint32_t blk_idx = row_addr / host->block_page_cnt;
+	struct mtd_info *mtd = nand_to_mtd(chip);
+	struct cvsnfc_chip_info *spi_nand = &host->spi_nand;
+	struct spi_nand_driver *spi_driver = spi_nand->driver;
+	unsigned int die_id;
+
+	pr_debug("=>%s, row_addr 0x%x blk_idx %d\n", __func__, row_addr, blk_idx);
+	host->last_row_addr = row_addr;
+
+	if (spi_driver->select_die) {
+		die_id = row_addr / (host->diesize / host->pagesize);
+		spi_driver->select_die(host, die_id);
+	}
+
+	spi_nand_send_read_page_cmd(host, row_addr);
+
+	if (host->flags & FLAGS_SET_PLANE_BIT && (blk_idx & BIT(0))) {
+		pr_debug("%s set plane bit for blkidx %d\n", __func__, blk_idx);
+		col_addr |= SPI_NAND_PLANE_BIT_OFFSET;
+	}
+
+	ret = spi_nand_read_from_cache(host, mtd, col_addr, mtd->writesize, host->buforg);
+
+	memcpy(buf, (void *)host->buforg, mtd->writesize);
+
+	if (ret) {
+		pr_debug("%s row_addr 0x%x ret %d\n", __func__, row_addr, ret);
+	}
+
+	return ret;
+}
+
+static int read_oob_data(struct mtd_info *mtd, uint8_t *buf, int row_addr)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct cvsnfc_host *host = chip->priv;
+	uint32_t col_addr = 0;
+	uint32_t blk_idx = row_addr / host->block_page_cnt;
+	int ret = 0;
+	struct spi_nand_driver *spi_driver = host->spi_nand.driver;
+
+	pr_debug("%s, row_addr 0x%x\n", __func__, row_addr);
+
+	host->last_row_addr = row_addr;
+
+	if (spi_driver->select_die) {
+		unsigned int die_id =
+			row_addr / (host->diesize / host->pagesize);
+
+		spi_driver->select_die(host, die_id);
+	}
+
+	cvsnfc_ctrl_ecc(mtd, DISABLE_ECC);
+
+	spi_nand_send_read_page_cmd(host, row_addr);
+
+	if (host->flags & FLAGS_SET_PLANE_BIT && (blk_idx & BIT(0))) {
+		pr_debug("%s set plane bit for blkidx %d\n", __func__, blk_idx);
+		col_addr |= SPI_NAND_PLANE_BIT_OFFSET;
+	}
+
+	ret = spi_nand_read_from_cache(host, mtd, mtd->writesize, mtd->oobsize, host->buforg);
+
+	memcpy(buf, (void *)host->buforg, mtd->oobsize);
+
+	cvsnfc_ctrl_ecc(mtd, ENABLE_ECC);
+
+	if (ret) {
+		pr_err("%s row_addr 0x%x ret %d\n", __func__, row_addr, ret);
+	}
+
+	return ret;
+}
+
+static int cvsnfc_read_oob(struct nand_chip *chip,
+			     int page)
+{
+    struct mtd_info *mtd = nand_to_mtd(chip);
+	return read_oob_data(mtd, chip->oob_poi, page);
+}
+
+static int cvsnfc_read_page_raw(struct nand_chip *chip,
+							   uint8_t *buf, int oob_required, int page)
+{
+	return 0;
+}
+
+static int cvsnfc_read_subpage(struct nand_chip *chip,
+			      u32 data_offs, u32 readlen, u8 *buf, int row_addr)
+{
+	struct cvsnfc_host *host = chip->priv;
+	uint32_t col_addr = 0;
+	uint32_t blk_idx = row_addr / host->block_page_cnt;
+	int ret = 0;
+	struct spi_nand_driver *spi_driver = host->spi_nand.driver;
+	struct mtd_info *mtd = nand_to_mtd(chip);
+
+	pr_debug("=>%s, row_addr 0x%x, data_offs %d, readlen %d, buf %p\n",
+			__func__, row_addr, data_offs, readlen, buf);
+
+	host->last_row_addr = row_addr;
+
+	if (spi_driver->select_die) {
+		unsigned int die_id = row_addr / (host->diesize / host->pagesize);
+
+		spi_driver->select_die(host, die_id);
+	}
+
+	cvsnfc_ctrl_ecc(mtd, ENABLE_ECC);
+
+	spi_nand_send_read_page_cmd(host, row_addr);
+
+	if (host->flags & FLAGS_SET_PLANE_BIT && (blk_idx & BIT(0))) {
+		pr_debug("%s set plane bit for blkidx %d\n", __func__, blk_idx);
+		col_addr |= SPI_NAND_PLANE_BIT_OFFSET;
+	}
+
+	ret = spi_nand_read_from_cache(host, mtd, col_addr, mtd->writesize,
+			host->buforg);
+
+	memcpy(buf, (void *)PTR_INC(host->buforg, data_offs), readlen);
+
+	if (ret) {
+		pr_debug("%s row_addr 0x%x ret %d\n", __func__, row_addr, ret);
+	}
+
+	return ret;
+}
+
+static int spi_nand_prog_load(struct cvsnfc_host *host, const uint8_t *buf,
+		size_t size, uint32_t col_addr, uint32_t qe)
+{
+	uint8_t cmd = qe ? SPI_NAND_CMD_PROGRAM_LOADX4 : SPI_NAND_CMD_PROGRAM_LOAD;
+	uint32_t r_col_addr = ((col_addr & 0xff00) >> 8) | ((col_addr & 0xff) << 8);
+	uint32_t ctrl3 = 0;
+	void *data_buf = (void *) buf;
+	int ret = 0;
+	int retry = 3;
+	struct spi_nand_driver *spi_driver = host->spi_nand.driver;
+
+	if (qe && spi_driver->qe_enable)
+		spi_driver->qe_enable(host);
+
+RETRY_WRITE_CMD:
+
+	pr_debug("=>%s size %u, col_addr 0x%x, r_col_addr 0x%x,  qe %d\n",
+			__func__, (int) size, col_addr, r_col_addr, qe);
+
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2,
+			(size << TRX_DATA_SIZE_SHIFT) | 2 << TRX_CMD_CONT_SIZE_SHIFT);
+
+	ctrl3 = qe ?
+		(BIT_REG_TRX_RW | BIT_REG_TRX_DMA_EN | SPI_NAND_CTRL3_IO_TYPE_X4_MODE) :
+		(BIT_REG_TRX_RW | BIT_REG_TRX_DMA_EN);
+
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, ctrl3);
+
+	cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, cmd | (r_col_addr << TRX_CMD_CONT0_SHIFT));
+
+	cvsnfc_setup_intr(host);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL0, cvsfc_read(host, REG_SPI_NAND_TRX_CTRL0) | BIT_REG_TRX_START);
+
+	ret = spi_nand_rw_dma_setup(host, data_buf, size, 1);
+	if (ret == 0) {
+		struct cvsnfc_irq_status_t irq_mask, irq_status;
+
+		irq_mask.status =
+			BIT_REG_DMA_DONE_INT_CLR | BIT_REG_TRX_DONE_INT_CLR;
+		irq_status.status = 0;
+
+		wait_for_irq(host, &irq_mask, &irq_status);
+
+		if (irq_status.status == 0) {
+			u32 int_status = cvsfc_read(host, REG_SPI_NAND_INT);
+			dev_err(host->dev, "%s command timeout 0x%x\n", __func__, int_status);
+			ret = -ETIMEDOUT;
+		}
+	} else if (ret == -ETIMEDOUT) {
+		if (--retry) {
+			pr_err("retry prog load cmd\n");
+			goto RETRY_WRITE_CMD;
+		} else {
+			pr_err("retry write failed\n");
+		}
+	} else {
+		pr_err("rw dma setup error %d\n", ret);
+	}
+
+	pr_debug("<=%s\n", __func__);
+
+	return ret;
+}
+
+static int spi_nand_prog_exec(struct cvsnfc_host *host, uint32_t row_addr)
+{
+	uint32_t r_row_addr = ((row_addr & 0xff0000) >> 16) | (row_addr & 0xff00) | ((row_addr & 0xff) << 16);
+
+	pr_debug("=>%s\n", __func__);
+	pr_debug("row_addr 0x%x\n", row_addr);
+	pr_debug("r_row_addr 0x%x\n", r_row_addr);
+
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, 3 << TRX_CMD_CONT_SIZE_SHIFT);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, 0);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, SPI_NAND_CMD_PROGRAM_EXECUTE | (r_row_addr << TRX_CMD_CONT0_SHIFT));
+	cvsfc_write(host, REG_SPI_NAND_RSP_POLLING, 0xff00ff);
+
+	cvsnfc_send_nondata_cmd_and_wait(host);
+
+	cvsnfc_dev_ready(&host->nand);
+
+	pr_debug("<=%s\n", __func__);
+
+	return 0;
+}
+
+static int write_page_helper(struct mtd_info *mtd, struct nand_chip *chip,
+		const uint8_t *buf, int row_addr)
+{
+	struct cvsnfc_host *host = chip->priv;
+	unsigned int val;
+	uint32_t col_addr = 0;
+	uint32_t blk_idx = row_addr / host->block_page_cnt;
+	struct spi_nand_driver *spi_driver = host->spi_nand.driver;
+	int ret = 0;
+
+	pr_debug("=>%s, buf %p, page 0x%x ", __func__, buf, row_addr);
+
+	host->last_row_addr = row_addr;
+
+	if (spi_driver->select_die) {
+		unsigned int die_id =
+			row_addr / (host->diesize / host->pagesize);
+
+		spi_driver->select_die(host, die_id);
+	}
+
+	val = spi_driver->wait_ready(host);
+	if (val) {
+		pr_err("cvsnfc: write wait ready fail! status[%#x]\n", val);
+		return -1;
+	}
+
+	if (spi_driver->write_enable(host)) {
+		pr_err("%s write enable failed!\n", __func__);
+		return -1;
+	}
+
+	cvsnfc_ctrl_ecc(mtd, ENABLE_ECC);
+
+	spi_feature_op(host, GET_OP, STATUS_ADDR, &val);
+
+	pr_debug("Get feature addr[0xC0], val[%#x]\n", val);
+	pr_debug("blk idx %d\n", blk_idx);
+
+	if (host->flags & FLAGS_SET_PLANE_BIT && (blk_idx & BIT(0))) {
+		pr_debug("%s set plane bit for blkidx %d\n", __func__, blk_idx);
+		col_addr |= SPI_NAND_PLANE_BIT_OFFSET;
+	}
+
+	memcpy((void *)host->buforg, buf, mtd->writesize);
+	ret = spi_nand_prog_load(host, host->buforg, host->pagesize, col_addr,
+			0);
+	if (ret) {
+		return ret;
+	}
+
+	ret = spi_nand_prog_exec(host, row_addr);
+	if (ret) {
+		pr_err("%s spi_nand_prog_exec failed! %d\n", __func__, ret);
+		return ret;
+	}
+
+	val = spi_driver->wait_ready(host);
+	if (val & STATUS_E_FAIL_MASK)
+		pr_err("cvsnfc: write failed! status[%#x]\n", val);
+
+	pr_debug("<=\n");
+
+	return ret;
+}
+
+static int cvsnfc_write_page(struct nand_chip *chip,
+			    const uint8_t *buf, int oob_required, int row_addr)
+{
+	int status = 0;
+    struct mtd_info *mtd = nand_to_mtd(chip);
+
+	/*
+	 * for regular page writes, we let HW handle all the ECC
+	 * data written to the device.
+	 */
+
+	status = write_page_helper(mtd, chip, buf, row_addr);
+
+	if (status) {
+		pr_err("write error\n");
+		return status;
+	}
+
+	return status;
+}
+
+static int cvsnfc_attach_chip(struct nand_chip *chip)
+{
+	//struct mtd_info *mtd = nand_to_mtd(chip);
+	struct cvsnfc_host *host = nand_get_controller_data(chip);
+
+
+	if (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_ON_HOST)
+		cvsnfc_ecc_probe(host);
+
+	return 0;
+}
+
+static const struct nand_controller_ops cvsnfc_controller_ops = {
+	.attach_chip = cvsnfc_attach_chip,
+};
+/*****************************************************************************/
+void cvsnfc_nand_init(struct nand_chip *chip)
+{
+	struct cvsnfc_host *host = chip->priv;
+
+	cvsnfc_setup_intr(host);
+
+	chip->legacy.read_byte   = cvsnfc_read_byte;
+	chip->legacy.write_buf   = cvsnfc_write_buf;
+	chip->legacy.read_buf    = cvsnfc_read_buf;
+
+	chip->legacy.select_chip = cvsnfc_select_chip;
+	chip->legacy.cmdfunc = cvsnfc_cmdfunc;
+	chip->legacy.waitfunc = cvsnfc_waitfunc;
+	chip->legacy.cmd_ctrl    = cvsnfc_cmd_ctrl;
+	chip->legacy.dev_ready   = cvsnfc_dev_ready;
+
+	chip->legacy.chip_delay  = CVSNFC_CHIP_DELAY;
+
+	chip->options     = NAND_BROKEN_XD;
+
+	chip->bbt_options = NAND_BBT_USE_FLASH | NAND_BBT_NO_OOB;
+
+	/* override the default read operations */
+	chip->ecc.read_page = cvsnfc_read_page;
+	chip->ecc.read_oob = cvsnfc_read_oob;
+	chip->ecc.read_page_raw = cvsnfc_read_page_raw;
+	chip->ecc.read_subpage = cvsnfc_read_subpage;
+	chip->ecc.write_page = cvsnfc_write_page;
+
+	chip->options |= NAND_NO_SUBPAGE_WRITE;
+
+	chip->legacy.dummy_controller.ops = &cvsnfc_controller_ops;
+}
+
+static void cvsnfc_clear_interrupt(struct cvsnfc_host *host, struct cvsnfc_irq_status_t *irq_status)
+{
+	pr_debug("%s\n", __func__);
+
+	writel(irq_status->status, host->regbase + REG_SPI_NAND_INT_CLR);
+}
+
+static inline uint32_t irq_detected(struct cvsnfc_host *host, struct cvsnfc_irq_status_t *irq_status)
+{
+
+	irq_status->status = readl(host->regbase + REG_SPI_NAND_INT);
+
+	pr_debug("%s irq_status->status 0x%x\n", __func__, irq_status->status);
+
+	return irq_status->status;
+}
+
+/*
+ * This is the interrupt service routine. It handles all interrupts
+ * sent to this device.
+ */
+static irqreturn_t cvsnfc_isr(int irq, void *dev_id)
+{
+	struct cvsnfc_host *host = dev_id;
+	struct cvsnfc_irq_status_t irq_status;
+	irqreturn_t result = IRQ_NONE;
+
+	pr_debug("%s\n", __func__);
+
+	spin_lock(&host->irq_lock);
+
+	if (irq_detected(host, &irq_status)) {
+		/* handle interrupt */
+		/* first acknowledge it */
+		cvsnfc_clear_interrupt(host, &irq_status);
+		/* store the status in the device context for someone to read */
+		host->irq_status.status |= irq_status.status;
+		/* notify anyone who cares that it happened */
+		complete(&host->complete);
+		/* tell the OS that we've handled this */
+		result = IRQ_HANDLED;
+	}
+	spin_unlock(&host->irq_lock);
+
+	return result;
+}
+
+static int cvsnfc_dma_setup(struct cvsnfc_host *host)
+{
+	struct mtd_info *mtd = nand_to_mtd(&(host->nand));
+	dma_cap_mask_t mask;
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+	host->dma_chan_rx = dma_request_slave_channel(host->dev, "rx");
+	host->dma_chan_tx = dma_request_slave_channel(host->dev, "tx");
+	if (!host->dma_chan_rx) {
+		dev_err(mtd->dev.parent, "Failed to request DMA rx channel\n");
+		return -EBUSY;
+	}
+
+	if (!host->dma_chan_tx) {
+		dev_err(mtd->dev.parent, "Failed to request DMA tx channel\n");
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+/*****************************************************************************/
+int cvsnfc_host_init(struct cvsnfc_host *host)
+{
+	int ret = 0;
+	struct mtd_info *mtd = nand_to_mtd(&host->nand);
+
+	if (host->set_system_clock)
+		host->set_system_clock(NULL, ENABLE);
+
+	host->buforg = devm_kzalloc(host->dev, CVSNFC_BUFFER_LEN, GFP_DMA | GFP_KERNEL);
+
+	if (!host->buforg) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	ret = dma_set_mask(host->dev, DMA_BIT_MASK(64));
+
+	if (ret) {
+		dev_err(host->dev, "no usable DMA configuration\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	host->dma_buffer =
+		dma_map_single(host->dev, host->buforg, CVSNFC_BUFFER_LEN,
+				DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(host->dev, host->dma_buffer)) {
+		dev_err(host->dev, "Failed to map DMA buffer\n");
+		ret = -EIO;
+		goto err;
+	}
+
+	/*
+	 * Allocate a large enough buffer for a single huge page plus
+	 * extra space for the spare area and ECC storage area
+	 */
+	host->dma_buf_len = CVSNFC_BUFFER_LEN;
+	host->data_buf = devm_kzalloc(host->dev, host->dma_buf_len,
+			GFP_KERNEL);
+
+	if (!host->data_buf) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	cvsnfc_dma_setup(host);
+
+	host->send_cmd_pageprog  = cvsnfc_send_cmd_pageprog;
+	host->send_cmd_status    = cvsnfc_send_cmd_status;
+	host->send_cmd_readstart = cvsnfc_send_cmd_readstart;
+	host->send_cmd_erase     = cvsnfc_send_cmd_erase;
+	host->send_cmd_readid    = cvsnfc_send_cmd_readid;
+	host->send_cmd_reset     = cvsnfc_send_cmd_reset;
+
+	mtd->dev.parent = host->dev;
+
+	if (request_irq(host->irq, cvsnfc_isr, IRQF_SHARED,
+				NAND_NAME, host)) {
+		dev_err(host->dev, "Unable to allocate IRQ\n");
+		return -ENODEV;
+	}
+
+	mtd->name = NAND_NAME;
+	mtd->owner = THIS_MODULE;
+	mtd->priv = &host->nand;
+
+	spin_lock_init(&host->irq_lock);
+	init_completion(&host->complete);
+	return 0;
+err:
+	return ret;
+}
+
+/*****************************************************************************/
+EXPORT_SYMBOL(cvsnfc_host_init);
+
+static void cvsnfc_irq_cleanup(int irqnum, struct cvsnfc_host *host)
+{
+	free_irq(irqnum, host);
+}
+
+/* driver exit point */
+void cvsnfc_remove(struct cvsnfc_host *host)
+{
+	cvsnfc_irq_cleanup(host->irq, host);
+}
+EXPORT_SYMBOL(cvsnfc_remove);
diff --git a/drivers/mtd/nand/raw/cvitek/cvsnfc.h b/drivers/mtd/nand/raw/cvitek/cvsnfc.h
new file mode 100644
index 000000000000..712f38940459
--- /dev/null
+++ b/drivers/mtd/nand/raw/cvitek/cvsnfc.h
@@ -0,0 +1,668 @@
+#ifndef CVSNFCH
+#define CVSNFCH
+
+#include <linux/types.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/rawnand.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/io.h>
+
+#include "cvsnfc_common.h"
+#include "cvsnfc_spi_ids.h"
+
+/******************************************************************************/
+/* These macroes are for debug only, reg option is slower then dma option */
+#undef CVSNFC_SUPPORT_REG_READ
+/* #define CVSNFC_SUPPORT_REG_READ */
+#undef CVSNFC_SUPPORT_REG_WRITE
+/* #define CVSNFC_SUPPORT_REG_WRITE */
+
+/*****************************************************************************/
+#define PROTECTION_ADDR				0xa0
+#define FEATURE_ADDR				0xb0
+#define STATUS_ADDR					0xc0
+#define WRITE_ENABLE_STATUS_ADDR		STATUS_ADDR
+/*****************************************************************************/
+#define GET_OP					0
+#define SET_OP					1
+
+#define PROTECTION_BRWD_MASK			(1 << 7)
+#define PROTECTION_BP3_MASK			(1 << 6)
+#define PROTECTION_BP2_MASK			(1 << 5)
+#define PROTECTION_BP1_MASK			(1 << 4)
+#define PROTECTION_BP0_MASK			(1 << 3)
+
+#define ANY_BP_ENABLE(_val)		((PROTECTION_BP3_MASK & _val) \
+		|| (PROTECTION_BP2_MASK & _val) \
+		|| (PROTECTION_BP1_MASK & _val) \
+		|| (PROTECTION_BP0_MASK & _val))
+
+#define ALL_BP_MASK				(PROTECTION_BP3_MASK \
+		| PROTECTION_BP2_MASK \
+		| PROTECTION_BP1_MASK \
+		| PROTECTION_BP0_MASK)
+
+#define FEATURE_ECC_ENABLE			(1 << 4)
+#define FEATURE_QE_ENABLE			(1 << 0)
+
+#define STATUS_ECC_MASK				(0x3 << 4)
+#define STATUS_P_FAIL_MASK			(1 << 3)
+#define STATUS_E_FAIL_MASK			(1 << 2)
+#define STATUS_WEL_MASK				(1 << 1)
+#define STATUS_OIP_MASK				(1 << 0)
+
+/*****************************************************************************/
+/* latest register definition */
+#define SPI_NAND_PROGRAM_LOAD_X1 0
+#define SPI_NAND_PROGRAM_LOAD_X4 1
+
+#define SPI_NAND_READ_FROM_CACHE_MODE_X1 0
+#define SPI_NAND_READ_FROM_CACHE_MODE_X2 1
+#define SPI_NAND_READ_FROM_CACHE_MODE_X4 2
+
+#define SPI_NAND_CMD_WREN			0x06
+#define SPI_NAND_CMD_WRDI			0x04
+#define SPI_NAND_CMD_GET_FEATURE		0x0F
+#define SPI_NAND_CMD_SET_FEATURE		0x1F
+#define SPI_NAND_CMD_PAGE_READ_TO_CACHE		0x13
+#define SPI_NAND_CMD_READ_FROM_CACHE		0x03
+#define SPI_NAND_CMD_READ_FROM_CACHE2		0x0B
+#define SPI_NAND_CMD_READ_FROM_CACHEX2		0x3B
+#define SPI_NAND_CMD_READ_FROM_CACHEX4		0x6B
+#define SPI_NAND_CMD_READ_FROM_DUAL_IO		0xBB
+#define SPI_NAND_CMD_READ_FROM_QUAL_IO		0xEB
+#define SPI_NAND_CMD_READ_ID			0x9F
+#define SPI_NAND_CMD_PROGRAM_LOAD		0x02
+#define SPI_NAND_CMD_PROGRAM_LOADX4		0x32
+#define SPI_NAND_CMD_PROGRAM_EXECUTE		0x10
+#define SPI_NAND_CMD_PROGRAM_LOAD_RANDOM_DATA		0x84
+#define SPI_NAND_CMD_PROGRAM_LOAD_RANDOM_DATAX4		0xC4
+#define SPI_NAND_CMD_PROGRAM_LOAD_RANDOM_DATA_QUAD_IO	0x72
+
+#define SPI_NAND_CMD_4K_SUBSECTOR_ERASE		0x20
+#define SPI_NAND_CMD_32K_SUBSECTOR_ERASE	0x52
+#define SPI_NAND_CMD_BLOCK_ERASE		0xD8
+#define SPI_NAND_CMD_RESET			0xFF
+
+#define SPI_NAND_FEATURE_ECC_CONFIG	(0x90)
+#define SPI_NAND_FEATURE_CFG_ECC_EN	(0x01 << 4)
+
+#define SPI_NAND_FEATURE_PROTECTION	(0xA0)
+#define FEATURE_PROTECTION_NONE			0
+#define SPI_NAND_PROTECTION_CMP			(0x01 << 1)
+#define SPI_NAND_PROTECTION_INV			(0x01 << 2)
+#define SPI_NAND_PROTECTION_BP0			(0x01 << 3)
+#define SPI_NAND_PROTECTION_BP1			(0x01 << 4)
+#define SPI_NAND_PROTECTION_BP2			(0x01 << 5)
+#define SPI_NAND_PROTECTION_BRWD		(0x01 << 7)
+
+
+#define SPI_NAND_FEATURE_FEATURE0	(0xB0)
+#define SPI_NAND_FEATURE0_QE			(0x01 << 0)
+#define SPI_NAND_FEATURE0_ECC_EN		(0x01 << 4)
+#define SPI_NAND_FEATURE0_OTP_EN		(0x01 << 6)
+#define SPI_NAND_FEATURE0_OTP_PRT		(0x01 << 7)
+
+#define SPI_NAND_FEATURE_STATUS0	(0xC0)
+#define SPI_NAND_STATUS0_OIP			(0x01 << 0)
+#define SPI_NAND_STATUS0_WEL			(0x01 << 1)
+#define SPI_NAND_STATUS0_E_FAIL			(0x01 << 2)
+#define SPI_NAND_STATUS0_P_FAIL			(0x01 << 3)
+#define SPI_NAND_STATUS0_ECCS0			(0x01 << 4)
+#define SPI_NAND_STATUS0_ECCS1			(0x01 << 5)
+
+#define SPI_NAND_FEATURE_FEATURE1	(0xD0)
+#define SPI_NAND_FEATURE1_DS_S0			(0x01 << 5)
+#define SPI_NAND_FEATURE1_DS_S1			(0x01 << 6)
+
+#define SPI_NAND_FEATURE_STATUS1	(0xF0)
+#define SPI_NAND_STATUS1_ECCSE0			(0x01 << 4)
+#define SPI_NAND_STATUS1_ECCSE1			(0x01 << 5)
+
+#define SPI_NAND_FLASH_BLOCK_SIZE             256
+#define SPI_NAND_TRAN_CSR_ADDR_BYTES_SHIFT    8
+#define SPI_NAND_MAX_FIFO_DEPTH               8
+
+/*1880V2 spi nand definitions */
+#define REG_SPI_NAND_TRX_CTRL0  0x000
+#define BIT_REG_TRX_START           (0x01 << 0)
+#define BIT_REG_TRX_SW_RST          (0x01 << 1)
+#define BIT_REG_TRX_RST_DONE        (0x01 << 16)
+
+#define REG_SPI_NAND_TRX_CTRL1  0x004
+#define BIT_REG_TRX_TIME_START      (0x01 << 0)
+#define BIT_REG_TRX_TIME_TA         (0x01 << 4)
+#define BIT_REG_TRX_TIME_END        (0x01 << 4)
+#define BIT_REG_TRX_TIME_WAIT       (0x01 << 8)
+#define BIT_REG_TRX_SCK_H           (0x01 << 16)
+#define BIT_REG_TRX_SCK_L           (0x01 << 20)
+#define BIT_REG_IO_CPOL             (0x01 << 24)
+#define BIT_REG_IO_CPHA             (0x01 << 25)
+
+
+#define REG_SPI_NAND_TRX_CTRL2  0x008
+#define BIT_REG_TRX_CMD_CONT_SIZE   (0x01 << 0)
+#define BIT_REG_TRX_DUMMY_SIZE      (0x01 << 4)
+#define BIT_REG_TRX_DATA_SIZE       (0x01 << 16)
+#define TRX_CMD_CONT_SIZE_SHIFT    (0)
+#define TRX_DUMMY_SIZE_SHIFT        (4)
+#define TRX_DATA_SIZE_SHIFT         (16)
+
+#define REG_SPI_NAND_TRX_CTRL3  0x00C
+#define BIT_REG_IO_SIZE_MODE        (0x01 << 0)
+#define SPI_NAND_CTRL3_IO_TYPE_X1_MODE      0
+#define SPI_NAND_CTRL3_IO_TYPE_X2_MODE      2
+#define SPI_NAND_CTRL3_IO_TYPE_X4_MODE      3
+
+#define BIT_REG_TRX_RW              (0x01 << 16) // 1 for write, 0 for read
+#define BIT_REG_TRX_DUMMY_HIZ       (0x01 << 17)
+#define BIT_REG_TRX_DMA_EN          (0x01 << 18)
+#define BIT_REG_RSP_CHK_EN          (0x01 << 19)
+
+
+#define REG_SPI_NAND_INT_EN         0x010
+#define BIT_REG_TRX_DONE_INT_EN         (0x01 << 0)
+#define BIT_REG_TRX_EXCEPTION_INT_EN    (0x01 << 1)
+#define BIT_REG_TX_PUSH_ERR_INT_EN      (0x01 << 4)
+#define BIT_REG_TX_POP_ERR_INT_EN       (0x01 << 5)
+#define BIT_REG_RX_PUSH_ERR_INT_EN      (0x01 << 6)
+#define BIT_REG_RX_POP_ERR_INT_EN       (0x01 << 7)
+#define BIT_REG_DMA_DONE_INT_EN         (0x01 << 8)
+#define BIT_REG_DMA_E_TERM_INT_EN       (0x01 << 9)
+#define BITS_SPI_NAND_INT_EN_ALL         (BIT_REG_TRX_DONE_INT_EN | BIT_REG_TRX_EXCEPTION_INT_EN \
+		| BIT_REG_TX_PUSH_ERR_INT_EN | BIT_REG_TX_POP_ERR_INT_EN \
+		| BIT_REG_RX_PUSH_ERR_INT_EN | BIT_REG_RX_POP_ERR_INT_EN \
+		| BIT_REG_DMA_DONE_INT_EN | BIT_REG_DMA_E_TERM_INT_EN)
+
+
+#define REG_SPI_NAND_INT_CLR        0x014
+#define BIT_REG_TRX_DONE_INT_CLR        (0x01 << 0)
+#define BIT_REG_TRX_EXCEPTION_INT_CLR   (0x01 << 1)
+#define BIT_REG_TX_PUSH_ERR_INT_CLR     (0x01 << 4)
+#define BIT_REG_TX_POP_ERR_INT_CLR      (0x01 << 5)
+#define BIT_REG_RX_PUSH_ERR_INT_CLR     (0x01 << 6)
+#define BIT_REG_RX_POP_ERR_INT_CLR      (0x01 << 7)
+#define BIT_REG_DMA_DONE_INT_CLR        (0x01 << 8)
+#define BIT_REG_DMA_E_TERM_INT_CLR      (0x01 << 9)
+#define BITS_SPI_NAND_INT_CLR_ALL         (BIT_REG_TRX_DONE_INT_CLR | BIT_REG_TRX_EXCEPTION_INT_CLR \
+		| BIT_REG_TX_PUSH_ERR_INT_CLR | BIT_REG_TX_POP_ERR_INT_CLR \
+		| BIT_REG_RX_PUSH_ERR_INT_CLR | BIT_REG_RX_POP_ERR_INT_CLR \
+		| BIT_REG_DMA_DONE_INT_CLR | BIT_REG_DMA_E_TERM_INT_CLR)
+
+
+#define REG_SPI_NAND_INT_MASK       0x018
+#define BIT_REG_TRX_DONE_INT_MSK        (0x01 << 0)
+#define BIT_REG_TRX_EXCEPTION_INT_MSK   (0x01 << 1)
+#define BIT_REG_TX_PUSH_ERR_INT_MSK     (0x01 << 4)
+#define BIT_REG_TX_POP_ERR_INT_MSK      (0x01 << 5)
+#define BIT_REG_RX_PUSH_ERR_INT_MSK     (0x01 << 6)
+#define BIT_REG_RX_POP_ERR_INT_MSK      (0x01 << 7)
+#define BIT_REG_DMA_DONE_INT_MSK        (0x01 << 8)
+#define BIT_REG_DMA_E_TERM_INT_MSK      (0x01 << 9)
+#define BITS_SPI_NAND_INT_MASK_ALL      (BIT_REG_TRX_DONE_INT_MSK | BIT_REG_TRX_EXCEPTION_INT_MSK \
+		| BIT_REG_TX_PUSH_ERR_INT_MSK | BIT_REG_TX_POP_ERR_INT_MSK \
+		| BIT_REG_RX_PUSH_ERR_INT_MSK | BIT_REG_RX_POP_ERR_INT_MSK \
+		| BIT_REG_DMA_DONE_INT_MSK | BIT_REG_DMA_E_TERM_INT_MSK)
+
+
+#define REG_SPI_NAND_INT            0x01C
+#define BIT_REG_TRX_DONE_INT            (0x01 << 0)
+#define BIT_REG_TRX_EXCEPTION_INT       (0x01 << 1)
+#define BIT_REG_TX_PUSH_ERR_INT         (0x01 << 4)
+#define BIT_REG_TX_POP_ERR_INT          (0x01 << 5)
+#define BIT_REG_RX_PUSH_ERR_INT         (0x01 << 6)
+#define BIT_REG_RX_POP_ERR_INT          (0x01 << 7)
+#define BIT_REG_DMA_DONE_INT            (0x01 << 8)
+#define BIT_REG_DMA_E_TERM_INT          (0x01 << 9)
+#define BITS_REG_TRX_DMA_DONE_INT       (BIT_REG_TRX_DONE_INT | BIT_REG_DMA_DONE_INT)
+
+
+#define REG_SPI_NAND_INT_RAW            0x020
+#define BIT_REG_TRX_DONE_INT_RAW            (0x01 << 0)
+#define BIT_REG_TRX_EXCEPTION_INT_RAW       (0x01 << 1)
+#define BIT_REG_TX_PUSH_ERR_INT_RAW         (0x01 << 4)
+#define BIT_REG_TX_POP_ERR_INT_RAW          (0x01 << 5)
+#define BIT_REG_RX_PUSH_ERR_INT_RAW         (0x01 << 6)
+#define BIT_REG_RX_POP_ERR_INT_RAW          (0x01 << 7)
+#define BIT_REG_DMA_DONE_INT_RAW            (0x01 << 8)
+#define BIT_REG_DMA_E_TERM_INT_RAW          (0x01 << 9)
+
+#define REG_SPI_NAND_BOOT_CTRL          0x024
+#define BIT_REG_BOOT_PRD                    (0x01 << 0)
+#define BIT_REG_RSP_DLY_SEL                 (0x01 << 8)
+#define BIT_REG_RSP_NEG_SEL                 (0x01 << 12)
+
+
+
+#define REG_SPI_NAND_IO_CTRL            0x028
+#define BIT_REG_CSN0_OUT_OW_EN              (0x01 << 0)
+#define BIT_REG_CSN1_OUT_OW_EN              (0x01 << 1)
+#define BIT_REG_SCK_OUT_OW_EN               (0x01 << 3)
+#define BIT_REG_MOSI_OUT_OW_EN              (0x01 << 4)
+#define BIT_REG_MISO_OUT_OW_EN              (0x01 << 5)
+#define BIT_REG_WPN_OUT_OW_EN               (0x01 << 6)
+#define BIT_REG_HOLDN_OUT_OW_EN             (0x01 << 7)
+#define BIT_REG_CSN0_OUT_OW_VAL             (0x01 << 8)
+#define BIT_REG_CSN1_OUT_OW_VAL             (0x01 << 9)
+#define BIT_REG_SCK_OUT_OW_VAL              (0x01 << 11)
+#define BIT_REG_MOSI_OUT_OW_VAL             (0x01 << 12)
+#define BIT_REG_MISO_OUT_OW_VAL             (0x01 << 13)
+#define BIT_REG_WPN_OUT_OW_VAL              (0x01 << 14)
+#define BIT_REG_HOLDN_OUT_OW_VAL            (0x01 << 15)
+#define BIT_REG_CSN0_OEN_OW_EN              (0x01 << 16)
+#define BIT_REG_CSN1_OEN_OW_EN              (0x01 << 17)
+#define BIT_REG_SCK_OEN_OW_EN               (0x01 << 19)
+#define BIT_REG_MOSI_OEN_OW_EN              (0x01 << 20)
+#define BIT_REG_MISO_OEN_OW_EN              (0x01 << 21)
+#define BIT_REG_WPN_OEN_OW_EN               (0x01 << 22)
+#define BIT_REG_HOLDN_OEN_OW_EN             (0x01 << 23)
+#define BIT_REG_CSN0_OEN_OW_VAL             (0x01 << 24)
+#define BIT_REG_CSN1_OEN_OW_VAL             (0x01 << 25)
+#define BIT_REG_SCK_OEN_OW_VAL              (0x01 << 27)
+#define BIT_REG_MOSI_OEN_OW_VAL             (0x01 << 28)
+#define BIT_REG_MISO_OEN_OW_VAL             (0x01 << 29)
+#define BIT_REG_WPN_OEN_OW_VAL              (0x01 << 30)
+#define BIT_REG_HOLDN_OEN_OW_VAL            (0x01 << 31)
+
+
+#define REG_SPI_NAND_IO_STATUS      0x02C
+#define BIT_REG_CSN0_VAL                (0x01 << 0)
+#define BIT_REG_CSN1_VAL                (0x01 << 1)
+#define BIT_REG_SCK_VAL                 (0x01 << 3)
+#define BIT_REG_MOSI_VAL                (0x01 << 4)
+#define BIT_REG_MISO_VAL                (0x01 << 5)
+#define BIT_REG_WPN_VAL                 (0x01 << 6)
+#define BIT_REG_HOLDN_VAL               (0x01 << 7)
+
+
+#define REG_SPI_NAND_TRX_CMD0       0x30
+#define BIT_REG_TRX_CMD_IDX             (0x01 << 0)
+#define BIT_REG_TRX_CMD_CONT0           (0x01 << 8)
+#define TRX_CMD_CONT0_SHIFT             (8)
+
+
+#define REG_SPI_NAND_TRX_CMD1           0x034
+//#define BIT_REG_TRX_CMD_CONT1               (0x01 << 0)
+
+
+#define REG_SPI_NAND_TRX_CS             0x3C
+#define BIT_REG_TRX_CS_SEL                  (0x01 << 0)
+
+
+#define REG_SPI_NAND_TRX_DMA_CTRL       0x40
+#define BIT_REG_DMA_WT_TH                   (0x01 << 0)
+#define BIT_REG_DMA_RD_TH                   (0x01 << 8)
+#define BIT_REG_DMA_REQ_SIZE                (0x01 << 16)
+#define BIT_REG_DMA_TX_EMPTY_SEL            (0x01 << 24)
+#define BIT_REG_DMA_RX_FULL_SEL             (0x01 << 25)
+
+
+#define REG_SPI_NAND_TRX_DMA_STATUS     0x44
+#define BIT_REG_DMA_REQ                     (0x01 << 0)
+#define BIT_REG_DMA_SINGLE                  (0x01 << 1)
+#define BIT_REG_DMA_LAST                    (0x01 << 2)
+#define BIT_REG_DMA_ACK                     (0x01 << 3)
+#define BIT_REG_DMA_FINISH                  (0x01 << 4)
+
+
+#define REG_SPI_NAND_TRX_DMA_SW         0x48
+#define BIT_REG_DMA_SW_MODE                 (0x01 << 0)
+#define BIT_REG_DMA_SW_ACK                  (0x01 << 8)
+#define BIT_REG_DMA_SW_FINISH               (0x01 << 9)
+
+
+#define REG_SPI_NAND_TX_FIFO_STATUS     0x50
+#define BIT_REG_TX_PUSH_EMPTY               (0x01 << 0)
+#define BIT_REG_TX_PUSH_AE                  (0x01 << 1)
+#define BIT_REG_TX_PUSH_HF                  (0x01 << 2)
+#define BIT_REG_TX_PUSH_AF                  (0x01 << 3)
+#define BIT_REG_TX_PUSH_FULL                (0x01 << 4)
+#define BIT_REG_TX_PUSH_ERROR               (0x01 << 5)
+#define BIT_REG_TX_PUSH_WORD_COUNT          (0x01 << 8)
+#define BIT_REG_TX_POP_EMPTY                (0x01 << 16)
+#define BIT_REG_TX_POP_AE                   (0x01 << 17)
+#define BIT_REG_TX_POP_HF                   (0x01 << 18)
+#define BIT_REG_TX_POP_AF                   (0x01 << 19)
+#define BIT_REG_TX_POP_FULL                 (0x01 << 20)
+#define BIT_REG_TX_POP_ERROR                (0x01 << 21)
+#define BIT_REG_TX_POP_WORD_COUNT           (0x01 << 24)
+
+
+#define REG_SPI_NAND_RX_FIFO_STATUS     0x54
+#define BIT_REG_RX_PUSH_EMPTY               (0x01 << 0)
+#define BIT_REG_RX_PUSH_AE                  (0x01 << 1)
+#define BIT_REG_RX_PUSH_HF                  (0x01 << 2)
+#define BIT_REG_RX_PUSH_AF                  (0x01 << 3)
+#define BIT_REG_RX_PUSH_FULL                (0x01 << 4)
+#define BIT_REG_RX_PUSH_ERROR               (0x01 << 5)
+#define BIT_REG_RX_PUSH_WORD_COUNT          (0x01 << 8)
+#define BIT_REG_RX_POP_EMPTY                (0x01 << 16)
+#define BIT_REG_RX_POP_AE                   (0x01 << 17)
+#define BIT_REG_RX_POP_HF                   (0x01 << 18)
+#define BIT_REG_RX_POP_AF                   (0x01 << 19)
+#define BIT_REG_RX_POP_FULL                 (0x01 << 20)
+#define BIT_REG_RX_POP_ERROR                (0x01 << 21)
+#define BIT_REG_RX_POP_WORD_COUNT           (0x01 << 24)
+
+#define REG_SPI_NAND_CMPLT_BYTE_CNT     0x58
+#define BIT_REG_CMPLT_CNT                   (0x01 << 0)
+
+#define REG_SPI_NAND_TX_DATA            0x60
+#define BIT_REG_TX_DATA                     (0x01 << 0)
+
+#define REG_SPI_NAND_RX_DATA            0x64
+#define BIT_REG_RX_DATA                     (0x01 << 0)
+
+#define REG_SPI_NAND_RSP_POLLING        0x68
+#define BIT_REG_RSP_EXP_MSK                 (0x01 << 0)
+#define BIT_REG_RSP_EXP_VAL                 (0x01 << 8)
+#define BIT_REG_RSP_WAIT_TIME_OFFSET        (16)
+
+#define REG_SPI_NAND_SPARE0             0x70
+#define BIT_REG_SPARE0                      (0x01 << 0)
+
+#define REG_SPI_NAND_SPARE1             0x74
+#define BIT_REG_SPARE1                      (0x01 << 0)
+
+#define REG_SPI_NAND_SPARE_RO           0x78
+#define BIT_REG_SPARE_RO                    (0x01 << 0)
+
+#define REG_SPI_NAND_TX_FIFO            0x800
+#define BIT_REG_TX_FIFO                     (0x01 << 0)
+
+#define REG_SPI_NAND_RX_FIFO            0xC00
+#define BIT_REG_RX_FIFO                     (0x01 << 0)
+
+#define SPI_NAND_ID_GD5F1GQ4U           0xD1C8  // SPI NAND 1Gbit 3.3V
+#define SPI_NAND_ID_GD5F1GQ4R           0xC1C8  // SPI NAND 1Gbit 1.8V
+
+#define SPI_NAND_BLOCK_RA_SHIFT         (6)     // RA<15:6>
+
+#define SPI_NAND_BLOCK_RA_NUM           (10)    // RA<15:6>
+#define SPI_NAND_PAGE_RA_NUM            (6)     // RA<5:0>
+
+#define SPI_NAND_PLANE_BIT_OFFSET	BIT(12)
+
+#define ENABLE_ECC	1
+#define DISABLE_ECC	0
+
+/*
+ * P_FAIL : Program Fail
+ *	This bit indicates that a program failure has occurred (P_FAIL set to 1). It will also be
+ *	set if the user attempts to program an invalid address or a protected region, including
+ *	the OTP area. This bit is cleared during the PROGRAM EXECUTE command
+ *	sequence or a RESET command (P_FAIL = 0).
+ *
+ * E_FAIL : Erase Fail
+ *	This bit indicates that an erase failure has occurred (E_FAIL set to 1). It will also be
+ *	set if the user attempts to erase a locked region. This bit is cleared (E_FAIL = 0) at the
+ *	start of the BLOCK ERASE command sequence or the RESET command.
+ *
+ * WEL : Write Enable  Latch
+ *	This bit indicates the current status of the write enable latch (WEL) and must be set
+ *	(WEL = 1), prior to issuing a PROGRAM EXECUTE or BLOCK ERASE command. It
+ *	is set by issuing the WRITE ENABLE command. WEL can also be disabled (WEL =
+ *	0), by issuing the WRITE DISABLE command.
+ *
+ * OIP : Operation In Progress
+ *	This bit is set (OIP = 1 ) when a PROGRAM EXECUTE, PAGE READ, BLOCK
+ *	ERASE, or RESET command is executing, indicating the device is busy. When the bit
+ *	is 0, the interface is in the ready state
+ *
+ * Register Addr. 7        6        5      4      3        2        1        0
+ * Status C0H     Reserved Reserved ECCS1  ECCS0  P_FAIL   E_FAIL   WEL      OIP
+ * Status F0H     Reserved Reserved ECCSE1 ECCSE0 Reserved Reserved Reserved Reserved
+ *
+ * ECCS1 ECCS0 ECCSE1 ECCSE0 Description
+ *   0     0     x      x     No bit errors were detected during the previous read algorithm.
+ *   0     1     0      0     Bit errors(<4) were detected and corrected.
+ *   0     1     0      1     Bit errors(=5) were detected and corrected.
+ *   0     1     1      0     Bit errors(=6) were detected and corrected.
+ *   0     1     1      1     Bit errors(=7) were detected and corrected.
+ *   1     0     x      x     Bit errors greater than ECC capability(8 bits) and not corrected
+ *   1     1     x      x     Bit errors reach ECC capability( 8 bits) and corrected
+ */
+
+#define ECC_NOERR  0
+#define ECC_CORR   1
+#define ECC_UNCORR 2
+
+struct spinand_cmd {
+	uint8_t		cmd;
+	uint32_t	n_cmd_cont;		/* Number of command content */
+	uint8_t		content[3];	/* Command content */
+	uint32_t	n_dummy;	/* Dummy use */
+	uint32_t	n_tx;		/* Number of tx bytes */
+	uint32_t	*tx_buf;	/* Tx buf */
+	uint32_t	n_rx;		/* Number of rx bytes */
+	uint32_t	*rx_buf;	/* Rx buf */
+	uint32_t	flags;		/* Flags */
+};
+
+
+/*****************************************************************************/
+#define SPI_NAND_MAX_PAGESIZE			4096
+#define SPI_NAND_MAX_OOBSIZE			256
+
+#define CVSNFC_BUFFER_LEN	(SPI_NAND_MAX_PAGESIZE + SPI_NAND_MAX_OOBSIZE)
+
+/* DMA address align with 32 bytes. */
+#define CVSNFC_DMA_ALIGN			32
+
+#define CVSNFC_CHIP_DELAY			25
+
+#define CVSNFC_ADDR_CYCLE_MASK			0x2
+
+/*****************************************************************************/
+struct cvsfc_cmd_option {
+	unsigned char chipselect;
+	unsigned char command;
+	unsigned char last_cmd;
+	unsigned char address_h;
+	unsigned int address_l;
+	unsigned int date_num;
+	unsigned short option;
+	unsigned short op_config;
+};
+
+#define MAX_PAGE_SIZE	(16 * 1024)
+
+//#define SPI_NAND_REG_BASE 0x4060000
+#define CONFIG_SYS_MAX_NAND_DEVICE		1
+#define CONFIG_SYS_NAND_MAX_CHIPS		1
+//#define CONFIG_SYS_NAND_BASE			SPI_NAND_REG_BASE
+#define CONFIG_CVSNFC_MAX_CHIP			CONFIG_SYS_MAX_NAND_DEVICE
+//#define CONFIG_CVSNFC_REG_BASE_ADDRESS		SPI_NAND_REG_BASE
+#define CONFIG_CVSNFC_MAX_CHIP			CONFIG_SYS_MAX_NAND_DEVICE
+
+struct cvsnfc_host;
+
+/* interrupt status */
+struct cvsnfc_irq_status_t {
+	/* Controller status  */
+	uint32_t status;
+};
+
+struct cvsnfc_platform_data {
+	bool (*dma_filter)(struct dma_chan *chan, void *filter_param);
+};
+
+struct nand_ecc_info {
+	uint8_t ecc_sr_addr;
+	uint8_t ecc_mbf_addr;
+	uint8_t read_ecc_opcode;
+	uint8_t ecc_bits;
+	uint8_t ecc_bit_shift;
+	uint8_t uncorr_val;
+	char *remap;
+};
+
+struct spi_nand_driver {
+	int (*wait_ready)(struct cvsnfc_host *host);
+	int (*write_enable)(struct cvsnfc_host *host);
+	int (*qe_enable)(struct cvsnfc_host *host);
+	int (*select_die)(struct cvsnfc_host *host, unsigned int id);
+	int (*set_ecc_detect_bits)(struct cvsnfc_host *host, unsigned int bits);
+};
+
+struct cvsnfc_chip_info {
+	struct nand_flash_dev nand_info;
+	struct nand_ecc_info ecc_info;
+	struct spi_nand_driver *driver;
+	unsigned int flags;
+};
+
+struct cvsnfc_host {
+	struct nand_chip nand;
+	struct cvsnfc_platform_data *pdata;
+	struct cvsnfc_op spi[CONFIG_CVSNFC_MAX_CHIP];
+	struct cvsfc_cmd_option cmd_option;
+
+	void __iomem *regbase;
+	void __iomem *dmabase;
+	void __iomem *topbase;
+
+	unsigned int offset;
+
+	struct device *dev;
+	int irq;
+	struct cvsnfc_irq_status_t irq_status;
+	struct cvsnfc_irq_status_t irq_mask;
+	struct completion complete;
+	spinlock_t irq_lock;
+
+	unsigned int flags;
+	struct cvsnfc_chip_info spi_nand;
+	unsigned int last_row_addr;
+
+	unsigned int early_bad_blk_id;
+	unsigned int early_bad_row_addr;
+
+	unsigned int max_banks;
+
+	unsigned int addr_cycle;
+	unsigned int addr_value[2];
+	unsigned int cache_addr_value[2];
+	unsigned int column;
+
+	unsigned int block_page_cnt;
+
+	unsigned int dma_oob;
+
+	unsigned int ecctype;
+	unsigned int pagesize;
+	unsigned int oobsize;
+	unsigned long diesize;
+	/* This is maybe an un-aligment address, only for malloc or free */
+	char *buforg;
+	dma_addr_t dma_buffer;
+
+	dma_addr_t			io_base_phy;
+	struct completion	comp;
+	struct dma_chan		*dma_chan_rx;
+	struct dma_chan		*dma_chan_tx;
+	uint32_t			dma_buf_len;
+	struct dma_slave_config	dma_slave_config;
+	struct scatterlist	sgl;
+	dma_addr_t			io_base_dma;
+	dma_cookie_t		cookie;
+
+	uint8_t				*data_buf;
+	uint8_t				*blk_max_err_bits_map;
+
+	int add_partition;
+
+	/* BOOTROM read two bytes to detect the bad block flag */
+	unsigned char *bbm;  /* nand bad block mark */
+	unsigned short *epm;  /* nand empty page mark */
+
+	unsigned int uc_er;
+
+	void (*set_system_clock)(struct spi_op_info *op, int clk_en);
+
+	void (*send_cmd_pageprog)(struct cvsnfc_host *host);
+	void (*send_cmd_status)(struct cvsnfc_host *host);
+	void (*send_cmd_readstart)(struct cvsnfc_host *host);
+	void (*send_cmd_erase)(struct cvsnfc_host *host);
+	void (*send_cmd_readid)(struct cvsnfc_host *host);
+	void (*send_cmd_reset)(struct cvsnfc_host *host);
+};
+
+/*****************************************************************************/
+#define cvsfc_read(_host, _reg) \
+	readl(_host->regbase + (_reg))
+
+#define cvsfc_readb(_host, _reg) \
+	readb(_host->regbase + (_reg))
+
+#define cvsfc_write(_host, _reg, _value) \
+	writel((_value), (_host->regbase + (_reg)))
+
+/*****************************************************************************/
+#define CVSNFC_WAIT_TIMEOUT 1000000
+
+#define CVSNFC_CMD_WAIT_CPU_FINISH(_host) do { \
+	unsigned int regval, timeout = CVSNFC_WAIT_TIMEOUT; \
+	do { \
+		regval = cvsfc_read((_host), REG_SPI_NAND_INT); \
+		--timeout; \
+	} while ((regval & BIT_REG_TRX_DONE_INT) == 0 && timeout); \
+	if (!timeout) \
+		pr_err("%s CVSNFC_CMD_WAIT_CPU_FINISH timeout! %d\n", __func__, __LINE__); \
+} while (0)
+
+#define CVSNFC_WAIT_DMA_FINISH(_host) do { \
+	unsigned int regval, timeout = CVSNFC_WAIT_TIMEOUT; \
+	do { \
+		regval = cvsfc_read((_host), REG_SPI_NAND_INT); \
+		--timeout; \
+	} while ((regval & BIT_REG_DMA_DONE_INT) == 0 && timeout); \
+	if (!timeout) \
+		pr_err("CVSNFC_WAIT_DMA_FINISH timeout!\n"); \
+} while (0)
+
+#define CVSNFC_CLEAR_INT(_host) do { \
+	unsigned int regval; \
+	regval = cvsfc_read((_host), REG_SPI_NAND_INT); \
+	cvsfc_write((_host), REG_SPI_NAND_INT, regval); \
+} while (0)
+
+/*****************************************************************************/
+#define CVSNFC_DMA_WAIT_INT_FINISH(_host) do { \
+	unsigned int regval, timeout = CVSNFC_WAIT_TIMEOUT; \
+	do { \
+		regval = cvsfc_read((_host), CVSNFC_INT); \
+		--timeout; \
+	} while ((!(regval & CVSNFC_INT_OP_DONE) && timeout)); \
+	if (!timeout) \
+		pr_err("CVSNFC_DMA_WAIT_INT_FINISH timeout!\n"); \
+} while (0)
+
+/*****************************************************************************/
+#define CVSNFC_DMA_WAIT_CPU_FINISH(_host) do { \
+	unsigned int regval, timeout = CVSNFC_WAIT_TIMEOUT; \
+	do { \
+		regval = cvsfc_read((_host), CVSNFC_OP_CTRL); \
+		--timeout; \
+	} while ((regval & CVSNFC_OP_CTRL_OP_READY) && timeout); \
+	if (!timeout) \
+		pr_err("CVSNFC_DMA_WAIT_CPU_FINISH timeout\n"); \
+} while (0)
+
+/*****************************************************************************/
+int cvsnfc100_host_init(struct cvsnfc_host *host);
+
+void cvsnfc100_nand_init(struct nand_chip *chip);
+
+int cvsnfc_init(struct cvsnfc_host *host);
+void cvsnfc_remove(struct cvsnfc_host *host);
+
+void cvsnfc_nand_init(struct nand_chip *chip);
+int cvsnfc_host_init(struct cvsnfc_host *host);
+int cvsnfc_send_nondata_cmd_and_wait(struct cvsnfc_host *host);
+void cvsnfc_spi_nand_init(struct cvsnfc_host *host);
+int cvsnfc_nand_setup_op(struct cvsnfc_host *host);
+/******************************************************************************/
+#endif /* CVSNFCH */
+
diff --git a/drivers/mtd/nand/raw/cvitek/cvsnfc_common.c b/drivers/mtd/nand/raw/cvitek/cvsnfc_common.c
new file mode 100644
index 000000000000..a6def21a8a42
--- /dev/null
+++ b/drivers/mtd/nand/raw/cvitek/cvsnfc_common.c
@@ -0,0 +1,165 @@
+#include <linux/mtd/nand.h>
+#include <cvsnfc_common.h>
+#include <match_table.h>
+
+/*****************************************************************************/
+struct nand_flash_dev *(*nand_get_spl_flash_type)(
+	struct mtd_info *mtd,
+	struct nand_chip *chip,
+	struct nand_dev_t *flash_dev_ex) = NULL;
+
+int (*nand_oob_resize)(struct mtd_info *mtd, struct nand_chip *chip,
+	struct nand_dev_t *flash_dev_ex) = NULL;
+
+/*****************************************************************************/
+#if defined(CONFIG_NAND_FLASH_CVSNFC)
+static struct match_type_str ecc2name[] = {
+	{NAND_ECC_0BIT,  "none"     },
+	{NAND_ECC_8BIT,  "4bit/512" },
+	{NAND_ECC_16BIT, "8bit/512" },
+	{NAND_ECC_24BIT, "24bit/1K" },
+	{NAND_ECC_28BIT, "28bit/1K" },
+	{NAND_ECC_40BIT, "40bit/1K" },
+	{NAND_ECC_42BIT, "42bit/1K" },
+	{NAND_ECC_64BIT, "64bit/1K" },
+};
+
+const char *nand_ecc_name(int type)
+{
+	return type2str(ecc2name, ARRAY_SIZE(ecc2name), type, "unknown");
+}
+
+/*****************************************************************************/
+static struct match_type_str page2name[] = {
+	{ NAND_PAGE_512B, "512" },
+	{ NAND_PAGE_2K,   "2K" },
+	{ NAND_PAGE_4K,   "4K" },
+	{ NAND_PAGE_8K,   "8K" },
+	{ NAND_PAGE_16K,  "16K" },
+	{ NAND_PAGE_32K,  "32K" },
+};
+
+const char *nand_page_name(int type)
+{
+	return type2str(page2name, ARRAY_SIZE(page2name), type, "unknown");
+}
+
+/*****************************************************************************/
+static struct match_reg_type page2size[] = {
+	{ _512B, NAND_PAGE_512B },
+	{ _2K, NAND_PAGE_2K },
+	{ _4K, NAND_PAGE_4K },
+	{ _8K, NAND_PAGE_8K },
+	{ _16K, NAND_PAGE_16K },
+	{ _32K, NAND_PAGE_32K },
+};
+
+int nandpage_size2type(int size)
+{
+	return reg2type(page2size, ARRAY_SIZE(page2size), size, NAND_PAGE_2K);
+}
+
+int nandpage_type2size(int size)
+{
+	return type2reg(page2size, ARRAY_SIZE(page2size), size, NAND_PAGE_2K);
+}
+#endif
+
+/*****************************************************************************/
+#define et_ecc_none	0x00
+#define et_ecc_4bit	0x02
+#define et_ecc_8bit	0x03
+#define et_ecc_24bit1k	0x04
+#define et_ecc_40bit1k	0x05
+#define et_ecc_64bit1k	0x06
+
+static struct match_reg_type ecc_yaffs_type_t[] = {
+	{et_ecc_none,		NAND_ECC_0BIT},
+	{et_ecc_4bit,		NAND_ECC_8BIT},
+	{et_ecc_8bit,		NAND_ECC_16BIT},
+	{et_ecc_24bit1k,	NAND_ECC_24BIT},
+	{et_ecc_40bit1k,	NAND_ECC_40BIT},
+	{et_ecc_64bit1k,	NAND_ECC_64BIT}
+};
+
+unsigned char match_ecc_type_to_yaffs(unsigned char type)
+{
+	return type2reg(ecc_yaffs_type_t, ARRAY_SIZE(ecc_yaffs_type_t), type,
+			et_ecc_4bit);
+}
+
+/*****************************************************************************/
+static struct match_t page_table[] = {
+	{NAND_PAGE_2K,	PAGE_SIZE_2KB,	"2K"},
+	{NAND_PAGE_4K,	PAGE_SIZE_4KB,	"4K"},
+	{NAND_PAGE_8K,	PAGE_SIZE_8KB,	"8K"},
+	{NAND_PAGE_16K,	PAGE_SIZE_16KB,	"16K"},
+};
+
+unsigned char match_page_reg_to_type(unsigned char reg)
+{
+	return match_reg_to_type(page_table, ARRAY_SIZE(page_table), reg,
+			NAND_PAGE_2K);
+}
+
+unsigned char match_page_type_to_reg(unsigned char type)
+{
+	return match_type_to_reg(page_table, ARRAY_SIZE(page_table), type,
+			PAGE_SIZE_2KB);
+}
+
+const char *match_page_type_to_str(unsigned char type)
+{
+	return match_type_to_data(page_table, ARRAY_SIZE(page_table), type,
+			"unknown");
+}
+
+/*****************************************************************************/
+static struct match_t ecc_table[] = {
+	{NAND_ECC_0BIT,		ECC_TYPE_0BIT,	"none"},
+	{NAND_ECC_8BIT,		ECC_TYPE_8BIT,	"4bit/512"},
+	{NAND_ECC_16BIT,	ECC_TYPE_16BIT,	"8bit/512"},
+	{NAND_ECC_24BIT,	ECC_TYPE_24BIT,	"24bit/1K"},
+	{NAND_ECC_28BIT,	ECC_TYPE_28BIT,	"28bit/1K"},
+	{NAND_ECC_40BIT,	ECC_TYPE_40BIT,	"40bit/1K"},
+	{NAND_ECC_64BIT,	ECC_TYPE_64BIT,	"64bit/1K"},
+};
+
+unsigned char match_ecc_reg_to_type(unsigned char reg)
+{
+	return match_reg_to_type(ecc_table, ARRAY_SIZE(ecc_table), reg,
+			NAND_ECC_8BIT);
+}
+
+unsigned char match_ecc_type_to_reg(unsigned char type)
+{
+	return match_type_to_reg(ecc_table, ARRAY_SIZE(ecc_table), type,
+			ECC_TYPE_8BIT);
+}
+
+const char *match_ecc_type_to_str(unsigned char type)
+{
+	return match_type_to_data(ecc_table, ARRAY_SIZE(ecc_table), type,
+			"unknown");
+}
+
+/*****************************************************************************/
+static struct match_t page_type_size_table[] = {
+	{NAND_PAGE_2K,	_2K,	NULL},
+	{NAND_PAGE_4K,	_4K,	NULL},
+	{NAND_PAGE_8K,	_8K,	NULL},
+	{NAND_PAGE_16K,	_16K,	NULL},
+};
+
+unsigned char match_page_size_to_type(unsigned int size)
+{
+	return match_reg_to_type(page_type_size_table,
+			ARRAY_SIZE(page_type_size_table), size, NAND_PAGE_2K);
+}
+
+unsigned int match_page_type_to_size(unsigned char type)
+{
+	return match_type_to_reg(page_type_size_table,
+			ARRAY_SIZE(page_type_size_table), type, _2K);
+}
+
diff --git a/drivers/mtd/nand/raw/cvitek/cvsnfc_common.h b/drivers/mtd/nand/raw/cvitek/cvsnfc_common.h
new file mode 100644
index 000000000000..e18704f7004e
--- /dev/null
+++ b/drivers/mtd/nand/raw/cvitek/cvsnfc_common.h
@@ -0,0 +1,159 @@
+#ifndef __CVSNFC_COMMON_H__
+#define __CVSNFC_COMMON_H__
+
+/*****************************************************************************/
+#include <linux/version.h>
+#include <cvmc_common.h>
+
+/*****************************************************************************/
+#define NAND_PAGE_512B                   0
+#define NAND_PAGE_1K                     1
+#define NAND_PAGE_2K                     2
+#define NAND_PAGE_4K                     3
+#define NAND_PAGE_8K                     4
+#define NAND_PAGE_16K                    5
+#define NAND_PAGE_32K                    6
+
+/*****************************************************************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+#define NAND_ECC_NONE                    0
+#endif
+#define NAND_ECC_0BIT                    0
+#define NAND_ECC_1BIT                    1
+#define NAND_ECC_1BIT_512                1
+#define NAND_ECC_4BIT                    2
+#define NAND_ECC_4BIT_512                2
+#define NAND_ECC_4BYTE                   2
+#define NAND_ECC_8BIT                    2
+#define NAND_ECC_8BIT_512                3
+#define NAND_ECC_8BYTE                   3
+#define NAND_ECC_13BIT                   4
+#define NAND_ECC_16BIT                   5
+#define NAND_ECC_18BIT                   6
+#define NAND_ECC_24BIT                   7
+#define NAND_ECC_27BIT                   8
+#define NAND_ECC_28BIT                   9
+#define NAND_ECC_32BIT                   10
+#define NAND_ECC_40BIT                   11
+#define NAND_ECC_41BIT                   12
+#define NAND_ECC_42BIT                   13
+#define NAND_ECC_48BIT                   14
+#define NAND_ECC_60BIT                   15
+#define NAND_ECC_64BIT                   16
+#define NAND_ECC_72BIT                   17
+#define NAND_ECC_80BIT                   18
+
+#define ERSTR_HARDWARE                   "Hardware configuration error."
+#define ERSTR_DRIVER                     "Driver does not support."
+
+#define DISABLE                          0
+#define ENABLE                           1
+
+#define IS_RANDOMIZER(_dev)        ((_dev)->flags & NAND_RANDOMIZER)
+#define IS_HW_AUTO(_dev)           ((_dev)->flags & NAND_HW_AUTO)
+#define IS_SYNCHRONOUS(_dev)       ((_dev)->flags & NAND_SYNCHRONOUS)
+#define IS_CONFIG_DONE(_dev)       ((_dev)->flags & NAND_CONFIG_DONE)
+#define IS_SYNCHRONOUS_BOOT(_dev)  ((_dev)->flags & NAND_SYNCHRONOUS_BOOT)
+
+#define NAND_PAGE_SHIFT                  9 /* 512 */
+
+
+#ifndef NAND_NEED_PLANE_BIT
+#define NAND_NEED_PLANE_BIT 0x20000000
+#endif
+#if defined(CONFIG_NAND_FLASH_CVSNFC)
+/*****************************************************************************/
+enum ecc_type {
+	et_ecc_none    = 0x00,
+	et_ecc_1bit    = 0x01,
+	et_ecc_4bit    = 0x02,
+	et_ecc_8bit    = 0x03,
+	et_ecc_24bit1k = 0x04,
+	et_ecc_40bit1k = 0x05,
+	et_ecc_64bit1k = 0x06,
+};
+
+enum page_type {
+	pt_pagesize_512   = 0x00,
+	pt_pagesize_2K    = 0x01,
+	pt_pagesize_4K    = 0x02,
+	pt_pagesize_8K    = 0x03,
+	pt_pagesize_16K   = 0x04,
+};
+
+struct nand_config_info {
+	unsigned int pagetype;
+	unsigned int ecctype;
+	unsigned int oobsize;
+	struct nand_ecclayout *layout;
+};
+#endif
+
+/*****************************************************************************/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+struct nand_flash_dev_ex {
+	struct nand_flash_dev flash_dev;
+
+	char *start_type;
+	unsigned char ids[8];
+	int oobsize;
+	int ecctype;
+
+//#define NAND_RANDOMIZER        0x01 /* nand chip need randomizer */
+#define NAND_HW_AUTO           0x02 /*controller support hardware auto config*/
+#define NAND_SYNCHRONOUS       0x04 /* nand chip support synchronous */
+#define NAND_ASYNCHRONOUS      0x08 /* nand chip support asynchronous */
+#define NAND_SYNCHRONOUS_BOOT  0x10 /* nand boot from synchronous mode */
+#define NAND_CONFIG_DONE       0x20 /* current controller config finish */
+	int flags;
+	int is_randomizer;
+#define NAND_RR_NONE                   0x00
+#define NAND_RR_HYNIX_BG_BDIE          0x10
+#define NAND_RR_HYNIX_BG_CDIE          0x11
+#define NAND_RR_HYNIX_CG_ADIE          0x12
+#define NAND_RR_MICRON                 0x20
+#define NAND_RR_SAMSUNG                0x30
+#define NAND_RR_TOSHIBA_24nm           0x40
+#define NAND_RR_TOSHIBA_19nm           0x41
+#define NAND_RR_MASK                   0xF0
+	int read_retry_type;
+
+	int hostver; /* host controller version. */
+};
+#endif
+/*****************************************************************************/
+const char *nand_ecc_name(int type);
+
+const char *nand_page_name(int type);
+
+int nandpage_size2type(int size);
+
+int nandpage_type2size(int size);
+
+/*****************************************************************************/
+extern int nand_get_ecctype(void);
+
+/*****************************************************************************/
+extern unsigned char match_ecc_type_to_yaffs(unsigned char type);
+
+extern unsigned char match_page_reg_to_type(unsigned char reg);
+
+extern unsigned char match_page_type_to_reg(unsigned char type);
+
+extern const char *match_page_type_to_str(unsigned char type);
+
+/*****************************************************************************/
+extern unsigned char match_ecc_reg_to_type(unsigned char reg);
+
+extern unsigned char match_ecc_type_to_reg(unsigned char type);
+
+extern const char *match_ecc_type_to_str(unsigned char type);
+
+/*****************************************************************************/
+extern unsigned char match_page_size_to_type(unsigned int size);
+
+extern unsigned int match_page_type_to_size(unsigned char type);
+
+#endif /* End of __CVSNFC_COMMON_H__ */
+
diff --git a/drivers/mtd/nand/raw/cvitek/cvsnfc_dt.c b/drivers/mtd/nand/raw/cvitek/cvsnfc_dt.c
new file mode 100644
index 000000000000..ff7720136070
--- /dev/null
+++ b/drivers/mtd/nand/raw/cvitek/cvsnfc_dt.c
@@ -0,0 +1,137 @@
+/*
+ * SPI NAND Flash Controller Device Driver for DT
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/slab.h>
+
+#include "cvsnfc.h"
+
+struct cvsnfc_dt {
+	struct cvsnfc_host cvsnfc;
+};
+
+static const struct of_device_id cvsnfc_dt_ids[] = {
+	{ .compatible = "cvitek,cv1835-spinf"},
+	{/* */}
+};
+
+MODULE_DEVICE_TABLE(of, cvsnfc_dt_ids);
+
+static int cvsnfc_dt_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct resource *res;
+	struct cvsnfc_dt *dt;
+	struct cvsnfc_host *host;
+	const struct of_device_id *of_id;
+	struct mtd_info *mtd;
+
+	of_id = of_match_device(cvsnfc_dt_ids, &pdev->dev);
+
+	if (of_id) {
+		pdev->id_entry = of_id->data;
+	} else {
+		pr_err("Failed to find the right device id.\n");
+		return -ENOMEM;
+	}
+
+	dt = devm_kzalloc(&pdev->dev, sizeof(*dt), GFP_KERNEL);
+	if (!dt)
+		return -ENOMEM;
+
+	host = &dt->cvsnfc;
+	host->dev = &pdev->dev;
+	mtd = nand_to_mtd(&host->nand);
+	mtd->priv = host;
+
+	mtd->dev.of_node = pdev->dev.of_node;
+	host->irq = platform_get_irq(pdev, 0);
+
+	if (host->irq < 0) {
+		dev_err(&pdev->dev, "no irq defined\n");
+		return host->irq;
+	}
+
+	dev_info(host->dev, "IRQ: nr %d\n", host->irq);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	host->regbase = devm_ioremap_resource(host->dev, res);
+
+	if (IS_ERR(host->regbase)) {
+		dev_err(&pdev->dev, "devm_ioremap_resource res 0 failed\n");
+		return PTR_ERR(host->regbase);
+	}
+
+	host->io_base_phy = res->start;
+	host->nand.priv = host;
+
+	cvsnfc_nand_init(&host->nand);
+
+	ret = cvsnfc_host_init(host);
+	if (ret) {
+		pr_err("cvsnfc dt probe error\n");
+		return ret;
+	}
+
+	ret = cvsnfc_scan_nand(host);
+	if (ret) {
+		pr_err("cvsnfc scan nand error\n");
+		return ret;
+	}
+
+	cvsnfc_spi_nand_init(host);
+	ret = mtd_device_register(mtd, NULL, 0);
+	if (ret) {
+		dev_err(host->dev, "mtd parse partition error\n");
+		nand_cleanup(&host->nand);
+		return ret;
+	}
+
+
+	platform_set_drvdata(pdev, dt);
+	return 0;
+}
+
+static int cvsnfc_dt_remove(struct platform_device *pdev)
+{
+	struct cvsnfc_dt *dt = platform_get_drvdata(pdev);
+
+	cvsnfc_remove(&dt->cvsnfc);
+
+	return 0;
+}
+
+static struct platform_driver cvsnfc_dt_driver = {
+	.probe          = cvsnfc_dt_probe,
+	.remove         = cvsnfc_dt_remove,
+	.driver         = {
+		.name   = "cvsnfc",
+		.of_match_table = cvsnfc_dt_ids,
+	},
+};
+
+module_platform_driver(cvsnfc_dt_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("CV");
+MODULE_DESCRIPTION("DT driver for SPI NAND flash controller");
+
diff --git a/drivers/mtd/nand/raw/cvitek/cvsnfc_spi_ids.c b/drivers/mtd/nand/raw/cvitek/cvsnfc_spi_ids.c
new file mode 100644
index 000000000000..100fe4947232
--- /dev/null
+++ b/drivers/mtd/nand/raw/cvitek/cvsnfc_spi_ids.c
@@ -0,0 +1,1456 @@
+#include "linux/types.h"
+#include <linux/mtd/rawnand.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include "cvsnfc_spi_ids.h"
+#include "cvsnfc.h"
+
+#define DEBUG_SPI_IDS 0
+
+struct nand_flash_dev *(*match_spi_nand_by_id)(struct mtd_info *mtd, unsigned char *id) = NULL;
+
+static int spi_nand_gd_qe_enable(struct cvsnfc_host *host);
+
+/* Read status[C0H]:[0]bit OIP, judge whether the device is busy or not */
+static int spi_general_wait_ready(struct cvsnfc_host *host);
+
+/* Send write enable command to SPI Nand, status[C0H]:[2]bit WEL must be set 1 */
+static int spi_general_write_enable(struct cvsnfc_host *host);
+
+static int spi_nand_winbond_select_die(struct cvsnfc_host *host, unsigned int id);
+
+static int spi_nand_tsb_set_ecc_detect_bits(struct cvsnfc_host *host, unsigned int bits);
+
+static struct spi_nand_driver  spi_nand_driver_general = {
+	.wait_ready   = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+};
+
+static struct spi_nand_driver  spi_nand_driver_gd = {
+	.wait_ready   = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.qe_enable = spi_nand_gd_qe_enable,
+};
+
+static struct spi_nand_driver  spi_nand_driver_winbond_multi = {
+	.wait_ready   = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.select_die = spi_nand_winbond_select_die,
+};
+
+static struct spi_nand_driver  spi_nand_driver_toshiba = {
+	.wait_ready   = spi_general_wait_ready,
+	.write_enable = spi_general_write_enable,
+	.set_ecc_detect_bits = spi_nand_tsb_set_ecc_detect_bits,
+};
+
+/*****************************************************************************/
+#define SPI_NAND_ID_TAB_VER		"1.4"
+
+/*
+ *	ECCS2	ECCS1	ECCS0	Description
+ *	0	0	0	No errors
+ *	0	0	1	1-3 bit error detected and corrected
+ *	0	1	0	9-bits or more than 9-bits errors detected and not corrected
+ *	0	1	1	4-6 bit error detected and corrected
+ *	1	0	1	7-8 bit error detected and corrected
+ *	1	0	0	Reserved
+ *	1	1	0	Reserved
+ *	1	1	1	Reserved
+ */
+
+/* only for 8 bit threshold */
+char ECC_3bits_remap[8] = {0, 1, -1, 4, 0xff, 7, 0xff, 0xff };
+
+/*
+ *	ECCS1	ECCS0	Description
+ *	0	0	No bit errors were detected in last page read
+ *	0	1	Bit errors were detected and corrected (<=7 bits)
+ *	1	0	Bit errors greater than ECC capability (8bits) and not corrected
+ *	1	1	Bit errors were detected and corrected,Bit errors count was equal
+ *				to the threshold bit count (8 bits)
+ */
+char ECC_XT26G11C[4] = {0, 1, -1, 8};
+
+/*
+ *	ECCS1	ECCS0	Description
+ *	0	0	0 bit error
+ *	0	1	1 ~ 4 bits error and been corrected.
+ *	1	0	More than 4-bit error and not corrected.
+ *	1	1	Reserved
+ */
+char ECC_2bits_remap[4] = {0, 1, -1, 0xff};
+
+/*
+ *	ECCS1	ECCS0	ECCSE1	ECCSE0	Description
+ *	0	0	x	x	No bit errors were detected during the previous read algorithm
+ *	0	1	0	0	Bit errors(=1) were detected and corrected
+ *	0	1	0	1	Bit errors (=2) were detected and corrected
+ *	0	1	1	0	Bit errors (=3) were detected and corrected
+ *	0	1	1	1	Bit errors (=4) were detected and corrected
+ *	1	1	x	x	Reserved
+ *	1	0	x	x	Bit errors greater than ECC capability(4 bits) and not corrected
+ *	ECCS0-ECCS1 is located in field 4-5 of addr of 0xC0
+ *	ECCSE0-ECCSE1 is located in field 4-5 of addr of 0xF0
+ */
+char ECC_GD_4bit_remap[16] = {0, 0, 0, 0, 1, 2, 3, 4, 0, 0, 0, 0, 0xff, 0xff, 0xff, 0xff};
+char ECC_GD_8bit_remap[16] = {0, 0, 0, 0, 4, 5, 6, 7, 0, 0, 0, 0, 8, 8, 8, 8};
+char ECC_HYF2G_remap[4] = {0, 1, -1, 14};
+
+struct cvsnfc_chip_info nand_flash_cvitek_supported_ids[] = {
+
+	{
+		{	.name = "F50L1G41LB",
+			.id = {0xC8, 0x01},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_128,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = 64,
+			{	.strength_ds = 1,
+				.step_ds = 512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = NULL
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = 0
+	},
+
+	{
+		{	.name = "F50L512M41A",
+			.id = {0xC8, 0x20},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_64,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_64,
+			{	.strength_ds = 1,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = NULL
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = 0
+	},
+
+	{
+		{	.name = "F50L1G41A",
+			.id = {0xC8, 0x21},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_128,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_64,
+			{	.strength_ds = 1,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = NULL
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = 0
+	},
+
+	{
+		{	.name = "F50L2G41KA",
+			.id = {0xC8, 0x41},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_256,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_128,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 3,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_3bits_remap
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = 0
+	},
+
+	{
+		{	.name = "F50L2G41XA",
+			.id = {0x2c, 0x24},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_256,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_128,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 3,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_3bits_remap
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = FLAGS_SET_PLANE_BIT
+	},
+
+	{
+		{	.name = "F50L4G41XB",
+			.id = {0x2c, 0x34},
+			.pagesize = SZ_4K,
+			.chipsize = SZ_512,
+			.erasesize = SZ_256K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_256,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 3,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_3bits_remap
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = 0
+	},
+
+	{
+		{	.name = "XT26G11C",
+			.id = {0x0b, 0x15},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_128,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_128,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_XT26G11C
+		},
+		.driver = &spi_nand_driver_gd,
+		.flags = 0
+	},
+
+	{
+		{	.name = "GD5F1GQ4UAYIG",
+			.id = {0xc8, 0xf1},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_128,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_128,
+			{	.strength_ds = 4,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0xf0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_GD_4bit_remap
+		},
+		.driver = &spi_nand_driver_gd,
+		.flags = 0
+	},
+
+	{
+		{	.name = "GD5F1GQ4UBYIG",
+			.id = {0xc8, 0xd1},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_128,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_128,
+			{ .strength_ds = 4,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0xf0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_GD_4bit_remap
+		},
+		.driver = &spi_nand_driver_gd,
+		.flags = 0
+	},
+
+	{
+		{	.name = "GD5F2GQ4UAYIG",
+			.id = {0xc8, 0xf2},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_256,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_128,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0xf0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_GD_8bit_remap
+		},
+		.driver = &spi_nand_driver_gd,
+		.flags = 0
+	},
+
+	{
+		{	.name = "GD5F2GQ4UBYIG",
+			.id = {0xc8, 0xd2},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_256,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_128,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0xf0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_GD_4bit_remap
+		},
+		.driver = &spi_nand_driver_gd,
+		.flags = 0
+	},
+
+	{
+		{	.name = "GD5F4GQ4UAYIG",
+			.id = {0xc8, 0xf4},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_512,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_64,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0xf0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_GD_8bit_remap
+		},
+		.driver = &spi_nand_driver_gd,
+		.flags = 0
+	},
+
+	{
+		{	.name = "GD5F4GQ4UBYIG",
+			.id = {0xc8, 0xd4},
+			.pagesize = SZ_4K,
+			.chipsize = SZ_512,
+			.erasesize = SZ_256K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_256,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0xf0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_GD_8bit_remap
+		},
+		.driver = &spi_nand_driver_gd,
+		.flags = 0
+	},
+
+	{
+		{	.name = "GD5F1GQ5UExxH",
+			.id = {0xc8, 0x31},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_128,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_64,
+			{	.strength_ds = 4,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0xf0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_GD_4bit_remap
+		},
+		.driver = &spi_nand_driver_gd,
+		.flags = 0
+	},
+
+	{
+		{	.name = "GD5F1GQ5UExxG",
+			.id = {0xc8, 0x51},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_128,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_64,
+			{	.strength_ds = 4,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0xf0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_GD_4bit_remap
+		},
+		.driver = &spi_nand_driver_gd,
+		.flags = 0
+	},
+
+	{
+		{	.name = "GD5F1GQ5UExxH",
+			.id = {0xc8, 0x31},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_128,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_64,
+			{	.strength_ds = 4,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0xf0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_GD_4bit_remap
+		},
+		.driver = &spi_nand_driver_gd,
+		.flags = 0
+	},
+
+	{
+		{	.name = "GD5F2GQ5UExxH",
+			.id = {0xc8, 0x52},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_256,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_64,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0xf0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_GD_8bit_remap
+		},
+		.driver = &spi_nand_driver_gd,
+		.flags = 0
+	},
+
+	{
+		{	.name = "GD5F4GQ6UEYIG",
+			.id = {0xC8, 0x55},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_512,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_128,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0xf0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_GD_8bit_remap
+		},
+		.driver = &spi_nand_driver_gd,
+		.flags = 0
+	},
+
+	/* GD GD5F1GM7 1Gbit */
+	{
+		{	.name = "GD5F1GM7UEYIG",
+			.id = {0xC8, 0x91},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_128,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_64,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0xf0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_GD_8bit_remap
+		},
+		.driver = &spi_nand_driver_gd,
+		.flags = 0
+	},
+	/* GD GD5F2GM7 2Gbit */
+	{
+		{	.name = "GD5F2GM7UEYIG",
+			.id = {0xC8, 0x92},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_256,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_64,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0xf0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_GD_8bit_remap
+		},
+		.driver = &spi_nand_driver_gd,
+		.flags = 0
+	},
+
+	{
+		{	.name = "MT29F1G01",
+			.id = {0x2c, 0x12},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_128,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_64,
+			{	.strength_ds = 4,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_2bits_remap
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = 0
+	},
+
+	{
+		{	.name = "MT29F2G01",
+			.id = {0x2c, 0x22},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_256,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_64,
+			{	.strength_ds = 4,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_2bits_remap
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = 0
+	},
+
+	{
+		{	.name = "MT29F4G01",
+			.id = {0x2c, 0x32},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_512,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_64,
+			{	.strength_ds = 4,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_2bits_remap
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = 0
+	},
+
+	{
+		{	.name = "MT29F1G01ABAFDWB",
+			.id = {0x2c, 0x14},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_128,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_128,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 3,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_3bits_remap
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = 0
+	},
+
+	{
+		{	.name = "MX35LF1GE4AB",
+			.id = {0xc2, 0x12},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_128,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_64,
+			{	.strength_ds = 4,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0,
+			.read_ecc_opcode = 0x7c,
+			.ecc_bits = 4,
+			.ecc_bit_shift = 0,
+			.uncorr_val = 0x2,
+			.remap = NULL
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = 0
+	},
+
+	{
+		{	.name = "MX35LF2GE4AB",
+			.id = {0xc2, 0x22},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_256,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_64,
+			{	.strength_ds = 4,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0,
+			.read_ecc_opcode = 0x7c,
+			.ecc_bits = 4,
+			.ecc_bit_shift = 0,
+			.uncorr_val = 0x2,
+			.remap = NULL
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = 0
+	},
+
+	{
+		{	.name = "MX35LF2GE4AD",
+			.id = {0xc2, 0x26, 0x03},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_256,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 3,
+			.oobsize = SZ_64,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0,
+			.read_ecc_opcode = 0x7c,
+			.ecc_bits = 4,
+			.ecc_bit_shift = 0,
+			.uncorr_val = 0x2,
+			.remap = NULL
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = 0
+	},
+
+	{
+		{	.name = "MX35LF4GE4AD",
+			.id = {0xc2, 0x37, 0x03},
+			.pagesize = SZ_4K,
+			.chipsize = SZ_512,
+			.erasesize = SZ_256K,
+			.options = 0,
+			.id_len = 3,
+			.oobsize = SZ_128,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0,
+			.read_ecc_opcode = 0x7c,
+			.ecc_bits = 4,
+			.ecc_bit_shift = 0,
+			.uncorr_val = 0x2,
+			.remap = NULL
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = 0
+	},
+
+	{
+		{	.name = "TC58CVG2S0HRAIJ",
+			.id = {0x98, 0xed, 0x51},
+			.pagesize = SZ_4K,
+			.chipsize = SZ_512,
+			.erasesize = SZ_256K,
+			.options = 0,
+			.id_len = 3,
+			.oobsize = SZ_128,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0x30,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 4,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 2,
+			.remap = NULL
+		},
+		.driver = &spi_nand_driver_toshiba,
+		.flags = 0
+	},
+
+	{
+		{	.name = "TC58CVG1S0HRAIJ",
+			.id = {0x98, 0xeb, 0x40},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_256,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 3,
+			.oobsize = SZ_128,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0x30,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 4,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = NULL
+		},
+		.driver = &spi_nand_driver_toshiba,
+		.flags = 0
+	},
+
+	{
+		{	.name = "TC58CVG1S3HxAI",
+			.id = {0x98, 0xcb},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_128,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_64,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0x30,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 4,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = NULL
+		},
+		.driver = &spi_nand_driver_toshiba,
+		.flags = 0
+	},
+
+	{
+		{	.name = "TC58CVG0S3HRAIJ",
+			.id = {0x98, 0xe2},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_128,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_64,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0x30,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 4,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = NULL
+		},
+		.driver = &spi_nand_driver_toshiba,
+		.flags = 0
+	},
+
+	{
+		{	.name = "W25N01GV",
+			.id = {0xef, 0xaa, 0x21},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_128,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 3,
+			.oobsize = SZ_64,
+			{	.strength_ds = 4,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_2bits_remap
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = 0
+	},
+
+	{
+		{	.name = "W25M02GV",
+			.id = {0xef, 0xab, 0x21},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_256,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 3,
+			.oobsize = SZ_64,
+			{	.strength_ds = 4,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_2bits_remap
+		},
+		.driver = &spi_nand_driver_winbond_multi,
+		.flags = FLAGS_NAND_HAS_TWO_DIE
+	},
+
+	/* Winbond W25N01KVxxIR 1Gbit */
+	{
+		{	.name = "W25N01KV",
+			.id = {0xef, 0xae, 0x21},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_128,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 3,
+			.oobsize = SZ_64,
+			{	.strength_ds = 4,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0x30,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 3,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = NULL
+		},
+		.driver = &spi_nand_driver_toshiba,
+		.flags = 0
+	},
+
+	{
+		{	.name = "W25N02KV",
+			.id = {0xef, 0xaa, 0x22},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_256,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 3,
+			.oobsize = SZ_64,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0x30,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 4,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = NULL
+		},
+		.driver = &spi_nand_driver_toshiba,
+		.flags = 0
+	},
+
+	{
+		{	.name = "W25N04KV",
+			.id = {0xef, 0xaa, 0x23},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_512,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 3,
+			.oobsize = SZ_128,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0x30,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 4,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = NULL
+		},
+		.driver = &spi_nand_driver_toshiba,
+		.flags = 0
+	},
+
+	{
+		{	.name = "DS35Q1GA-IB",
+			.id = {0xe5, 0x71},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_128,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_64,
+			{	.strength_ds = 4,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_2bits_remap
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = 0
+	},
+
+	/* DOSILICON DS35X1GBXXX 1Gbit */
+	{
+		{	.name = "DS35Q1GB-IB",
+			.id = {0xe5, 0xf1},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_128,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_128,
+			{	.strength_ds = 8,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 3,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_3bits_remap
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = 0
+	},
+
+	{
+		{	.name = "F35SQA512M",
+			.id = {0xcd, 0x70, 0x70},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_64,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 3,
+			.oobsize = SZ_64,
+			{	.strength_ds = 1,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0x0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = NULL
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = 0
+	},
+
+	{
+		{	.name = "F35SQA001G",
+			.id = {0xcd, 0x71, 0x71},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_128,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 3,
+			.oobsize = SZ_64,
+			{	.strength_ds = 1,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0x0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = NULL
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = 0
+	},
+
+	{
+		{	.name = "F35SQA002G",
+			.id = {0xCD, 0x72, 0x72},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_256,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_64,
+			{	.strength_ds = 1,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0x0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = NULL
+		},
+		.driver = &spi_nand_driver_general,
+		.flags = 0
+	},
+
+	{
+		{	.name = "HYF2GQ4UAACAE",
+			.id = {0xC9, 0x52},
+			.pagesize = SZ_2K,
+			.chipsize = SZ_256,
+			.erasesize = SZ_128K,
+			.options = 0,
+			.id_len = 2,
+			.oobsize = SZ_64,
+			{	.strength_ds = 14,
+				.step_ds = SZ_512
+			},
+		},
+
+		{	.ecc_sr_addr = 0xc0,
+			.ecc_mbf_addr = 0x0,
+			.read_ecc_opcode = 0,
+			.ecc_bits = 2,
+			.ecc_bit_shift = 4,
+			.uncorr_val = 0x2,
+			.remap = ECC_HYF2G_remap
+		},
+		.driver = &spi_nand_driver_gd,
+		.flags = 0
+	},
+
+	{ NULL }
+};
+
+/* addr: 0xb0
+ * qe bit shhift: 0
+ *
+ */
+static int spi_nand_gd_qe_enable(struct cvsnfc_host *host)
+{
+	unsigned int regval = 0;
+
+	spi_feature_op(host, GET_OP, FEATURE_ADDR, &regval);
+
+	regval |= FEATURE_QE_ENABLE;
+	spi_feature_op(host, SET_OP, FEATURE_ADDR, &regval);
+
+	/* check qe bit */
+	spi_feature_op(host, GET_OP, FEATURE_ADDR, &regval);
+	if (!(regval & FEATURE_ADDR))
+		return -1;
+
+	return 0;
+}
+
+/* Read status[C0H]:[0]bit OIP, judge whether the device is busy or not */
+static int spi_general_wait_ready(struct cvsnfc_host *host)
+{
+	unsigned int regval = 0;
+	unsigned int deadline = 0;
+
+	if (DEBUG_SPI_IDS)
+		pr_info("%s\n", __func__);
+
+	do {
+		spi_feature_op(host, GET_OP, STATUS_ADDR, &regval);
+		if (!(regval & STATUS_OIP_MASK)) {
+			if ((host->cmd_option.last_cmd == NAND_CMD_ERASE2)
+					&& (regval & STATUS_E_FAIL_MASK))
+				return regval;
+			if ((host->cmd_option.last_cmd == NAND_CMD_PAGEPROG)
+					&& (regval & STATUS_P_FAIL_MASK))
+				return regval;
+			return 0;
+		}
+		udelay(1);
+	} while (deadline++ < (40 << 20));
+
+	if (DEBUG_SPI_IDS)
+		pr_info("cvsnfc: wait ready timeout.\n");
+
+	return 1;
+}
+
+/* Send write enable command to SPI Nand, status[C0H]:[2]bit WEL must be set 1 */
+static int spi_general_write_enable(struct cvsnfc_host *host)
+{
+	unsigned int val = FEATURE_PROTECTION_NONE;
+
+	if (DEBUG_SPI_IDS)
+		pr_info("%s\n", __func__);
+
+	spi_feature_op(host, SET_OP, SPI_NAND_FEATURE_PROTECTION, &val);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, 0x0);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, 0x0);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CMD0, SPI_NAND_CMD_WREN);
+
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL0,
+			cvsfc_read(host, REG_SPI_NAND_TRX_CTRL0) |
+			BIT_REG_TRX_START);
+
+	cvsnfc_send_nondata_cmd_and_wait(host);
+
+	spi_feature_op(host, GET_OP, WRITE_ENABLE_STATUS_ADDR, &val);
+
+	if (!(val & STATUS_WEL_MASK)) {
+		pr_info("cvsnfc: write enable failed! val[%#x]\n", val);
+		return 1;
+	}
+
+	return 0;
+}
+
+static int spi_nand_winbond_select_die(struct cvsnfc_host *host, unsigned int id)
+{
+	static uint8_t pre_id = 0xff;
+
+	if (id == pre_id) {
+		return 0;
+	}
+
+	// Select Die
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL2, 0x1);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CTRL3, 0x0);
+	cvsfc_write(host, REG_SPI_NAND_TRX_CMD0,
+			(id << TRX_CMD_CONT0_SHIFT) | 0xC2);
+	// Wait for completion
+	cvsnfc_send_nondata_cmd_and_wait(host);
+	pre_id = id;
+	return 0;
+}
+
+static int spi_nand_tsb_set_ecc_detect_bits(struct cvsnfc_host *host, unsigned int bits)
+{
+	unsigned int val = 0;
+	unsigned int val_readback = 0;
+
+	pr_info("%s set detect bits 0x%x\n", __func__, bits);
+
+	spi_feature_op(host, GET_OP, 0x10, &val);
+	pr_info("orginal BFD %u\n", val);
+
+	val = (bits & 0xF) << 4;
+	spi_feature_op(host, SET_OP, 0x10, &val);
+
+	spi_feature_op(host, GET_OP, 0x10, &val_readback);
+	pr_info("new BFD %u\n", val_readback);
+
+	if (val != val_readback) {
+		pr_err("unable to set BFD val %u, val_readback %u\n", val, val_readback);
+		return -1;
+	}
+
+	return 0;
+}
+
+void cvsnfc_enable_ecc(struct cvsnfc_host *host, struct cvsnfc_chip_info *spi_nand, int op)
+{
+	uint32_t regval;
+	struct spi_nand_driver *spi = spi_nand->driver;
+
+	spi_feature_op(host, GET_OP, FEATURE_ADDR, &regval);
+	if (op)
+		regval &= FEATURE_ECC_ENABLE;
+	else
+		regval &= ~FEATURE_ECC_ENABLE;
+
+	spi_feature_op(host, SET_OP, FEATURE_ADDR, &regval);
+
+	spi->wait_ready(host);
+
+	spi_feature_op(host, GET_OP, FEATURE_ADDR, &regval);
+	if (regval & FEATURE_ECC_ENABLE)
+		pr_info("%s Internal ECC %s fail! val[%#x]\n",
+				__func__, (op ? "enable" : "disable"), regval);
+
+}
+
+void cvsnfc_disable_block_protect(struct cvsnfc_host *host,
+		struct cvsnfc_chip_info *spi_nand)
+{
+	uint32_t regval;
+	struct spi_nand_driver *spi = spi_nand->driver;
+
+	if (DEBUG_SPI_IDS)
+		pr_info("%s\n", __func__);
+
+	spi_feature_op(host, GET_OP, PROTECTION_ADDR, &regval);
+
+	if (ANY_BP_ENABLE(regval)) {
+		regval &= ~ALL_BP_MASK;
+		spi_feature_op(host, SET_OP, PROTECTION_ADDR, &regval);
+
+		spi->wait_ready(host);
+
+		spi_feature_op(host, GET_OP, PROTECTION_ADDR, &regval);
+		if (ANY_BP_ENABLE(regval))
+			pr_info("%s write protection disable fail! val[%#x]\n",
+					__func__, regval);
+	}
+
+}
+
+/*****************************************************************************/
+void cvsnfc_spi_nand_init(struct cvsnfc_host *host)
+{
+	int ecc_bits;
+
+	struct cvsnfc_chip_info *spi_nand = &host->spi_nand;
+	struct nand_flash_dev *info = &host->spi_nand.nand_info;
+	struct spi_nand_driver *driver = host->spi_nand.driver;
+
+	ecc_bits = info->ecc.strength_ds;
+	cvsnfc_disable_block_protect(host, spi_nand);
+#ifdef RW_DEBUG
+	cvsnfc_enable_ecc(host, spi_nand, 0);
+#endif
+
+	if (driver->set_ecc_detect_bits) {
+		if (driver->set_ecc_detect_bits(host, ecc_bits))
+			pr_info("set ecc detect bit failed, ecc bits: %d\n", ecc_bits);
+	}
+
+}
+
+extern uint8_t cvsnfc_read_byte(struct nand_chip *chip);
+int cvsnfc_scan_nand(struct cvsnfc_host *host)
+{
+	int i;
+	u8 *ids = host->nand.id.data;
+	struct cvsnfc_chip_info *spi_nand = nand_flash_cvitek_supported_ids;
+	uint32_t val;
+
+	host->send_cmd_reset(host);
+	udelay(500);
+	host->send_cmd_readid(host);
+	pr_info("SPI Nand ID Table Version %s\n", SPI_NAND_ID_TAB_VER);
+	val = cvsfc_read(host, REG_SPI_NAND_RX_DATA);
+	for (i = sizeof(val) - 1; i >= 0 ; i--) {
+		ids[i] = (val >> i * 8) & 0xff;
+		pr_debug("id%d:0x%x\n", i, ids[i]);
+	}
+
+	for (; spi_nand; spi_nand++) {
+		if (!memcmp(ids, spi_nand->nand_info.id, spi_nand->nand_info.id_len)) {
+			host->pagesize = spi_nand->nand_info.pagesize;
+			host->oobsize = spi_nand->nand_info.oobsize;
+			host->dma_oob = host->dma_buffer + host->pagesize;
+			// The number of pages per block
+			host->block_page_cnt = spi_nand->nand_info.erasesize / spi_nand->nand_info.pagesize;
+			host->flags = spi_nand->flags;
+			if (spi_nand->flags & FLAGS_NAND_HAS_TWO_DIE)
+				/* chipsize / 2 * 1024 * 1024 */
+				host->diesize = spi_nand->nand_info.chipsize << 19;
+			else
+				host->diesize = 0;
+
+			memcpy(&host->spi_nand, spi_nand, sizeof(struct cvsnfc_chip_info));
+			return nand_scan_with_ids(&host->nand, 1, &spi_nand->nand_info);
+		}
+	}
+	pr_info("can not scan spi nand!\n");
+	return -1;
+}
+
diff --git a/drivers/mtd/nand/raw/cvitek/cvsnfc_spi_ids.h b/drivers/mtd/nand/raw/cvitek/cvsnfc_spi_ids.h
new file mode 100644
index 000000000000..a74e849f126a
--- /dev/null
+++ b/drivers/mtd/nand/raw/cvitek/cvsnfc_spi_ids.h
@@ -0,0 +1,120 @@
+#ifndef CVSNFC_SPI_IDSH
+#define CVSNFC_SPI_IDSH
+
+/*****************************************************************************/
+#define INFINITE			(0xFFFFFFFF)
+
+#define DEFAULT_ID_LEN			2
+#define MAX_ID_LEN			8
+#define MAX_SPI_NAND_OP			8
+
+#define BBP_LAST_PAGE			0x01
+#define BBP_FIRST_PAGE			0x02
+
+/*****************************************************************************/
+#define SPI_IF_READ_STD			(0x01)
+#define SPI_IF_READ_FAST		(0x02)
+#define SPI_IF_READ_DUAL		(0x04)
+#define SPI_IF_READ_DUAL_ADDR		(0x08)
+#define SPI_IF_READ_QUAD		(0x10)
+#define SPI_IF_READ_QUAD_ADDR		(0x20)
+
+#define SPI_IF_WRITE_STD		(0x01)
+#define SPI_IF_WRITE_DUAL		(0x02)
+#define SPI_IF_WRITE_DUAL_ADDR		(0x04)
+#define SPI_IF_WRITE_QUAD		(0x08)
+#define SPI_IF_WRITE_QUAD_ADDR		(0x10)
+
+#define SPI_IF_ERASE_SECTOR_128K	(0x08)  /* 128K */
+#define SPI_IF_ERASE_SECTOR_256K	(0x10)  /* 256K */
+
+/******************************************************************************/
+#define CVSNFC_SUPPORT_READ		(SPI_IF_READ_STD \
+		| SPI_IF_READ_FAST \
+		| SPI_IF_READ_DUAL \
+		| SPI_IF_READ_DUAL_ADDR \
+		| SPI_IF_READ_QUAD \
+		| SPI_IF_READ_QUAD_ADDR)
+
+#define CVSNFC_SUPPORT_WRITE		(SPI_IF_WRITE_STD | SPI_IF_WRITE_QUAD)
+
+#define CVSNFC_SUPPORT_MAX_DUMMY	8
+
+#define SPI_NAND_READ			0
+#define SPI_NAND_WRITE			1
+
+#define CVSNFC_IFCYCLE_STD				0
+#define CVSNFC_IFCYCLE_DUAL				1
+#define CVSNFC_IFCYCLE_DUAL_ADDR			2
+#define CVSNFC_IFCYCLE_QUAD				3
+#define CVSNFC_IFCYCLE_QUAD_ADDR			4
+
+/*****************************************************************************/
+#define SPI_CMD_WREN			0x06   /* Write Enable */
+#define SPI_CMD_WRDI			0x04   /* Write Disable */
+
+#define SPI_CMD_GET_FEATURES		0x0F   /* Get Features */
+#define SPI_CMD_SET_FEATURE		0x1F   /* Set Feature */
+
+#define SPI_CMD_PAGE_READ		0x13   /* Page Read to Cache */
+#define SPI_CMD_READ_STD	0x03   /* Read From Cache at Standard Speed */
+#define SPI_CMD_READ_FAST	0x0B   /* Read From Cache at Higher Speed */
+#define SPI_CMD_READ_DUAL	0x3B   /* Read From Cache at Dual Output */
+#define SPI_CMD_READ_QUAD	0x6B   /* Read From Cache at Quad Output */
+#define SPI_CMD_READ_DUAL_ADDR	0xBB   /* Read From Cache at Dual I/O */
+#define SPI_CMD_READ_QUAD_ADDR	0xEB   /* Read From Cache at Quad I/O */
+
+#define SPI_CMD_RDID			0x9F   /* Read Identification */
+
+#define SPI_CMD_WRITE_STD	0x02   /* Page Load at Standard Input */
+#define SPI_CMD_WRITE_QUAD	0x32   /* Page Load at Quad Input */
+
+#define SPI_CMD_SE_128K			0xD8   /* 128KB sector Erase */
+#define SPI_CMD_SE_256K			0xD8   /* 256KB sector Erase */
+
+#define SPI_CMD_RESET			0xff   /* Reset the device */
+
+/*****************************************************************************/
+/* SPI operation information */
+struct spi_op_info {
+	unsigned char  iftype;
+	unsigned char  cmd;
+	unsigned char  dummy;
+	unsigned int   size;
+	unsigned int   clock;
+};
+
+struct spi_nand_driver;
+
+struct cvsnfc_op {
+	void *host;
+	struct spi_nand_driver *driver;
+	struct spi_op_info  read[1];
+	struct spi_op_info  write[1];
+	struct spi_op_info  erase[MAX_SPI_NAND_OP];
+};
+
+#define FLAGS_SET_PLANE_BIT			BIT(0)
+#define FLAGS_ONLY_ONEBIT_MODE_BIT		BIT(1)
+#define FLAGS_CONTORL_WP_BIT			BIT(2)
+#define FLAGS_SUPPORT_W_TWICE_DEBUG		BIT(3)
+#define FLAGS_SUPPORT_EARLY_BAD_BLOCK		BIT(4)
+#define FLAGS_SUPPORT_READ_ECCSR		BIT(5)
+#define FLAGS_SUPPORT_4BIT_READ			BIT(6)
+#define FLAGS_SUPPORT_4BIT_WRITE		BIT(7)
+#define FLAGS_ECC_STATUS_REMAP1			BIT(8)
+#define FLAGS_NAND_NO_QE			BIT(9)
+#define FLAGS_NAND_HAS_TWO_DIE			BIT(10)
+
+#define FLAGS_FOUND_EARLY_BAD_BLOCK	BIT(31)
+
+
+/*****************************************************************************/
+struct cvsnfc_host;
+int cvsnfc_scan_nand(struct cvsnfc_host *host);
+void cvsnfc_get_best_clock(unsigned int *clock);
+void spi_feature_op(struct cvsnfc_host *host, int op, int addr, unsigned int *val);
+
+/******************************************************************************/
+
+#endif /* CVSNFC_SPI_IDSH */
diff --git a/drivers/mtd/nand/raw/cvitek/match_table.c b/drivers/mtd/nand/raw/cvitek/match_table.c
new file mode 100644
index 000000000000..3d10293ad648
--- /dev/null
+++ b/drivers/mtd/nand/raw/cvitek/match_table.c
@@ -0,0 +1,88 @@
+#include <linux/string.h>
+#include <match_table.h>
+
+/*****************************************************************************/
+int reg2type(struct match_reg_type *table, int length, int reg, int def)
+{
+	while (length-- > 0) {
+		if (table->reg == reg)
+			return table->type;
+		table++;
+	}
+	return def;
+}
+
+int type2reg(struct match_reg_type *table, int length, int type, int def)
+{
+	while (length-- > 0) {
+		if (table->type == type)
+			return table->reg;
+		table++;
+	}
+	return def;
+}
+
+int str2type(struct match_type_str *table, int length, const char *str,
+	     int size, int def)
+{
+	while (length-- > 0) {
+		if (!strncmp(table->str, str, size))
+			return table->type;
+		table++;
+	}
+	return def;
+}
+
+const char *type2str(struct match_type_str *table, int length, int type,
+		     const char *def)
+{
+	while (length-- > 0) {
+		if (table->type == type)
+			return table->str;
+		table++;
+	}
+	return def;
+}
+
+int match_reg_to_type(struct match_t *table, int nr_table, int reg, int def)
+{
+	while (nr_table-- > 0) {
+		if (table->reg == reg)
+			return table->type;
+		table++;
+	}
+	return def;
+}
+
+int match_type_to_reg(struct match_t *table, int nr_table, int type, int def)
+{
+	while (nr_table-- > 0) {
+		if (table->type == type)
+			return table->reg;
+		table++;
+	}
+	return def;
+}
+
+int match_data_to_type(struct match_t *table, int nr_table, char *data,
+		int size, int def)
+{
+	while (nr_table-- > 0) {
+		if (!memcmp(table->data, data, size))
+			return table->type;
+		table++;
+	}
+	return def;
+}
+
+void *match_type_to_data(struct match_t *table, int nr_table, int type,
+			 void *def)
+{
+	while (nr_table-- > 0) {
+		if (table->type == type)
+			return table->data;
+		table++;
+	}
+	return def;
+}
+
diff --git a/drivers/mtd/nand/raw/cvitek/match_table.h b/drivers/mtd/nand/raw/cvitek/match_table.h
new file mode 100644
index 000000000000..b41a6b6c32f8
--- /dev/null
+++ b/drivers/mtd/nand/raw/cvitek/match_table.h
@@ -0,0 +1,49 @@
+#ifndef __MATCH_TABLE_H__
+#define __MATCH_TABLE_H__
+
+/*****************************************************************************/
+struct match_reg_type {
+	int reg;
+	int type;
+};
+
+struct match_type_str {
+	int type;
+	const char *str;
+};
+
+struct match_t {
+	int type;
+	int reg;
+	void *data;
+};
+
+/*****************************************************************************/
+#define MATCH_SET_TYPE_REG(_type, _reg)   {(_type), (_reg), (void *)0}
+#define MATCH_SET_TYPE_DATA(_type, _data) {(_type), 0, (void *)(_data)}
+#define MATCH_SET(_type, _reg, _data)     {(_type), (_reg), (void *)(_data)}
+
+/*****************************************************************************/
+int reg2type(struct match_reg_type *table, int length, int reg, int def);
+
+int type2reg(struct match_reg_type *table, int length, int type, int def);
+
+int str2type(struct match_type_str *table, int length, const char *str,
+	     int size, int def);
+
+const char *type2str(struct match_type_str *table, int length, int type,
+		     const char *def);
+
+int match_reg_to_type(struct match_t *table, int nr_table, int reg, int def);
+
+int match_type_to_reg(struct match_t *table, int nr_table, int type, int def);
+
+int match_data_to_type(struct match_t *table, int nr_table, char *data,
+		int size, int def);
+
+void *match_type_to_data(struct match_t *table, int nr_table, int type,
+			 void *def);
+
+/*****************************************************************************/
+
+#endif /* End of __MATCH_TABLE_H__ */
diff --git a/drivers/mtd/nand/raw/nand_base.c b/drivers/mtd/nand/raw/nand_base.c
index c41c0ff611b1..f561fc6bc5bd 100644
--- a/drivers/mtd/nand/raw/nand_base.c
+++ b/drivers/mtd/nand/raw/nand_base.c
@@ -4703,6 +4703,7 @@ static int nand_detect(struct nand_chip *chip, struct nand_flash_dev *type)
 	memorg->planes_per_lun = 1;
 	memorg->luns_per_target = 1;
 
+#ifndef CONFIG_MTD_NAND_CVSNFC
 	/*
 	 * Reset the chip, required by some chips (e.g. Micron MT29FxGxxxxx)
 	 * after power-up.
@@ -4741,6 +4742,10 @@ static int nand_detect(struct nand_chip *chip, struct nand_flash_dev *type)
 		return -ENODEV;
 	}
 
+#endif
+	memcpy(chip->id.data, type->id, NAND_MAX_ID_LEN);
+	maf_id = chip->id.data[0];
+	dev_id = chip->id.data[1];
 	chip->id.len = nand_id_len(id_data, ARRAY_SIZE(chip->id.data));
 
 	/* Try to identify manufacturer */
@@ -5643,6 +5648,7 @@ static int nand_scan_tail(struct nand_chip *chip)
 			break;
 		case 64:
 		case 128:
+		case 256:
 			mtd_set_ooblayout(mtd,
 					  nand_get_large_page_hamming_ooblayout());
 			break;
diff --git a/drivers/mtd/spi-nor/Makefile b/drivers/mtd/spi-nor/Makefile
index 653923896205..6aed429a7683 100644
--- a/drivers/mtd/spi-nor/Makefile
+++ b/drivers/mtd/spi-nor/Makefile
@@ -15,6 +15,7 @@ spi-nor-objs			+= micron-st.o
 spi-nor-objs			+= spansion.o
 spi-nor-objs			+= sst.o
 spi-nor-objs			+= winbond.o
+spi-nor-objs			+= cvitek_support_list.o
 spi-nor-objs			+= xilinx.o
 spi-nor-objs			+= xmc.o
 obj-$(CONFIG_MTD_SPI_NOR)	+= spi-nor.o
diff --git a/drivers/mtd/spi-nor/controllers/Kconfig b/drivers/mtd/spi-nor/controllers/Kconfig
index 5c0e0ec2e6d1..61cf04f7b596 100644
--- a/drivers/mtd/spi-nor/controllers/Kconfig
+++ b/drivers/mtd/spi-nor/controllers/Kconfig
@@ -27,6 +27,16 @@ config SPI_NXP_SPIFI
 	  Flash. Enable this option if you have a device with a SPIFI
 	  controller and want to access the Flash as a mtd device.
 
+config SPI_CVI_SPIF
+     tristate "Cvitek SPI Flash Interface (SPIF)"
+     depends on HAS_IOMEM
+     help
+       Enable support for the Cvitek SPI Flash controller.
+
+       SPIF is a specialized controller for connecting serial SPI
+       Flash. Enable this option if you have a device with a SPIF
+       controller and want to access the Flash as a mtd device.
+
 config SPI_INTEL_SPI
 	tristate
 
diff --git a/drivers/mtd/spi-nor/controllers/Makefile b/drivers/mtd/spi-nor/controllers/Makefile
index e7abba491d98..d97457902692 100644
--- a/drivers/mtd/spi-nor/controllers/Makefile
+++ b/drivers/mtd/spi-nor/controllers/Makefile
@@ -5,3 +5,4 @@ obj-$(CONFIG_SPI_NXP_SPIFI)	+= nxp-spifi.o
 obj-$(CONFIG_SPI_INTEL_SPI)	+= intel-spi.o
 obj-$(CONFIG_SPI_INTEL_SPI_PCI)	+= intel-spi-pci.o
 obj-$(CONFIG_SPI_INTEL_SPI_PLATFORM)	+= intel-spi-platform.o
+obj-$(CONFIG_SPI_CVI_SPIF)  += cvi-spif.o
diff --git a/drivers/mtd/spi-nor/controllers/cvi-spif.c b/drivers/mtd/spi-nor/controllers/cvi-spif.c
new file mode 100644
index 000000000000..b13c8351c023
--- /dev/null
+++ b/drivers/mtd/spi-nor/controllers/cvi-spif.c
@@ -0,0 +1,849 @@
+/*
+ * SPI-NOR driver for Cvitek SPI Flash Controller
+ *
+ * Copyright (C) 2015 Joachim Eastwood <manabian@gmail.com>
+ *
+ * Based on Freescale QuadSPI driver:
+ * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/spi-nor.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/iopoll.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/mtd/spi-nor.h>
+
+/* SPINOR DMMR read mode uses SYSDMA */
+#define DMMR_DMA_MODE
+
+/* Cvitek SPIF registers, bits and macros */
+#define SPI_FLASH_BLOCK_SIZE             256
+#define SPI_TRAN_CSR_ADDR_BYTES_SHIFT    8
+#define SPI_MAX_FIFO_DEPTH               8
+
+/* register definitions */
+#define REG_SPI_CTRL                     0x000
+#define REG_SPI_CE_CTRL                  0x004
+#define REG_SPI_DLY_CTRL                 0x008
+#define REG_SPI_DMMR                     0x00C
+#define REG_SPI_TRAN_CSR                 0x010
+#define REG_SPI_TRAN_NUM                 0x014
+#define REG_SPI_FIFO_PORT                0x018
+#define REG_SPI_FIFO_PT                  0x020
+#define REG_SPI_INT_STS                  0x028
+#define REG_SPI_INT_EN                   0x02C
+
+/* bit definition */
+#define BIT_SPI_CTRL_CPHA                    (0x01 << 12)
+#define BIT_SPI_CTRL_CPOL                    (0x01 << 13)
+#define BIT_SPI_CTRL_HOLD_OL                 (0x01 << 14)
+#define BIT_SPI_CTRL_WP_OL                   (0x01 << 15)
+#define BIT_SPI_CTRL_LSBF                    (0x01 << 20)
+#define BIT_SPI_CTRL_SRST                    (0x01 << 21)
+#define BIT_SPI_CTRL_SCK_DIV_SHIFT           0
+#define BIT_SPI_CTRL_FRAME_LEN_SHIFT         16
+#define BIT_SPI_CTRL_SCK_DIV_MASK            0x7FF
+
+#define BIT_SPI_CE_CTRL_CEMANUAL             (0x01 << 0)
+#define BIT_SPI_CE_CTRL_CEMANUAL_EN          (0x01 << 1)
+
+#define BIT_SPI_CTRL_FM_INTVL_SHIFT          0
+#define BIT_SPI_CTRL_CET_SHIFT               8
+
+#define BIT_SPI_DMMR_EN                      (0x01 << 0)
+
+#define BIT_SPI_TRAN_CSR_TRAN_MODE_RX        (0x01 << 0)
+#define BIT_SPI_TRAN_CSR_TRAN_MODE_TX        (0x01 << 1)
+#define BIT_SPI_TRAN_CSR_CNTNS_READ          (0x01 << 2)
+#define BIT_SPI_TRAN_CSR_FAST_MODE           (0x01 << 3)
+#define BIT_SPI_TRAN_CSR_BUS_WIDTH_1_BIT     (0x0 << 4)
+#define BIT_SPI_TRAN_CSR_BUS_WIDTH_2_BIT     (0x01 << 4)
+#define BIT_SPI_TRAN_CSR_BUS_WIDTH_4_BIT     (0x02 << 4)
+#define BIT_SPI_TRAN_CSR_DMA_EN              (0x01 << 6)
+#define BIT_SPI_TRAN_CSR_MISO_LEVEL          (0x01 << 7)
+#define BIT_SPI_TRAN_CSR_ADDR_BYTES_NO_ADDR  (0x0 << 8)
+#define BIT_SPI_TRAN_CSR_WITH_CMD            (0x01 << 11)
+#define BIT_SPI_TRAN_CSR_FIFO_TRG_LVL_1_BYTE (0x0 << 12)
+#define BIT_SPI_TRAN_CSR_FIFO_TRG_LVL_2_BYTE (0x01 << 12)
+#define BIT_SPI_TRAN_CSR_FIFO_TRG_LVL_4_BYTE (0x02 << 12)
+#define BIT_SPI_TRAN_CSR_FIFO_TRG_LVL_8_BYTE (0x03 << 12)
+#define BIT_SPI_TRAN_CSR_GO_BUSY             (0x01 << 15)
+#define SPI_TRAN_CSR_DUMMY_MASK              (0xf << 16)
+
+#define BIT_SPI_TRAN_CSR_TRAN_MODE_MASK      0x0003
+#define BIT_SPI_TRAN_CSR_ADDR_BYTES_MASK     0x0700
+#define BIT_SPI_TRAN_CSR_FIFO_TRG_LVL_MASK   0x3000
+#define BIT_SPI_TRAN_CSR_BUS_WIDTH_MASK     (0x3 << 4)
+
+#define BIT_SPI_INT_TRAN_DONE                (0x01 << 0)
+#define BIT_SPI_INT_RD_FIFO                  (0x01 << 2)
+#define BIT_SPI_INT_WR_FIFO                  (0x01 << 3)
+#define BIT_SPI_INT_RX_FRAME                 (0x01 << 4)
+#define BIT_SPI_INT_TX_FRAME                 (0x01 << 5)
+
+#define BIT_SPI_INT_TRAN_DONE_EN             (0x01 << 0)
+#define BIT_SPI_INT_RD_FIFO_EN               (0x01 << 2)
+#define BIT_SPI_INT_WR_FIFO_EN               (0x01 << 3)
+#define BIT_SPI_INT_RX_FRAME_EN              (0x01 << 4)
+#define BIT_SPI_INT_TX_FRAME_EN              (0x01 << 5)
+
+#define SPI_NOR_MAX_ID_LEN	6
+#define SPI_NOR_MAX_ADDR_WIDTH	4
+
+/* SPI Flash Device Table */
+struct flash_dev_info {
+	char	*name;
+	u32	jedec_id;
+	u32	max_freq_div;
+	u32	dmmr_setting;
+};
+
+struct cvi_spif {
+	void __iomem *io_base;
+	struct device *dev;
+	struct platform_device	*pdev;
+	u32 pending;
+	struct spi_nor nor;
+	struct completion cmd_completion;
+	int irq;
+	spinlock_t irq_lock;
+	struct flash_dev_info *dev_info;
+
+	bool memory_mode;
+	u32 org_ce_ctrl;
+	u32 org_tran_csr;
+
+	dma_addr_t		dmmr_base_phy;
+	struct completion	rx_dma_complete;
+	struct dma_chan		*rx_chan;
+	dma_cookie_t		cookie;
+};
+
+struct dmmr_reg_t {
+	uint8_t read_cmd;
+	uint8_t dummy_clock;
+	uint32_t reg_set;
+};
+
+static unsigned int match_value_for_read(u8 opcode)
+{
+	int i;
+	uint32_t val = 0;
+	const struct dmmr_reg_t dmmr_reg_set[] = {
+		{0x03, 0x0, 0x003B81},
+		{0x0B, 0x8, 0x003B89},
+		{0x3B, 0x8, 0x003B91},
+		{0xBB, 0x4, 0x003B99},
+		{0x6B, 0x8, 0x003BA1},
+		{0xEB, 0x6, 0x003BA9},
+		{0x13, 0x0, 0x303C81},
+		{0x0C, 0x8, 0x303C89},
+		{0x3C, 0x8, 0x303C91},
+		{0xBC, 0x4, 0x303C99},
+		{0x6C, 0x8, 0x303CA1},
+		{0xEC, 0x6, 0x303CA9},
+		{0x0, 0x0, 0x0}
+	};
+
+	for (i = 0; i < ARRAY_SIZE(dmmr_reg_set); i++) {
+		if (opcode == dmmr_reg_set[i].read_cmd) {
+			val = dmmr_reg_set[i].reg_set & (~SPI_TRAN_CSR_DUMMY_MASK);
+			val |= (dmmr_reg_set[i].dummy_clock & 0xf) << 16;
+			return val;
+		}
+	}
+	return dmmr_reg_set[0].reg_set;
+}
+
+static int cvi_spif_read_reg(struct spi_nor *nor, u8 opcode, u8 *buf, size_t len);
+static int cvi_spif_write_reg(struct spi_nor *nor, u8 opcode, const u8 *buf, size_t len);
+static void cvi_spif_dump_reg(struct cvi_spif *spif);
+
+static void cvi_spif_rx_dma_callback(void *param)
+{
+	struct cvi_spif *spif = param;
+
+	pr_debug("%s\n", __func__);
+
+	complete(&spif->rx_dma_complete);
+}
+
+static void cvi_spif_dma_setup(struct cvi_spif *spif)
+{
+	dma_cap_mask_t mask;
+	int ret;
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_MEMCPY, mask);
+	ret = dma_set_mask(spif->dev, DMA_BIT_MASK(64));
+	if (ret)
+		dev_err(spif->dev, "no usable DMA configuration\n");
+
+	spif->rx_chan = dma_request_chan_by_mask(&mask);
+	if (IS_ERR(spif->rx_chan)) {
+		dev_err(&spif->pdev->dev, "No Rx DMA available\n");
+		spif->rx_chan = NULL;
+	}
+	init_completion(&spif->rx_dma_complete);
+}
+
+
+static void timeout_dump_reg(struct cvi_spif *spif, struct dma_chan *chan)
+{
+	void __iomem *clk_reg;
+	void __iomem *sysdma_reg;
+	uint32_t i = 0;
+
+	cvi_spif_dump_reg(spif);
+
+	clk_reg = ioremap(0x3002000, 0x10);
+	sysdma_reg = ioremap(0x4330000, 0x800);
+
+	pr_err("%s timeout, 0x3002000=0x%x, 0x3002004=0x%x, ch0 sar=0x%x ch1 dar=0x%x\n",
+	       __func__, readl(clk_reg), readl(clk_reg+4), readl(sysdma_reg + 0x100),
+	       readl(sysdma_reg + 0x208));
+
+	pr_err("CFG=0x%x, CHEN=0x%x, ch0 status=0x%x, ch1 status=0x%x\n",
+	       readl(sysdma_reg+0x10), readl(sysdma_reg + 0x18), readl(sysdma_reg + 0x130),
+	       readl(sysdma_reg + 0x230));
+
+	pr_err("ch_id=%d\n", chan->chan_id);
+
+	for (i = 0; i <= 0x20; i += 4) {
+		pr_info("0x%x: 0x%x\n", (0x0 + i), readl(sysdma_reg + i));
+	}
+	for (i = 0; i <= 0x20; i += 4) {
+		pr_info("0x%x: 0x%x\n", (0x100 + i), readl(sysdma_reg + 0x100 + i));
+	}
+	for (i = 0; i <= 0x20; i += 4) {
+		pr_info("0x%x: 0x%x\n", (0x200 + i), readl(sysdma_reg + 0x200 + i));
+	}
+
+	iounmap(clk_reg);
+	iounmap(sysdma_reg);
+}
+
+
+#define DMA_MIN_THLD 1024
+
+static int cvi_spif_direct_read_execute(struct spi_nor *nor, u_char *buf,
+					loff_t from, size_t len)
+{
+	struct cvi_spif *spif = nor->priv;
+	enum dma_ctrl_flags flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;
+	dma_addr_t dma_src = (dma_addr_t)spif->dmmr_base_phy + from;
+	int ret = 0;
+	struct dma_async_tx_descriptor *tx;
+	dma_cookie_t cookie;
+	dma_addr_t dma_dst;
+
+	pr_debug("%s from 0x%x, len 0x%x\n", __func__, (int)from, (int)len);
+
+	if (!spif->rx_chan || !virt_addr_valid(buf)  || len <= DMA_MIN_THLD) {
+		memcpy_fromio(buf, spif->io_base + from, len);
+		pr_debug("cpy no dma\n");
+		return 0;
+	}
+
+	dma_dst = dma_map_single(nor->dev, buf, len, DMA_FROM_DEVICE);
+	if (dma_mapping_error(nor->dev, dma_dst)) {
+		dev_err(nor->dev, "dma mapping failed\n");
+		return -ENOMEM;
+	}
+	tx = dmaengine_prep_dma_memcpy(spif->rx_chan, dma_dst, dma_src,
+				       len, flags);
+	if (!tx) {
+		dev_err(nor->dev, "device_prep_dma_memcpy error\n");
+		ret = -EIO;
+		goto err_unmap;
+	}
+
+	tx->callback = cvi_spif_rx_dma_callback;
+	tx->callback_param = spif;
+	cookie = tx->tx_submit(tx);
+	reinit_completion(&spif->rx_dma_complete);
+
+	ret = dma_submit_error(cookie);
+	if (ret) {
+		dev_err(nor->dev, "dma_submit_error %d\n", cookie);
+		ret = -EIO;
+		goto err_unmap;
+	}
+
+	dma_async_issue_pending(spif->rx_chan);
+
+	if (!wait_for_completion_timeout(&spif->rx_dma_complete,
+					 msecs_to_jiffies(len))) {
+
+		pr_err("spinor dma timeout f 0x%x l 0x%x\n",
+		       (int)from, (int)len);
+		timeout_dump_reg(spif, spif->rx_chan);
+
+		dmaengine_terminate_sync(spif->rx_chan);
+
+		ret = -ETIMEDOUT;
+	}
+
+err_unmap:
+	dma_unmap_single(nor->dev, dma_dst, len, DMA_FROM_DEVICE);
+
+	return ret;
+}
+
+static int cvi_spif_wait_for_tran_done(struct cvi_spif *spif)
+{
+	u8 stat;
+	int err = 0;
+
+	/* wait tran done */
+	err = readb_poll_timeout(spif->io_base + REG_SPI_INT_STS, stat,
+				 (stat & BIT_SPI_INT_TRAN_DONE), 1, 300*1000);
+	if (err)
+		dev_warn(spif->dev, " %s command timed out\n", __func__);
+
+
+	writeb(readb(spif->io_base + REG_SPI_INT_STS) & ~BIT_SPI_INT_TRAN_DONE, spif->io_base + REG_SPI_INT_STS);
+	writeb(readb(spif->io_base + REG_SPI_INT_STS) & ~BIT_SPI_INT_RD_FIFO, spif->io_base + REG_SPI_INT_STS);
+
+	return err;
+}
+
+static int cvi_spif_clk_setup(struct cvi_spif *spif, u32 sck_div)
+{
+	u32 reg, sck_div_backup;
+
+	writel(0, spif->io_base + REG_SPI_DMMR);
+
+	/* set positive edge sampling if SCK <= 30MHz */
+	if (sck_div >= 4) {
+		reg = readl(spif->io_base + REG_SPI_DLY_CTRL);
+		reg &= ~BIT(14);
+	} else { /* set negative edge sampling otherwise */
+		reg = readl(spif->io_base + REG_SPI_DLY_CTRL);
+		reg |= BIT(14);
+	}
+	writel(reg, spif->io_base + REG_SPI_DLY_CTRL);
+
+	/* set spinor clock divider */
+	reg = readl(spif->io_base + REG_SPI_CTRL);
+	sck_div_backup = reg & BIT_SPI_CTRL_SCK_DIV_MASK;
+	reg &= ~BIT_SPI_CTRL_SCK_DIV_MASK;
+	reg |= sck_div;
+	writel(reg, spif->io_base + REG_SPI_CTRL);
+
+	return sck_div_backup;
+}
+
+static void cvi_spif_set_memory_mode_off(struct spi_nor *nor)
+{
+	struct cvi_spif *spif = nor->priv;
+
+	writel(0, spif->io_base + REG_SPI_DMMR);
+	writel(0x3, spif->io_base + REG_SPI_CE_CTRL);
+	writel(spif->org_tran_csr, spif->io_base + REG_SPI_TRAN_CSR);
+}
+
+static void cvi_spif_set_memory_mode_on(struct spi_nor *nor)
+{
+	struct cvi_spif *spif = nor->priv;
+	u32 reg = match_value_for_read(nor->read_opcode);
+
+	writel(0, spif->io_base + REG_SPI_DMMR);
+	spif->org_tran_csr = readl(spif->io_base + REG_SPI_TRAN_CSR);
+
+	/* support only 1 ce */
+	writel(0, spif->io_base + REG_SPI_CE_CTRL);
+	if ((reg >> 16 & 0xf) != nor->read_dummy) {
+		reg &= ~SPI_TRAN_CSR_DUMMY_MASK;
+		reg |= (nor->read_dummy & 0xf) << 16;
+	}
+	writel(reg, spif->io_base + REG_SPI_TRAN_CSR);
+	writel(1, spif->io_base + REG_SPI_DMMR);
+}
+
+static void cvi_spif_dump_reg(struct cvi_spif *spif)
+{
+	int i = 0;
+	u32 dmmrreg = readl(spif->io_base + REG_SPI_TRAN_CSR);
+
+	pr_info("%s spif->memory_mode %d, dmmr reg 0x%x, lr %p\n",
+		__func__, spif->memory_mode, dmmrreg, __builtin_return_address(0));
+
+	writel(0, spif->io_base + REG_SPI_DMMR);
+
+	for (i = 0; i <= 0x28; i = i + 4) {
+		pr_info("0x%x : 0x%x\n", i, readl(spif->io_base + i));
+	}
+
+	writel(1, spif->io_base + REG_SPI_DMMR);
+}
+
+static u8 cvi_spi_data_out_tran(struct spi_nor *nor, const u8 *src_buf,
+				uint32_t data_bytes, unsigned char bus_width)
+{
+	struct cvi_spif *spif = nor->priv;
+	uint32_t tran_csr = 0;
+	uint32_t xfer_size, off;
+	int i;
+	int ret;
+	u32 stat;
+
+	pr_debug("src[0] 0x%x data_bytes %d\n", src_buf[0], data_bytes);
+
+	if (data_bytes > 65535) {
+		pr_err("data out overflow, should be less than 65535 bytes(%d)\n", data_bytes);
+		return -1;
+	}
+
+	writel(0, spif->io_base + REG_SPI_INT_STS);
+	writel(BIT_SPI_INT_TRAN_DONE, spif->io_base + REG_SPI_INT_EN);
+
+	/* init tran_csr */
+	tran_csr = readw(spif->io_base + REG_SPI_TRAN_CSR);
+	tran_csr &= ~(BIT_SPI_TRAN_CSR_TRAN_MODE_MASK
+		     | BIT_SPI_TRAN_CSR_ADDR_BYTES_MASK
+		     | BIT_SPI_TRAN_CSR_FIFO_TRG_LVL_MASK
+		     | BIT_SPI_TRAN_CSR_BUS_WIDTH_MASK
+		     | BIT_SPI_TRAN_CSR_WITH_CMD);
+	tran_csr |= BIT_SPI_TRAN_CSR_FIFO_TRG_LVL_8_BYTE;
+	tran_csr |= BIT_SPI_TRAN_CSR_TRAN_MODE_TX;
+
+	writel(0, spif->io_base + REG_SPI_FIFO_PT);
+
+	/* issue tran */
+	writew(data_bytes, spif->io_base + REG_SPI_TRAN_NUM);
+	tran_csr |= BIT_SPI_TRAN_CSR_GO_BUSY;
+	tran_csr |= (bus_width / 2) << 4;
+
+	writew(tran_csr, spif->io_base + REG_SPI_TRAN_CSR);
+	/* 300 ms */
+	ret = readb_poll_timeout(spif->io_base + REG_SPI_INT_STS, stat,
+				 (stat & BIT_SPI_INT_WR_FIFO), 1, 300 * 1000);
+	if (ret) {
+		dev_warn(spif->dev, "%s BIT_SPI_INT_WR_FIFO timed out\n", __func__);
+		return ret;
+	}
+
+	/* fill data */
+	off = 0;
+	while (off < data_bytes) {
+		if (data_bytes - off >= SPI_MAX_FIFO_DEPTH)
+			xfer_size = SPI_MAX_FIFO_DEPTH;
+		else
+			xfer_size = data_bytes - off;
+
+		ret = readb_poll_timeout(spif->io_base + REG_SPI_FIFO_PT, stat,
+					 (stat & 0xF) == 0, 1, 300 * 1000); // 300ms
+
+		if (ret) {
+			dev_warn(spif->dev, "%s REG_SPI_FIFO_PT timed out\n", __func__);
+			return ret;
+		}
+
+		/*
+		 * odd thing, if we use writeb, the BIT_SPI_INT_WR_FIFO bit can't
+		 * be cleared after transfer done. and BIT_SPI_INT_RD_FIFO bit will not
+		 * be set even when REG_SPI_FIFO_PT shows non-zero value.
+		 */
+		for (i = 0; i < xfer_size; i++) {
+			writeb(*(src_buf + off + i), spif->io_base + REG_SPI_FIFO_PORT);
+		}
+
+		off += xfer_size;
+	}
+
+	/* wait tran done */
+	ret = cvi_spif_wait_for_tran_done(spif);
+	if (ret)
+		return ret;
+
+	writel(0, spif->io_base + REG_SPI_FIFO_PT);
+
+	/* clear interrupts */
+	writeb(readb(spif->io_base + REG_SPI_INT_STS) & ~BIT_SPI_INT_TRAN_DONE, spif->io_base + REG_SPI_INT_STS);
+	writeb(readb(spif->io_base + REG_SPI_INT_STS) & ~BIT_SPI_INT_WR_FIFO, spif->io_base + REG_SPI_INT_STS);
+
+	pr_debug("%s exit\n", __func__);
+
+	return 0;
+}
+
+static int cvi_spi_data_in_tran(struct spi_nor *nor, u8 *dst_buf,
+				int data_bytes, unsigned char bus_width)
+{
+	struct cvi_spif *spif = nor->priv;
+	uint32_t tran_csr = 0;
+	int i, xfer_size, off;
+	u32 stat;
+	int ret;
+
+	if (data_bytes > 65535) {
+		pr_err("SPI data in overflow, should be less than 65535 bytes(%d)\n", data_bytes);
+		return -1;
+	}
+
+	writel(0, spif->io_base + REG_SPI_INT_STS);
+	writel(BIT_SPI_INT_TRAN_DONE, spif->io_base + REG_SPI_INT_EN);
+
+	/* init tran_csr */
+	tran_csr = readw(spif->io_base + REG_SPI_TRAN_CSR);
+	tran_csr &= ~(BIT_SPI_TRAN_CSR_TRAN_MODE_MASK
+			| BIT_SPI_TRAN_CSR_ADDR_BYTES_MASK
+			| BIT_SPI_TRAN_CSR_FIFO_TRG_LVL_MASK
+			| BIT_SPI_TRAN_CSR_BUS_WIDTH_MASK
+			| BIT_SPI_TRAN_CSR_WITH_CMD);
+	tran_csr |= BIT_SPI_TRAN_CSR_FIFO_TRG_LVL_8_BYTE;
+	tran_csr |= BIT_SPI_TRAN_CSR_TRAN_MODE_RX;
+
+	writel(0, spif->io_base + REG_SPI_FIFO_PT);
+
+	/* issue tran */
+	writew(data_bytes, spif->io_base + REG_SPI_TRAN_NUM);
+	tran_csr |= BIT_SPI_TRAN_CSR_GO_BUSY;
+	tran_csr |= (bus_width / 2) << 4;
+	writew(tran_csr, spif->io_base + REG_SPI_TRAN_CSR);
+
+	ret = readb_poll_timeout(spif->io_base + REG_SPI_INT_STS, stat,
+				 stat & (BIT_SPI_INT_RD_FIFO | BIT_SPI_INT_TRAN_DONE), 1, 300 * 1000); // 300ms
+
+	if (ret)
+		dev_warn(spif->dev, "%s timedout2\n", __func__);
+
+	/* get data */
+	off = 0;
+	while (off < data_bytes) {
+		if (data_bytes - off >= SPI_MAX_FIFO_DEPTH)
+			xfer_size = SPI_MAX_FIFO_DEPTH;
+		else
+			xfer_size = data_bytes - off;
+
+		/*
+		 * sometimes we get more than we want, why...
+		 */
+		ret = readb_poll_timeout(spif->io_base + REG_SPI_FIFO_PT, stat,
+					 (stat & 0xF) >= xfer_size, 1, 300 * 1000); // 300ms
+
+		if (ret)
+			dev_warn(spif->dev, "%s timedout3\n", __func__);
+
+		for (i = 0; i < xfer_size; i++)
+			*(dst_buf + off + i) = readb(spif->io_base + REG_SPI_FIFO_PORT);
+
+		off += xfer_size;
+	}
+
+	ret = cvi_spif_wait_for_tran_done(spif);
+	if (ret)
+		return ret;
+
+	writeb(0, spif->io_base + REG_SPI_FIFO_PT); // flush unwanted data
+
+	/* write 0 to clear interrupts */
+	writeb(readb(spif->io_base + REG_SPI_INT_STS) & ~BIT_SPI_INT_TRAN_DONE, spif->io_base + REG_SPI_INT_STS);
+	writeb(readb(spif->io_base + REG_SPI_INT_STS) & ~BIT_SPI_INT_RD_FIFO, spif->io_base + REG_SPI_INT_STS);
+	return 0;
+}
+
+static int cvi_spif_read_reg(struct spi_nor *nor, u8 opcode, u8 *buf, size_t len)
+{
+	struct cvi_spif *spif = nor->priv;
+	u8 bus_width;
+	u32 sck_div_orig;
+
+	/* always 1 bit bus width */
+	bus_width = spi_nor_get_protocol_inst_nbits(nor->read_proto);
+
+	pr_debug("%s opcode 0x%x\n", __func__, opcode);
+
+	/* set clock to 30MHz for no-addr cmd */
+	sck_div_orig = cvi_spif_clk_setup(spif, 4);
+
+	writel(0, spif->io_base + REG_SPI_DMMR);
+	writel(0x2, spif->io_base + REG_SPI_CE_CTRL);
+
+	cvi_spi_data_out_tran(nor, &opcode, 1, bus_width);
+
+	cvi_spi_data_in_tran(nor, buf, len, bus_width);
+
+	writel(0x3, spif->io_base + REG_SPI_CE_CTRL);
+
+	/* restore higher speed */
+	cvi_spif_clk_setup(spif, sck_div_orig);
+
+	return 0;
+}
+
+static int cvi_spif_write_reg(struct spi_nor *nor, u8 opcode, const u8 *buf, size_t len)
+{
+	struct cvi_spif *spif = nor->priv;
+	u8 bus_width;
+	u32 sck_div_orig;
+
+	pr_debug("%s opcode 0x%x\n", __func__, opcode);
+
+	/* always 1 bit bus width */
+	bus_width = spi_nor_get_protocol_inst_nbits(nor->read_proto);
+
+	/* set clock to 30MHz for no-addr cmd */
+	sck_div_orig = cvi_spif_clk_setup(spif, 4);
+
+	writel(0x2, spif->io_base + REG_SPI_CE_CTRL);
+
+	cvi_spi_data_out_tran(nor, &opcode, 1, bus_width);
+
+	if (len)
+		cvi_spi_data_out_tran(nor, buf, len, bus_width);
+
+	writel(0x3, spif->io_base + REG_SPI_CE_CTRL);
+
+	/* restore higher speed */
+	cvi_spif_clk_setup(spif, sck_div_orig);
+
+	return 0;
+}
+
+static ssize_t cvi_spif_read(struct spi_nor *nor, loff_t from, size_t len,
+			      u_char *buf)
+{
+#ifndef DMMR_DMA_MODE
+	struct cvi_spif *spif = nor->priv;
+#endif
+	pr_debug("from 0x%llx, len %lu\n", from, len);
+
+	cvi_spif_set_memory_mode_on(nor);
+
+#ifdef DMMR_DMA_MODE
+	cvi_spif_direct_read_execute(nor, buf, from, len);
+#else
+	memcpy_fromio(buf, spif->io_base + from, len);
+#endif
+
+	cvi_spif_set_memory_mode_off(nor);
+
+	return len;
+}
+
+static void spi_flash_addr(struct spi_nor *nor, u32 addr, u8 *cmd)
+{
+	if (nor->addr_width == 4) {
+		/* cmd[0] is actual command */
+		cmd[1] = addr >> 24;
+		cmd[2] = addr >> 16;
+		cmd[3] = addr >> 8;
+		cmd[4] = addr >> 0;
+
+		pr_debug("cmd %2X%2X%2X%2X\n", cmd[1], cmd[2], cmd[3], cmd[4]);
+	} else {
+		/* cmd[0] is actual command */
+		cmd[1] = addr >> 16;
+		cmd[2] = addr >> 8;
+		cmd[3] = addr >> 0;
+		pr_debug("cmd %2X%2X%2X\n", cmd[1], cmd[2], cmd[3]);
+	}
+}
+
+#define SPI_FLASH_3B_ADDR_LEN		3
+#define SPI_FLASH_4B_ADDR_LEN		4
+#define SPI_FLASH_BUF_LEN		(1 + SPI_FLASH_4B_ADDR_LEN)
+#define SPI_FLASH_16MB_BOUN		0x1000000
+
+static int cvi_spif_nor_write(struct cvi_spif *spif, struct spi_nor *nor,
+		u8 opcode, unsigned int to, const u8 *buf,
+		unsigned int len)
+{
+
+	u8 cmd[SPI_FLASH_BUF_LEN];
+	u8 bus_width;
+
+	pr_debug("%s opcode 0x%x\n", __func__, opcode);
+
+	cmd[0] = opcode;
+
+	spi_flash_addr(nor, to, cmd);
+	/* cmd */
+	bus_width = spi_nor_get_protocol_inst_nbits(nor->write_proto);
+	cvi_spi_data_out_tran(nor, cmd, 1, bus_width);
+
+	/* addr */
+	bus_width = spi_nor_get_protocol_addr_nbits(nor->write_proto);
+	cvi_spi_data_out_tran(nor, cmd + 1, nor->addr_width, bus_width);
+
+	/* data */
+	if (len) {
+		bus_width = spi_nor_get_protocol_data_nbits(nor->write_proto);
+		cvi_spi_data_out_tran(nor, buf, len, bus_width);
+	}
+	return 0;
+}
+
+static ssize_t cvi_spif_write(struct spi_nor *nor, loff_t to, size_t len,
+			       const u_char *buf)
+{
+
+	struct cvi_spif *spif = nor->priv;
+
+	pr_debug("to 0x%llx, len 0x%x\n", to, len);
+
+	writel(0, spif->io_base + REG_SPI_DMMR);
+
+	writel(0x2, spif->io_base + REG_SPI_CE_CTRL);
+
+	cvi_spif_nor_write(spif, nor, nor->program_opcode, to, buf, len);
+
+	writel(0x3, spif->io_base + REG_SPI_CE_CTRL);
+
+	return len;
+}
+
+static const struct spi_nor_controller_ops cvi_controller_ops = {
+	.read_reg = cvi_spif_read_reg,
+	.write_reg = cvi_spif_write_reg,
+	.read = cvi_spif_read,
+	.write = cvi_spif_write,
+};
+
+static int cvi_spif_setup_flash(struct cvi_spif *spif,
+				 struct device_node *np)
+{
+	struct spi_nor_hwcaps hwcaps = {
+		.mask = SNOR_HWCAPS_READ	|
+			SNOR_HWCAPS_READ_FAST	|
+			SNOR_HWCAPS_READ_1_1_2	|
+			SNOR_HWCAPS_READ_1_1_4	|
+			SNOR_HWCAPS_READ_1_4_4	|
+			SNOR_HWCAPS_PP		|
+			SNOR_HWCAPS_PP_1_1_4,
+	};
+	int ret;
+
+	spif->nor.dev   = spif->dev;
+	spi_nor_set_flash_node(&spif->nor, np);
+	spif->nor.priv  = spif;
+	spif->nor.controller_ops = &cvi_controller_ops;
+
+	ret = spi_nor_scan(&spif->nor, NULL, &hwcaps);
+	if (ret) {
+		dev_err(spif->dev, "device scan failed\n");
+		return ret;
+	}
+
+	ret = mtd_device_register(&spif->nor.mtd, NULL, 0);
+	if (ret) {
+		dev_err(spif->dev, "mtd device parse failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int cvi_spif_probe(struct platform_device *pdev)
+{
+	struct device_node *flash_np;
+	struct cvi_spif *spif;
+	struct resource *res;
+	int ret = 0;
+
+	spif = devm_kzalloc(&pdev->dev, sizeof(*spif), GFP_KERNEL);
+	if (!spif)
+		return -ENOMEM;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "spif");
+	spif->io_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(spif->io_base)) {
+		dev_err(&pdev->dev, "Cannot remap AHB address.\n");
+		return PTR_ERR(spif->io_base);
+	}
+
+	spif->dmmr_base_phy = (dma_addr_t)res->start;
+
+	spif->dev = &pdev->dev;
+	spif->pdev = pdev;
+	platform_set_drvdata(pdev, spif);
+
+	init_completion(&spif->cmd_completion);
+
+	/* Request the IRQ */
+	spif->irq = platform_get_irq(pdev, 0);
+
+	if (spif->irq < 0) {
+		dev_err(&pdev->dev, "missing IRQ\n");
+		ret = spif->irq;
+		goto bailout;
+	}
+
+	flash_np = of_get_next_available_child(pdev->dev.of_node, NULL);
+	if (!flash_np) {
+		dev_err(&pdev->dev, "no SPI flash device to configure\n");
+		return -ENODEV;
+	}
+
+	ret = cvi_spif_setup_flash(spif, flash_np);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to setup flash chip\n");
+		return -ENODEV;
+	}
+
+	/* Ignore init clock, u-boot has init it already */
+	// cvi_spif_clk_setup(spif, 1);
+	cvi_spif_dma_setup(spif);
+
+bailout:
+	return ret;
+}
+
+static int cvi_spif_remove(struct platform_device *pdev)
+{
+	struct cvi_spif *spif = platform_get_drvdata(pdev);
+
+	pr_info("%s\n", __func__);
+
+	mtd_device_unregister(&spif->nor.mtd);
+
+	return 0;
+}
+
+static void cvi_spif_shutdown(struct platform_device *pdev)
+{
+	struct cvi_spif *spif = platform_get_drvdata(pdev);
+
+	if (spif == NULL)
+		return;
+
+	spi_nor_restore(&spif->nor);
+}
+
+static const struct of_device_id cvi_spif_match[] = {
+	{.compatible = "cvitek,cvi-spif"},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, cvi_spif_match);
+
+static struct platform_driver cvi_spif_driver = {
+	.probe	= cvi_spif_probe,
+	.remove	= cvi_spif_remove,
+	.shutdown = cvi_spif_shutdown,
+	.driver	= {
+		.name = "cvi-spif",
+		.of_match_table = cvi_spif_match,
+	},
+};
+module_platform_driver(cvi_spif_driver);
+
+MODULE_DESCRIPTION("Cvitek SPI Flash Interface driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mtd/spi-nor/core.c b/drivers/mtd/spi-nor/core.c
index 09e112f37691..48dc08ca29f3 100644
--- a/drivers/mtd/spi-nor/core.c
+++ b/drivers/mtd/spi-nor/core.c
@@ -749,6 +749,42 @@ static int spi_nor_write_sr(struct spi_nor *nor, const u8 *sr, size_t len)
 	return spi_nor_wait_till_ready(nor);
 }
 
+/**
+ * spi_nor_write_sr2_jy() - Write the Status Register.
+ * @nor:	pointer to 'struct spi_nor'.
+ * @sr:		pointer to DMA-able buffer to write to the Status Register.
+ * @len:	number of bytes to write to the Status Register.
+ *
+ * Return: 0 on success, -errno otherwise.
+ */
+static int spi_nor_write_sr2_jy(struct spi_nor *nor, const u8 *sr, size_t len)
+{
+	int ret;
+
+	ret = spi_nor_write_enable(nor);
+	if (ret)
+		return ret;
+
+	if (nor->spimem) {
+		struct spi_mem_op op =
+			SPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_WRSR2_JY, 1),
+				   SPI_MEM_OP_NO_ADDR,
+				   SPI_MEM_OP_NO_DUMMY,
+				   SPI_MEM_OP_DATA_OUT(len, sr, 1));
+
+		ret = spi_mem_exec_op(nor->spimem, &op);
+	} else {
+		ret = nor->controller_ops->write_reg(nor, SPINOR_OP_WRSR2_JY,
+						     sr, len);
+	}
+
+	if (ret) {
+		dev_dbg(nor->dev, "error %d writing SR\n", ret);
+		return ret;
+	}
+
+	return spi_nor_wait_till_ready(nor);
+}
 /**
  * spi_nor_write_sr1_and_check() - Write one byte to the Status Register 1 and
  * ensure that the byte written match the received value.
@@ -1973,6 +2009,40 @@ int spi_nor_sr2_bit1_quad_enable(struct spi_nor *nor)
 	return spi_nor_write_16bit_cr_and_check(nor, nor->bouncebuf[0]);
 }
 
+int spi_nor_sr_bit1_quad_enable(struct spi_nor *nor)
+{
+	int ret;
+	u8 sr2;
+	u8 sr2_written;
+
+	ret = spi_nor_read_cr(nor, &sr2);
+	if (ret)
+		return ret;
+
+	if (sr2 & SR2_QUAD_EN_BIT1)
+		return 0;
+
+	sr2 |= SR2_QUAD_EN_BIT1;
+
+	ret = spi_nor_write_sr2_jy(nor, &sr2, 1);
+	if (ret)
+		return ret;
+
+	sr2_written = sr2;
+
+	/* Read back and check it. */
+	ret = spi_nor_read_cr(nor, &sr2);
+	if (ret)
+		return ret;
+
+	if (sr2 != sr2_written) {
+		dev_dbg(nor->dev, "SR2: Read back test failed\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
 /**
  * spi_nor_sr2_bit7_quad_enable() - set QE bit in Status Register 2.
  * @nor:	pointer to a 'struct spi_nor'
@@ -2021,6 +2091,7 @@ int spi_nor_sr2_bit7_quad_enable(struct spi_nor *nor)
 }
 
 static const struct spi_nor_manufacturer *manufacturers[] = {
+	&spi_nor_cvitek,
 	&spi_nor_atmel,
 	&spi_nor_catalyst,
 	&spi_nor_eon,
@@ -2778,15 +2849,28 @@ static void spi_nor_info_init_params(struct spi_nor *nor)
 	if (info->flags & SPI_NOR_DUAL_READ) {
 		params->hwcaps.mask |= SNOR_HWCAPS_READ_1_1_2;
 		spi_nor_set_read_settings(&params->reads[SNOR_CMD_READ_1_1_2],
-					  0, 8, SPINOR_OP_READ_1_1_2,
-					  SNOR_PROTO_1_1_2);
+				0, 8, SPINOR_OP_READ_1_1_2,
+				SNOR_PROTO_1_1_2);
 	}
 
 	if (info->flags & SPI_NOR_QUAD_READ) {
 		params->hwcaps.mask |= SNOR_HWCAPS_READ_1_1_4;
 		spi_nor_set_read_settings(&params->reads[SNOR_CMD_READ_1_1_4],
-					  0, 8, SPINOR_OP_READ_1_1_4,
-					  SNOR_PROTO_1_1_4);
+				0, 8, SPINOR_OP_READ_1_1_4,
+				SNOR_PROTO_1_1_4);
+
+		params->hwcaps.mask |= SNOR_HWCAPS_READ_1_4_4;
+		spi_nor_set_read_settings(&params->reads[SNOR_CMD_READ_1_4_4],
+				0, 6, SPINOR_OP_READ_1_4_4,
+				SNOR_PROTO_1_4_4);
+
+	}
+
+	if (info->flags & SPI_NOR_HAS_FIX_DUMMY) {
+		spi_nor_set_read_settings(&params->reads[SNOR_CMD_READ_1_4_4],
+				0, 10, SPINOR_OP_READ_1_4_4,
+				SNOR_PROTO_1_4_4);
+
 	}
 
 	if (info->flags & SPI_NOR_OCTAL_READ) {
@@ -2799,7 +2883,13 @@ static void spi_nor_info_init_params(struct spi_nor *nor)
 	/* Page Program settings. */
 	params->hwcaps.mask |= SNOR_HWCAPS_PP;
 	spi_nor_set_pp_settings(&params->page_programs[SNOR_CMD_PP],
-				SPINOR_OP_PP, SNOR_PROTO_1_1_1);
+			SPINOR_OP_PP, SNOR_PROTO_1_1_1);
+
+	if (info->flags & SPI_NOR_QUAD_WRITE) {
+		params->hwcaps.mask |= SNOR_HWCAPS_PP_1_1_4;
+		spi_nor_set_pp_settings(&params->page_programs[SNOR_CMD_PP_1_1_4],
+				SPINOR_OP_PP_1_1_4, SNOR_PROTO_1_1_4);
+	}
 
 	/*
 	 * Sector Erase settings. Sort Erase Types in ascending order, with the
@@ -3272,7 +3362,7 @@ int spi_nor_scan(struct spi_nor *nor, const char *name,
 	dev_info(dev, "%s (%lld Kbytes)\n", info->name,
 			(long long)mtd->size >> 10);
 
-	dev_dbg(dev,
+	dev_info(dev,
 		"mtd .name = %s, .size = 0x%llx (%lldMiB), "
 		".erasesize = 0x%.8x (%uKiB) .numeraseregions = %d\n",
 		mtd->name, (long long)mtd->size, (long long)(mtd->size >> 20),
diff --git a/drivers/mtd/spi-nor/core.h b/drivers/mtd/spi-nor/core.h
index 788775bb6795..09305a66766b 100644
--- a/drivers/mtd/spi-nor/core.h
+++ b/drivers/mtd/spi-nor/core.h
@@ -311,7 +311,10 @@ struct flash_info {
 					 * BP3 is bit 6 of status register.
 					 * Must be used with SPI_NOR_4BIT_BP.
 					 */
+#define SPI_NOR_QUAD_WRITE      BIT(19) /* Flash support Quad write */
+#define SPI_NOR_QUAD_OP         (SPI_NOR_QUAD_READ | SPI_NOR_QUAD_WRITE)
 
+#define SPI_NOR_HAS_FIX_DUMMY  BIT(20)
 	/* Part specific fixup hooks. */
 	const struct spi_nor_fixups *fixups;
 };
@@ -398,6 +401,7 @@ extern const struct spi_nor_manufacturer spi_nor_sst;
 extern const struct spi_nor_manufacturer spi_nor_winbond;
 extern const struct spi_nor_manufacturer spi_nor_xilinx;
 extern const struct spi_nor_manufacturer spi_nor_xmc;
+extern const struct spi_nor_manufacturer spi_nor_cvitek;
 
 int spi_nor_write_enable(struct spi_nor *nor);
 int spi_nor_write_disable(struct spi_nor *nor);
@@ -410,6 +414,7 @@ int spi_nor_sr1_bit6_quad_enable(struct spi_nor *nor);
 int spi_nor_sr2_bit1_quad_enable(struct spi_nor *nor);
 int spi_nor_sr2_bit7_quad_enable(struct spi_nor *nor);
 int spi_nor_write_sr_and_check(struct spi_nor *nor, u8 sr1);
+int spi_nor_sr_bit1_quad_enable(struct spi_nor *nor);
 
 int spi_nor_xread_sr(struct spi_nor *nor, u8 *sr);
 ssize_t spi_nor_read_data(struct spi_nor *nor, loff_t from, size_t len,
diff --git a/drivers/mtd/spi-nor/cvitek_support_list.c b/drivers/mtd/spi-nor/cvitek_support_list.c
new file mode 100644
index 000000000000..a455d93c20f3
--- /dev/null
+++ b/drivers/mtd/spi-nor/cvitek_support_list.c
@@ -0,0 +1,182 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2005, Intec Automation Inc.
+ * Copyright (C) 2014, Freescale Semiconductor, Inc.
+ */
+
+#include <linux/mtd/spi-nor.h>
+
+#include "core.h"
+
+static void sr_bit1_qe_default_init(struct spi_nor *nor)
+{
+	nor->params->quad_enable = spi_nor_sr_bit1_quad_enable;
+	nor->flags &= ~SNOR_F_HAS_16BIT_SR;
+}
+
+static struct spi_nor_fixups sr_bit1_qe_fixups = {
+	.default_init = sr_bit1_qe_default_init,
+};
+
+static void sr1_bit6_qe_default_init(struct spi_nor *nor)
+{
+	nor->params->quad_enable = spi_nor_sr1_bit6_quad_enable;
+	nor->flags &= ~SNOR_F_HAS_16BIT_SR;
+}
+
+static struct spi_nor_fixups sr1_bit6_qe_fixups = {
+	.default_init = sr1_bit6_qe_default_init,
+};
+
+static void sr2_bit1_qe_default_init(struct spi_nor *nor)
+{
+	nor->params->quad_enable = spi_nor_sr2_bit1_quad_enable;
+	nor->flags &= ~SNOR_F_HAS_16BIT_SR;
+}
+
+static struct spi_nor_fixups sr2_bit1_qe_fixups = {
+	.default_init = sr2_bit1_qe_default_init,
+};
+
+static void no_qe_default_init(struct spi_nor *nor)
+{
+	nor->params->quad_enable = NULL;
+	nor->flags &= ~SNOR_F_HAS_16BIT_SR;
+}
+
+static struct spi_nor_fixups no_qe_fixups = {
+	.default_init = no_qe_default_init,
+};
+
+static const struct flash_info cvitek_parts[] = {
+
+	{ "XM25QH64A", INFO(0x207017, 0, 64 * 1024, 128,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)
+		.fixups = &no_qe_fixups
+	},
+	{ "XM25QH128A", INFO(0x207018, 0, 64 * 1024, 256,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)
+		.fixups = &no_qe_fixups
+	},
+	{ "XM25Qx128A", INFO(0x207118, 0, 64 * 1024, 256,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)
+		.fixups = &no_qe_fixups
+	},
+	{ "JY25VQ128A", INFO(0x1c4018, 0x0, 64 * 1024, 256,
+			SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP | SECT_4K)
+		.fixups = &sr_bit1_qe_fixups },
+	{ "JY25VQ64A", INFO(0x4a4017, 0x0, 64 * 1024, 128,
+			SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP | SECT_4K)
+		.fixups = &sr_bit1_qe_fixups },
+	{ "XM25QH64C", INFO(0x204017, 0x0, 64 * 1024, 128,
+			SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP | SECT_4K)
+		.fixups = &sr_bit1_qe_fixups },
+	{ "XM25QH128C", INFO(0x204018, 0x0, 64 * 1024, 256,
+			SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP | SECT_4K)
+		.fixups = &sr_bit1_qe_fixups },
+	{ "XM25QH256C", INFO(0x204019, 0x0, 64 * 1024, 512,
+			SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP | SECT_4K |
+			SPI_NOR_4B_OPCODES)
+		.fixups = &sr_bit1_qe_fixups },
+	{ "MT25QL256A",  INFO6(0x20ba19, 0x104400, 64 * 1024,  512,
+			SECT_4K | USE_FSR | SPI_NOR_DUAL_READ |
+			SPI_NOR_QUAD_OP | SPI_NOR_4B_OPCODES | SPI_NOR_HAS_FIX_DUMMY)
+		.fixups = &no_qe_fixups},
+	{ "W25Q128JV-IQ", INFO(0xef4018, 0, 64 * 1024, 256,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP)
+		.fixups = &sr_bit1_qe_fixups },
+	{ "W25Q256JV-IQ", INFO(0xef4019, 0, 64 * 1024, 512,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP |
+			SPI_NOR_4B_OPCODES)
+		.fixups = &sr_bit1_qe_fixups },
+	{ "W25Q64JV-IQ", INFO(0xef4017, 0, 64 * 1024, 128,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP)
+		.fixups = &sr_bit1_qe_fixups },
+	/* Juyang 32M Nor Flash(JY25VQ256A) uses the same wafers as MXIC */
+	{ "MX25L25645G", INFO(0xc22019, 0, 64 * 1024, 512,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP |
+			SPI_NOR_4B_OPCODES)
+		.fixups = &sr1_bit6_qe_fixups },
+	{ "MX25L12835F", INFO(0xc22018, 0, 64 * 1024, 256,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP)
+		.fixups = &sr1_bit6_qe_fixups },
+	{ "EN25QH128A", INFO(0x1c7018, 0, 64 * 1024,  256,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP) },
+	{ "EN25QX64A", INFO(0x1c7117, 0, 64 * 1024,  128,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP) },
+	{ "EN25QX128A", INFO(0x1c7118, 0, 64 * 1024,  256,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP) },
+	{ "EN25QH256A",  INFO(0x1c7019, 0, 64 * 1024,  512,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP |
+			SPI_NOR_4B_OPCODES) },
+	{ "GD25Q128E", INFO(0xc84018, 0, 64 * 1024, 256,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP)
+		.fixups = &sr_bit1_qe_fixups },
+	{ "GD25Q64E", INFO(0xc84017, 0, 64 * 1024, 128,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP)
+		.fixups = &sr_bit1_qe_fixups },
+	{ "GD25Q256E", INFO(0xc84019, 0, 64 * 1024, 512,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP |
+			SPI_NOR_4B_OPCODES)},
+	{ "IS25LP064D", INFO(0x9d6017, 0x0, 64 * 1024, 128,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP)
+		.fixups = &sr1_bit6_qe_fixups },
+	{ "IS25LP128F", INFO(0x9d6018, 0, 64 * 1024, 256,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP)
+		.fixups = &sr1_bit6_qe_fixups },
+	{ "IS25LP256E", INFO(0x9d6019, 0, 64 * 1024, 256,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP |
+			SPI_NOR_4B_OPCODES)
+		.fixups = &sr1_bit6_qe_fixups },
+	{ "KH25L6433FM2I", INFO(0xc22017, 0x0, 64 * 1024, 128,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP)
+		.fixups = &sr1_bit6_qe_fixups },
+	//{ "KH25L12833FM2I", INFO(0xc22018, 0x0, 64 * 1024, 256,
+	//      SECT_4K | SPI_NOR_DUAL_READ) },
+	{ "ZB25VQ64B", INFO(0x5e4017, 0x0, 64 * 1024, 128,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP)
+		.fixups = &sr_bit1_qe_fixups },
+	{ "ZB25VQ128A", INFO(0x5e4018, 0x0, 64 * 1024, 256,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP)
+		.fixups = &sr_bit1_qe_fixups },
+	{ "S25FL128L", INFO(0x016018, 0x0, 64 * 1024, 256,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP |
+			SPI_NOR_HAS_FIX_DUMMY)
+		.fixups = &sr2_bit1_qe_fixups
+	},
+	{ "S25FL256L", INFO(0x016019, 0x0, 64 * 1024, 512,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP |
+			SPI_NOR_4B_OPCODES | SPI_NOR_HAS_FIX_DUMMY)
+		.fixups = &sr2_bit1_qe_fixups },
+	{ "XT25F64F", INFO(0x0b4017, 0x0, 64 * 1024, 128,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP)
+		.fixups = &sr_bit1_qe_fixups },
+	{ "XT25F128F", INFO(0x0b4018, 0x0, 64 * 1024, 256,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP)
+		.fixups = &sr_bit1_qe_fixups },
+	{ "FM25Q64", INFO(0xF83217, 0x0, 64 * 1024, 128,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP)
+		.fixups = &sr_bit1_qe_fixups },
+	{ "BY25Q128AS", INFO(0x684018, 0x0, 64 * 1024, 256,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP)
+		.fixups = &sr_bit1_qe_fixups },
+	{ "BY25Q256FS", INFO(0x684919, 0x0, 64 * 1024, 512,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP |
+			SPI_NOR_4B_OPCODES)
+		.fixups = &sr_bit1_qe_fixups },
+	{ "PY25Q128HA", INFO(0x852018, 0x0, 64 * 1024, 256,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP)
+		.fixups = &sr_bit1_qe_fixups },
+	{ "P25Q64SH", INFO(0x856017, 0x0, 64 * 1024, 128,
+			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_OP)
+		.fixups = &sr_bit1_qe_fixups },
+	{}
+
+
+};
+
+const struct spi_nor_manufacturer spi_nor_cvitek = {
+	.name = "cvitek_support_list",
+	.parts = cvitek_parts,
+	.nparts = ARRAY_SIZE(cvitek_parts),
+};
diff --git a/drivers/mtd/spi-nor/eon.c b/drivers/mtd/spi-nor/eon.c
index ddb8e3650835..2d8be16274c2 100644
--- a/drivers/mtd/spi-nor/eon.c
+++ b/drivers/mtd/spi-nor/eon.c
@@ -24,6 +24,10 @@ static const struct flash_info eon_parts[] = {
 			     SECT_4K | SPI_NOR_DUAL_READ) },
 	{ "en25qh128",  INFO(0x1c7018, 0, 64 * 1024,  256, 0) },
 	{ "en25qh256",  INFO(0x1c7019, 0, 64 * 1024,  512, 0) },
+	{ "en25qx64a",  INFO(0x1c7117, 0, 64 * 1024,  128,
+		SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+	{ "en25qx128a", INFO(0x1c7118, 0, 64 * 1024,  256,
+		SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ "en25s64",	INFO(0x1c3817, 0, 64 * 1024,  128, SECT_4K) },
 };
 
diff --git a/drivers/mtd/spi-nor/winbond.c b/drivers/mtd/spi-nor/winbond.c
index e5dfa786f190..56386aae83ec 100644
--- a/drivers/mtd/spi-nor/winbond.c
+++ b/drivers/mtd/spi-nor/winbond.c
@@ -71,7 +71,7 @@ static const struct flash_info winbond_parts[] = {
 			    SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB) },
 	{ "w25q256jwm", INFO(0xef8019, 0, 64 * 1024, 512,
 			    SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
-			    SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB) },
+			    SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB | SPI_NOR_4B_OPCODES) },
 	{ "w25x64", INFO(0xef3017, 0, 64 * 1024, 128, SECT_4K) },
 	{ "w25q64", INFO(0xef4017, 0, 64 * 1024, 128,
 			 SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
@@ -89,14 +89,22 @@ static const struct flash_info winbond_parts[] = {
 	{ "w25q80bl", INFO(0xef4014, 0, 64 * 1024,  16, SECT_4K) },
 	{ "w25q128", INFO(0xef4018, 0, 64 * 1024, 256, SECT_4K) },
 	{ "w25q256", INFO(0xef4019, 0, 64 * 1024, 512,
-			  SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)
+			  SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
+			  SPI_NOR_4B_OPCODES)
+	  .fixups = &w25q256_fixups },
+	{ "w25q512jveiq", INFO(0xef4020, 0, 64 * 1024, 1024,
+			  SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
+			  SPI_NOR_4B_OPCODES)
 	  .fixups = &w25q256_fixups },
 	{ "w25q256jvm", INFO(0xef7019, 0, 64 * 1024, 512,
-			     SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+			     SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
+				 SPI_NOR_4B_OPCODES) },
 	{ "w25q256jw", INFO(0xef6019, 0, 64 * 1024, 512,
-			     SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+			     SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
+				 SPI_NOR_4B_OPCODES) },
 	{ "w25m512jv", INFO(0xef7119, 0, 64 * 1024, 1024,
-			    SECT_4K | SPI_NOR_QUAD_READ | SPI_NOR_DUAL_READ) },
+			    SECT_4K | SPI_NOR_QUAD_READ | SPI_NOR_DUAL_READ |
+				SPI_NOR_4B_OPCODES) },
 };
 
 /**
diff --git a/drivers/mtd/spi-nor/xmc.c b/drivers/mtd/spi-nor/xmc.c
index 2c7773b68993..8d8248341ce9 100644
--- a/drivers/mtd/spi-nor/xmc.c
+++ b/drivers/mtd/spi-nor/xmc.c
@@ -10,10 +10,38 @@
 
 static const struct flash_info xmc_parts[] = {
 	/* XMC (Wuhan Xinxin Semiconductor Manufacturing Corp.) */
+	{ "XM25QH64C", INFO(0x204017, 0x0, 64 * 1024, 128,
+				SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SECT_4K)},
+	{ "XM25QH128C", INFO(0x204018, 0x0, 64 * 1024, 256,
+				SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SECT_4K)},
+	{ "XM25QH256C", INFO(0x204019, 0x0, 64 * 1024, 512,
+				SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SECT_4K |
+				SPI_NOR_4B_OPCODES)},
 	{ "XM25QH64A", INFO(0x207017, 0, 64 * 1024, 128,
 			    SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
 	{ "XM25QH128A", INFO(0x207018, 0, 64 * 1024, 256,
-			     SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+			    SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+	{ "XM25Qx128A", INFO(0x207118, 0, 64 * 1024, 256,
+				SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+
+
+	{ "JY25VQ128A", INFO(0x1c4018, 0x0, 64 * 1024, 256,
+				SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SECT_4K)},
+	{ "JY25VQ64A", INFO(0x4a4017, 0x0, 64 * 1024, 128,
+				SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SECT_4K)},
+
+	{ "ZB25VQ64B", INFO(0x5e4017, 0x0, 64 * 1024, 128,
+				SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)},
+	{ "ZB25VQ128A", INFO(0x5e4018, 0x0, 64 * 1024, 256,
+				SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)},
+
+	{ "XT25F64F", INFO(0x0b4017, 0x0, 64 * 1024, 128,
+				SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)},
+	{ "XT25F128F", INFO(0x0b4018, 0x0, 64 * 1024, 256,
+				SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)},
+
+	{ "FM25Q64", INFO(0xF83217, 0x0, 64 * 1024, 128,
+				SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)},
 };
 
 const struct spi_nor_manufacturer spi_nor_xmc = {
diff --git a/drivers/net/ethernet/stmicro/stmmac/Kconfig b/drivers/net/ethernet/stmicro/stmmac/Kconfig
index 53f14c5a9e02..9ed29786f20b 100644
--- a/drivers/net/ethernet/stmicro/stmmac/Kconfig
+++ b/drivers/net/ethernet/stmicro/stmmac/Kconfig
@@ -57,6 +57,16 @@ config DWMAC_GENERIC
 	  platform specific code to function or is using platform
 	  data for setup.
 
+config DWMAC_CVITEK
+    tristate "CVITEK DWMAC support"
+    default ARCH_CVITEK
+    depends on OF && (ARCH_CVITEK || COMPILE_TEST)
+    help
+      Support for CVITEK DWMAC Ethernet.
+      This selects CVITEK SoC glue layer support for the stmmac
+      device driver. This driver is used for the CVITEK series
+      SOCs GMAC ethernet controller.
+
 config DWMAC_ANARION
 	tristate "Adaptrum Anarion GMAC support"
 	default ARC
diff --git a/drivers/net/ethernet/stmicro/stmmac/Makefile b/drivers/net/ethernet/stmicro/stmmac/Makefile
index 24e6145d4eae..f96047f05400 100644
--- a/drivers/net/ethernet/stmicro/stmmac/Makefile
+++ b/drivers/net/ethernet/stmicro/stmmac/Makefile
@@ -1,5 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
-obj-$(CONFIG_STMMAC_ETH) += stmmac.o
+obj-$(CONFIG_STMMAC_ETH) += stmmac.o dwmac-thead.o
 stmmac-objs:= stmmac_main.o stmmac_ethtool.o stmmac_mdio.o ring_mode.o	\
 	      chain_mode.o dwmac_lib.o dwmac1000_core.o dwmac1000_dma.o	\
 	      dwmac100_core.o dwmac100_dma.o enh_desc.o norm_desc.o	\
@@ -12,6 +12,7 @@ stmmac-$(CONFIG_STMMAC_SELFTESTS) += stmmac_selftests.o
 
 # Ordering matters. Generic driver must be last.
 obj-$(CONFIG_STMMAC_PLATFORM)	+= stmmac-platform.o
+obj-$(CONFIG_DWMAC_CVITEK)      += dwmac-cvitek.o
 obj-$(CONFIG_DWMAC_ANARION)	+= dwmac-anarion.o
 obj-$(CONFIG_DWMAC_IPQ806X)	+= dwmac-ipq806x.o
 obj-$(CONFIG_DWMAC_LPC18XX)	+= dwmac-lpc18xx.o
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-cvitek.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-cvitek.c
new file mode 100644
index 000000000000..1bdd8e23c3e9
--- /dev/null
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-cvitek.c
@@ -0,0 +1,159 @@
+// SPDX-License-Identifier: GPL-2.0
+/* dwmac-cvitek.c - Bitmain DWMAC specific glue layer
+ *
+ * Copyright (c) 2019 Cvitek Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/stmmac.h>
+#include <linux/module.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/of_net.h>
+#include <linux/of_gpio.h>
+#include <linux/io.h>
+
+#include "stmmac_platform.h"
+
+struct cvitek_mac {
+	struct device *dev;
+	struct reset_control *rst;
+	struct clk *clk_tx;
+	struct clk *gate_clk_500m;
+	struct clk *gate_clk_axi4;
+	struct gpio_desc *reset;
+};
+
+static u64 bm_dma_mask = DMA_BIT_MASK(40);
+
+static int bm_eth_reset_phy(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	int phy_reset_gpio;
+	u32	ephy_addr = 0x0;
+	void __iomem *ephy_reg;
+
+	if (!np)
+		return 0;
+
+	of_property_read_u32(np, "ephy_ctl_reg", &ephy_addr);
+
+	if (ephy_addr) {
+		ephy_reg = ioremap(ephy_addr, 0x10);
+		writel(readl(ephy_reg) & 0xFFFFFFFC, ephy_reg);
+		mdelay(2);
+		iounmap(ephy_reg);
+	}
+
+	phy_reset_gpio = of_get_named_gpio(np, "phy-reset-gpios", 0);
+
+	if (phy_reset_gpio < 0)
+		return 0;
+
+	if (gpio_request(phy_reset_gpio, "eth-phy-reset"))
+		return 0;
+
+	/* RESET_PU */
+	gpio_direction_output(phy_reset_gpio, 0);
+	mdelay(20);
+
+	gpio_direction_output(phy_reset_gpio, 1);
+	/* RC charging time */
+	mdelay(60);
+
+	return 0;
+}
+
+void bm_dwmac_exit(struct platform_device *pdev, void *priv)
+{
+	struct cvitek_mac *bsp_priv = priv;
+
+	clk_disable_unprepare(bsp_priv->gate_clk_500m);
+	clk_disable_unprepare(bsp_priv->gate_clk_axi4);
+}
+
+static int bm_dwmac_probe(struct platform_device *pdev)
+{
+	struct plat_stmmacenet_data *plat_dat;
+	struct stmmac_resources stmmac_res;
+	struct cvitek_mac *bsp_priv = NULL;
+	int ret;
+
+	pdev->dev.dma_mask = &bm_dma_mask;
+	pdev->dev.coherent_dma_mask = bm_dma_mask;
+
+	bm_eth_reset_phy(pdev);
+
+	ret = stmmac_get_platform_resources(pdev, &stmmac_res);
+	if (ret)
+		return ret;
+
+	plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
+	if (IS_ERR(plat_dat))
+		return PTR_ERR(plat_dat);
+
+	ret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);
+	if (ret)
+		goto err_remove_config_dt;
+
+	bsp_priv = devm_kzalloc(&pdev->dev, sizeof(*bsp_priv), GFP_KERNEL);
+	if (!bsp_priv)
+		return PTR_ERR(bsp_priv);
+
+	bsp_priv->dev = &pdev->dev;
+
+	/* clock setup */
+	bsp_priv->gate_clk_500m = devm_clk_get(&pdev->dev, "clk_500m_eth");
+
+	if (IS_ERR(bsp_priv->gate_clk_500m))
+		dev_warn(&pdev->dev, "Cannot get clk_500m_eth!\n");
+	else
+		clk_prepare_enable(bsp_priv->gate_clk_500m);
+
+	bsp_priv->gate_clk_axi4 = devm_clk_get(&pdev->dev, "clk_axi4_eth");
+
+	if (IS_ERR(bsp_priv->gate_clk_axi4))
+		dev_warn(&pdev->dev, "Cannot get gate_clk_axi4!\n");
+	else
+		clk_prepare_enable(bsp_priv->gate_clk_axi4);
+
+	plat_dat->bsp_priv = bsp_priv;
+	plat_dat->exit = bm_dwmac_exit;
+
+	return 0;
+
+err_remove_config_dt:
+	stmmac_remove_config_dt(pdev, plat_dat);
+
+	return ret;
+}
+
+static const struct of_device_id bm_dwmac_match[] = {
+	{ .compatible = "cvitek,ethernet" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, bm_dwmac_match);
+
+static struct platform_driver bm_dwmac_driver = {
+	.probe  = bm_dwmac_probe,
+	.remove = stmmac_pltfr_remove,
+	.driver = {
+		.name           = "bm-dwmac",
+		.pm		= &stmmac_pltfr_pm_ops,
+		.of_match_table = bm_dwmac_match,
+	},
+};
+module_platform_driver(bm_dwmac_driver);
+
+MODULE_AUTHOR("Wei Huang<wei.huang01@bitmain.com>");
+MODULE_DESCRIPTION("Cvitek DWMAC specific glue layer");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-thead.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-thead.c
new file mode 100644
index 000000000000..5f14951b611f
--- /dev/null
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-thead.c
@@ -0,0 +1,606 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_net.h>
+#include <linux/platform_device.h>
+
+#include "stmmac_platform.h"
+
+/* clock registers */
+#define GMAC_CLK_CFG0	0x00
+#define GMAC_CLK_CFG1	0x04
+#define GMAC_CLK_CFG2	0x08
+#define GMAC_CLK_CFG3	0x0C
+#define GMAC_CLK_CFG4	0x10
+#define GMAC_CLK_CFG5	0x14
+#define GMAC_CLK_CFG6	0x18
+
+/* phy interface */
+#define DWMAC_PHYIF_MII_GMII	0
+#define DWMAC_PHYIF_RGMII	1
+#define DWMAC_PHYIF_RMII	4
+/* register bit fields, bit[3]: reserved, bit[2:0]: phy interface */
+#define DWMAC_PHYIF_MASK	0x7
+#define DWMAC_PHYIF_BIT_WIDTH	4
+
+/* TXCLK direction, 1:input, 0:output */
+#define TXCLK_DIR_OUTPUT	0
+#define TXCLK_DIR_INPUT		1
+
+#define GMAC_CLK_PLLOUT_250M	250000000
+#define GMAC_GMII_RGMII_RATE	125000000
+#define GMAC_MII_RATE		25000000
+/* clock divider for speed */
+#define GMAC_CLKDIV_125M	(GMAC_CLK_PLLOUT_250M / GMAC_GMII_RGMII_RATE)
+#define GMAC_CLKDIV_25M		(GMAC_CLK_PLLOUT_250M / GMAC_MII_RATE)
+
+struct thead_dwmac_priv_data {
+	int id;
+	void __iomem *phy_if_reg;
+	void __iomem *txclk_dir_reg;
+	void __iomem *gmac_clk_reg;
+	phy_interface_t interface;
+	struct clk *gmac_pll_clk;
+	unsigned int gmac_pll_clk_freq;
+};
+
+/* set GMAC PHY interface, 0:MII/GMII, 1:RGMII, 4:RMII */
+static void thead_dwmac_set_phy_if(struct platform_device *pdev,
+				   void __iomem *phy_if_reg, int interface,
+				   int devid)
+{
+	struct device *dev = &pdev->dev;
+	unsigned int phyif = PHY_INTERFACE_MODE_MII;
+	volatile uint32_t reg;
+
+	if (phy_if_reg == NULL)
+		return;
+
+	switch (interface)
+	{
+	case PHY_INTERFACE_MODE_MII:
+	case PHY_INTERFACE_MODE_GMII:
+		phyif = DWMAC_PHYIF_MII_GMII;
+		break;
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+	case PHY_INTERFACE_MODE_RGMII_ID:
+		phyif = DWMAC_PHYIF_RGMII;
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		phyif = DWMAC_PHYIF_RMII;
+		break;
+	default:
+		dev_err(dev, "phy interface %d not supported\n", interface);
+		return;
+	};
+
+	reg = readl(phy_if_reg);
+	reg &= ~(DWMAC_PHYIF_MASK << (DWMAC_PHYIF_BIT_WIDTH * devid));
+	reg |= (phyif & DWMAC_PHYIF_MASK) << (DWMAC_PHYIF_BIT_WIDTH * devid);
+	writel(reg, phy_if_reg);
+}
+
+/*
+ * set GMAC TXCLK direction
+ *     MII        : TXCLK is input
+ *     GMII/RGMII : TXCLK is output
+ */
+static void thead_dwmac_set_txclk_dir(struct platform_device *pdev,
+				void __iomem *txclk_dir_reg, int interface)
+{
+	struct device *dev = &pdev->dev;
+	unsigned int txclk_dir = TXCLK_DIR_INPUT;
+
+	if (txclk_dir_reg == NULL)
+		return;
+
+	switch (interface)
+	{
+	case PHY_INTERFACE_MODE_MII:
+	case PHY_INTERFACE_MODE_RMII:
+		txclk_dir = TXCLK_DIR_INPUT;
+		break;
+	case PHY_INTERFACE_MODE_GMII:
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+	case PHY_INTERFACE_MODE_RGMII_ID:
+		txclk_dir = TXCLK_DIR_OUTPUT;
+		break;
+	default:
+		dev_err(dev, "phy interface %d not supported\n", interface);
+		return;
+	};
+
+	writel(txclk_dir, txclk_dir_reg);
+}
+
+static void thead_dwmac_set_clk_source(struct platform_device *pdev,
+				void __iomem *gmac_clk_reg, int interface)
+{
+	struct device *dev = &pdev->dev;
+	volatile uint32_t reg;
+
+	if (gmac_clk_reg == NULL)
+		return;
+
+	reg = readl(gmac_clk_reg + GMAC_CLK_CFG0);
+
+	/* RX clock source */
+	reg |= BIT(7);  /* gmac_rx_clk_sel: extern pin */
+
+	/* TX clock source */
+	if (interface == PHY_INTERFACE_MODE_MII) {
+		reg |= BIT(1);  /* gmac_tx_clk_sel: extern pin */
+		reg &= ~BIT(2); /* gmac_tx_clk_gbit_sel: u_tx_clk_mux */
+	} else if (interface == PHY_INTERFACE_MODE_GMII) {
+		reg &= ~BIT(5); /* gmac_tx_clk_out_sel: GMAC PLL */
+		reg |= BIT(2);  /* gmac_tx_clk_gbit_sel: GMAC PLL */
+	} else if (interface == PHY_INTERFACE_MODE_RGMII
+		|| interface == PHY_INTERFACE_MODE_RGMII_ID
+		|| interface == PHY_INTERFACE_MODE_RGMII_RXID
+		|| interface == PHY_INTERFACE_MODE_RGMII_TXID) {
+		reg &= ~BIT(5); /* gmac_tx_clk_out_sel: GMAC PLL */
+		reg |= BIT(2);  /* gmac_tx_clk_gbit_sel: GMAC PLL */
+	} else {
+		dev_err(dev, "phy interface %d not supported\n", interface);
+		return;
+	}
+
+	writel(reg, gmac_clk_reg + GMAC_CLK_CFG0);
+}
+
+
+/* set clock source */
+static void thead_dwmac_set_clock_delay(struct platform_device *pdev,
+				void __iomem *gmac_clk_reg, int interface)
+{
+	unsigned int delay;
+
+	if (gmac_clk_reg == NULL)
+		return;
+
+	if (of_property_read_u32(pdev->dev.of_node, "rx-clk-delay",
+				 &delay) == 0) {
+		/* RX clk delay */
+		writel(delay, gmac_clk_reg + GMAC_CLK_CFG1);
+		pr_info("RX clk delay: 0x%X\n", delay);
+	}
+
+	if (of_property_read_u32(pdev->dev.of_node, "tx-clk-delay",
+				 &delay) == 0) {
+		/* TX clk delay */
+		writel(delay, gmac_clk_reg + GMAC_CLK_CFG2);
+		pr_info("TX clk delay: 0x%X\n", delay);
+	}
+}
+
+/* set gmac pll divider (u_pll_clk_div) to get 250MHz clock */
+static void thead_dwmac_set_pll_250M(void __iomem *gmac_clk_reg, int interface,
+				unsigned int src_freq)
+{
+	volatile unsigned int reg;
+	unsigned int div = 1;
+
+	if (gmac_clk_reg == NULL)
+		return;
+
+	if (interface == PHY_INTERFACE_MODE_MII) {
+		/* For MII, no internal PLL is used */
+		return;
+	} else if (interface == PHY_INTERFACE_MODE_GMII
+		|| interface == PHY_INTERFACE_MODE_RGMII
+		|| interface == PHY_INTERFACE_MODE_RGMII_ID
+		|| interface == PHY_INTERFACE_MODE_RGMII_RXID
+		|| interface == PHY_INTERFACE_MODE_RGMII_TXID) {
+
+		/* check clock */
+		if ((src_freq == 0) || (src_freq % GMAC_CLK_PLLOUT_250M != 0)) {
+			pr_err("error! invalid gmac pll freq %d\n", src_freq);
+			return;
+		}
+		div = src_freq / GMAC_CLK_PLLOUT_250M;
+
+		/* disable pll_clk_div */
+		reg = readl(gmac_clk_reg + GMAC_CLK_CFG3);
+		reg &= ~BIT(31);
+		writel(reg, gmac_clk_reg + GMAC_CLK_CFG3);
+
+		/* modify divider */
+		writel(div, gmac_clk_reg + GMAC_CLK_CFG3);
+
+		/* enable pll_clk_div */
+		reg = readl(gmac_clk_reg + GMAC_CLK_CFG3);
+		reg |= BIT(31);
+		writel(reg, gmac_clk_reg + GMAC_CLK_CFG3);
+	} else {
+		pr_err("phy interface %d not supported\n", interface);
+		return;
+	}
+}
+
+/* set gmac speed */
+static void thead_dwmac_set_speed(void __iomem *gmac_clk_reg, int interface,
+				unsigned int speed)
+{
+	volatile unsigned int reg;
+
+	if (gmac_clk_reg == NULL)
+		return;
+
+	if (interface == PHY_INTERFACE_MODE_MII) {
+		/* For MII, no internal PLL is used */
+		return;
+	} else if (interface == PHY_INTERFACE_MODE_GMII
+		|| interface == PHY_INTERFACE_MODE_RGMII
+		|| interface == PHY_INTERFACE_MODE_RGMII_ID
+		|| interface == PHY_INTERFACE_MODE_RGMII_RXID
+		|| interface == PHY_INTERFACE_MODE_RGMII_TXID) {
+
+		/* disable gtx_clk_div */
+		reg = readl(gmac_clk_reg + GMAC_CLK_CFG4);
+		reg &= ~BIT(31);
+		writel(reg, gmac_clk_reg + GMAC_CLK_CFG4);
+
+		/*
+		 * modify divider
+		 */
+		/* gtx_clk_div */
+		if (speed == SPEED_1000) {
+			writel(GMAC_CLKDIV_125M, gmac_clk_reg + GMAC_CLK_CFG4);
+		} else if (speed == SPEED_100) {
+			writel(GMAC_CLKDIV_25M, gmac_clk_reg + GMAC_CLK_CFG4);
+		} else {
+			writel(GMAC_CLKDIV_25M / 10, gmac_clk_reg + GMAC_CLK_CFG4);
+		}
+
+		/* enable gtx_clk_div */
+		reg = readl(gmac_clk_reg + GMAC_CLK_CFG4);
+		reg |= BIT(31);
+		writel(reg, gmac_clk_reg + GMAC_CLK_CFG4);
+	} else {
+		pr_err("phy interface %d not supported\n", interface);
+		return;
+	}
+}
+
+/* enable gmac clock */
+static void thead_dwmac_enable_clock(struct platform_device *pdev,
+				void __iomem *gmac_clk_reg, int interface)
+{
+	struct device *dev = &pdev->dev;
+	volatile unsigned int reg;
+
+	if (gmac_clk_reg == NULL)
+		return;
+
+	reg = readl(gmac_clk_reg + GMAC_CLK_CFG0);
+
+	/* enable gmac_hclk */
+	reg |= BIT(14);
+
+	if (interface == PHY_INTERFACE_MODE_MII) {
+		reg |= BIT(8);  /* enable gmac_rx_clk */
+		reg |= BIT(3);  /* enable gmac_tx_clk */
+	} else if (interface == PHY_INTERFACE_MODE_GMII) {
+		reg |= BIT(8);  /* enable gmac_rx_clk */
+		reg |= BIT(3);  /* enable gmac_tx_clk */
+		reg |= BIT(6);  /* enable gmac_tx_clk_out */
+	} else if (interface == PHY_INTERFACE_MODE_RGMII
+		|| interface == PHY_INTERFACE_MODE_RGMII_ID
+		|| interface == PHY_INTERFACE_MODE_RGMII_RXID
+		|| interface == PHY_INTERFACE_MODE_RGMII_TXID) {
+		reg |= BIT(8);  /* enable gmac_rx_clk */
+		reg |= BIT(3);  /* enable gmac_tx_clk */
+		reg |= BIT(6);  /* enable gmac_tx_clk_out */
+		reg |= BIT(9);  /* enable gmac_rx_clk_n */
+		reg |= BIT(4);  /* enable gmac_tx_clk_n */
+	} else {
+		dev_err(dev, "phy interface %d not supported\n", interface);
+		return;
+	}
+
+	writel(reg, gmac_clk_reg + GMAC_CLK_CFG0);
+}
+
+#if 0
+/* disable gmac clock */
+static void thead_dwmac_disable_clock(struct platform_device *pdev,
+				void __iomem *gmac_clk_reg, int interface)
+{
+	struct device *dev = &pdev->dev;
+	volatile unsigned int reg;
+
+	if (gmac_clk_reg == NULL)
+		return;
+
+	reg = readl(gmac_clk_reg + GMAC_CLK_CFG0);
+
+	/* disable gmac_hclk */
+	reg &= ~BIT(14);
+
+	if (interface == PHY_INTERFACE_MODE_MII) {
+		reg &= ~BIT(8); /* disable gmac_rx_clk */
+		reg &= ~BIT(3); /* disable gmac_tx_clk */
+	} else if (interface == PHY_INTERFACE_MODE_GMII) {
+		reg &= ~BIT(8); /* disable gmac_rx_clk */
+		reg &= ~BIT(3); /* disable gmac_tx_clk */
+		reg &= ~BIT(6); /* disable gmac_tx_clk_out */
+	} else if (interface == PHY_INTERFACE_MODE_RGMII
+		|| interface == PHY_INTERFACE_MODE_RGMII_ID
+		|| interface == PHY_INTERFACE_MODE_RGMII_RXID
+		|| interface == PHY_INTERFACE_MODE_RGMII_TXID) {
+		reg &= ~BIT(8); /* disable gmac_rx_clk */
+		reg &= ~BIT(3); /* disable gmac_tx_clk */
+		reg &= ~BIT(6); /* disable gmac_tx_clk_out */
+		reg &= ~BIT(9); /* disable gmac_rx_clk_n */
+		reg &= ~BIT(4); /* disable gmac_tx_clk_n */
+	} else {
+		dev_err(dev, "phy interface %d not supported\n", interface);
+		return;
+	}
+
+	writel(reg, gmac_clk_reg + GMAC_CLK_CFG0);
+}
+#endif
+
+static int thead_dwmac_init(struct platform_device *pdev, void *bsp_priv)
+{
+	struct thead_dwmac_priv_data *thead_plat_dat = bsp_priv;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	struct resource *res;
+	void __iomem *ptr;
+	struct clk *clktmp;
+	int ret;
+
+	thead_plat_dat->id = of_alias_get_id(np, "ethernet");
+	if (thead_plat_dat->id < 0) {
+		thead_plat_dat->id = 0;
+	}
+	dev_info(dev, "id: %d\n", thead_plat_dat->id);
+
+	if (of_get_phy_mode(dev->of_node, &(thead_plat_dat->interface))) {
+		dev_err(dev, "of_get_phy_mode error\n");
+		return -1;
+	}
+
+	dev_info(dev, "phy interface: %d\n", thead_plat_dat->interface);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phy_if_reg");
+	if ((res != NULL) && (resource_type(res) == IORESOURCE_MEM)) {
+		ptr = devm_ioremap(dev, res->start, resource_size(res));
+		if (!ptr) {
+			dev_err(dev, "phy interface register not exist, skipped it\n");
+		} else {
+			thead_plat_dat->phy_if_reg = ptr;
+		}
+	}
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "txclk_dir_reg");
+	ptr = devm_ioremap_resource(dev, res);
+	if (IS_ERR(ptr)) {
+		dev_err(dev, "txclk_dir register not exist, skipped it\n");
+	} else {
+		thead_plat_dat->txclk_dir_reg = ptr;
+	}
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "clk_mgr_reg");
+	ptr = devm_ioremap_resource(dev, res);
+	if (IS_ERR(ptr)) {
+		dev_err(dev, "gmac_clk register not exist, skipped it\n");
+	} else {
+		thead_plat_dat->gmac_clk_reg = ptr;
+	}
+
+	/* get gmac pll clk */
+	clktmp = devm_clk_get(dev, "gmac_pll_clk");
+	if (IS_ERR(clktmp)) {
+		dev_err(dev, "gmac_pll_clk not exist, skipped it\n");
+	} else {
+		thead_plat_dat->gmac_pll_clk = clktmp;
+
+		ret = clk_prepare_enable(thead_plat_dat->gmac_pll_clk);
+		if (ret) {
+			dev_err(dev, "Failed to enable clk 'gmac_pll_clk'\n");
+			return -1;
+		}
+
+		thead_plat_dat->gmac_pll_clk_freq =
+				clk_get_rate(thead_plat_dat->gmac_pll_clk);
+	}
+
+	thead_dwmac_set_phy_if(pdev, thead_plat_dat->phy_if_reg,
+				thead_plat_dat->interface, thead_plat_dat->id);
+
+	thead_dwmac_set_txclk_dir(pdev, thead_plat_dat->txclk_dir_reg,
+				thead_plat_dat->interface);
+
+	thead_dwmac_set_clk_source(pdev, thead_plat_dat->gmac_clk_reg,
+				thead_plat_dat->interface);
+	thead_dwmac_set_clock_delay(pdev, thead_plat_dat->gmac_clk_reg,
+				thead_plat_dat->interface);
+
+	thead_dwmac_set_pll_250M(thead_plat_dat->gmac_clk_reg,
+				thead_plat_dat->interface,
+				thead_plat_dat->gmac_pll_clk_freq);
+
+	/* default speed is 1Gbps */
+	thead_dwmac_set_speed(thead_plat_dat->gmac_clk_reg,
+				thead_plat_dat->interface, SPEED_1000);
+
+	thead_dwmac_enable_clock(pdev, thead_plat_dat->gmac_clk_reg,
+				thead_plat_dat->interface);
+	return 0;
+}
+
+static void thead_dwmac_fix_speed(void *bsp_priv, unsigned int speed)
+{
+	struct thead_dwmac_priv_data *thead_plat_dat = bsp_priv;
+
+	thead_dwmac_set_speed(thead_plat_dat->gmac_clk_reg,
+				thead_plat_dat->interface, speed);
+}
+
+/**
+ * dwmac1000_validate_mcast_bins - validates the number of Multicast filter bins
+ * @mcast_bins: Multicast filtering bins
+ * Description:
+ * this function validates the number of Multicast filtering bins specified
+ * by the configuration through the device tree. The Synopsys GMAC supports
+ * 64 bins, 128 bins, or 256 bins. "bins" refer to the division of CRC
+ * number space. 64 bins correspond to 6 bits of the CRC, 128 corresponds
+ * to 7 bits, and 256 refers to 8 bits of the CRC. Any other setting is
+ * invalid and will cause the filtering algorithm to use Multicast
+ * promiscuous mode.
+ */
+static int dwmac1000_validate_mcast_bins(int mcast_bins)
+{
+	int x = mcast_bins;
+
+	switch (x) {
+	case HASH_TABLE_SIZE:
+	case 128:
+	case 256:
+		break;
+	default:
+		x = 0;
+		pr_info("Hash table entries set to unexpected value %d",
+			mcast_bins);
+		break;
+	}
+	return x;
+}
+
+/**
+ * dwmac1000_validate_ucast_entries - validate the Unicast address entries
+ * @ucast_entries: number of Unicast address entries
+ * Description:
+ * This function validates the number of Unicast address entries supported
+ * by a particular Synopsys 10/100/1000 controller. The Synopsys controller
+ * supports 1..32, 64, or 128 Unicast filter entries for it's Unicast filter
+ * logic. This function validates a valid, supported configuration is
+ * selected, and defaults to 1 Unicast address if an unsupported
+ * configuration is selected.
+ */
+static int dwmac1000_validate_ucast_entries(int ucast_entries)
+{
+	int x = ucast_entries;
+
+	switch (x) {
+	case 1 ... 32:
+	case 64:
+	case 128:
+		break;
+	default:
+		x = 1;
+		pr_info("Unicast table entries set to unexpected value %d\n",
+			ucast_entries);
+		break;
+	}
+	return x;
+}
+
+static int thead_dwmac_probe(struct platform_device *pdev)
+{
+	struct plat_stmmacenet_data *plat_dat;
+	struct stmmac_resources stmmac_res;
+	struct thead_dwmac_priv_data *thead_plat_dat;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	thead_plat_dat = devm_kzalloc(dev, sizeof(*thead_plat_dat), GFP_KERNEL);
+	if (thead_plat_dat == NULL) {
+		dev_err(&pdev->dev, "allocate memory failed\n");
+		return -ENOMEM;
+	}
+
+	ret = stmmac_get_platform_resources(pdev, &stmmac_res);
+	if (ret)
+		return ret;
+
+	if (pdev->dev.of_node) {
+		plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
+		if (IS_ERR(plat_dat)) {
+			dev_err(&pdev->dev, "dt configuration failed\n");
+			return PTR_ERR(plat_dat);
+		}
+	} else {
+		plat_dat = dev_get_platdata(&pdev->dev);
+		if (!plat_dat) {
+			dev_err(&pdev->dev, "no platform data provided\n");
+			return  -EINVAL;
+		}
+
+		/* Set default value for multicast hash bins */
+		plat_dat->multicast_filter_bins = HASH_TABLE_SIZE;
+
+		/* Set default value for unicast filter entries */
+		plat_dat->unicast_filter_entries = 1;
+	}
+
+	/* Custom initialisation (if needed) */
+	if (plat_dat->init) {
+		ret = plat_dat->init(pdev, plat_dat->bsp_priv);
+		if (ret)
+			goto err_remove_config_dt;
+	}
+
+	/* populate bsp private data */
+	plat_dat->bsp_priv = thead_plat_dat;
+	plat_dat->fix_mac_speed = thead_dwmac_fix_speed;
+	of_property_read_u32(np, "max-frame-size", &plat_dat->maxmtu);
+	of_property_read_u32(np, "snps,multicast-filter-bins",
+			     &plat_dat->multicast_filter_bins);
+	of_property_read_u32(np, "snps,perfect-filter-entries",
+			     &plat_dat->unicast_filter_entries);
+	plat_dat->unicast_filter_entries = dwmac1000_validate_ucast_entries(
+				       plat_dat->unicast_filter_entries);
+	plat_dat->multicast_filter_bins = dwmac1000_validate_mcast_bins(
+				      plat_dat->multicast_filter_bins);
+	plat_dat->has_gmac = 1;
+	plat_dat->pmt = 1;
+
+	ret = thead_dwmac_init(pdev, plat_dat->bsp_priv);
+	if (ret)
+		goto err_exit;
+
+	ret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);
+	if (ret)
+		goto err_exit;
+
+	return 0;
+
+err_exit:
+	if (plat_dat->exit)
+		plat_dat->exit(pdev, plat_dat->bsp_priv);
+err_remove_config_dt:
+	if (pdev->dev.of_node)
+		stmmac_remove_config_dt(pdev, plat_dat);
+
+	return ret;
+}
+
+static const struct of_device_id thead_dwmac_match[] = {
+	{ .compatible = "thead,dwmac"},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, thead_dwmac_match);
+
+static struct platform_driver thead_dwmac_driver = {
+	.probe  = thead_dwmac_probe,
+	.remove = stmmac_pltfr_remove,
+	.driver = {
+		.name           = "thead_dwmac_eth",
+		.pm		= &stmmac_pltfr_pm_ops,
+		.of_match_table = of_match_ptr(thead_dwmac_match),
+	},
+};
+module_platform_driver(thead_dwmac_driver);
+
+MODULE_DESCRIPTION("T-HEAD dwmac driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
index f02ce09020fb..d6a04ed9b698 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
@@ -516,6 +516,19 @@ stmmac_probe_config_dt(struct platform_device *pdev, const char **mac)
 		plat->pmt = 1;
 	}
 
+	if (of_device_is_compatible(np, "cvitek,ethernet")) {
+		of_property_read_u32(np, "snps,multicast-filter-bins",
+				     &plat->multicast_filter_bins);
+		of_property_read_u32(np, "snps,perfect-filter-entries",
+				     &plat->unicast_filter_entries);
+		plat->unicast_filter_entries = dwmac1000_validate_ucast_entries(&pdev->dev, plat->unicast_filter_entries);
+		plat->multicast_filter_bins = dwmac1000_validate_mcast_bins(&pdev->dev, plat->multicast_filter_bins);
+		plat->has_gmac4 = 0;
+		plat->has_gmac = 1;
+		plat->tso_en = 0;
+		plat->pmt = 0;
+	}
+
 	if (of_device_is_compatible(np, "snps,dwmac-4.00") ||
 	    of_device_is_compatible(np, "snps,dwmac-4.10a") ||
 	    of_device_is_compatible(np, "snps,dwmac-4.20a") ||
diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c
index 6c95bbdf9265..55aea5206e59 100644
--- a/drivers/of/of_reserved_mem.c
+++ b/drivers/of/of_reserved_mem.c
@@ -23,6 +23,16 @@
 #include <linux/memblock.h>
 
 #define MAX_RESERVED_REGIONS	64
+
+#if defined(CONFIG_ARCH_CVITEK)
+struct reserved_mem_size_entry {
+	char *uname;
+	phys_addr_t size;
+};
+static struct reserved_mem_size_entry reserved_mem_size_array[MAX_RESERVED_REGIONS];
+static int reserved_mem_size_entry_count;
+#endif
+
 static struct reserved_mem reserved_mem[MAX_RESERVED_REGIONS];
 static int reserved_mem_count;
 
@@ -81,6 +91,9 @@ static int __init __reserved_mem_alloc_size(unsigned long node,
 	const __be32 *prop;
 	bool nomap;
 	int ret;
+#if defined(CONFIG_ARCH_CVITEK)
+	int i;
+#endif
 
 	prop = of_get_flat_dt_prop(node, "size", &len);
 	if (!prop)
@@ -91,6 +104,18 @@ static int __init __reserved_mem_alloc_size(unsigned long node,
 		return -EINVAL;
 	}
 	size = dt_mem_next_cell(dt_root_size_cells, &prop);
+#if defined(CONFIG_ARCH_CVITEK)
+	for (i = 0; i < reserved_mem_size_entry_count; i++) {
+		if (!strcmp(uname, reserved_mem_size_array[i].uname)) {
+			pr_info("fix reserved-memory item %s from bootargs\n", reserved_mem_size_array[i].uname);
+
+			pr_info("old size=%pa, new size=%pa\n", &size, &reserved_mem_size_array[i].size);
+
+			size = reserved_mem_size_array[i].size;
+			break;
+		}
+	}
+#endif
 
 	prop = of_get_flat_dt_prop(node, "alignment", &len);
 	if (prop) {
@@ -161,6 +186,82 @@ static int __init __reserved_mem_alloc_size(unsigned long node,
 	return 0;
 }
 
+#if defined(CONFIG_ARCH_CVITEK)
+static char *next_arg_separator(char *args, char **param, char **val, char separator)
+{
+	unsigned int i, equals = 0;
+	int in_quote = 0, quoted = 0;
+	char *next;
+
+	if (*args == '"') {
+		args++;
+		in_quote = 1;
+		quoted = 1;
+	}
+
+	for (i = 0; args[i]; i++) {
+		if (args[i] == separator && !in_quote)
+			break;
+		if (equals == 0) {
+			if (args[i] == '=')
+				equals = i;
+		}
+		if (args[i] == '"')
+			in_quote = !in_quote;
+	}
+
+	*param = args;
+	if (!equals)
+		*val = NULL;
+	else {
+		args[equals] = '\0';
+		*val = args + equals + 1;
+
+		/* Don't include quotes in value. */
+		if (**val == '"') {
+			(*val)++;
+			if (args[i-1] == '"')
+				args[i-1] = '\0';
+		}
+	}
+	if (quoted && args[i-1] == '"')
+		args[i-1] = '\0';
+
+	if (args[i]) {
+		args[i] = '\0';
+		next = args + i + 1;
+	} else
+		next = args + i;
+
+	/* Chew up trailing spaces. */
+	return skip_spaces(next);
+}
+
+
+static int __init early_reserved_size(char *args)
+{
+	char *param, *size;
+	u64 u64_size;
+
+	pr_debug("%s args is %s\n", __func__, args);
+
+	while (*args) {
+		args = next_arg_separator(args, &param, &size, ':');
+		reserved_mem_size_array[reserved_mem_size_entry_count].uname = param;
+		kstrtou64(size, 16, &u64_size);
+		reserved_mem_size_array[reserved_mem_size_entry_count].size = u64_size;
+		reserved_mem_size_entry_count++;
+
+		pr_debug("%s, parsed %s", __func__, param);
+
+		pr_debug(" val=%pa\n", &reserved_mem_size_array[reserved_mem_size_entry_count - 1].size);
+	}
+
+	return 0;
+}
+early_param("reserved_mem_size", early_reserved_size);
+#endif
+
 static const struct of_device_id __rmem_of_table_sentinel
 	__used __section("__reservedmem_of_table_end");
 
@@ -356,8 +457,8 @@ int of_reserved_mem_device_init_by_idx(struct device *dev,
 		mutex_lock(&of_rmem_assigned_device_mutex);
 		list_add(&rd->list, &of_rmem_assigned_device_list);
 		mutex_unlock(&of_rmem_assigned_device_mutex);
-
-		dev_info(dev, "assigned reserved memory node %s\n", rmem->name);
+		// FIXME: dmesg -n 8
+		//dev_info(dev, "assigned reserved memory node %s\n", rmem->name);
 	} else {
 		kfree(rd);
 	}
diff --git a/drivers/perf/Makefile b/drivers/perf/Makefile
index 5365fd56f88f..e4edaec4852e 100644
--- a/drivers/perf/Makefile
+++ b/drivers/perf/Makefile
@@ -1,4 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_RISCV) += thead_c900_pmu.o
 obj-$(CONFIG_ARM_CCI_PMU) += arm-cci.o
 obj-$(CONFIG_ARM_CCN) += arm-ccn.o
 obj-$(CONFIG_ARM_CMN) += arm-cmn.o
@@ -13,3 +14,4 @@ obj-$(CONFIG_QCOM_L3_PMU) += qcom_l3_pmu.o
 obj-$(CONFIG_THUNDERX2_PMU) += thunderx2_pmu.o
 obj-$(CONFIG_XGENE_PMU) += xgene_pmu.o
 obj-$(CONFIG_ARM_SPE_PMU) += arm_spe_pmu.o
+obj-$(CONFIG_RISCV) += thead_c900_pmu_v1.o
diff --git a/drivers/perf/thead_c900_pmu.c b/drivers/perf/thead_c900_pmu.c
new file mode 100644
index 000000000000..03fdaa121127
--- /dev/null
+++ b/drivers/perf/thead_c900_pmu.c
@@ -0,0 +1,754 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/perf_event.h>
+#include <linux/platform_device.h>
+#include <linux/smp.h>
+#include <asm/sbi.h>
+
+#define MAX_COUNTERS		32
+
+/*
+ * Counter Enable register
+ */
+#define SCOUNTEREN		0x106
+
+/*
+ * Counter inhibit register
+ */
+#define SCOUNTINHIBIT		0x5c8
+
+/*
+ * 11: PMDS - rw, Performance monitor disable S-mode counting
+ * 10: PMDU - rw, Performance monitor disable U-mode counting
+ */
+#define SXSTATUS		0x5c0
+
+/*
+ * Overflow interrupt enable & status register
+ */
+#define SCOUNTERINTEN		0x5c4
+#define SCOUNTEROF		0x5c5
+
+/*
+ * 63: TS - rw, status of trigger
+ * 13: PMDM - ro, Performance monitor disable machine mode counting
+ * 11: PMDS - rw, Performance monitor disable supervisor mode counting
+ * 10: PMDU - rw, Performance monitor disable user mode counting
+ * 0-1: TME - Trigger Mode, 2'b00 trigger disabled, 2'b01 triger enable
+ */
+#define SHPMCR			0x5c9
+
+/*
+ * Start/End trigger register
+ */
+#define SHPMSP			0x5ca
+#define SHPMEP			0x5cb
+
+#define SHPMCOUNTER0		0x5e0
+
+struct pmu_hw_events {
+	struct perf_event	*events[MAX_COUNTERS];
+	DECLARE_BITMAP(used_mask, MAX_COUNTERS);
+};
+
+static struct thead_pmu_t {
+	struct pmu			pmu;
+	struct pmu_hw_events __percpu	*hw_events;
+	struct platform_device		*plat_device;
+	unsigned long			max_period;
+	int				irq;
+} thead_pmu;
+
+/*
+ * Hardware events
+ */
+#define EVENT_NONE				0
+#define EVENT_L1_ICACHE_ACCESS			1
+#define EVENT_L1_ICACHE_MISS			2
+#define EVENT_ITLB_MISS				3
+#define EVENT_DTLB_MISS				4
+#define EVENT_JTLB_MISS				5
+#define EVENT_BRANCH_MISS			6
+#define EVENT_BRANCH				7
+#define EVENT_INDIRECT_BRANCH_MISS		8
+#define EVENT_INDIRECT_BRANCH			9
+#define EVENT_LSU_SPEC_FAIL			10
+#define EVENT_STORE_INSTRUCTION			11
+#define EVENT_L1_DCACHE_LOAD_ACCESS		12
+#define EVENT_L1_DCACHE_LOAD_MISS		13
+#define EVENT_L1_DCACHE_STORE_ACCESS		14
+#define EVENT_L1_DCACHE_STORE_MISS		15
+#define EVENT_L2_LOAD_ACCESS			16
+#define EVENT_L2_LOAD_MISS			17
+#define EVENT_L2_STORE_ACCESS			18
+#define EVENT_L2_STORE_MISS			19
+#define EVENT_RF_LAUNCH_FAIL			20
+#define EVENT_RF_REG_LAUNCH_FAIL		21
+#define EVENT_RF_INSTRUCTION			22
+#define EVENT_LSU_CROSS_4K_STALL		23
+#define EVENT_LSU_OTHER_STALL			24
+#define EVENT_LSU_SQ_DISCARD			25
+#define EVENT_LSU_SQ_DATA_DISCARD		26
+#define EVENT_IFU_BRANCH_TARGET_MISPRED		27
+#define EVENT_IFU_BRANCH_TARGET_INSTRUCTION	28
+#define EVENT_ALU_INSTRUCTION			29
+#define EVENT_LDST_INSTRUCTION			30
+#define EVENT_VECTOR_SIMD_INSTRUCTION		31
+#define EVENT_CSR_INSTRUCTION			32
+#define EVENT_SYNC_INSTRUCTION			33
+#define EVENT_LDST_UNALIGNED_ACCESS		34
+#define EVENT_INTERRUPT_NUMBER			35
+#define EVENT_INTERRUPT_OFF_CYCLE		36
+#define EVENT_ENVIRONMENT_CALL			37
+#define EVENT_LONG_JUMP				38
+#define EVENT_STALLED_CYCLES_FRONTEND		39
+#define EVENT_STALLED_CYCLES_BACKEND		40
+#define EVENT_SYNC_STALL			41
+#define EVENT_FLOAT_POINT_INSTRUCTION		42
+
+static const int hw_event_map[] = {
+	[PERF_COUNT_HW_CPU_CYCLES]			= -EOPNOTSUPP,
+	[PERF_COUNT_HW_INSTRUCTIONS]			= -EOPNOTSUPP,
+	[PERF_COUNT_HW_CACHE_REFERENCES]		= EVENT_L1_ICACHE_ACCESS,
+	[PERF_COUNT_HW_CACHE_MISSES]			= EVENT_L1_ICACHE_MISS,
+	[PERF_COUNT_HW_BRANCH_INSTRUCTIONS]		= EVENT_BRANCH,
+	[PERF_COUNT_HW_BRANCH_MISSES]			= EVENT_BRANCH_MISS,
+	[PERF_COUNT_HW_BUS_CYCLES]			= -EOPNOTSUPP,
+	[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND]		= EVENT_STALLED_CYCLES_FRONTEND,
+	[PERF_COUNT_HW_STALLED_CYCLES_BACKEND]		= EVENT_STALLED_CYCLES_BACKEND,
+	[PERF_COUNT_HW_REF_CPU_CYCLES]			= -EOPNOTSUPP,
+};
+
+#define C(x) PERF_COUNT_HW_CACHE_##x
+static const int thead_cache_event_map[PERF_COUNT_HW_CACHE_MAX]
+[PERF_COUNT_HW_CACHE_OP_MAX]
+[PERF_COUNT_HW_CACHE_RESULT_MAX] = {
+	[C(L1D)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = EVENT_L1_DCACHE_LOAD_ACCESS,
+			[C(RESULT_MISS)] = EVENT_L1_DCACHE_LOAD_MISS,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = EVENT_L1_DCACHE_STORE_ACCESS,
+			[C(RESULT_MISS)] = EVENT_L1_DCACHE_STORE_MISS,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = -EOPNOTSUPP,
+			[C(RESULT_MISS)] = -EOPNOTSUPP,
+		},
+	},
+	[C(L1I)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = EVENT_L1_ICACHE_ACCESS,
+			[C(RESULT_MISS)] = EVENT_L1_ICACHE_MISS,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = -EOPNOTSUPP,
+			[C(RESULT_MISS)] = -EOPNOTSUPP,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = -EOPNOTSUPP,
+			[C(RESULT_MISS)] = -EOPNOTSUPP,
+		},
+	},
+	[C(LL)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = EVENT_L2_LOAD_ACCESS,
+			[C(RESULT_MISS)] = EVENT_L2_LOAD_MISS,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = EVENT_L2_STORE_ACCESS,
+			[C(RESULT_MISS)] = EVENT_L2_STORE_MISS,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = -EOPNOTSUPP,
+			[C(RESULT_MISS)] = -EOPNOTSUPP,
+		},
+	},
+	[C(DTLB)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = EVENT_L1_DCACHE_LOAD_ACCESS,
+			[C(RESULT_MISS)] = EVENT_DTLB_MISS,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = EVENT_L1_DCACHE_STORE_ACCESS,
+			[C(RESULT_MISS)] = EVENT_DTLB_MISS,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = -EOPNOTSUPP,
+			[C(RESULT_MISS)] = -EOPNOTSUPP,
+		},
+	},
+	[C(ITLB)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = EVENT_L1_ICACHE_ACCESS,
+			[C(RESULT_MISS)] = EVENT_ITLB_MISS,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = -EOPNOTSUPP,
+			[C(RESULT_MISS)] = -EOPNOTSUPP,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = -EOPNOTSUPP,
+			[C(RESULT_MISS)] = -EOPNOTSUPP,
+		},
+	},
+	[C(BPU)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = -EOPNOTSUPP,
+			[C(RESULT_MISS)] = -EOPNOTSUPP,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = -EOPNOTSUPP,
+			[C(RESULT_MISS)] = -EOPNOTSUPP,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = -EOPNOTSUPP,
+			[C(RESULT_MISS)] = -EOPNOTSUPP,
+		},
+	},
+	[C(NODE)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = -EOPNOTSUPP,
+			[C(RESULT_MISS)] = -EOPNOTSUPP,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = -EOPNOTSUPP,
+			[C(RESULT_MISS)] = -EOPNOTSUPP,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = -EOPNOTSUPP,
+			[C(RESULT_MISS)] = -EOPNOTSUPP,
+		},
+	},
+};
+
+#define RW_COUNTER(idx, value, is_write) \
+	if (is_write) { \
+		csr_write(SHPMCOUNTER0 + idx, value); \
+		return 0; \
+	} else \
+		return csr_read(SHPMCOUNTER0 + idx);
+
+static inline u64 rw_counter(int idx, u64 value, bool is_write)
+{
+	switch (idx) {
+	case 0:
+		RW_COUNTER(0, value, is_write);
+	case 1:
+		return -EINVAL;
+	case 2:
+		RW_COUNTER(2, value, is_write);
+	case 3:
+		RW_COUNTER(3, value, is_write);
+	case 4:
+		RW_COUNTER(4, value, is_write);
+	case 5:
+		RW_COUNTER(5, value, is_write);
+	case 6:
+		RW_COUNTER(6, value, is_write);
+	case 7:
+		RW_COUNTER(7, value, is_write);
+	case 8:
+		RW_COUNTER(8, value, is_write);
+	case 9:
+		RW_COUNTER(9, value, is_write);
+	case 10:
+		RW_COUNTER(10, value, is_write);
+	case 11:
+		RW_COUNTER(11, value, is_write);
+	case 12:
+		RW_COUNTER(12, value, is_write);
+	case 13:
+		RW_COUNTER(13, value, is_write);
+	case 14:
+		RW_COUNTER(14, value, is_write);
+	case 15:
+		RW_COUNTER(15, value, is_write);
+	case 16:
+		RW_COUNTER(16, value, is_write);
+	case 17:
+		RW_COUNTER(17, value, is_write);
+	case 18:
+		RW_COUNTER(18, value, is_write);
+	case 19:
+		RW_COUNTER(19, value, is_write);
+	case 20:
+		RW_COUNTER(20, value, is_write);
+	case 21:
+		RW_COUNTER(21, value, is_write);
+	case 22:
+		RW_COUNTER(22, value, is_write);
+	case 23:
+		RW_COUNTER(23, value, is_write);
+	case 24:
+		RW_COUNTER(24, value, is_write);
+	case 25:
+		RW_COUNTER(25, value, is_write);
+	case 26:
+		RW_COUNTER(26, value, is_write);
+	case 27:
+		RW_COUNTER(27, value, is_write);
+	case 28:
+		RW_COUNTER(28, value, is_write);
+	case 29:
+		RW_COUNTER(29, value, is_write);
+	case 30:
+		RW_COUNTER(30, value, is_write);
+	case 31:
+		RW_COUNTER(31, value, is_write);
+	}
+
+	return -EINVAL;
+}
+
+static int thead_pmu_event_set_period(struct perf_event *event)
+{
+	struct hw_perf_event *hwc = &event->hw;
+	s64 left = local64_read(&hwc->period_left);
+	s64 period = hwc->sample_period;
+	int ret = 0;
+
+	if (period < 4096 && period != 0 && (
+	    hwc->idx == 0 || hwc->idx == 2 ||
+	    hwc->config_base == EVENT_L1_ICACHE_ACCESS ||
+	    hwc->config_base == EVENT_L1_DCACHE_LOAD_ACCESS ||
+	    hwc->config_base == EVENT_L1_DCACHE_STORE_ACCESS ||
+	    hwc->config_base == EVENT_L2_LOAD_ACCESS ||
+	    hwc->config_base == EVENT_L2_STORE_ACCESS))
+		hwc->sample_period = period = 4096;
+
+	if (unlikely(left <= -period)) {
+		left = period;
+		local64_set(&hwc->period_left, left);
+		hwc->last_period = period;
+		ret = 1;
+	}
+
+	if (unlikely(left <= 0)) {
+		left += period;
+		local64_set(&hwc->period_left, left);
+		hwc->last_period = period;
+		ret = 1;
+	}
+
+	if (left < 0)
+		left = thead_pmu.max_period;
+
+	local64_set(&hwc->prev_count, (u64)(-left));
+
+	csr_clear(SCOUNTEROF, BIT(hwc->idx));
+
+	rw_counter(hwc->idx, (u64)(-left), true);
+
+	perf_event_update_userpage(event);
+
+	return ret;
+}
+
+static void thead_perf_event_update(struct perf_event *event,
+				   struct hw_perf_event *hwc)
+{
+	uint64_t prev_raw_count = local64_read(&hwc->prev_count);
+	/*
+	 * Sign extend count value to 64bit, otherwise delta calculation
+	 * would be incorrect when overflow occurs.
+	 */
+	uint64_t new_raw_count = rw_counter(hwc->idx, 0, false);
+	int64_t delta = new_raw_count - prev_raw_count;
+
+	/*
+	 * We aren't afraid of hwc->prev_count changing beneath our feet
+	 * because there's no way for us to re-enter this function anytime.
+	 */
+	local64_set(&hwc->prev_count, new_raw_count);
+	local64_add(delta, &event->count);
+	local64_sub(delta, &hwc->period_left);
+}
+
+static void thead_pmu_read(struct perf_event *event)
+{
+	thead_perf_event_update(event, &event->hw);
+}
+
+static int thead_pmu_cache_event(u64 config)
+{
+	unsigned int cache_type, cache_op, cache_result;
+
+	cache_type      = (config >>  0) & 0xff;
+	cache_op	= (config >>  8) & 0xff;
+	cache_result    = (config >> 16) & 0xff;
+
+	if (cache_type >= PERF_COUNT_HW_CACHE_MAX)
+		return -EINVAL;
+	if (cache_op >= PERF_COUNT_HW_CACHE_OP_MAX)
+		return -EINVAL;
+	if (cache_result >= PERF_COUNT_HW_CACHE_RESULT_MAX)
+		return -EINVAL;
+
+	return thead_cache_event_map[cache_type][cache_op][cache_result];
+}
+
+static int thead_pmu_event_init(struct perf_event *event)
+{
+	struct hw_perf_event *hwc = &event->hw;
+	int event_id;
+
+	hwc->idx		= -1;
+	hwc->config_base	= 0;
+	hwc->config		= 0;
+	hwc->event_base		= 0;
+
+	switch (event->attr.type) {
+	case PERF_TYPE_HARDWARE:
+		if (event->attr.config >= PERF_COUNT_HW_MAX)
+			return -ENOENT;
+
+		event_id = hw_event_map[event->attr.config];
+
+		if (event->attr.config == PERF_COUNT_HW_CPU_CYCLES ||
+		    event->attr.config == PERF_COUNT_HW_BUS_CYCLES ||
+		    event->attr.config == PERF_COUNT_HW_REF_CPU_CYCLES) {
+			hwc->idx = 0;
+			hwc->config_base = EVENT_NONE;
+			break;
+		}
+
+		if (event->attr.config == PERF_COUNT_HW_INSTRUCTIONS) {
+			hwc->idx = 2;
+			hwc->config_base = EVENT_NONE;
+			break;
+		}
+
+		break;
+	case PERF_TYPE_HW_CACHE:
+		event_id = thead_pmu_cache_event(event->attr.config);
+		if (event_id == -EOPNOTSUPP)
+			return -ENOENT;
+
+		hwc->config_base = event_id;
+		break;
+	case PERF_TYPE_RAW:
+		event_id = event->attr.config;
+		if (event_id < 0)
+			return -ENOENT;
+
+		hwc->config_base = event_id;
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return 0;
+}
+
+static void thead_pmu_enable(struct pmu *pmu)
+{
+}
+
+static void thead_pmu_disable(struct pmu *pmu)
+{
+}
+
+static void thead_pmu_start(struct perf_event *event, int flags)
+{
+	unsigned long flg;
+	struct hw_perf_event *hwc = &event->hw;
+	int idx = hwc->idx;
+
+	if (WARN_ON_ONCE(idx == -1))
+		return;
+
+	if (flags & PERF_EF_RELOAD)
+		WARN_ON_ONCE(!(hwc->state & PERF_HES_UPTODATE));
+
+	hwc->state = 0;
+
+	thead_pmu_event_set_period(event);
+
+	local_irq_save(flg);
+
+	csr_set(SCOUNTERINTEN, BIT(idx));
+
+	local_irq_restore(flg);
+}
+
+static void thead_pmu_stop_event(struct perf_event *event)
+{
+	unsigned long flg;
+	struct hw_perf_event *hwc = &event->hw;
+	int idx = hwc->idx;
+
+	local_irq_save(flg);
+
+	csr_clear(SCOUNTERINTEN, BIT(idx));
+
+	local_irq_restore(flg);
+}
+
+static void thead_pmu_stop(struct perf_event *event, int flags)
+{
+	if (!(event->hw.state & PERF_HES_STOPPED)) {
+		thead_pmu_stop_event(event);
+		event->hw.state |= PERF_HES_STOPPED;
+	}
+
+	if ((flags & PERF_EF_UPDATE) &&
+	    !(event->hw.state & PERF_HES_UPTODATE)) {
+		thead_perf_event_update(event, &event->hw);
+		event->hw.state |= PERF_HES_UPTODATE;
+	}
+}
+
+static void thead_pmu_del(struct perf_event *event, int flags)
+{
+	struct pmu_hw_events *hw_events = this_cpu_ptr(thead_pmu.hw_events);
+	struct hw_perf_event *hwc = &event->hw;
+	unsigned long *used_mask = hw_events->used_mask;
+
+	thead_pmu_stop(event, PERF_EF_UPDATE);
+
+	hw_events->events[hwc->idx] = NULL;
+
+	if (hwc->config_base != EVENT_NONE) {
+		clear_bit(hwc->idx, used_mask);
+		hwc->idx = -1;
+	}
+
+	perf_event_update_userpage(event);
+}
+
+/* allocate hardware counter and optionally start counting */
+static int thead_pmu_add(struct perf_event *event, int flags)
+{
+	struct pmu_hw_events *hw_events = this_cpu_ptr(thead_pmu.hw_events);
+	struct hw_perf_event *hwc = &event->hw;
+	unsigned long *used_mask = hw_events->used_mask;
+	int idx;
+
+	if (hwc->config_base != EVENT_NONE) {
+		set_bit(0, used_mask);
+		set_bit(1, used_mask);
+		set_bit(2, used_mask);
+
+		idx = find_first_zero_bit(used_mask, MAX_COUNTERS);
+		if (idx == MAX_COUNTERS)
+			return -EAGAIN;
+
+		set_bit(idx, used_mask);
+
+		sbi_ecall(0x09000001, 0, 2, idx, hwc->config_base, 0, 0, 0);
+
+		hwc->idx = idx;
+	}
+
+	hw_events->events[hwc->idx] = event;
+
+	hwc->state = PERF_HES_UPTODATE | PERF_HES_STOPPED;
+
+	if (flags & PERF_EF_START)
+		thead_pmu_start(event, PERF_EF_RELOAD);
+
+	perf_event_update_userpage(event);
+
+	return 0;
+}
+
+static irqreturn_t thead_pmu_handle_irq(int irq, void *dev_id)
+{
+	struct perf_sample_data data;
+	struct pmu_hw_events *cpuc = this_cpu_ptr(thead_pmu.hw_events);
+	struct pt_regs *regs;
+	int idx;
+
+	/*
+	 * Did an overflow occur?
+	 */
+	if (!csr_read(SCOUNTEROF))
+		return IRQ_NONE;
+
+	csr_write(SCOUNTINHIBIT, UINT_MAX);
+
+	/*
+	 * Handle the counter(s) overflow(s)
+	 */
+	regs = get_irq_regs();
+
+	for (idx = 0; idx < MAX_COUNTERS; ++idx) {
+		struct perf_event *event = cpuc->events[idx];
+		struct hw_perf_event *hwc;
+
+		/* Ignore if we don't have an event. */
+		if (!event)
+			continue;
+
+		/*
+		 * We have a single interrupt for all counters. Check that
+		 * each counter has overflowed before we process it.
+		 */
+		if (!(csr_read(SCOUNTEROF) & BIT(idx)))
+			continue;
+
+		hwc = &event->hw;
+		thead_perf_event_update(event, &event->hw);
+		perf_sample_data_init(&data, 0, hwc->last_period);
+		thead_pmu_event_set_period(event);
+
+		if (perf_event_overflow(event, &data, regs))
+			thead_pmu_stop_event(event);
+	}
+
+	csr_write(SCOUNTINHIBIT, 0);
+
+	/*
+	 * Handle the pending perf events.
+	 *
+	 * Note: this call *must* be run with interrupts disabled. For
+	 * platforms that can have the PMU interrupts raised as an NMI, this
+	 * will not work.
+	 */
+	irq_work_run();
+
+	return IRQ_HANDLED;
+}
+
+static int thead_pmu_request_irq(irq_handler_t handler)
+{
+	int err, irqs;
+	struct platform_device *pmu_device = thead_pmu.plat_device;
+
+	if (!pmu_device)
+		return -ENODEV;
+
+	irqs = min(pmu_device->num_resources, num_possible_cpus());
+	if (irqs < 1) {
+		pr_err("no irqs for PMUs defined\n");
+		return -ENODEV;
+	}
+
+	thead_pmu.irq = platform_get_irq(pmu_device, 0);
+	if (thead_pmu.irq < 0)
+		return -ENODEV;
+	err = request_percpu_irq(thead_pmu.irq, handler, "c9xx-pmu-v1", &thead_pmu);
+	if (err) {
+		pr_err("unable to request IRQ%d for c9xx PMU counters\n",
+		       thead_pmu.irq);
+		return err;
+	}
+
+	return 0;
+}
+
+static void thead_pmu_free_irq(void)
+{
+	int irq;
+	struct platform_device *pmu_device = thead_pmu.plat_device;
+
+	irq = platform_get_irq(pmu_device, 0);
+	if (irq >= 0)
+		free_percpu_irq(irq, this_cpu_ptr(thead_pmu.hw_events));
+}
+
+static int init_hw_perf_events(void)
+{
+	thead_pmu.hw_events = alloc_percpu_gfp(struct pmu_hw_events,
+					      GFP_KERNEL);
+	if (!thead_pmu.hw_events) {
+		pr_info("failed to allocate per-cpu PMU data.\n");
+		return -ENOMEM;
+	}
+
+	thead_pmu.pmu = (struct pmu) {
+		.pmu_enable	= thead_pmu_enable,
+		.pmu_disable	= thead_pmu_disable,
+		.event_init	= thead_pmu_event_init,
+		.add		= thead_pmu_add,
+		.del		= thead_pmu_del,
+		.start		= thead_pmu_start,
+		.stop		= thead_pmu_stop,
+		.read		= thead_pmu_read,
+	};
+
+	return 0;
+}
+
+static int thead_pmu_starting_cpu(unsigned int cpu)
+{
+	sbi_ecall(0x09000001, 0, 1, 0, 0, 0, 0, 0);
+
+	enable_percpu_irq(thead_pmu.irq, 0);
+	return 0;
+}
+
+static int thead_pmu_dying_cpu(unsigned int cpu)
+{
+	disable_percpu_irq(thead_pmu.irq);
+	return 0;
+}
+
+static int thead_pmu_device_probe(struct platform_device *pdev,
+			  const struct of_device_id *of_table)
+{
+	int ret;
+
+	ret = init_hw_perf_events();
+	if (ret) {
+		pr_notice("[perf] failed to probe PMU!\n");
+		return ret;
+	}
+	thead_pmu.max_period = ULONG_MAX;
+	thead_pmu.plat_device = pdev;
+
+	ret = thead_pmu_request_irq(thead_pmu_handle_irq);
+	if (ret) {
+		thead_pmu.pmu.capabilities |= PERF_PMU_CAP_NO_INTERRUPT;
+		pr_notice("[perf] PMU request irq fail!\n");
+	}
+
+	ret = cpuhp_setup_state(CPUHP_AP_PERF_ONLINE + 1, "perf thead:online",
+				thead_pmu_starting_cpu,
+				thead_pmu_dying_cpu);
+	if (ret) {
+		thead_pmu_free_irq();
+		free_percpu(thead_pmu.hw_events);
+		return ret;
+	}
+
+	ret = perf_pmu_register(&thead_pmu.pmu, "thead_xt_pmu", PERF_TYPE_RAW);
+	if (ret) {
+		thead_pmu_free_irq();
+		free_percpu(thead_pmu.hw_events);
+	}
+
+	pr_notice("[perf] T-HEAD C900 PMU probed\n");
+
+	return ret;
+}
+
+const static struct of_device_id thead_pmu_of_device_ids[] = {
+	{.compatible = "thead,c900_pmu"},
+	{},
+};
+
+static int thead_pmu_dev_probe(struct platform_device *pdev)
+{
+	return thead_pmu_device_probe(pdev, thead_pmu_of_device_ids);
+}
+
+static struct platform_driver thead_pmu_driver = {
+	.driver = {
+		.name = "thead_c900_pmu",
+		.of_match_table = thead_pmu_of_device_ids,
+	},
+	.probe = thead_pmu_dev_probe,
+};
+
+int __init thead_c900_pmu_probe(void)
+{
+	return platform_driver_register(&thead_pmu_driver);
+}
+device_initcall(thead_c900_pmu_probe);
diff --git a/drivers/perf/thead_c900_pmu_v1.c b/drivers/perf/thead_c900_pmu_v1.c
new file mode 100644
index 000000000000..656e7e0d61b2
--- /dev/null
+++ b/drivers/perf/thead_c900_pmu_v1.c
@@ -0,0 +1,800 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (C) 2018 Hangzhou C-SKY Microsystems co.,ltd. */
+
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/perf_event.h>
+#include <linux/platform_device.h>
+#include <linux/smp.h>
+#include <asm/sbi.h>
+
+#define RISCV_MAX_COUNTERS	32
+#define RISCV_OP_UNSUPP		(-EOPNOTSUPP)
+
+#define RISCV_PMU_CYCLE		0
+#define RISCV_PMU_TIME		1
+#define RISCV_PMU_INSTRET	2
+#define RISCV_PMU_L1ICAC	3	/* ICache Access */
+#define RISCV_PMU_L1ICMC	4	/* ICache Miss */
+#define RISCV_PMU_IUTLBMC	5	/* I-UTLB Miss */
+#define RISCV_PMU_DUTLBMC	6	/* D-UTLB Miss */
+#define RISCV_PMU_JTLBMC	7	/* JTLB Miss Counter */
+
+#define RISCV_PMU_CBMC		8	/* Cond-br-mispredict */
+#define RISCV_PMU_CBIC		9	/* Cond-br-instruction */
+#define RISCV_PMU_IBMC		10	/* Indirect Branch Mispredict */
+#define RISCV_PMU_IBIC		11	/* Indirect Branch Instruction */
+#define RISCV_PMU_LSUSFC	12	/* LSU Spec Fail */
+#define RISCV_PMU_STC		13	/* Store Instruction */
+
+#define RISCV_PMU_L1DCRAC	14	/* L1 DCache Read Access */
+#define RISCV_PMU_L1DCRMC	15	/* L1 DCache Read Miss */
+#define RISCV_PMU_L1DCWAC	16	/* L1 DCache Write Access */
+#define RISCV_PMU_L1DCWMC	17	/* L1 DCache Write Miss */
+
+#define RISCV_PMU_L2CRAC	18	/* L2 Cache Read Access */
+#define RISCV_PMU_L2CRMC	19	/* L2 Cache Read Miss */
+#define RISCV_PMU_L2CWAC	20	/* L2 Cache Write Access */
+#define RISCV_PMU_L2CWMC	21	/* L2 Cache Write Miss */
+
+#define RISCV_PMU_RFLFC		22	/* RF Launch Fail */
+#define RISCV_PMU_RFRLFC	23	/* RF Reg Launch Fail */
+#define RISCV_PMU_RFIC		24	/* RF Instruction */
+
+#define RISCV_PMU_LSUC4SC	25	/* LSU Cross 4K Stall */
+#define RISCV_PMU_LSUOSC	26	/* LSU Other Stall */
+#define RISCV_PMU_LSUSQDC	27	/* LSU SQ Discard */
+#define RISCV_PMU_LSUSQDDC	28	/* LSU SQ Data Discard */
+
+#define SCOUNTERINTEN		0x5c4
+#define SCOUNTEROF		0x5c5
+#define SCOUNTERBASE		0x5e0
+
+#define WRITE_COUNTER(idx, value) \
+		csr_write(SCOUNTERBASE + idx, value)
+
+/* The events for a given PMU register set. */
+struct pmu_hw_events {
+	/*
+	 * The events that are active on the PMU for the given index.
+	 */
+	struct perf_event *events[RISCV_MAX_COUNTERS];
+
+	/*
+	 * A 1 bit for an index indicates that the counter is being used for
+	 * an event. A 0 means that the counter can be used.
+	 */
+	unsigned long used_mask[BITS_TO_LONGS(RISCV_MAX_COUNTERS)];
+};
+
+static struct riscv_pmu_t {
+	struct pmu		      pmu;
+	struct pmu_hw_events __percpu   *hw_events;
+	struct platform_device	  *plat_device;
+	u64			     max_period;
+} riscv_pmu;
+
+static int riscv_pmu_irq;
+
+/*
+ * Hardware & cache maps and their methods
+ */
+
+static const int riscv_hw_event_map[] = {
+	[PERF_COUNT_HW_CPU_CYCLES]			= RISCV_PMU_CYCLE,
+	[PERF_COUNT_HW_INSTRUCTIONS]			= RISCV_PMU_INSTRET,
+
+	[PERF_COUNT_HW_CACHE_REFERENCES]		= RISCV_PMU_L1ICAC,
+	[PERF_COUNT_HW_CACHE_MISSES]			= RISCV_PMU_L1ICMC,
+
+	[PERF_COUNT_HW_BRANCH_INSTRUCTIONS]		= RISCV_PMU_CBIC,
+	[PERF_COUNT_HW_BRANCH_MISSES]			= RISCV_PMU_CBMC,
+
+	[PERF_COUNT_HW_BUS_CYCLES]			= RISCV_PMU_IBMC,
+	[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND]		= RISCV_PMU_IBIC,
+	[PERF_COUNT_HW_STALLED_CYCLES_BACKEND]		= RISCV_PMU_LSUSFC,
+	[PERF_COUNT_HW_REF_CPU_CYCLES]			= RISCV_PMU_STC,
+};
+
+#define C(x) PERF_COUNT_HW_CACHE_##x
+static const int riscv_cache_event_map[PERF_COUNT_HW_CACHE_MAX]
+[PERF_COUNT_HW_CACHE_OP_MAX]
+[PERF_COUNT_HW_CACHE_RESULT_MAX] = {
+	[C(L1D)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = RISCV_PMU_L1DCRAC,
+			[C(RESULT_MISS)] = RISCV_PMU_L1DCRMC,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = RISCV_PMU_L1DCWAC,
+			[C(RESULT_MISS)] = RISCV_PMU_L1DCWMC,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+	},
+	[C(L1I)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+	},
+	[C(LL)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = RISCV_PMU_L2CRAC,
+			[C(RESULT_MISS)] = RISCV_PMU_L2CRMC,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = RISCV_PMU_L2CWAC,
+			[C(RESULT_MISS)] = RISCV_PMU_L2CWMC,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+	},
+	[C(DTLB)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+	},
+	[C(ITLB)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+	},
+	[C(BPU)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+	},
+	[C(NODE)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = RISCV_OP_UNSUPP,
+			[C(RESULT_MISS)] = RISCV_OP_UNSUPP,
+		},
+	},
+};
+
+/*
+ * Low-level functions: reading/writing counters
+ */
+static inline u64 read_counter(int idx)
+{
+	u64 val = 0;
+
+	switch (idx) {
+	case RISCV_PMU_CYCLE:
+		val = csr_read(cycle);
+		break;
+	case RISCV_PMU_INSTRET:
+		val = csr_read(instret);
+		break;
+	case RISCV_PMU_L1ICAC:
+		val = csr_read(hpmcounter3);
+		break;
+	case RISCV_PMU_L1ICMC:
+		val = csr_read(hpmcounter4);
+		break;
+	case RISCV_PMU_IUTLBMC:
+		val = csr_read(hpmcounter5);
+		break;
+	case RISCV_PMU_DUTLBMC:
+		val = csr_read(hpmcounter6);
+		break;
+	case RISCV_PMU_JTLBMC:
+		val = csr_read(hpmcounter7);
+		break;
+	case RISCV_PMU_CBMC:
+		val = csr_read(hpmcounter8);
+		break;
+	case RISCV_PMU_CBIC:
+		val = csr_read(hpmcounter9);
+		break;
+	case RISCV_PMU_IBMC:
+		val = csr_read(hpmcounter10);
+		break;
+	case RISCV_PMU_IBIC:
+		val = csr_read(hpmcounter11);
+		break;
+	case RISCV_PMU_LSUSFC:
+		val = csr_read(hpmcounter12);
+		break;
+	case RISCV_PMU_STC:
+		val = csr_read(hpmcounter13);
+		break;
+	case RISCV_PMU_L1DCRAC:
+		val = csr_read(hpmcounter14);
+		break;
+	case RISCV_PMU_L1DCRMC:
+		val = csr_read(hpmcounter15);
+		break;
+	case RISCV_PMU_L1DCWAC:
+		val = csr_read(hpmcounter16);
+		break;
+	case RISCV_PMU_L1DCWMC:
+		val = csr_read(hpmcounter17);
+		break;
+	case RISCV_PMU_L2CRAC:
+		val = csr_read(hpmcounter18);
+		break;
+	case RISCV_PMU_L2CRMC:
+		val = csr_read(hpmcounter19);
+		break;
+	case RISCV_PMU_L2CWAC:
+		val = csr_read(hpmcounter20);
+		break;
+	case RISCV_PMU_L2CWMC:
+		val = csr_read(hpmcounter21);
+		break;
+	case RISCV_PMU_RFLFC:
+		val = csr_read(hpmcounter22);
+		break;
+	case RISCV_PMU_RFRLFC:
+		val = csr_read(hpmcounter23);
+		break;
+	case RISCV_PMU_RFIC:
+		val = csr_read(hpmcounter24);
+		break;
+	case RISCV_PMU_LSUC4SC:
+		val = csr_read(hpmcounter25);
+		break;
+	case RISCV_PMU_LSUOSC:
+		val = csr_read(hpmcounter26);
+		break;
+	case RISCV_PMU_LSUSQDC:
+		val = csr_read(hpmcounter27);
+		break;
+	case RISCV_PMU_LSUSQDDC:
+		val = csr_read(hpmcounter28);
+		break;
+	default:
+		WARN_ON_ONCE(idx < 0 ||	idx > RISCV_MAX_COUNTERS);
+		return -EINVAL;
+	}
+
+	return val;
+}
+
+static inline void write_counter(int idx, u64 value)
+{
+	switch (idx) {
+	case RISCV_PMU_CYCLE:
+		WRITE_COUNTER(RISCV_PMU_CYCLE, value);
+		break;
+	case RISCV_PMU_INSTRET:
+		WRITE_COUNTER(RISCV_PMU_INSTRET, value);
+		break;
+	case RISCV_PMU_L1ICAC:
+		WRITE_COUNTER(RISCV_PMU_L1ICAC, value);
+		break;
+	case RISCV_PMU_L1ICMC:
+		WRITE_COUNTER(RISCV_PMU_L1ICMC, value);
+		break;
+	case RISCV_PMU_IUTLBMC:
+		WRITE_COUNTER(RISCV_PMU_IUTLBMC, value);
+		break;
+	case RISCV_PMU_DUTLBMC:
+		WRITE_COUNTER(RISCV_PMU_DUTLBMC, value);
+		break;
+	case RISCV_PMU_JTLBMC:
+		WRITE_COUNTER(RISCV_PMU_JTLBMC, value);
+		break;
+	case RISCV_PMU_CBMC:
+		WRITE_COUNTER(RISCV_PMU_CBMC, value);
+		break;
+	case RISCV_PMU_CBIC:
+		WRITE_COUNTER(RISCV_PMU_CBIC, value);
+		break;
+	case RISCV_PMU_IBMC:
+		WRITE_COUNTER(RISCV_PMU_IBMC, value);
+		break;
+	case RISCV_PMU_IBIC:
+		WRITE_COUNTER(RISCV_PMU_IBIC, value);
+		break;
+	case RISCV_PMU_LSUSFC:
+		WRITE_COUNTER(RISCV_PMU_LSUSFC, value);
+		break;
+	case RISCV_PMU_STC:
+		WRITE_COUNTER(RISCV_PMU_STC, value);
+		break;
+	case RISCV_PMU_L1DCRAC:
+		WRITE_COUNTER(RISCV_PMU_L1DCRAC, value);
+		break;
+	case RISCV_PMU_L1DCRMC:
+		WRITE_COUNTER(RISCV_PMU_L1DCRMC, value);
+		break;
+	case RISCV_PMU_L1DCWAC:
+		WRITE_COUNTER(RISCV_PMU_L1DCWAC, value);
+		break;
+	case RISCV_PMU_L1DCWMC:
+		WRITE_COUNTER(RISCV_PMU_L1DCWMC, value);
+		break;
+	case RISCV_PMU_L2CRAC:
+		WRITE_COUNTER(RISCV_PMU_L2CRAC, value);
+		break;
+	case RISCV_PMU_L2CRMC:
+		WRITE_COUNTER(RISCV_PMU_L2CRMC, value);
+		break;
+	case RISCV_PMU_L2CWAC:
+		WRITE_COUNTER(RISCV_PMU_L2CWAC, value);
+		break;
+	case RISCV_PMU_L2CWMC:
+		WRITE_COUNTER(RISCV_PMU_L2CWMC, value);
+		break;
+	case RISCV_PMU_RFLFC:
+		WRITE_COUNTER(RISCV_PMU_RFLFC, value);
+		break;
+	case RISCV_PMU_RFRLFC:
+		WRITE_COUNTER(RISCV_PMU_RFRLFC, value);
+		break;
+	case RISCV_PMU_RFIC:
+		WRITE_COUNTER(RISCV_PMU_RFIC, value);
+		break;
+	case RISCV_PMU_LSUC4SC:
+		WRITE_COUNTER(RISCV_PMU_LSUC4SC, value);
+		break;
+	case RISCV_PMU_LSUOSC:
+		WRITE_COUNTER(RISCV_PMU_LSUOSC, value);
+		break;
+	case RISCV_PMU_LSUSQDC:
+		WRITE_COUNTER(RISCV_PMU_LSUSQDC, value);
+		break;
+	case RISCV_PMU_LSUSQDDC:
+		WRITE_COUNTER(RISCV_PMU_LSUSQDDC, value);
+		break;
+	default:
+		WARN_ON_ONCE(idx < 0 ||	idx > RISCV_MAX_COUNTERS);
+	}
+}
+
+static int riscv_pmu_event_is_frequent(int idx)
+{
+	return  idx >= RISCV_PMU_CYCLE &&
+		idx <= RISCV_PMU_L1DCWMC;
+}
+
+static int riscv_pmu_event_set_period(struct perf_event *event)
+{
+	struct hw_perf_event *hwc = &event->hw;
+	s64 left = local64_read(&hwc->period_left);
+	s64 period = hwc->sample_period;
+	int ret = 0;
+
+	if (period < 4096 && period != 0 &&
+	    riscv_pmu_event_is_frequent(hwc->idx)) {
+		hwc->sample_period = period = 4096;
+	}
+
+	if (unlikely(left <= -period)) {
+		left = period;
+		local64_set(&hwc->period_left, left);
+		hwc->last_period = period;
+		ret = 1;
+	}
+
+	if (unlikely(left <= 0)) {
+		left += period;
+		local64_set(&hwc->period_left, left);
+		hwc->last_period = period;
+		ret = 1;
+	}
+
+	if (left < 0)
+		left = riscv_pmu.max_period;
+
+	/*
+	 * The hw event starts counting from this event offset,
+	 * mark it to be able to extract future "deltas":
+	 */
+	local64_set(&hwc->prev_count, (u64)(-left));
+	csr_write(SCOUNTEROF, csr_read(SCOUNTEROF) & ~BIT(hwc->idx));
+	write_counter(hwc->idx, (u64)(-left));
+
+	perf_event_update_userpage(event);
+
+	return ret;
+}
+
+static void riscv_perf_event_update(struct perf_event *event,
+				   struct hw_perf_event *hwc)
+{
+	uint64_t prev_raw_count = local64_read(&hwc->prev_count);
+	/*
+	 * Sign extend count value to 64bit, otherwise delta calculation
+	 * would be incorrect when overflow occurs.
+	 */
+	uint64_t new_raw_count = read_counter(hwc->idx);
+	int64_t delta = new_raw_count - prev_raw_count;
+
+	/*
+	 * We aren't afraid of hwc->prev_count changing beneath our feet
+	 * because there's no way for us to re-enter this function anytime.
+	 */
+	local64_set(&hwc->prev_count, new_raw_count);
+	local64_add(delta, &event->count);
+	local64_sub(delta, &hwc->period_left);
+}
+
+static void riscv_pmu_read(struct perf_event *event)
+{
+	riscv_perf_event_update(event, &event->hw);
+}
+
+static int riscv_pmu_cache_event(u64 config)
+{
+	unsigned int cache_type, cache_op, cache_result;
+
+	cache_type      = (config >>  0) & 0xff;
+	cache_op	= (config >>  8) & 0xff;
+	cache_result    = (config >> 16) & 0xff;
+
+	if (cache_type >= PERF_COUNT_HW_CACHE_MAX)
+		return -EINVAL;
+	if (cache_op >= PERF_COUNT_HW_CACHE_OP_MAX)
+		return -EINVAL;
+	if (cache_result >= PERF_COUNT_HW_CACHE_RESULT_MAX)
+		return -EINVAL;
+
+	return riscv_cache_event_map[cache_type][cache_op][cache_result];
+}
+
+static int riscv_pmu_event_init(struct perf_event *event)
+{
+	struct hw_perf_event *hwc = &event->hw;
+	int ret;
+
+	switch (event->attr.type) {
+	case PERF_TYPE_HARDWARE:
+		if (event->attr.config >= PERF_COUNT_HW_MAX)
+			return -ENOENT;
+		ret = riscv_hw_event_map[event->attr.config];
+		if (ret == RISCV_OP_UNSUPP)
+			return -ENOENT;
+		hwc->idx = ret;
+		break;
+	case PERF_TYPE_HW_CACHE:
+		ret = riscv_pmu_cache_event(event->attr.config);
+		if (ret == RISCV_OP_UNSUPP)
+			return -ENOENT;
+		hwc->idx = ret;
+		break;
+	case PERF_TYPE_RAW:
+		if (event->attr.config < 0 || event->attr.config >
+		    RISCV_MAX_COUNTERS)
+			return -ENOENT;
+		hwc->idx = event->attr.config;
+		break;
+	default:
+		return -ENOENT;
+	}
+
+	return 0;
+}
+
+static void riscv_pmu_enable(struct pmu *pmu)
+{
+}
+
+/* stops all counters */
+static void riscv_pmu_disable(struct pmu *pmu)
+{
+}
+
+static void riscv_pmu_start(struct perf_event *event, int flags)
+{
+	unsigned long flg;
+	struct hw_perf_event *hwc = &event->hw;
+	int idx = hwc->idx;
+
+	if (WARN_ON_ONCE(idx == -1))
+		return;
+
+	if (flags & PERF_EF_RELOAD)
+		WARN_ON_ONCE(!(hwc->state & PERF_HES_UPTODATE));
+
+	hwc->state = 0;
+
+	riscv_pmu_event_set_period(event);
+
+	local_irq_save(flg);
+
+	csr_write(SCOUNTERINTEN, BIT(idx) | csr_read(SCOUNTERINTEN));
+
+	local_irq_restore(flg);
+}
+
+static void riscv_pmu_stop_event(struct perf_event *event)
+{
+	unsigned long flg;
+	struct hw_perf_event *hwc = &event->hw;
+	int idx = hwc->idx;
+
+	local_irq_save(flg);
+
+	csr_write(SCOUNTERINTEN, ~BIT(idx) & csr_read(SCOUNTERINTEN));
+
+	local_irq_restore(flg);
+}
+
+static void riscv_pmu_stop(struct perf_event *event, int flags)
+{
+	if (!(event->hw.state & PERF_HES_STOPPED)) {
+		riscv_pmu_stop_event(event);
+		event->hw.state |= PERF_HES_STOPPED;
+	}
+
+	if ((flags & PERF_EF_UPDATE) &&
+	    !(event->hw.state & PERF_HES_UPTODATE)) {
+		riscv_perf_event_update(event, &event->hw);
+		event->hw.state |= PERF_HES_UPTODATE;
+	}
+}
+
+static void riscv_pmu_del(struct perf_event *event, int flags)
+{
+	struct pmu_hw_events *hw_events = this_cpu_ptr(riscv_pmu.hw_events);
+	struct hw_perf_event *hwc = &event->hw;
+
+	riscv_pmu_stop(event, PERF_EF_UPDATE);
+
+	hw_events->events[hwc->idx] = NULL;
+
+	perf_event_update_userpage(event);
+}
+
+/* allocate hardware counter and optionally start counting */
+static int riscv_pmu_add(struct perf_event *event, int flags)
+{
+	struct pmu_hw_events *hw_events = this_cpu_ptr(riscv_pmu.hw_events);
+	struct hw_perf_event *hwc = &event->hw;
+
+	hw_events->events[hwc->idx] = event;
+
+	hwc->state = PERF_HES_UPTODATE | PERF_HES_STOPPED;
+
+	if (flags & PERF_EF_START)
+		riscv_pmu_start(event, PERF_EF_RELOAD);
+
+	perf_event_update_userpage(event);
+
+	return 0;
+}
+
+static irqreturn_t riscv_pmu_handle_irq(int irq, void *dev_id)
+{
+	struct perf_sample_data data;
+	struct pmu_hw_events *cpuc = this_cpu_ptr(riscv_pmu.hw_events);
+	struct pt_regs *regs;
+	int idx;
+
+	/*
+	 * Did an overflow occur?
+	 */
+	if (!csr_read(SCOUNTEROF))
+		return IRQ_NONE;
+
+	/*
+	 * Handle the counter(s) overflow(s)
+	 */
+	regs = get_irq_regs();
+
+
+	for (idx = 0; idx < RISCV_MAX_COUNTERS; ++idx) {
+		struct perf_event *event = cpuc->events[idx];
+		struct hw_perf_event *hwc;
+
+		/* Ignore if we don't have an event. */
+		if (!event)
+			continue;
+		/*
+		 * We have a single interrupt for all counters. Check that
+		 * each counter has overflowed before we process it.
+		 */
+		if (!(csr_read(SCOUNTEROF) & BIT(idx)))
+			continue;
+
+		hwc = &event->hw;
+		riscv_perf_event_update(event, &event->hw);
+		perf_sample_data_init(&data, 0, hwc->last_period);
+		riscv_pmu_event_set_period(event);
+
+		if (perf_event_overflow(event, &data, regs))
+			riscv_pmu_stop_event(event);
+	}
+
+	/*
+	 * Handle the pending perf events.
+	 *
+	 * Note: this call *must* be run with interrupts disabled. For
+	 * platforms that can have the PMU interrupts raised as an NMI, this
+	 * will not work.
+	 */
+	irq_work_run();
+
+	return IRQ_HANDLED;
+}
+
+static int riscv_pmu_request_irq(irq_handler_t handler)
+{
+	int err, irqs;
+	struct platform_device *pmu_device = riscv_pmu.plat_device;
+
+	if (!pmu_device)
+		return -ENODEV;
+
+	irqs = min(pmu_device->num_resources, num_possible_cpus());
+	if (irqs < 1) {
+		pr_err("no irqs for PMUs defined\n");
+		return -ENODEV;
+	}
+
+	riscv_pmu_irq = platform_get_irq(pmu_device, 0);
+	if (riscv_pmu_irq < 0)
+		return -ENODEV;
+	err = request_percpu_irq(riscv_pmu_irq, handler, "c9xx-pmu-v1", &riscv_pmu);
+	if (err) {
+		pr_err("unable to request IRQ%d for c9xx PMU counters\n",
+		       riscv_pmu_irq);
+		return err;
+	}
+
+	return 0;
+}
+
+static void riscv_pmu_free_irq(void)
+{
+	int irq;
+	struct platform_device *pmu_device = riscv_pmu.plat_device;
+
+	irq = platform_get_irq(pmu_device, 0);
+	if (irq >= 0)
+		free_percpu_irq(irq, this_cpu_ptr(riscv_pmu.hw_events));
+}
+
+static int init_hw_perf_events(void)
+{
+	riscv_pmu.hw_events = alloc_percpu_gfp(struct pmu_hw_events,
+					      GFP_KERNEL);
+	if (!riscv_pmu.hw_events) {
+		pr_info("failed to allocate per-cpu PMU data.\n");
+		return -ENOMEM;
+	}
+
+	riscv_pmu.pmu = (struct pmu) {
+		.pmu_enable     = riscv_pmu_enable,
+		.pmu_disable    = riscv_pmu_disable,
+		.event_init     = riscv_pmu_event_init,
+		.add	    = riscv_pmu_add,
+		.del	    = riscv_pmu_del,
+		.start	  = riscv_pmu_start,
+		.stop	   = riscv_pmu_stop,
+		.read	   = riscv_pmu_read,
+	};
+
+	return 0;
+}
+
+static int riscv_pmu_starting_cpu(unsigned int cpu)
+{
+	sbi_ecall(0x09000001, 0, 1, 0, 0, 0, 0, 0);
+
+	enable_percpu_irq(riscv_pmu_irq, 0);
+	return 0;
+}
+
+static int riscv_pmu_dying_cpu(unsigned int cpu)
+{
+	disable_percpu_irq(riscv_pmu_irq);
+	return 0;
+}
+
+static int riscv_pmu_device_probe(struct platform_device *pdev,
+			  const struct of_device_id *of_table)
+{
+	int ret;
+
+	ret = init_hw_perf_events();
+	if (ret) {
+		pr_notice("[perf] failed to probe PMU!\n");
+		return ret;
+	}
+	riscv_pmu.max_period = ULONG_MAX;
+	riscv_pmu.plat_device = pdev;
+
+	ret = riscv_pmu_request_irq(riscv_pmu_handle_irq);
+	if (ret) {
+		riscv_pmu.pmu.capabilities |= PERF_PMU_CAP_NO_INTERRUPT;
+		pr_notice("[perf] PMU request irq fail!\n");
+	}
+
+	ret = cpuhp_setup_state(CPUHP_AP_PERF_ONLINE + 1, "perf riscv:online",
+				riscv_pmu_starting_cpu,
+				riscv_pmu_dying_cpu);
+	if (ret) {
+		riscv_pmu_free_irq();
+		free_percpu(riscv_pmu.hw_events);
+		return ret;
+	}
+
+	ret = perf_pmu_register(&riscv_pmu.pmu, "thead_xt_pmu", PERF_TYPE_RAW);
+	if (ret) {
+		riscv_pmu_free_irq();
+		free_percpu(riscv_pmu.hw_events);
+	}
+
+	pr_notice("[perf] T-HEAD C900 PMU v1 probed\n");
+
+	return ret;
+}
+
+const static struct of_device_id riscv_pmu_of_device_ids[] = {
+	{.compatible = "riscv,thead_xt_pmu"},
+	{.compatible = "riscv,c910_pmu"},
+	{},
+};
+
+static int riscv_pmu_dev_probe(struct platform_device *pdev)
+{
+	return riscv_pmu_device_probe(pdev, riscv_pmu_of_device_ids);
+}
+
+static struct platform_driver riscv_pmu_driver = {
+	.driver = {
+		   .name = "thead_xt_pmu_v1",
+		   .of_match_table = riscv_pmu_of_device_ids,
+		   },
+	.probe = riscv_pmu_dev_probe,
+};
+
+int __init riscv_pmu_v1_probe(void)
+{
+	return platform_driver_register(&riscv_pmu_driver);
+}
+device_initcall(riscv_pmu_v1_probe);
diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
index 815095326e2d..2b1cd81a94e0 100644
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -400,6 +400,7 @@ source "drivers/pinctrl/zte/Kconfig"
 source "drivers/pinctrl/meson/Kconfig"
 source "drivers/pinctrl/cirrus/Kconfig"
 source "drivers/pinctrl/visconti/Kconfig"
+source "drivers/pinctrl/cvitek/Kconfig"
 
 config PINCTRL_XWAY
 	bool
diff --git a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
index f53933b2ff02..537758e52043 100644
--- a/drivers/pinctrl/Makefile
+++ b/drivers/pinctrl/Makefile
@@ -72,3 +72,4 @@ obj-y				+= mediatek/
 obj-$(CONFIG_PINCTRL_ZX)	+= zte/
 obj-y				+= cirrus/
 obj-$(CONFIG_PINCTRL_VISCONTI)	+= visconti/
+obj-$(CONFIG_ARCH_CVITEK)   += cvitek/
diff --git a/drivers/pinctrl/cvitek/Kconfig b/drivers/pinctrl/cvitek/Kconfig
new file mode 100644
index 000000000000..2775fe220aed
--- /dev/null
+++ b/drivers/pinctrl/cvitek/Kconfig
@@ -0,0 +1,10 @@
+if ARCH_CVITEK
+
+config CVITEK_PINCTRL_CV1835
+	bool "cvitek pinctrl"
+	select PINMUX
+	select PINCONF
+	select GENERIC_PINCONF
+	help
+	  This enable pinctrl driver for cvitek cv1835 platform
+endif
diff --git a/drivers/pinctrl/cvitek/Makefile b/drivers/pinctrl/cvitek/Makefile
new file mode 100644
index 000000000000..cd486f69935d
--- /dev/null
+++ b/drivers/pinctrl/cvitek/Makefile
@@ -0,0 +1 @@
+obj-y += pinctrl-$(patsubst "%",%,${CONFIG_ARCH_CVITEK_CHIP}).o
diff --git a/drivers/pinctrl/cvitek/cv180x_pinlist_swconfig.h b/drivers/pinctrl/cvitek/cv180x_pinlist_swconfig.h
new file mode 100644
index 000000000000..4b69ae28b33d
--- /dev/null
+++ b/drivers/pinctrl/cvitek/cv180x_pinlist_swconfig.h
@@ -0,0 +1,407 @@
+//##==============================================================================
+//##=== This script is generate by genswconfig.pl from .\00_CV180X_Pinlist_20220315.xls
+//##=== Generate Time stamp is : 2022-03-17 14:04:49
+//##==============================================================================
+
+#ifndef __CV180X_PINLIST_SWCONFIG_H__
+#define __CV180X_PINLIST_SWCONFIG_H__
+
+#define SD0_CLK__SDIO0_CLK 0
+#define SD0_CLK__IIC1_SDA 1
+#define SD0_CLK__SPI0_SCK 2
+#define SD0_CLK__XGPIOA_7 3
+#define SD0_CLK__PWM_15 5
+#define SD0_CLK__EPHY_LNK_LED 6
+#define SD0_CLK__DBG_0 7
+#define SD0_CMD__SDIO0_CMD 0
+#define SD0_CMD__IIC1_SCL 1
+#define SD0_CMD__SPI0_SDO 2
+#define SD0_CMD__XGPIOA_8 3
+#define SD0_CMD__PWM_14 5
+#define SD0_CMD__EPHY_SPD_LED 6
+#define SD0_CMD__DBG_1 7
+#define SD0_D0__SDIO0_D_0 0
+#define SD0_D0__CAM_MCLK1 1
+#define SD0_D0__SPI0_SDI 2
+#define SD0_D0__XGPIOA_9 3
+#define SD0_D0__UART3_TX 4
+#define SD0_D0__PWM_13 5
+#define SD0_D0__WG0_D0 6
+#define SD0_D0__DBG_2 7
+#define SD0_D1__SDIO0_D_1 0
+#define SD0_D1__IIC1_SDA 1
+#define SD0_D1__AUX0 2
+#define SD0_D1__XGPIOA_10 3
+#define SD0_D1__UART1_TX 4
+#define SD0_D1__PWM_12 5
+#define SD0_D1__WG0_D1 6
+#define SD0_D1__DBG_3 7
+#define SD0_D2__SDIO0_D_2 0
+#define SD0_D2__IIC1_SCL 1
+#define SD0_D2__AUX1 2
+#define SD0_D2__XGPIOA_11 3
+#define SD0_D2__UART1_RX 4
+#define SD0_D2__PWM_11 5
+#define SD0_D2__WG1_D0 6
+#define SD0_D2__DBG_4 7
+#define SD0_D3__SDIO0_D_3 0
+#define SD0_D3__CAM_MCLK0 1
+#define SD0_D3__SPI0_CS_X 2
+#define SD0_D3__XGPIOA_12 3
+#define SD0_D3__UART3_RX 4
+#define SD0_D3__PWM_10 5
+#define SD0_D3__WG1_D1 6
+#define SD0_D3__DBG_5 7
+#define SD0_CD__SDIO0_CD 0
+#define SD0_CD__XGPIOA_13 3
+#define SD0_PWR_EN__SDIO0_PWR_EN 0
+#define SD0_PWR_EN__XGPIOA_14 3
+#define SPK_EN__XGPIOA_15 3
+#define UART0_TX__UART0_TX 0
+#define UART0_TX__CAM_MCLK1 1
+#define UART0_TX__PWM_4 2
+#define UART0_TX__XGPIOA_16 3
+#define UART0_TX__UART1_TX 4
+#define UART0_TX__AUX1 5
+#define UART0_TX__JTAG_TMS 6
+#define UART0_TX__DBG_6 7
+#define UART0_RX__UART0_RX 0
+#define UART0_RX__CAM_MCLK0 1
+#define UART0_RX__PWM_5 2
+#define UART0_RX__XGPIOA_17 3
+#define UART0_RX__UART1_RX 4
+#define UART0_RX__AUX0 5
+#define UART0_RX__JTAG_TCK 6
+#define UART0_RX__DBG_7 7
+#define SPINOR_HOLD_X__SPINOR_HOLD_X 1
+#define SPINOR_HOLD_X__SPINAND_HOLD 2
+#define SPINOR_HOLD_X__XGPIOA_26 3
+#define SPINOR_SCK__SPINOR_SCK 1
+#define SPINOR_SCK__SPINAND_CLK 2
+#define SPINOR_SCK__XGPIOA_22 3
+#define SPINOR_MOSI__SPINOR_MOSI 1
+#define SPINOR_MOSI__SPINAND_MOSI 2
+#define SPINOR_MOSI__XGPIOA_25 3
+#define SPINOR_WP_X__SPINOR_WP_X 1
+#define SPINOR_WP_X__SPINAND_WP 2
+#define SPINOR_WP_X__XGPIOA_27 3
+#define SPINOR_MISO__SPINOR_MISO 1
+#define SPINOR_MISO__SPINAND_MISO 2
+#define SPINOR_MISO__XGPIOA_23 3
+#define SPINOR_CS_X__SPINOR_CS_X 1
+#define SPINOR_CS_X__SPINAND_CS 2
+#define SPINOR_CS_X__XGPIOA_24 3
+#define JTAG_CPU_TMS__JTAG_TMS 0
+#define JTAG_CPU_TMS__CAM_MCLK0 1
+#define JTAG_CPU_TMS__PWM_7 2
+#define JTAG_CPU_TMS__XGPIOA_19 3
+#define JTAG_CPU_TMS__UART1_RTS 4
+#define JTAG_CPU_TMS__AUX0 5
+#define JTAG_CPU_TMS__UART1_TX 6
+#define JTAG_CPU_TCK__JTAG_TCK 0
+#define JTAG_CPU_TCK__CAM_MCLK1 1
+#define JTAG_CPU_TCK__PWM_6 2
+#define JTAG_CPU_TCK__XGPIOA_18 3
+#define JTAG_CPU_TCK__UART1_CTS 4
+#define JTAG_CPU_TCK__AUX1 5
+#define JTAG_CPU_TCK__UART1_RX 6
+#define IIC0_SCL__CV_SCL0__CR_4WTDI 0
+#define IIC0_SDA__CV_SDA0__CR_4WTDO 0
+#define IIC0_SCL__JTAG_TDI 0
+#define IIC0_SCL__UART1_TX 1
+#define IIC0_SCL__UART2_TX 2
+#define IIC0_SCL__XGPIOA_28 3
+#define IIC0_SCL__IIC0_SCL 4
+#define IIC0_SCL__WG0_D0 5
+#define IIC0_SCL__DBG_10 7
+#define IIC0_SDA__JTAG_TDO 0
+#define IIC0_SDA__UART1_RX 1
+#define IIC0_SDA__UART2_RX 2
+#define IIC0_SDA__XGPIOA_29 3
+#define IIC0_SDA__IIC0_SDA 4
+#define IIC0_SDA__WG0_D1 5
+#define IIC0_SDA__WG1_D0 6
+#define IIC0_SDA__DBG_11 7
+#define AUX0__AUX0 0
+#define AUX0__XGPIOA_30 3
+#define AUX0__IIS1_MCLK 4
+#define AUX0__WG1_D1 6
+#define AUX0__DBG_12 7
+#define GPIO_ZQ__PWR_GPIO_24 3
+#define GPIO_ZQ__PWM_2 4
+#define PWR_VBAT_DET__PWR_VBAT_DET 0
+#define PWR_RSTN__PWR_RSTN 0
+#define PWR_SEQ1__PWR_SEQ1 0
+#define PWR_SEQ1__PWR_GPIO_3 3
+#define PWR_SEQ2__PWR_SEQ2 0
+#define PWR_SEQ2__PWR_GPIO_4 3
+#define PTEST__PWR_PTEST 0
+#define PWR_WAKEUP0__PWR_WAKEUP0 0
+#define PWR_WAKEUP0__PWR_IR0 1
+#define PWR_WAKEUP0__PWR_UART0_TX 2
+#define PWR_WAKEUP0__PWR_GPIO_6 3
+#define PWR_WAKEUP0__UART1_TX 4
+#define PWR_WAKEUP0__IIC4_SCL 5
+#define PWR_WAKEUP0__EPHY_LNK_LED 6
+#define PWR_WAKEUP0__WG2_D0 7
+#define PWR_BUTTON1__PWR_BUTTON1 0
+#define PWR_BUTTON1__PWR_GPIO_8 3
+#define PWR_BUTTON1__UART1_RX 4
+#define PWR_BUTTON1__IIC4_SDA 5
+#define PWR_BUTTON1__EPHY_SPD_LED 6
+#define PWR_BUTTON1__WG2_D1 7
+#define XTAL_XIN__PWR_XTAL_CLKIN 0
+#define PWR_GPIO0__PWR_GPIO_0 0
+#define PWR_GPIO0__UART2_TX 1
+#define PWR_GPIO0__PWR_UART0_RX 2
+#define PWR_GPIO0__PWM_8 4
+#define PWR_GPIO1__PWR_GPIO_1 0
+#define PWR_GPIO1__UART2_RX 1
+#define PWR_GPIO1__EPHY_LNK_LED 3
+#define PWR_GPIO1__PWM_9 4
+#define PWR_GPIO1__PWR_IIC_SCL 5
+#define PWR_GPIO1__IIC2_SCL 6
+#define PWR_GPIO1__IIC0_SDA 7
+#define PWR_GPIO2__PWR_GPIO_2 0
+#define PWR_GPIO2__PWR_SECTICK 2
+#define PWR_GPIO2__EPHY_SPD_LED 3
+#define PWR_GPIO2__PWM_10 4
+#define PWR_GPIO2__PWR_IIC_SDA 5
+#define PWR_GPIO2__IIC2_SDA 6
+#define PWR_GPIO2__IIC0_SCL 7
+#define SD1_GPIO1__UART4_TX 1
+#define SD1_GPIO1__PWR_GPIO_26 3
+#define SD1_GPIO1__PWM_10 7
+#define SD1_GPIO0__UART4_RX 1
+#define SD1_GPIO0__PWR_GPIO_25 3
+#define SD1_GPIO0__PWM_11 7
+#define SD1_D3__PWR_SD1_D3 0
+#define SD1_D3__SPI2_CS_X 1
+#define SD1_D3__IIC1_SCL 2
+#define SD1_D3__PWR_GPIO_18 3
+#define SD1_D3__CAM_MCLK0 4
+#define SD1_D3__UART3_CTS 5
+#define SD1_D3__PWR_SPINOR1_CS_X 6
+#define SD1_D3__PWM_4 7
+#define SD1_D2__PWR_SD1_D2 0
+#define SD1_D2__IIC1_SCL 1
+#define SD1_D2__UART2_TX 2
+#define SD1_D2__PWR_GPIO_19 3
+#define SD1_D2__CAM_MCLK0 4
+#define SD1_D2__UART3_TX 5
+#define SD1_D2__PWR_SPINOR1_HOLD_X 6
+#define SD1_D2__PWM_5 7
+#define SD1_D1__PWR_SD1_D1 0
+#define SD1_D1__IIC1_SDA 1
+#define SD1_D1__UART2_RX 2
+#define SD1_D1__PWR_GPIO_20 3
+#define SD1_D1__CAM_MCLK1 4
+#define SD1_D1__UART3_RX 5
+#define SD1_D1__PWR_SPINOR1_WP_X 6
+#define SD1_D1__PWM_6 7
+#define SD1_D0__PWR_SD1_D0 0
+#define SD1_D0__SPI2_SDI 1
+#define SD1_D0__IIC1_SDA 2
+#define SD1_D0__PWR_GPIO_21 3
+#define SD1_D0__CAM_MCLK1 4
+#define SD1_D0__UART3_RTS 5
+#define SD1_D0__PWR_SPINOR1_MISO 6
+#define SD1_D0__PWM_7 7
+#define SD1_CMD__PWR_SD1_CMD 0
+#define SD1_CMD__SPI2_SDO 1
+#define SD1_CMD__IIC3_SCL 2
+#define SD1_CMD__PWR_GPIO_22 3
+#define SD1_CMD__CAM_VS0 4
+#define SD1_CMD__EPHY_LNK_LED 5
+#define SD1_CMD__PWR_SPINOR1_MOSI 6
+#define SD1_CMD__PWM_8 7
+#define SD1_CLK__PWR_SD1_CLK 0
+#define SD1_CLK__SPI2_SCK 1
+#define SD1_CLK__IIC3_SDA 2
+#define SD1_CLK__PWR_GPIO_23 3
+#define SD1_CLK__CAM_HS0 4
+#define SD1_CLK__EPHY_SPD_LED 5
+#define SD1_CLK__PWR_SPINOR1_SCK 6
+#define SD1_CLK__PWM_9 7
+#define PWM0_BUCK__PWM_0 0
+#define PWM0_BUCK__XGPIOB_0 3
+#define ADC1__XGPIOB_3 3
+#define ADC1__KEY_COL2 4
+#define ADC1__PWM_3 6
+#define USB_VBUS_DET__USB_VBUS_DET 0
+#define USB_VBUS_DET__XGPIOB_6 3
+#define USB_VBUS_DET__CAM_MCLK0 4
+#define USB_VBUS_DET__CAM_MCLK1 5
+#define USB_VBUS_DET__PWM_4 6
+#define MUX_SPI1_MISO__UART3_RTS 1
+#define MUX_SPI1_MISO__IIC1_SDA 2
+#define MUX_SPI1_MISO__XGPIOB_8 3
+#define MUX_SPI1_MISO__PWM_9 4
+#define MUX_SPI1_MISO__KEY_COL1 5
+#define MUX_SPI1_MISO__SPI1_SDI 6
+#define MUX_SPI1_MISO__DBG_14 7
+#define MUX_SPI1_MOSI__UART3_RX 1
+#define MUX_SPI1_MOSI__IIC1_SCL 2
+#define MUX_SPI1_MOSI__XGPIOB_7 3
+#define MUX_SPI1_MOSI__PWM_8 4
+#define MUX_SPI1_MOSI__KEY_COL0 5
+#define MUX_SPI1_MOSI__SPI1_SDO 6
+#define MUX_SPI1_MOSI__DBG_13 7
+#define MUX_SPI1_CS__UART3_CTS 1
+#define MUX_SPI1_CS__CAM_MCLK0 2
+#define MUX_SPI1_CS__XGPIOB_10 3
+#define MUX_SPI1_CS__PWM_11 4
+#define MUX_SPI1_CS__KEY_ROW3 5
+#define MUX_SPI1_CS__SPI1_CS_X 6
+#define MUX_SPI1_CS__DBG_16 7
+#define MUX_SPI1_SCK__UART3_TX 1
+#define MUX_SPI1_SCK__CAM_MCLK1 2
+#define MUX_SPI1_SCK__XGPIOB_9 3
+#define MUX_SPI1_SCK__PWM_10 4
+#define MUX_SPI1_SCK__KEY_ROW2 5
+#define MUX_SPI1_SCK__SPI1_SCK 6
+#define MUX_SPI1_SCK__DBG_15 7
+#define PAD_ETH_TXP__UART3_RX 1
+#define PAD_ETH_TXP__IIC1_SCL 2
+#define PAD_ETH_TXP__XGPIOB_25 3
+#define PAD_ETH_TXP__PWM_13 4
+#define PAD_ETH_TXP__CAM_MCLK0 5
+#define PAD_ETH_TXP__SPI1_SDO 6
+#define PAD_ETH_TXP__IIS2_LRCK 7
+#define PAD_ETH_TXM__UART3_RTS 1
+#define PAD_ETH_TXM__IIC1_SDA 2
+#define PAD_ETH_TXM__XGPIOB_24 3
+#define PAD_ETH_TXM__PWM_12 4
+#define PAD_ETH_TXM__CAM_MCLK1 5
+#define PAD_ETH_TXM__SPI1_SDI 6
+#define PAD_ETH_TXM__IIS2_BCLK 7
+#define PAD_ETH_RXP__UART3_TX 1
+#define PAD_ETH_RXP__CAM_MCLK1 2
+#define PAD_ETH_RXP__XGPIOB_27 3
+#define PAD_ETH_RXP__PWM_15 4
+#define PAD_ETH_RXP__CAM_HS0 5
+#define PAD_ETH_RXP__SPI1_SCK 6
+#define PAD_ETH_RXP__IIS2_DO 7
+#define PAD_ETH_RXM__UART3_CTS 1
+#define PAD_ETH_RXM__CAM_MCLK0 2
+#define PAD_ETH_RXM__XGPIOB_26 3
+#define PAD_ETH_RXM__PWM_14 4
+#define PAD_ETH_RXM__CAM_VS0 5
+#define PAD_ETH_RXM__SPI1_CS_X 6
+#define PAD_ETH_RXM__IIS2_DI 7
+#define GPIO_RTX__VI0_D_15 1
+#define GPIO_RTX__XGPIOB_23 3
+#define GPIO_RTX__PWM_1 4
+#define GPIO_RTX__CAM_MCLK0 5
+#define GPIO_RTX__IIS2_MCLK 7
+#define PAD_MIPIRX4N__VI0_CLK 1
+#define PAD_MIPIRX4N__IIC0_SCL 2
+#define PAD_MIPIRX4N__XGPIOC_2 3
+#define PAD_MIPIRX4N__IIC1_SDA 4
+#define PAD_MIPIRX4N__CAM_MCLK0 5
+#define PAD_MIPIRX4N__KEY_ROW0 6
+#define PAD_MIPIRX4N__MUX_SPI1_SCK 7
+#define PAD_MIPIRX4P__VI0_D_0 1
+#define PAD_MIPIRX4P__IIC0_SDA 2
+#define PAD_MIPIRX4P__XGPIOC_3 3
+#define PAD_MIPIRX4P__IIC1_SCL 4
+#define PAD_MIPIRX4P__CAM_MCLK1 5
+#define PAD_MIPIRX4P__KEY_ROW1 6
+#define PAD_MIPIRX4P__MUX_SPI1_CS 7
+#define PAD_MIPIRX3N__VI0_D_1 1
+#define PAD_MIPIRX3N__XGPIOC_4 3
+#define PAD_MIPIRX3N__CAM_MCLK0 4
+#define PAD_MIPIRX3N__MUX_SPI1_MISO 7
+#define PAD_MIPIRX3P__VI0_D_2 1
+#define PAD_MIPIRX3P__XGPIOC_5 3
+#define PAD_MIPIRX3P__MUX_SPI1_MOSI 7
+#define PAD_MIPIRX2N__VI0_D_3 1
+#define PAD_MIPIRX2N__XGPIOC_6 3
+#define PAD_MIPIRX2N__IIC4_SCL 5
+#define PAD_MIPIRX2N__DBG_6 7
+#define PAD_MIPIRX2P__VI0_D_4 1
+#define PAD_MIPIRX2P__XGPIOC_7 3
+#define PAD_MIPIRX2P__IIC4_SDA 5
+#define PAD_MIPIRX2P__DBG_7 7
+#define PAD_MIPIRX1N__VI0_D_5 1
+#define PAD_MIPIRX1N__XGPIOC_8 3
+#define PAD_MIPIRX1N__KEY_ROW3 6
+#define PAD_MIPIRX1N__DBG_8 7
+#define PAD_MIPIRX1P__VI0_D_6 1
+#define PAD_MIPIRX1P__XGPIOC_9 3
+#define PAD_MIPIRX1P__IIC1_SDA 4
+#define PAD_MIPIRX1P__KEY_ROW2 6
+#define PAD_MIPIRX1P__DBG_9 7
+#define PAD_MIPIRX0N__VI0_D_7 1
+#define PAD_MIPIRX0N__XGPIOC_10 3
+#define PAD_MIPIRX0N__IIC1_SCL 4
+#define PAD_MIPIRX0N__CAM_MCLK1 5
+#define PAD_MIPIRX0N__DBG_10 7
+#define PAD_MIPIRX0P__VI0_D_8 1
+#define PAD_MIPIRX0P__XGPIOC_11 3
+#define PAD_MIPIRX0P__CAM_MCLK0 4
+#define PAD_MIPIRX0P__DBG_11 7
+#define PAD_MIPI_TXM2__VI0_D_13 1
+#define PAD_MIPI_TXM2__IIC0_SDA 2
+#define PAD_MIPI_TXM2__XGPIOC_16 3
+#define PAD_MIPI_TXM2__IIC1_SDA 4
+#define PAD_MIPI_TXM2__PWM_8 5
+#define PAD_MIPI_TXM2__SPI0_SCK 6
+#define PAD_MIPI_TXP2__VI0_D_14 1
+#define PAD_MIPI_TXP2__IIC0_SCL 2
+#define PAD_MIPI_TXP2__XGPIOC_17 3
+#define PAD_MIPI_TXP2__IIC1_SCL 4
+#define PAD_MIPI_TXP2__PWM_9 5
+#define PAD_MIPI_TXP2__SPI0_CS_X 6
+#define PAD_MIPI_TXP2__IIS1_MCLK 7
+#define PAD_MIPI_TXM1__SPI3_SDO 0
+#define PAD_MIPI_TXM1__VI0_D_11 1
+#define PAD_MIPI_TXM1__IIS1_LRCK 2
+#define PAD_MIPI_TXM1__XGPIOC_14 3
+#define PAD_MIPI_TXM1__IIC2_SDA 4
+#define PAD_MIPI_TXM1__PWM_10 5
+#define PAD_MIPI_TXM1__SPI0_SDO 6
+#define PAD_MIPI_TXM1__DBG_14 7
+#define PAD_MIPI_TXP1__SPI3_SDI 0
+#define PAD_MIPI_TXP1__VI0_D_12 1
+#define PAD_MIPI_TXP1__IIS1_DO 2
+#define PAD_MIPI_TXP1__XGPIOC_15 3
+#define PAD_MIPI_TXP1__IIC2_SCL 4
+#define PAD_MIPI_TXP1__PWM_11 5
+#define PAD_MIPI_TXP1__SPI0_SDI 6
+#define PAD_MIPI_TXP1__DBG_15 7
+#define PAD_MIPI_TXM0__SPI3_SCK 0
+#define PAD_MIPI_TXM0__VI0_D_9 1
+#define PAD_MIPI_TXM0__IIS1_DI 2
+#define PAD_MIPI_TXM0__XGPIOC_12 3
+#define PAD_MIPI_TXM0__CAM_MCLK1 4
+#define PAD_MIPI_TXM0__PWM_14 5
+#define PAD_MIPI_TXM0__CAM_VS0 6
+#define PAD_MIPI_TXM0__DBG_12 7
+#define PAD_MIPI_TXP0__SPI3_CS_X 0
+#define PAD_MIPI_TXP0__VI0_D_10 1
+#define PAD_MIPI_TXP0__IIS1_BCLK 2
+#define PAD_MIPI_TXP0__XGPIOC_13 3
+#define PAD_MIPI_TXP0__CAM_MCLK0 4
+#define PAD_MIPI_TXP0__PWM_15 5
+#define PAD_MIPI_TXP0__CAM_HS0 6
+#define PAD_MIPI_TXP0__DBG_13 7
+#define PKG_TYPE0__PKG_TYPE0 0
+#define PKG_TYPE1__PKG_TYPE1 0
+#define PKG_TYPE2__PKG_TYPE2 0
+#define PAD_AUD_AINL_MIC__XGPIOC_23 3
+#define PAD_AUD_AINL_MIC__IIS1_BCLK 4
+#define PAD_AUD_AINL_MIC__IIS2_BCLK 5
+#define PAD_AUD_AINR_MIC__XGPIOC_22 3
+#define PAD_AUD_AINR_MIC__IIS1_DO 4
+#define PAD_AUD_AINR_MIC__IIS2_DI 5
+#define PAD_AUD_AINR_MIC__IIS1_DI 6
+#define PAD_AUD_AOUTL__XGPIOC_25 3
+#define PAD_AUD_AOUTL__IIS1_LRCK 4
+#define PAD_AUD_AOUTL__IIS2_LRCK 5
+#define PAD_AUD_AOUTR__XGPIOC_24 3
+#define PAD_AUD_AOUTR__IIS1_DI 4
+#define PAD_AUD_AOUTR__IIS2_DO 5
+#define PAD_AUD_AOUTR__IIS1_DO 6
+
+#endif /* __CV180X_PINLIST_SWCONFIG_H__ */
diff --git a/drivers/pinctrl/cvitek/cv180x_reg_fmux_gpio.h b/drivers/pinctrl/cvitek/cv180x_reg_fmux_gpio.h
new file mode 100644
index 000000000000..a07236fba3bc
--- /dev/null
+++ b/drivers/pinctrl/cvitek/cv180x_reg_fmux_gpio.h
@@ -0,0 +1,337 @@
+// $Module: fmux_gpio $
+// $RegisterBank Version: V 1.0.00 $
+// $Author: ghost $
+// $Date: Thu, 17 Mar 2022 04:53:31 PM $
+//
+
+//GEN REG ADDR/OFFSET/MASK
+
+#ifndef __CV180X_REG_FMUX_GPIO_H__
+#define __CV180X_REG_FMUX_GPIO_H__
+
+#define  FMUX_GPIO_REG_IOCTRL_SD0_CLK  0x0
+#define  FMUX_GPIO_REG_IOCTRL_SD0_CMD  0x4
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D0  0x8
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D1  0xc
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D2  0x10
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D3  0x14
+#define  FMUX_GPIO_REG_IOCTRL_SD0_CD  0x18
+#define  FMUX_GPIO_REG_IOCTRL_SD0_PWR_EN  0x1c
+#define  FMUX_GPIO_REG_IOCTRL_SPK_EN  0x20
+#define  FMUX_GPIO_REG_IOCTRL_UART0_TX  0x24
+#define  FMUX_GPIO_REG_IOCTRL_UART0_RX  0x28
+#define  FMUX_GPIO_REG_IOCTRL_SPINOR_HOLD_X  0x2c
+#define  FMUX_GPIO_REG_IOCTRL_SPINOR_SCK  0x30
+#define  FMUX_GPIO_REG_IOCTRL_SPINOR_MOSI  0x34
+#define  FMUX_GPIO_REG_IOCTRL_SPINOR_WP_X  0x38
+#define  FMUX_GPIO_REG_IOCTRL_SPINOR_MISO  0x3c
+#define  FMUX_GPIO_REG_IOCTRL_SPINOR_CS_X  0x40
+#define  FMUX_GPIO_REG_IOCTRL_JTAG_CPU_TMS  0x44
+#define  FMUX_GPIO_REG_IOCTRL_JTAG_CPU_TCK  0x48
+#define  FMUX_GPIO_REG_IOCTRL_IIC0_SCL  0x4c
+#define  FMUX_GPIO_REG_IOCTRL_IIC0_SDA  0x50
+#define  FMUX_GPIO_REG_IOCTRL_AUX0  0x54
+#define  FMUX_GPIO_REG_IOCTRL_GPIO_ZQ  0x58
+#define  FMUX_GPIO_REG_IOCTRL_PWR_VBAT_DET  0x5c
+#define  FMUX_GPIO_REG_IOCTRL_PWR_RSTN  0x60
+#define  FMUX_GPIO_REG_IOCTRL_PWR_SEQ1  0x64
+#define  FMUX_GPIO_REG_IOCTRL_PWR_SEQ2  0x68
+#define  FMUX_GPIO_REG_IOCTRL_PWR_WAKEUP0  0x6c
+#define  FMUX_GPIO_REG_IOCTRL_PWR_BUTTON1  0x70
+#define  FMUX_GPIO_REG_IOCTRL_XTAL_XIN  0x74
+#define  FMUX_GPIO_REG_IOCTRL_PWR_GPIO0  0x78
+#define  FMUX_GPIO_REG_IOCTRL_PWR_GPIO1  0x7c
+#define  FMUX_GPIO_REG_IOCTRL_PWR_GPIO2  0x80
+#define  FMUX_GPIO_REG_IOCTRL_SD1_GPIO1  0x84
+#define  FMUX_GPIO_REG_IOCTRL_SD1_GPIO0  0x88
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D3  0x8c
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D2  0x90
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D1  0x94
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D0  0x98
+#define  FMUX_GPIO_REG_IOCTRL_SD1_CMD  0x9c
+#define  FMUX_GPIO_REG_IOCTRL_SD1_CLK  0xa0
+#define  FMUX_GPIO_REG_IOCTRL_PWM0_BUCK  0xa4
+#define  FMUX_GPIO_REG_IOCTRL_ADC1  0xa8
+#define  FMUX_GPIO_REG_IOCTRL_USB_VBUS_DET  0xac
+#define  FMUX_GPIO_REG_IOCTRL_MUX_SPI1_MISO  0xb0
+#define  FMUX_GPIO_REG_IOCTRL_MUX_SPI1_MOSI  0xb4
+#define  FMUX_GPIO_REG_IOCTRL_MUX_SPI1_CS  0xb8
+#define  FMUX_GPIO_REG_IOCTRL_MUX_SPI1_SCK  0xbc
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_TXP  0xc0
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_TXM  0xc4
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_RXP  0xc8
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_RXM  0xcc
+#define  FMUX_GPIO_REG_IOCTRL_GPIO_RTX  0xd0
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX4N  0xd4
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX4P  0xd8
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX3N  0xdc
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX3P  0xe0
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX2N  0xe4
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX2P  0xe8
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX1N  0xec
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX1P  0xf0
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX0N  0xf4
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX0P  0xf8
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM2  0xfc
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP2  0x100
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM1  0x104
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP1  0x108
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM0  0x10c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP0  0x110
+#define  FMUX_GPIO_REG_IOCTRL_PKG_TYPE0  0x114
+#define  FMUX_GPIO_REG_IOCTRL_PKG_TYPE1  0x118
+#define  FMUX_GPIO_REG_IOCTRL_PKG_TYPE2  0x11c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AINL_MIC  0x120
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AINR_MIC  0x124
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AOUTL  0x128
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AOUTR  0x12c
+#define  FMUX_GPIO_REG_DEVMATRIX_UART0_IP_SEL  0x1d4
+#define  FMUX_GPIO_REG_DEVMATRIX_UART1_IP_SEL  0x1d8
+#define  FMUX_GPIO_REG_DEVMATRIX_UART2_IP_SEL  0x1dc
+#define  FMUX_GPIO_REG_DEVMATRIX_UART3_IP_SEL  0x1e0
+#define  FMUX_GPIO_REG_DEVMATRIX_UART4_IP_SEL  0x1e4
+#define  FMUX_GPIO_FUNCSEL_SD0_CLK   0x0
+#define  FMUX_GPIO_FUNCSEL_SD0_CLK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_CLK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_CMD   0x4
+#define  FMUX_GPIO_FUNCSEL_SD0_CMD_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_CMD_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D0   0x8
+#define  FMUX_GPIO_FUNCSEL_SD0_D0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D1   0xc
+#define  FMUX_GPIO_FUNCSEL_SD0_D1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D2   0x10
+#define  FMUX_GPIO_FUNCSEL_SD0_D2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D3   0x14
+#define  FMUX_GPIO_FUNCSEL_SD0_D3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_CD   0x18
+#define  FMUX_GPIO_FUNCSEL_SD0_CD_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_CD_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_PWR_EN   0x1c
+#define  FMUX_GPIO_FUNCSEL_SD0_PWR_EN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_PWR_EN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SPK_EN   0x20
+#define  FMUX_GPIO_FUNCSEL_SPK_EN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SPK_EN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART0_TX   0x24
+#define  FMUX_GPIO_FUNCSEL_UART0_TX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART0_TX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART0_RX   0x28
+#define  FMUX_GPIO_FUNCSEL_UART0_RX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART0_RX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SPINOR_HOLD_X   0x2c
+#define  FMUX_GPIO_FUNCSEL_SPINOR_HOLD_X_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SPINOR_HOLD_X_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SPINOR_SCK   0x30
+#define  FMUX_GPIO_FUNCSEL_SPINOR_SCK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SPINOR_SCK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SPINOR_MOSI   0x34
+#define  FMUX_GPIO_FUNCSEL_SPINOR_MOSI_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SPINOR_MOSI_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SPINOR_WP_X   0x38
+#define  FMUX_GPIO_FUNCSEL_SPINOR_WP_X_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SPINOR_WP_X_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SPINOR_MISO   0x3c
+#define  FMUX_GPIO_FUNCSEL_SPINOR_MISO_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SPINOR_MISO_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SPINOR_CS_X   0x40
+#define  FMUX_GPIO_FUNCSEL_SPINOR_CS_X_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SPINOR_CS_X_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TMS   0x44
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TMS_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TMS_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TCK   0x48
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TCK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TCK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC0_SCL   0x4c
+#define  FMUX_GPIO_FUNCSEL_IIC0_SCL_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC0_SCL_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC0_SDA   0x50
+#define  FMUX_GPIO_FUNCSEL_IIC0_SDA_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC0_SDA_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_AUX0   0x54
+#define  FMUX_GPIO_FUNCSEL_AUX0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_AUX0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_GPIO_ZQ   0x58
+#define  FMUX_GPIO_FUNCSEL_GPIO_ZQ_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_GPIO_ZQ_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_VBAT_DET   0x5c
+#define  FMUX_GPIO_FUNCSEL_PWR_VBAT_DET_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_VBAT_DET_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_RSTN   0x60
+#define  FMUX_GPIO_FUNCSEL_PWR_RSTN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_RSTN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ1   0x64
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ2   0x68
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP0   0x6c
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_BUTTON1   0x70
+#define  FMUX_GPIO_FUNCSEL_PWR_BUTTON1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_BUTTON1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_XTAL_XIN   0x74
+#define  FMUX_GPIO_FUNCSEL_XTAL_XIN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_XTAL_XIN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO0   0x78
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO1   0x7c
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO2   0x80
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_GPIO1   0x84
+#define  FMUX_GPIO_FUNCSEL_SD1_GPIO1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_GPIO1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_GPIO0   0x88
+#define  FMUX_GPIO_FUNCSEL_SD1_GPIO0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_GPIO0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D3   0x8c
+#define  FMUX_GPIO_FUNCSEL_SD1_D3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D2   0x90
+#define  FMUX_GPIO_FUNCSEL_SD1_D2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D1   0x94
+#define  FMUX_GPIO_FUNCSEL_SD1_D1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D0   0x98
+#define  FMUX_GPIO_FUNCSEL_SD1_D0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_CMD   0x9c
+#define  FMUX_GPIO_FUNCSEL_SD1_CMD_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_CMD_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_CLK   0xa0
+#define  FMUX_GPIO_FUNCSEL_SD1_CLK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_CLK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWM0_BUCK   0xa4
+#define  FMUX_GPIO_FUNCSEL_PWM0_BUCK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWM0_BUCK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_ADC1   0xa8
+#define  FMUX_GPIO_FUNCSEL_ADC1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_ADC1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_DET   0xac
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_DET_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_DET_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MISO   0xb0
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MISO_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MISO_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MOSI   0xb4
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MOSI_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MOSI_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_CS   0xb8
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_CS_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_CS_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_SCK   0xbc
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_SCK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_SCK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXP   0xc0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXP_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXP_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXM   0xc4
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXM_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXM_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXP   0xc8
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXP_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXP_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXM   0xcc
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXM_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXM_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_GPIO_RTX   0xd0
+#define  FMUX_GPIO_FUNCSEL_GPIO_RTX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_GPIO_RTX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4N   0xd4
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4P   0xd8
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3N   0xdc
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3P   0xe0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2N   0xe4
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2P   0xe8
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1N   0xec
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1P   0xf0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0N   0xf4
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0P   0xf8
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM2   0xfc
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP2   0x100
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM1   0x104
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP1   0x108
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM0   0x10c
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP0   0x110
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE0   0x114
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE1   0x118
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE2   0x11c
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINL_MIC   0x120
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINL_MIC_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINL_MIC_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINR_MIC   0x124
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINR_MIC_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINR_MIC_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTL   0x128
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTL_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTL_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTR   0x12c
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTR_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTR_MASK   0x7
+#define  FMUX_GPIO_MUX_UART0_IP_SEL   0x1d4
+#define  FMUX_GPIO_MUX_UART0_IP_SEL_OFFSET 0
+#define  FMUX_GPIO_MUX_UART0_IP_SEL_MASK   0x7
+#define  FMUX_GPIO_MUX_UART1_IP_SEL   0x1d8
+#define  FMUX_GPIO_MUX_UART1_IP_SEL_OFFSET 0
+#define  FMUX_GPIO_MUX_UART1_IP_SEL_MASK   0x7
+#define  FMUX_GPIO_MUX_UART2_IP_SEL   0x1dc
+#define  FMUX_GPIO_MUX_UART2_IP_SEL_OFFSET 0
+#define  FMUX_GPIO_MUX_UART2_IP_SEL_MASK   0x7
+#define  FMUX_GPIO_MUX_UART3_IP_SEL   0x1e0
+#define  FMUX_GPIO_MUX_UART3_IP_SEL_OFFSET 0
+#define  FMUX_GPIO_MUX_UART3_IP_SEL_MASK   0x7
+#define  FMUX_GPIO_MUX_UART4_IP_SEL   0x1e4
+#define  FMUX_GPIO_MUX_UART4_IP_SEL_OFFSET 0
+#define  FMUX_GPIO_MUX_UART4_IP_SEL_MASK   0x7
+
+#endif /* __CV180X_REG_FMUX_GPIO_H__ */
diff --git a/drivers/pinctrl/cvitek/cv181x_pinlist_swconfig.h b/drivers/pinctrl/cvitek/cv181x_pinlist_swconfig.h
new file mode 100644
index 000000000000..6c023c061131
--- /dev/null
+++ b/drivers/pinctrl/cvitek/cv181x_pinlist_swconfig.h
@@ -0,0 +1,676 @@
+//##==============================================================================
+//##=== This script is generate by genswconfig.pl from .\00_CV181X_Pinlist_20210827.xls
+//##=== Generate Time stamp is : 2021-08-27 20:43:11
+//##==============================================================================
+
+#ifndef __CV181X_PINLIST_SWCONFIG_H__
+#define __CV181X_PINLIST_SWCONFIG_H__
+
+
+#define CAM_MCLK0__CAM_MCLK0 0
+#define CAM_MCLK0__AUX1 2
+#define CAM_MCLK0__XGPIOA_0 3
+#define CAM_PD0__IIS1_MCLK 1
+#define CAM_PD0__XGPIOA_1 3
+#define CAM_PD0__CAM_HS0 4
+#define CAM_RST0__XGPIOA_2 3
+#define CAM_RST0__CAM_VS0 4
+#define CAM_RST0__IIC4_SCL 6
+#define CAM_MCLK1__CAM_MCLK1 0
+#define CAM_MCLK1__AUX2 2
+#define CAM_MCLK1__XGPIOA_3 3
+#define CAM_MCLK1__CAM_HS0 4
+#define CAM_PD1__IIS1_MCLK 1
+#define CAM_PD1__XGPIOA_4 3
+#define CAM_PD1__CAM_VS0 4
+#define CAM_PD1__IIC4_SDA 6
+#define IIC3_SCL__IIC3_SCL 0
+#define IIC3_SCL__XGPIOA_5 3
+#define IIC3_SDA__IIC3_SDA 0
+#define IIC3_SDA__XGPIOA_6 3
+#define SD0_CLK__SDIO0_CLK 0
+#define SD0_CLK__IIC1_SDA 1
+#define SD0_CLK__SPI0_SCK 2
+#define SD0_CLK__XGPIOA_7 3
+#define SD0_CLK__PWM_15 5
+#define SD0_CLK__EPHY_LNK_LED 6
+#define SD0_CLK__DBG_0 7
+#define SD0_CMD__SDIO0_CMD 0
+#define SD0_CMD__IIC1_SCL 1
+#define SD0_CMD__SPI0_SDO 2
+#define SD0_CMD__XGPIOA_8 3
+#define SD0_CMD__PWM_14 5
+#define SD0_CMD__EPHY_SPD_LED 6
+#define SD0_CMD__DBG_1 7
+#define SD0_D0__SDIO0_D_0 0
+#define SD0_D0__CAM_MCLK1 1
+#define SD0_D0__SPI0_SDI 2
+#define SD0_D0__XGPIOA_9 3
+#define SD0_D0__UART3_TX 4
+#define SD0_D0__PWM_13 5
+#define SD0_D0__WG0_D0 6
+#define SD0_D0__DBG_2 7
+#define SD0_D1__SDIO0_D_1 0
+#define SD0_D1__IIC1_SDA 1
+#define SD0_D1__AUX0 2
+#define SD0_D1__XGPIOA_10 3
+#define SD0_D1__UART1_TX 4
+#define SD0_D1__PWM_12 5
+#define SD0_D1__WG0_D1 6
+#define SD0_D1__DBG_3 7
+#define SD0_D2__SDIO0_D_2 0
+#define SD0_D2__IIC1_SCL 1
+#define SD0_D2__AUX1 2
+#define SD0_D2__XGPIOA_11 3
+#define SD0_D2__UART1_RX 4
+#define SD0_D2__PWM_11 5
+#define SD0_D2__WG1_D0 6
+#define SD0_D2__DBG_4 7
+#define SD0_D3__SDIO0_D_3 0
+#define SD0_D3__CAM_MCLK0 1
+#define SD0_D3__SPI0_CS_X 2
+#define SD0_D3__XGPIOA_12 3
+#define SD0_D3__UART3_RX 4
+#define SD0_D3__PWM_10 5
+#define SD0_D3__WG1_D1 6
+#define SD0_D3__DBG_5 7
+#define SD0_CD__SDIO0_CD 0
+#define SD0_CD__XGPIOA_13 3
+#define SD0_PWR_EN__SDIO0_PWR_EN 0
+#define SD0_PWR_EN__XGPIOA_14 3
+#define SPK_EN__XGPIOA_15 3
+#define UART0_TX__UART0_TX 0
+#define UART0_TX__CAM_MCLK1 1
+#define UART0_TX__PWM_4 2
+#define UART0_TX__XGPIOA_16 3
+#define UART0_TX__UART1_TX 4
+#define UART0_TX__AUX1 5
+#define UART0_TX__DBG_6 7
+#define UART0_RX__UART0_RX 0
+#define UART0_RX__CAM_MCLK0 1
+#define UART0_RX__PWM_5 2
+#define UART0_RX__XGPIOA_17 3
+#define UART0_RX__UART1_RX 4
+#define UART0_RX__AUX0 5
+#define UART0_RX__DBG_7 7
+#define EMMC_RSTN__EMMC_RSTN 0
+#define EMMC_RSTN__XGPIOA_21 3
+#define EMMC_RSTN__AUX2 4
+#define EMMC_DAT2__EMMC_DAT_2 0
+#define EMMC_DAT2__SPINOR_HOLD_X 1
+#define EMMC_DAT2__SPINAND_HOLD 2
+#define EMMC_DAT2__XGPIOA_26 3
+#define EMMC_CLK__EMMC_CLK 0
+#define EMMC_CLK__SPINOR_SCK 1
+#define EMMC_CLK__SPINAND_CLK 2
+#define EMMC_CLK__XGPIOA_22 3
+#define EMMC_DAT0__EMMC_DAT_0 0
+#define EMMC_DAT0__SPINOR_MOSI 1
+#define EMMC_DAT0__SPINAND_MOSI 2
+#define EMMC_DAT0__XGPIOA_25 3
+#define EMMC_DAT3__EMMC_DAT_3 0
+#define EMMC_DAT3__SPINOR_WP_X 1
+#define EMMC_DAT3__SPINAND_WP 2
+#define EMMC_DAT3__XGPIOA_27 3
+#define EMMC_CMD__EMMC_CMD 0
+#define EMMC_CMD__SPINOR_MISO 1
+#define EMMC_CMD__SPINAND_MISO 2
+#define EMMC_CMD__XGPIOA_23 3
+#define EMMC_DAT1__EMMC_DAT_1 0
+#define EMMC_DAT1__SPINOR_CS_X 1
+#define EMMC_DAT1__SPINAND_CS 2
+#define EMMC_DAT1__XGPIOA_24 3
+#define JTAG_CPU_TMS__CV_2WTMS_CR_4WTMS 0
+#define JTAG_CPU_TMS__CAM_MCLK0 1
+#define JTAG_CPU_TMS__PWM_7 2
+#define JTAG_CPU_TMS__XGPIOA_19 3
+#define JTAG_CPU_TMS__UART1_RTS 4
+#define JTAG_CPU_TMS__AUX0 5
+#define JTAG_CPU_TMS__UART1_TX 6
+#define JTAG_CPU_TMS__VO_D_28 7
+#define JTAG_CPU_TCK__CV_2WTCK_CR_4WTCK 0
+#define JTAG_CPU_TCK__CAM_MCLK1 1
+#define JTAG_CPU_TCK__PWM_6 2
+#define JTAG_CPU_TCK__XGPIOA_18 3
+#define JTAG_CPU_TCK__UART1_CTS 4
+#define JTAG_CPU_TCK__AUX1 5
+#define JTAG_CPU_TCK__UART1_RX 6
+#define JTAG_CPU_TCK__VO_D_29 7
+#define JTAG_CPU_TRST__JTAG_CPU_TRST 0
+#define JTAG_CPU_TRST__XGPIOA_20 3
+#define JTAG_CPU_TRST__VO_D_30 6
+#define IIC0_SCL__CV_SCL0__CR_4WTDI 0
+#define IIC0_SCL__UART1_TX 1
+#define IIC0_SCL__UART2_TX 2
+#define IIC0_SCL__XGPIOA_28 3
+#define IIC0_SCL__WG0_D0 5
+#define IIC0_SCL__DBG_10 7
+#define IIC0_SDA__CV_SDA0__CR_4WTDO 0
+#define IIC0_SDA__UART1_RX 1
+#define IIC0_SDA__UART2_RX 2
+#define IIC0_SDA__XGPIOA_29 3
+#define IIC0_SDA__WG0_D1 5
+#define IIC0_SDA__WG1_D0 6
+#define IIC0_SDA__DBG_11 7
+#define AUX0__AUX0 0
+#define AUX0__XGPIOA_30 3
+#define AUX0__IIS1_MCLK 4
+#define AUX0__VO_D_31 5
+#define AUX0__WG1_D1 6
+#define AUX0__DBG_12 7
+#define PWR_VBAT_DET__PWR_VBAT_DET 0
+#define PWR_RSTN__PWR_RSTN 0
+#define PWR_SEQ1__PWR_SEQ1 0
+#define PWR_SEQ1__PWR_GPIO_3 3
+#define PWR_SEQ2__PWR_SEQ2 0
+#define PWR_SEQ2__PWR_GPIO_4 3
+#define PWR_SEQ3__PWR_SEQ3 0
+#define PWR_SEQ3__PWR_GPIO_5 3
+#define PTEST__PWR_PTEST 0
+#define PWR_WAKEUP0__PWR_WAKEUP0 0
+#define PWR_WAKEUP0__PWR_IR0 1
+#define PWR_WAKEUP0__PWR_UART0_TX 2
+#define PWR_WAKEUP0__PWR_GPIO_6 3
+#define PWR_WAKEUP0__UART1_TX 4
+#define PWR_WAKEUP0__IIC4_SCL 5
+#define PWR_WAKEUP0__EPHY_LNK_LED 6
+#define PWR_WAKEUP0__WG2_D0 7
+#define PWR_WAKEUP1__PWR_WAKEUP1 0
+#define PWR_WAKEUP1__PWR_IR1 1
+#define PWR_WAKEUP1__PWR_GPIO_7 3
+#define PWR_WAKEUP1__UART1_TX 4
+#define PWR_WAKEUP1__IIC4_SCL 5
+#define PWR_WAKEUP1__EPHY_LNK_LED 6
+#define PWR_WAKEUP1__WG0_D0 7
+#define PWR_BUTTON1__PWR_BUTTON1 0
+#define PWR_BUTTON1__PWR_GPIO_8 3
+#define PWR_BUTTON1__UART1_RX 4
+#define PWR_BUTTON1__IIC4_SDA 5
+#define PWR_BUTTON1__EPHY_SPD_LED 6
+#define PWR_BUTTON1__WG2_D1 7
+#define PWR_ON__PWR_ON 0
+#define PWR_ON__PWR_GPIO_9 3
+#define PWR_ON__UART1_RX 4
+#define PWR_ON__IIC4_SDA 5
+#define PWR_ON__EPHY_SPD_LED 6
+#define PWR_ON__WG0_D1 7
+#define XTAL_XIN__PWR_XTAL_CLKIN 0
+#define PWR_GPIO0__PWR_GPIO_0 0
+#define PWR_GPIO0__UART2_TX 1
+#define PWR_GPIO0__PWR_UART0_RX 2
+#define PWR_GPIO0__PWM_8 4
+#define PWR_GPIO1__PWR_GPIO_1 0
+#define PWR_GPIO1__UART2_RX 1
+#define PWR_GPIO1__EPHY_LNK_LED 3
+#define PWR_GPIO1__PWM_9 4
+#define PWR_GPIO1__PWR_IIC_SCL 5
+#define PWR_GPIO1__IIC2_SCL 6
+#define PWR_GPIO1__CV_4WTMS_CR_SDA0 7
+#define PWR_GPIO2__PWR_GPIO_2 0
+#define PWR_GPIO2__PWR_SECTICK 2
+#define PWR_GPIO2__EPHY_SPD_LED 3
+#define PWR_GPIO2__PWM_10 4
+#define PWR_GPIO2__PWR_IIC_SDA 5
+#define PWR_GPIO2__IIC2_SDA 6
+#define PWR_GPIO2__CV_4WTCK_CR_2WTCK 7
+#define CLK32K__CLK32K 0
+#define CLK32K__AUX0 1
+#define CLK32K__CV_4WTDI_CR_SCL0 2
+#define CLK32K__PWR_GPIO_10 3
+#define CLK32K__PWM_2 4
+#define CLK32K__KEY_COL0 5
+#define CLK32K__CAM_MCLK0 6
+#define CLK32K__DBG_0 7
+#define CLK25M__CLK25M 0
+#define CLK25M__AUX1 1
+#define CLK25M__CV_4WTDO_CR_2WTMS 2
+#define CLK25M__PWR_GPIO_11 3
+#define CLK25M__PWM_3 4
+#define CLK25M__KEY_COL1 5
+#define CLK25M__CAM_MCLK1 6
+#define CLK25M__DBG_1 7
+#define IIC2_SCL__IIC2_SCL 0
+#define IIC2_SCL__PWM_14 1
+#define IIC2_SCL__PWR_GPIO_12 3
+#define IIC2_SCL__UART2_RX 4
+#define IIC2_SCL__KEY_COL2 7
+#define IIC2_SDA__IIC2_SDA 0
+#define IIC2_SDA__PWM_15 1
+#define IIC2_SDA__PWR_GPIO_13 3
+#define IIC2_SDA__UART2_TX 4
+#define IIC2_SDA__IIS1_MCLK 5
+#define IIC2_SDA__IIS2_MCLK 6
+#define IIC2_SDA__KEY_COL3 7
+#define UART2_TX__UART2_TX 0
+#define UART2_TX__PWM_11 1
+#define UART2_TX__PWR_UART1_TX 2
+#define UART2_TX__PWR_GPIO_14 3
+#define UART2_TX__KEY_ROW3 4
+#define UART2_TX__UART4_TX 5
+#define UART2_TX__IIS2_BCLK 6
+#define UART2_TX__WG2_D0 7
+#define UART2_RTS__UART2_RTS 0
+#define UART2_RTS__PWM_8 1
+#define UART2_RTS__PWR_GPIO_15 3
+#define UART2_RTS__KEY_ROW0 4
+#define UART2_RTS__UART4_RTS 5
+#define UART2_RTS__IIS2_DO 6
+#define UART2_RTS__WG1_D0 7
+#define UART2_RX__UART2_RX 0
+#define UART2_RX__PWM_10 1
+#define UART2_RX__PWR_UART1_RX 2
+#define UART2_RX__PWR_GPIO_16 3
+#define UART2_RX__KEY_COL3 4
+#define UART2_RX__UART4_RX 5
+#define UART2_RX__IIS2_DI 6
+#define UART2_RX__WG2_D1 7
+#define UART2_CTS__UART2_CTS 0
+#define UART2_CTS__PWM_9 1
+#define UART2_CTS__PWR_GPIO_17 3
+#define UART2_CTS__KEY_ROW1 4
+#define UART2_CTS__UART4_CTS 5
+#define UART2_CTS__IIS2_LRCK 6
+#define UART2_CTS__WG1_D1 7
+#define SD1_D3__PWR_SD1_D3_VO32 0
+#define SD1_D3__SPI2_CS_X 1
+#define SD1_D3__IIC1_SCL 2
+#define SD1_D3__PWR_GPIO_18 3
+#define SD1_D3__CAM_MCLK0 4
+#define SD1_D3__UART3_CTS 5
+#define SD1_D3__PWR_SPINOR1_CS_X 6
+#define SD1_D3__PWM_4 7
+#define SD1_D2__PWR_SD1_D2_VO33 0
+#define SD1_D2__IIC1_SCL 1
+#define SD1_D2__UART2_TX 2
+#define SD1_D2__PWR_GPIO_19 3
+#define SD1_D2__CAM_MCLK0 4
+#define SD1_D2__UART3_TX 5
+#define SD1_D2__PWR_SPINOR1_HOLD_X 6
+#define SD1_D2__PWM_5 7
+#define SD1_D1__PWR_SD1_D1_VO34 0
+#define SD1_D1__IIC1_SDA 1
+#define SD1_D1__UART2_RX 2
+#define SD1_D1__PWR_GPIO_20 3
+#define SD1_D1__CAM_MCLK1 4
+#define SD1_D1__UART3_RX 5
+#define SD1_D1__PWR_SPINOR1_WP_X 6
+#define SD1_D1__PWM_6 7
+#define SD1_D0__PWR_SD1_D0_VO35 0
+#define SD1_D0__SPI2_SDI 1
+#define SD1_D0__IIC1_SDA 2
+#define SD1_D0__PWR_GPIO_21 3
+#define SD1_D0__CAM_MCLK1 4
+#define SD1_D0__UART3_RTS 5
+#define SD1_D0__PWR_SPINOR1_MISO 6
+#define SD1_D0__PWM_7 7
+#define SD1_CMD__PWR_SD1_CMD_VO36 0
+#define SD1_CMD__SPI2_SDO 1
+#define SD1_CMD__IIC3_SCL 2
+#define SD1_CMD__PWR_GPIO_22 3
+#define SD1_CMD__CAM_VS0 4
+#define SD1_CMD__EPHY_LNK_LED 5
+#define SD1_CMD__PWR_SPINOR1_MOSI 6
+#define SD1_CMD__PWM_8 7
+#define SD1_CLK__PWR_SD1_CLK_VO37 0
+#define SD1_CLK__SPI2_SCK 1
+#define SD1_CLK__IIC3_SDA 2
+#define SD1_CLK__PWR_GPIO_23 3
+#define SD1_CLK__CAM_HS0 4
+#define SD1_CLK__EPHY_SPD_LED 5
+#define SD1_CLK__PWR_SPINOR1_SCK 6
+#define SD1_CLK__PWM_9 7
+#define RSTN__RSTN 0
+#define PWM0_BUCK__PWM_0 0
+#define PWM0_BUCK__XGPIOB_0 3
+#define ADC3__CAM_MCLK0 1
+#define ADC3__IIC4_SCL 2
+#define ADC3__XGPIOB_1 3
+#define ADC3__PWM_12 4
+#define ADC3__EPHY_LNK_LED 5
+#define ADC3__WG2_D0 6
+#define ADC3__UART3_TX 7
+#define ADC2__CAM_MCLK1 1
+#define ADC2__IIC4_SDA 2
+#define ADC2__XGPIOB_2 3
+#define ADC2__PWM_13 4
+#define ADC2__EPHY_SPD_LED 5
+#define ADC2__WG2_D1 6
+#define ADC2__UART3_RX 7
+#define ADC1__XGPIOB_3 3
+#define ADC1__KEY_COL2 4
+#define USB_ID__USB_ID 0
+#define USB_ID__XGPIOB_4 3
+#define USB_VBUS_EN__USB_VBUS_EN 0
+#define USB_VBUS_EN__XGPIOB_5 3
+#define PKG_TYPE0__PKG_TYPE0 0
+#define USB_VBUS_DET__USB_VBUS_DET 0
+#define USB_VBUS_DET__XGPIOB_6 3
+#define USB_VBUS_DET__CAM_MCLK0 4
+#define USB_VBUS_DET__CAM_MCLK1 5
+#define PKG_TYPE1__PKG_TYPE1 0
+#define PKG_TYPE2__PKG_TYPE2 0
+#define MUX_SPI1_MISO__UART3_RTS 1
+#define MUX_SPI1_MISO__IIC1_SDA 2
+#define MUX_SPI1_MISO__XGPIOB_8 3
+#define MUX_SPI1_MISO__PWM_9 4
+#define MUX_SPI1_MISO__KEY_COL1 5
+#define MUX_SPI1_MISO__SPI1_SDI 6
+#define MUX_SPI1_MISO__DBG_14 7
+#define MUX_SPI1_MOSI__UART3_RX 1
+#define MUX_SPI1_MOSI__IIC1_SCL 2
+#define MUX_SPI1_MOSI__XGPIOB_7 3
+#define MUX_SPI1_MOSI__PWM_8 4
+#define MUX_SPI1_MOSI__KEY_COL0 5
+#define MUX_SPI1_MOSI__SPI1_SDO 6
+#define MUX_SPI1_MOSI__DBG_13 7
+#define MUX_SPI1_CS__UART3_CTS 1
+#define MUX_SPI1_CS__CAM_MCLK0 2
+#define MUX_SPI1_CS__XGPIOB_10 3
+#define MUX_SPI1_CS__PWM_11 4
+#define MUX_SPI1_CS__KEY_ROW3 5
+#define MUX_SPI1_CS__SPI1_CS_X 6
+#define MUX_SPI1_CS__DBG_16 7
+#define MUX_SPI1_SCK__UART3_TX 1
+#define MUX_SPI1_SCK__CAM_MCLK1 2
+#define MUX_SPI1_SCK__XGPIOB_9 3
+#define MUX_SPI1_SCK__PWM_10 4
+#define MUX_SPI1_SCK__KEY_ROW2 5
+#define MUX_SPI1_SCK__SPI1_SCK 6
+#define MUX_SPI1_SCK__DBG_15 7
+#define PAD_ETH_TXP__UART3_RX 1
+#define PAD_ETH_TXP__IIC1_SCL 2
+#define PAD_ETH_TXP__XGPIOB_25 3
+#define PAD_ETH_TXP__PWM_13 4
+#define PAD_ETH_TXP__CAM_MCLK0 5
+#define PAD_ETH_TXP__SPI1_SDO 6
+#define PAD_ETH_TXP__IIS2_LRCK 7
+#define PAD_ETH_TXM__UART3_RTS 1
+#define PAD_ETH_TXM__IIC1_SDA 2
+#define PAD_ETH_TXM__XGPIOB_24 3
+#define PAD_ETH_TXM__PWM_12 4
+#define PAD_ETH_TXM__CAM_MCLK1 5
+#define PAD_ETH_TXM__SPI1_SDI 6
+#define PAD_ETH_TXM__IIS2_BCLK 7
+#define PAD_ETH_RXP__UART3_TX 1
+#define PAD_ETH_RXP__CAM_MCLK1 2
+#define PAD_ETH_RXP__XGPIOB_27 3
+#define PAD_ETH_RXP__PWM_15 4
+#define PAD_ETH_RXP__CAM_HS0 5
+#define PAD_ETH_RXP__SPI1_SCK 6
+#define PAD_ETH_RXP__IIS2_DO 7
+#define PAD_ETH_RXM__UART3_CTS 1
+#define PAD_ETH_RXM__CAM_MCLK0 2
+#define PAD_ETH_RXM__XGPIOB_26 3
+#define PAD_ETH_RXM__PWM_14 4
+#define PAD_ETH_RXM__CAM_VS0 5
+#define PAD_ETH_RXM__SPI1_CS_X 6
+#define PAD_ETH_RXM__IIS2_DI 7
+#define VIVO_D10__PWM_1 0
+#define VIVO_D10__VI1_D_10 1
+#define VIVO_D10__VO_D_23 2
+#define VIVO_D10__XGPIOB_11 3
+#define VIVO_D10__RMII0_IRQ 4
+#define VIVO_D10__CAM_MCLK0 5
+#define VIVO_D10__IIC1_SDA 6
+#define VIVO_D10__UART2_TX 7
+#define VIVO_D9__PWM_2 0
+#define VIVO_D9__VI1_D_9 1
+#define VIVO_D9__VO_D_22 2
+#define VIVO_D9__XGPIOB_12 3
+#define VIVO_D9__CAM_MCLK1 5
+#define VIVO_D9__IIC1_SCL 6
+#define VIVO_D9__UART2_RX 7
+#define VIVO_D8__PWM_3 0
+#define VIVO_D8__VI1_D_8 1
+#define VIVO_D8__VO_D_21 2
+#define VIVO_D8__XGPIOB_13 3
+#define VIVO_D8__RMII0_MDIO 4
+#define VIVO_D8__SPI3_SDO 5
+#define VIVO_D8__IIC2_SCL 6
+#define VIVO_D8__CAM_VS0 7
+#define VIVO_D7__VI2_D_7 0
+#define VIVO_D7__VI1_D_7 1
+#define VIVO_D7__VO_D_20 2
+#define VIVO_D7__XGPIOB_14 3
+#define VIVO_D7__RMII0_RXD1 4
+#define VIVO_D7__SPI3_SDI 5
+#define VIVO_D7__IIC2_SDA 6
+#define VIVO_D7__CAM_HS0 7
+#define VIVO_D6__VI2_D_6 0
+#define VIVO_D6__VI1_D_6 1
+#define VIVO_D6__VO_D_19 2
+#define VIVO_D6__XGPIOB_15 3
+#define VIVO_D6__RMII0_REFCLKI 4
+#define VIVO_D6__SPI3_SCK 5
+#define VIVO_D6__UART2_TX 6
+#define VIVO_D6__CAM_VS0 7
+#define VIVO_D5__VI2_D_5 0
+#define VIVO_D5__VI1_D_5 1
+#define VIVO_D5__VO_D_18 2
+#define VIVO_D5__XGPIOB_16 3
+#define VIVO_D5__RMII0_RXD0 4
+#define VIVO_D5__SPI3_CS_X 5
+#define VIVO_D5__UART2_RX 6
+#define VIVO_D5__CAM_HS0 7
+#define VIVO_D4__VI2_D_4 0
+#define VIVO_D4__VI1_D_4 1
+#define VIVO_D4__VO_D_17 2
+#define VIVO_D4__XGPIOB_17 3
+#define VIVO_D4__RMII0_MDC 4
+#define VIVO_D4__IIC1_SDA 5
+#define VIVO_D4__UART2_CTS 6
+#define VIVO_D4__CAM_VS0 7
+#define VIVO_D3__VI2_D_3 0
+#define VIVO_D3__VI1_D_3 1
+#define VIVO_D3__VO_D_16 2
+#define VIVO_D3__XGPIOB_18 3
+#define VIVO_D3__RMII0_TXD0 4
+#define VIVO_D3__IIC1_SCL 5
+#define VIVO_D3__UART2_RTS 6
+#define VIVO_D3__CAM_HS0 7
+#define VIVO_D2__VI2_D_2 0
+#define VIVO_D2__VI1_D_2 1
+#define VIVO_D2__VO_D_15 2
+#define VIVO_D2__XGPIOB_19 3
+#define VIVO_D2__RMII0_TXD1 4
+#define VIVO_D2__CAM_MCLK1 5
+#define VIVO_D2__PWM_2 6
+#define VIVO_D2__UART2_TX 7
+#define VIVO_D1__VI2_D_1 0
+#define VIVO_D1__VI1_D_1 1
+#define VIVO_D1__VO_D_14 2
+#define VIVO_D1__XGPIOB_20 3
+#define VIVO_D1__RMII0_RXDV 4
+#define VIVO_D1__IIC3_SDA 5
+#define VIVO_D1__PWM_3 6
+#define VIVO_D1__IIC4_SCL 7
+#define VIVO_D0__VI2_D_0 0
+#define VIVO_D0__VI1_D_0 1
+#define VIVO_D0__VO_D_13 2
+#define VIVO_D0__XGPIOB_21 3
+#define VIVO_D0__RMII0_TXCLK 4
+#define VIVO_D0__IIC3_SCL 5
+#define VIVO_D0__WG1_D0 6
+#define VIVO_D0__IIC4_SDA 7
+#define VIVO_CLK__VI2_CLK 0
+#define VIVO_CLK__VI1_CLK 1
+#define VIVO_CLK__VO_CLK1 2
+#define VIVO_CLK__XGPIOB_22 3
+#define VIVO_CLK__RMII0_TXEN 4
+#define VIVO_CLK__CAM_MCLK0 5
+#define VIVO_CLK__WG1_D1 6
+#define VIVO_CLK__UART2_RX 7
+#define PAD_MIPIRX5N__VI1_D_11 1
+#define PAD_MIPIRX5N__VO_D_12 2
+#define PAD_MIPIRX5N__XGPIOC_0 3
+#define PAD_MIPIRX5N__CAM_MCLK0 5
+#define PAD_MIPIRX5N__WG0_D0 6
+#define PAD_MIPIRX5N__DBG_0 7
+#define PAD_MIPIRX5P__VI1_D_12 1
+#define PAD_MIPIRX5P__VO_D_11 2
+#define PAD_MIPIRX5P__XGPIOC_1 3
+#define PAD_MIPIRX5P__IIS1_MCLK 4
+#define PAD_MIPIRX5P__CAM_MCLK1 5
+#define PAD_MIPIRX5P__WG0_D1 6
+#define PAD_MIPIRX5P__DBG_1 7
+#define PAD_MIPIRX4N__CV_4WTDI_CR_SCL0 0
+#define PAD_MIPIRX4N__VI0_CLK 1
+#define PAD_MIPIRX4N__VI1_D_13 2
+#define PAD_MIPIRX4N__XGPIOC_2 3
+#define PAD_MIPIRX4N__IIC1_SDA 4
+#define PAD_MIPIRX4N__CAM_MCLK0 5
+#define PAD_MIPIRX4N__KEY_ROW0 6
+#define PAD_MIPIRX4N__MUX_SPI1_SCK 7
+#define PAD_MIPIRX4P__CV_4WTMS_CR_SDA0 0
+#define PAD_MIPIRX4P__VI0_D_0 1
+#define PAD_MIPIRX4P__VI1_D_14 2
+#define PAD_MIPIRX4P__XGPIOC_3 3
+#define PAD_MIPIRX4P__IIC1_SCL 4
+#define PAD_MIPIRX4P__CAM_MCLK1 5
+#define PAD_MIPIRX4P__KEY_ROW1 6
+#define PAD_MIPIRX4P__MUX_SPI1_CS 7
+#define PAD_MIPIRX3N__CV_4WTDO_CR_2WTMS 0
+#define PAD_MIPIRX3N__VI0_D_1 1
+#define PAD_MIPIRX3N__VI1_D_15 2
+#define PAD_MIPIRX3N__XGPIOC_4 3
+#define PAD_MIPIRX3N__CAM_MCLK0 4
+#define PAD_MIPIRX3N__MUX_SPI1_MISO 7
+#define PAD_MIPIRX3P__CV_4WTCK_CR_2WTCK 0
+#define PAD_MIPIRX3P__VI0_D_2 1
+#define PAD_MIPIRX3P__VI1_D_16 2
+#define PAD_MIPIRX3P__XGPIOC_5 3
+#define PAD_MIPIRX3P__MUX_SPI1_MOSI 7
+#define PAD_MIPIRX2N__VI0_D_3 1
+#define PAD_MIPIRX2N__VO_D_10 2
+#define PAD_MIPIRX2N__XGPIOC_6 3
+#define PAD_MIPIRX2N__VI1_D_17 4
+#define PAD_MIPIRX2N__IIC4_SCL 5
+#define PAD_MIPIRX2N__DBG_6 7
+#define PAD_MIPIRX2P__VI0_D_4 1
+#define PAD_MIPIRX2P__VO_D_9 2
+#define PAD_MIPIRX2P__XGPIOC_7 3
+#define PAD_MIPIRX2P__VI1_D_18 4
+#define PAD_MIPIRX2P__IIC4_SDA 5
+#define PAD_MIPIRX2P__DBG_7 7
+#define PAD_MIPIRX1N__VI0_D_5 1
+#define PAD_MIPIRX1N__VO_D_8 2
+#define PAD_MIPIRX1N__XGPIOC_8 3
+#define PAD_MIPIRX1N__KEY_ROW3 6
+#define PAD_MIPIRX1N__DBG_8 7
+#define PAD_MIPIRX1P__VI0_D_6 1
+#define PAD_MIPIRX1P__VO_D_7 2
+#define PAD_MIPIRX1P__XGPIOC_9 3
+#define PAD_MIPIRX1P__IIC1_SDA 4
+#define PAD_MIPIRX1P__KEY_ROW2 6
+#define PAD_MIPIRX1P__DBG_9 7
+#define PAD_MIPIRX0N__VI0_D_7 1
+#define PAD_MIPIRX0N__VO_D_6 2
+#define PAD_MIPIRX0N__XGPIOC_10 3
+#define PAD_MIPIRX0N__IIC1_SCL 4
+#define PAD_MIPIRX0N__CAM_MCLK1 5
+#define PAD_MIPIRX0N__DBG_10 7
+#define PAD_MIPIRX0P__VI0_D_8 1
+#define PAD_MIPIRX0P__VO_D_5 2
+#define PAD_MIPIRX0P__XGPIOC_11 3
+#define PAD_MIPIRX0P__CAM_MCLK0 4
+#define PAD_MIPIRX0P__DBG_11 7
+#define PAD_MIPI_TXM4__VI0_D_15 0
+#define PAD_MIPI_TXM4__SD1_CLK 1
+#define PAD_MIPI_TXM4__VO_D_24 2
+#define PAD_MIPI_TXM4__XGPIOC_18 3
+#define PAD_MIPI_TXM4__CAM_MCLK1 4
+#define PAD_MIPI_TXM4__PWM_12 5
+#define PAD_MIPI_TXM4__IIC1_SDA 6
+#define PAD_MIPI_TXM4__DBG_18 7
+#define PAD_MIPI_TXP4__VI0_D_16 0
+#define PAD_MIPI_TXP4__SD1_CMD 1
+#define PAD_MIPI_TXP4__VO_D_25 2
+#define PAD_MIPI_TXP4__XGPIOC_19 3
+#define PAD_MIPI_TXP4__CAM_MCLK0 4
+#define PAD_MIPI_TXP4__PWM_13 5
+#define PAD_MIPI_TXP4__IIC1_SCL 6
+#define PAD_MIPI_TXP4__DBG_19 7
+#define PAD_MIPI_TXM3__VI0_D_17 0
+#define PAD_MIPI_TXM3__SD1_D0 1
+#define PAD_MIPI_TXM3__VO_D_26 2
+#define PAD_MIPI_TXM3__XGPIOC_20 3
+#define PAD_MIPI_TXM3__IIC2_SDA 4
+#define PAD_MIPI_TXM3__PWM_14 5
+#define PAD_MIPI_TXM3__IIC1_SDA 6
+#define PAD_MIPI_TXM3__CAM_VS0 7
+#define PAD_MIPI_TXP3__VI0_D_18 0
+#define PAD_MIPI_TXP3__SD1_D1 1
+#define PAD_MIPI_TXP3__VO_D_27 2
+#define PAD_MIPI_TXP3__XGPIOC_21 3
+#define PAD_MIPI_TXP3__IIC2_SCL 4
+#define PAD_MIPI_TXP3__PWM_15 5
+#define PAD_MIPI_TXP3__IIC1_SCL 6
+#define PAD_MIPI_TXP3__CAM_HS0 7
+#define PAD_MIPI_TXM2__CV_4WTMS_CR_SDA0 0
+#define PAD_MIPI_TXM2__VI0_D_13 1
+#define PAD_MIPI_TXM2__VO_D_0 2
+#define PAD_MIPI_TXM2__XGPIOC_16 3
+#define PAD_MIPI_TXM2__IIC1_SDA 4
+#define PAD_MIPI_TXM2__PWM_8 5
+#define PAD_MIPI_TXM2__SPI0_SCK 6
+#define PAD_MIPI_TXM2__SD1_D2 7
+#define PAD_MIPI_TXP2__CV_4WTDI_CR_SCL0 0
+#define PAD_MIPI_TXP2__VI0_D_14 1
+#define PAD_MIPI_TXP2__VO_CLK0 2
+#define PAD_MIPI_TXP2__XGPIOC_17 3
+#define PAD_MIPI_TXP2__IIC1_SCL 4
+#define PAD_MIPI_TXP2__PWM_9 5
+#define PAD_MIPI_TXP2__SPI0_CS_X 6
+#define PAD_MIPI_TXP2__SD1_D3 7
+#define PAD_MIPI_TXM1__CV_4WTDO_CR_2WTMS 0
+#define PAD_MIPI_TXM1__VI0_D_11 1
+#define PAD_MIPI_TXM1__VO_D_2 2
+#define PAD_MIPI_TXM1__XGPIOC_14 3
+#define PAD_MIPI_TXM1__IIC2_SDA 4
+#define PAD_MIPI_TXM1__PWM_10 5
+#define PAD_MIPI_TXM1__SPI0_SDO 6
+#define PAD_MIPI_TXM1__DBG_14 7
+#define PAD_MIPI_TXP1__CV_4WTCK_CR_2WTCK 0
+#define PAD_MIPI_TXP1__VI0_D_12 1
+#define PAD_MIPI_TXP1__VO_D_1 2
+#define PAD_MIPI_TXP1__XGPIOC_15 3
+#define PAD_MIPI_TXP1__IIC2_SCL 4
+#define PAD_MIPI_TXP1__PWM_11 5
+#define PAD_MIPI_TXP1__SPI0_SDI 6
+#define PAD_MIPI_TXP1__DBG_15 7
+#define PAD_MIPI_TXM0__VI0_D_9 1
+#define PAD_MIPI_TXM0__VO_D_4 2
+#define PAD_MIPI_TXM0__XGPIOC_12 3
+#define PAD_MIPI_TXM0__CAM_MCLK1 4
+#define PAD_MIPI_TXM0__PWM_14 5
+#define PAD_MIPI_TXM0__CAM_VS0 6
+#define PAD_MIPI_TXM0__DBG_12 7
+#define PAD_MIPI_TXP0__VI0_D_10 1
+#define PAD_MIPI_TXP0__VO_D_3 2
+#define PAD_MIPI_TXP0__XGPIOC_13 3
+#define PAD_MIPI_TXP0__CAM_MCLK0 4
+#define PAD_MIPI_TXP0__PWM_15 5
+#define PAD_MIPI_TXP0__CAM_HS0 6
+#define PAD_MIPI_TXP0__DBG_13 7
+#define PAD_AUD_AINL_MIC__XGPIOC_23 3
+#define PAD_AUD_AINL_MIC__IIS1_BCLK 4
+#define PAD_AUD_AINL_MIC__IIS2_BCLK 5
+#define PAD_AUD_AINR_MIC__XGPIOC_22 3
+#define PAD_AUD_AINR_MIC__IIS1_DO 4
+#define PAD_AUD_AINR_MIC__IIS2_DI 5
+#define PAD_AUD_AINR_MIC__IIS1_DI 6
+#define PAD_AUD_AOUTL__XGPIOC_25 3
+#define PAD_AUD_AOUTL__IIS1_LRCK 4
+#define PAD_AUD_AOUTL__IIS2_LRCK 5
+#define PAD_AUD_AOUTR__XGPIOC_24 3
+#define PAD_AUD_AOUTR__IIS1_DI 4
+#define PAD_AUD_AOUTR__IIS2_DO 5
+#define PAD_AUD_AOUTR__IIS1_DO 6
+#define GPIO_RTX__XGPIOB_23 3
+#define GPIO_RTX__PWM_1 4
+#define GPIO_RTX__CAM_MCLK0 5
+#define GPIO_ZQ__PWR_GPIO_24 3
+#define GPIO_ZQ__PWM_2 4
+
+
+#endif /* __CV181X_PINLIST_SWCONFIG_H__ */
diff --git a/drivers/pinctrl/cvitek/cv181x_reg_fmux_gpio.h b/drivers/pinctrl/cvitek/cv181x_reg_fmux_gpio.h
new file mode 100644
index 000000000000..918a5dfa8e56
--- /dev/null
+++ b/drivers/pinctrl/cvitek/cv181x_reg_fmux_gpio.h
@@ -0,0 +1,482 @@
+// $Module: fmux_gpio $
+// $RegisterBank Version: V 1.0.00 $
+// $Author: ghost $
+// $Date: Fri, 27 Aug 2021 08:47:09 PM $
+//
+
+//GEN REG ADDR/OFFSET/MASK
+
+#ifndef __CV181X_REG_FMUX_GPIO_H__
+#define __CV181X_REG_FMUX_GPIO_H__
+
+#define  FMUX_GPIO_REG_IOCTRL_CAM_MCLK0  0x0
+#define  FMUX_GPIO_REG_IOCTRL_CAM_PD0  0x4
+#define  FMUX_GPIO_REG_IOCTRL_CAM_RST0  0x8
+#define  FMUX_GPIO_REG_IOCTRL_CAM_MCLK1  0xc
+#define  FMUX_GPIO_REG_IOCTRL_CAM_PD1  0x10
+#define  FMUX_GPIO_REG_IOCTRL_IIC3_SCL  0x14
+#define  FMUX_GPIO_REG_IOCTRL_IIC3_SDA  0x18
+#define  FMUX_GPIO_REG_IOCTRL_SD0_CLK  0x1c
+#define  FMUX_GPIO_REG_IOCTRL_SD0_CMD  0x20
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D0  0x24
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D1  0x28
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D2  0x2c
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D3  0x30
+#define  FMUX_GPIO_REG_IOCTRL_SD0_CD  0x34
+#define  FMUX_GPIO_REG_IOCTRL_SD0_PWR_EN  0x38
+#define  FMUX_GPIO_REG_IOCTRL_SPK_EN  0x3c
+#define  FMUX_GPIO_REG_IOCTRL_UART0_TX  0x40
+#define  FMUX_GPIO_REG_IOCTRL_UART0_RX  0x44
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_RSTN  0x48
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_DAT2  0x4c
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_CLK  0x50
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_DAT0  0x54
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_DAT3  0x58
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_CMD  0x5c
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_DAT1  0x60
+#define  FMUX_GPIO_REG_IOCTRL_JTAG_CPU_TMS  0x64
+#define  FMUX_GPIO_REG_IOCTRL_JTAG_CPU_TCK  0x68
+#define  FMUX_GPIO_REG_IOCTRL_JTAG_CPU_TRST  0x6c
+#define  FMUX_GPIO_REG_IOCTRL_IIC0_SCL  0x70
+#define  FMUX_GPIO_REG_IOCTRL_IIC0_SDA  0x74
+#define  FMUX_GPIO_REG_IOCTRL_AUX0  0x78
+#define  FMUX_GPIO_REG_IOCTRL_PWR_VBAT_DET  0x7c
+#define  FMUX_GPIO_REG_IOCTRL_PWR_RSTN  0x80
+#define  FMUX_GPIO_REG_IOCTRL_PWR_SEQ1  0x84
+#define  FMUX_GPIO_REG_IOCTRL_PWR_SEQ2  0x88
+#define  FMUX_GPIO_REG_IOCTRL_PWR_SEQ3  0x8c
+#define  FMUX_GPIO_REG_IOCTRL_PWR_WAKEUP0  0x90
+#define  FMUX_GPIO_REG_IOCTRL_PWR_WAKEUP1  0x94
+#define  FMUX_GPIO_REG_IOCTRL_PWR_BUTTON1  0x98
+#define  FMUX_GPIO_REG_IOCTRL_PWR_ON  0x9c
+#define  FMUX_GPIO_REG_IOCTRL_XTAL_XIN  0xa0
+#define  FMUX_GPIO_REG_IOCTRL_PWR_GPIO0  0xa4
+#define  FMUX_GPIO_REG_IOCTRL_PWR_GPIO1  0xa8
+#define  FMUX_GPIO_REG_IOCTRL_PWR_GPIO2  0xac
+#define  FMUX_GPIO_REG_IOCTRL_CLK32K  0xb0
+#define  FMUX_GPIO_REG_IOCTRL_CLK25M  0xb4
+#define  FMUX_GPIO_REG_IOCTRL_IIC2_SCL  0xb8
+#define  FMUX_GPIO_REG_IOCTRL_IIC2_SDA  0xbc
+#define  FMUX_GPIO_REG_IOCTRL_UART2_TX  0xc0
+#define  FMUX_GPIO_REG_IOCTRL_UART2_RTS  0xc4
+#define  FMUX_GPIO_REG_IOCTRL_UART2_RX  0xc8
+#define  FMUX_GPIO_REG_IOCTRL_UART2_CTS  0xcc
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D3  0xd0
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D2  0xd4
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D1  0xd8
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D0  0xdc
+#define  FMUX_GPIO_REG_IOCTRL_SD1_CMD  0xe0
+#define  FMUX_GPIO_REG_IOCTRL_SD1_CLK  0xe4
+#define  FMUX_GPIO_REG_IOCTRL_RSTN  0xe8
+#define  FMUX_GPIO_REG_IOCTRL_PWM0_BUCK  0xec
+#define  FMUX_GPIO_REG_IOCTRL_ADC3  0xf0
+#define  FMUX_GPIO_REG_IOCTRL_ADC2  0xf4
+#define  FMUX_GPIO_REG_IOCTRL_ADC1  0xf8
+#define  FMUX_GPIO_REG_IOCTRL_USB_ID  0xfc
+#define  FMUX_GPIO_REG_IOCTRL_USB_VBUS_EN  0x100
+#define  FMUX_GPIO_REG_IOCTRL_PKG_TYPE0  0x104
+#define  FMUX_GPIO_REG_IOCTRL_USB_VBUS_DET  0x108
+#define  FMUX_GPIO_REG_IOCTRL_PKG_TYPE1  0x10c
+#define  FMUX_GPIO_REG_IOCTRL_PKG_TYPE2  0x110
+#define  FMUX_GPIO_REG_IOCTRL_MUX_SPI1_MISO  0x114
+#define  FMUX_GPIO_REG_IOCTRL_MUX_SPI1_MOSI  0x118
+#define  FMUX_GPIO_REG_IOCTRL_MUX_SPI1_CS  0x11c
+#define  FMUX_GPIO_REG_IOCTRL_MUX_SPI1_SCK  0x120
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_TXP  0x124
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_TXM  0x128
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_RXP  0x12c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_RXM  0x130
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D10  0x134
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D9  0x138
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D8  0x13c
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D7  0x140
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D6  0x144
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D5  0x148
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D4  0x14c
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D3  0x150
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D2  0x154
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D1  0x158
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D0  0x15c
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_CLK  0x160
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX5N  0x164
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX5P  0x168
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX4N  0x16c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX4P  0x170
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX3N  0x174
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX3P  0x178
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX2N  0x17c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX2P  0x180
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX1N  0x184
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX1P  0x188
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX0N  0x18c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX0P  0x190
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM4  0x194
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP4  0x198
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM3  0x19c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP3  0x1a0
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM2  0x1a4
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP2  0x1a8
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM1  0x1ac
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP1  0x1b0
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM0  0x1b4
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP0  0x1b8
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AINL_MIC  0x1bc
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AINR_MIC  0x1c0
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AOUTL  0x1c4
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AOUTR  0x1c8
+#define  FMUX_GPIO_REG_IOCTRL_GPIO_RTX  0x1cc
+#define  FMUX_GPIO_REG_IOCTRL_GPIO_ZQ  0x1d0
+#define  FMUX_GPIO_FUNCSEL_CAM_MCLK0   0x0
+#define  FMUX_GPIO_FUNCSEL_CAM_MCLK0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CAM_MCLK0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_CAM_PD0   0x4
+#define  FMUX_GPIO_FUNCSEL_CAM_PD0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CAM_PD0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_CAM_RST0   0x8
+#define  FMUX_GPIO_FUNCSEL_CAM_RST0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CAM_RST0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_CAM_MCLK1   0xc
+#define  FMUX_GPIO_FUNCSEL_CAM_MCLK1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CAM_MCLK1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_CAM_PD1   0x10
+#define  FMUX_GPIO_FUNCSEL_CAM_PD1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CAM_PD1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC3_SCL   0x14
+#define  FMUX_GPIO_FUNCSEL_IIC3_SCL_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC3_SCL_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC3_SDA   0x18
+#define  FMUX_GPIO_FUNCSEL_IIC3_SDA_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC3_SDA_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_CLK   0x1c
+#define  FMUX_GPIO_FUNCSEL_SD0_CLK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_CLK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_CMD   0x20
+#define  FMUX_GPIO_FUNCSEL_SD0_CMD_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_CMD_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D0   0x24
+#define  FMUX_GPIO_FUNCSEL_SD0_D0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D1   0x28
+#define  FMUX_GPIO_FUNCSEL_SD0_D1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D2   0x2c
+#define  FMUX_GPIO_FUNCSEL_SD0_D2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D3   0x30
+#define  FMUX_GPIO_FUNCSEL_SD0_D3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_CD   0x34
+#define  FMUX_GPIO_FUNCSEL_SD0_CD_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_CD_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_PWR_EN   0x38
+#define  FMUX_GPIO_FUNCSEL_SD0_PWR_EN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_PWR_EN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SPK_EN   0x3c
+#define  FMUX_GPIO_FUNCSEL_SPK_EN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SPK_EN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART0_TX   0x40
+#define  FMUX_GPIO_FUNCSEL_UART0_TX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART0_TX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART0_RX   0x44
+#define  FMUX_GPIO_FUNCSEL_UART0_RX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART0_RX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_RSTN   0x48
+#define  FMUX_GPIO_FUNCSEL_EMMC_RSTN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_RSTN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT2   0x4c
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_CLK   0x50
+#define  FMUX_GPIO_FUNCSEL_EMMC_CLK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_CLK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT0   0x54
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT3   0x58
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_CMD   0x5c
+#define  FMUX_GPIO_FUNCSEL_EMMC_CMD_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_CMD_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT1   0x60
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TMS   0x64
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TMS_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TMS_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TCK   0x68
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TCK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TCK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TRST   0x6c
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TRST_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TRST_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC0_SCL   0x70
+#define  FMUX_GPIO_FUNCSEL_IIC0_SCL_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC0_SCL_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC0_SDA   0x74
+#define  FMUX_GPIO_FUNCSEL_IIC0_SDA_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC0_SDA_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_AUX0   0x78
+#define  FMUX_GPIO_FUNCSEL_AUX0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_AUX0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_VBAT_DET   0x7c
+#define  FMUX_GPIO_FUNCSEL_PWR_VBAT_DET_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_VBAT_DET_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_RSTN   0x80
+#define  FMUX_GPIO_FUNCSEL_PWR_RSTN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_RSTN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ1   0x84
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ2   0x88
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ3   0x8c
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP0   0x90
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP1   0x94
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_BUTTON1   0x98
+#define  FMUX_GPIO_FUNCSEL_PWR_BUTTON1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_BUTTON1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_ON   0x9c
+#define  FMUX_GPIO_FUNCSEL_PWR_ON_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_ON_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_XTAL_XIN   0xa0
+#define  FMUX_GPIO_FUNCSEL_XTAL_XIN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_XTAL_XIN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO0   0xa4
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO1   0xa8
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO2   0xac
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_CLK32K   0xb0
+#define  FMUX_GPIO_FUNCSEL_CLK32K_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CLK32K_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_CLK25M   0xb4
+#define  FMUX_GPIO_FUNCSEL_CLK25M_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CLK25M_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC2_SCL   0xb8
+#define  FMUX_GPIO_FUNCSEL_IIC2_SCL_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC2_SCL_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC2_SDA   0xbc
+#define  FMUX_GPIO_FUNCSEL_IIC2_SDA_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC2_SDA_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART2_TX   0xc0
+#define  FMUX_GPIO_FUNCSEL_UART2_TX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART2_TX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART2_RTS   0xc4
+#define  FMUX_GPIO_FUNCSEL_UART2_RTS_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART2_RTS_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART2_RX   0xc8
+#define  FMUX_GPIO_FUNCSEL_UART2_RX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART2_RX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART2_CTS   0xcc
+#define  FMUX_GPIO_FUNCSEL_UART2_CTS_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART2_CTS_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D3   0xd0
+#define  FMUX_GPIO_FUNCSEL_SD1_D3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D2   0xd4
+#define  FMUX_GPIO_FUNCSEL_SD1_D2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D1   0xd8
+#define  FMUX_GPIO_FUNCSEL_SD1_D1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D0   0xdc
+#define  FMUX_GPIO_FUNCSEL_SD1_D0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_CMD   0xe0
+#define  FMUX_GPIO_FUNCSEL_SD1_CMD_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_CMD_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_CLK   0xe4
+#define  FMUX_GPIO_FUNCSEL_SD1_CLK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_CLK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_RSTN   0xe8
+#define  FMUX_GPIO_FUNCSEL_RSTN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_RSTN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWM0_BUCK   0xec
+#define  FMUX_GPIO_FUNCSEL_PWM0_BUCK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWM0_BUCK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_ADC3   0xf0
+#define  FMUX_GPIO_FUNCSEL_ADC3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_ADC3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_ADC2   0xf4
+#define  FMUX_GPIO_FUNCSEL_ADC2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_ADC2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_ADC1   0xf8
+#define  FMUX_GPIO_FUNCSEL_ADC1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_ADC1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_USB_ID   0xfc
+#define  FMUX_GPIO_FUNCSEL_USB_ID_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_USB_ID_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_EN   0x100
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_EN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_EN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE0   0x104
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_DET   0x108
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_DET_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_DET_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE1   0x10c
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE2   0x110
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MISO   0x114
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MISO_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MISO_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MOSI   0x118
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MOSI_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_MOSI_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_CS   0x11c
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_CS_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_CS_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_SCK   0x120
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_SCK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_MUX_SPI1_SCK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXP   0x124
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXP_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXP_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXM   0x128
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXM_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXM_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXP   0x12c
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXP_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXP_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXM   0x130
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXM_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXM_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D10   0x134
+#define  FMUX_GPIO_FUNCSEL_VIVO_D10_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D10_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D9   0x138
+#define  FMUX_GPIO_FUNCSEL_VIVO_D9_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D9_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D8   0x13c
+#define  FMUX_GPIO_FUNCSEL_VIVO_D8_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D8_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D7   0x140
+#define  FMUX_GPIO_FUNCSEL_VIVO_D7_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D7_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D6   0x144
+#define  FMUX_GPIO_FUNCSEL_VIVO_D6_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D6_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D5   0x148
+#define  FMUX_GPIO_FUNCSEL_VIVO_D5_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D5_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D4   0x14c
+#define  FMUX_GPIO_FUNCSEL_VIVO_D4_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D4_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D3   0x150
+#define  FMUX_GPIO_FUNCSEL_VIVO_D3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D2   0x154
+#define  FMUX_GPIO_FUNCSEL_VIVO_D2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D1   0x158
+#define  FMUX_GPIO_FUNCSEL_VIVO_D1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D0   0x15c
+#define  FMUX_GPIO_FUNCSEL_VIVO_D0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_CLK   0x160
+#define  FMUX_GPIO_FUNCSEL_VIVO_CLK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_CLK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX5N   0x164
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX5N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX5N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX5P   0x168
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX5P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX5P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4N   0x16c
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4P   0x170
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3N   0x174
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3P   0x178
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2N   0x17c
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2P   0x180
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1N   0x184
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1P   0x188
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0N   0x18c
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0P   0x190
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM4   0x194
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM4_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM4_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP4   0x198
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP4_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP4_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM3   0x19c
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP3   0x1a0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM2   0x1a4
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP2   0x1a8
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM1   0x1ac
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP1   0x1b0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM0   0x1b4
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP0   0x1b8
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINL_MIC   0x1bc
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINL_MIC_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINL_MIC_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINR_MIC   0x1c0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINR_MIC_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINR_MIC_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTL   0x1c4
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTL_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTL_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTR   0x1c8
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTR_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTR_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_GPIO_RTX   0x1cc
+#define  FMUX_GPIO_FUNCSEL_GPIO_RTX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_GPIO_RTX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_GPIO_ZQ   0x1d0
+#define  FMUX_GPIO_FUNCSEL_GPIO_ZQ_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_GPIO_ZQ_MASK   0x7
+
+
+#endif /* __CV181X_REG_FMUX_GPIO_H__ */
diff --git a/drivers/pinctrl/cvitek/cv1822_pinlist_swconfig.h b/drivers/pinctrl/cvitek/cv1822_pinlist_swconfig.h
new file mode 100644
index 000000000000..65fe201f2e4d
--- /dev/null
+++ b/drivers/pinctrl/cvitek/cv1822_pinlist_swconfig.h
@@ -0,0 +1,603 @@
+//##==============================================================================
+//##=== This script is generate by genswconfig.pl from .\00_Mercury_Pinlist_20200528.xls
+//##=== Generate Time stamp is : 2020-05-28 20:47:34
+//##==============================================================================
+
+
+#define CAM_MCLK0__CAM_MCLK0 0
+#define CAM_MCLK0__AUX1 2
+#define CAM_MCLK0__XGPIOA_0 3
+#define CAM_PD0__IIS1_MCLK 1
+#define CAM_PD0__XGPIOA_1 3
+#define CAM_RST0__XGPIOA_2 3
+#define CAM_RST0__IIC4_SCL 6
+#define CAM_MCLK1__CAM_MCLK1 0
+#define CAM_MCLK1__AUX2 2
+#define CAM_MCLK1__XGPIOA_3 3
+#define CAM_PD1__IIS1_MCLK 1
+#define CAM_PD1__XGPIOA_4 3
+#define CAM_PD1__IIC4_SDA 6
+#define IIC3_SCL__IIC3_SCL 0
+#define IIC3_SCL__XGPIOA_5 3
+#define IIC3_SDA__IIC3_SDA 0
+#define IIC3_SDA__XGPIOA_6 3
+#define SD0_CLK__SDIO0_CLK 0
+#define SD0_CLK__IIC1_SDA 1
+#define SD0_CLK__SPI0_SCK 2
+#define SD0_CLK__XGPIOA_7 3
+#define SD0_CLK__PWM_15 5
+#define SD0_CLK__EPHY_LNK_LED 6
+#define SD0_CLK__DBG_0 7
+#define SD0_CMD__SDIO0_CMD 0
+#define SD0_CMD__IIC1_SCL 1
+#define SD0_CMD__SPI0_SDO 2
+#define SD0_CMD__XGPIOA_8 3
+#define SD0_CMD__PWM_14 5
+#define SD0_CMD__EPHY_SPD_LED 6
+#define SD0_CMD__DBG_1 7
+#define SD0_D0__SDIO0_D_0 0
+#define SD0_D0__CAM_MCLK1 1
+#define SD0_D0__SPI0_SDI 2
+#define SD0_D0__XGPIOA_9 3
+#define SD0_D0__UART3_TX 4
+#define SD0_D0__PWM_13 5
+#define SD0_D0__WG0_D0 6
+#define SD0_D0__DBG_2 7
+#define SD0_D1__SDIO0_D_1 0
+#define SD0_D1__IIC1_SDA 1
+#define SD0_D1__AUX0 2
+#define SD0_D1__XGPIOA_10 3
+#define SD0_D1__UART1_TX 4
+#define SD0_D1__PWM_12 5
+#define SD0_D1__WG0_D1 6
+#define SD0_D1__DBG_3 7
+#define SD0_D2__SDIO0_D_2 0
+#define SD0_D2__IIC1_SCL 1
+#define SD0_D2__AUX1 2
+#define SD0_D2__XGPIOA_11 3
+#define SD0_D2__UART1_RX 4
+#define SD0_D2__PWM_11 5
+#define SD0_D2__WG1_D0 6
+#define SD0_D2__DBG_4 7
+#define SD0_D3__SDIO0_D_3 0
+#define SD0_D3__CAM_MCLK0 1
+#define SD0_D3__SPI0_CS_X 2
+#define SD0_D3__XGPIOA_12 3
+#define SD0_D3__UART3_RX 4
+#define SD0_D3__PWM_10 5
+#define SD0_D3__WG1_D1 6
+#define SD0_D3__DBG_5 7
+#define SD0_CD__SDIO0_CD 0
+#define SD0_CD__XGPIOA_13 3
+#define SD0_PWR_EN__SDIO0_PWR_EN 0
+#define SD0_PWR_EN__XGPIOA_14 3
+#define SPK_EN__XGPIOA_15 3
+#define UART0_TX__UART0_TX 0
+#define UART0_TX__CAM_MCLK1 1
+#define UART0_TX__PWM_4 2
+#define UART0_TX__XGPIOA_16 3
+#define UART0_TX__UART1_TX 4
+#define UART0_TX__AUX1 5
+#define UART0_TX__DBG_6 7
+#define UART0_RX__UART0_RX 0
+#define UART0_RX__CAM_MCLK0 1
+#define UART0_RX__PWM_5 2
+#define UART0_RX__XGPIOA_17 3
+#define UART0_RX__UART1_RX 4
+#define UART0_RX__AUX0 5
+#define UART0_RX__DBG_7 7
+#define EMMC_RSTN__EMMC_RSTN 0
+#define EMMC_RSTN__XGPIOA_21 3
+#define EMMC_RSTN__AUX2 4
+#define EMMC_DAT2__EMMC_DAT_2 0
+#define EMMC_DAT2__SPINOR_HOLD_X 1
+#define EMMC_DAT2__SPINAND_HOLD 2
+#define EMMC_DAT2__XGPIOA_26 3
+#define EMMC_CLK__EMMC_CLK 0
+#define EMMC_CLK__SPINOR_SCK 1
+#define EMMC_CLK__SPINAND_CLK 2
+#define EMMC_CLK__XGPIOA_22 3
+#define EMMC_DAT0__EMMC_DAT_0 0
+#define EMMC_DAT0__SPINOR_MOSI 1
+#define EMMC_DAT0__SPINAND_MOSI 2
+#define EMMC_DAT0__XGPIOA_25 3
+#define EMMC_DAT3__EMMC_DAT_3 0
+#define EMMC_DAT3__SPINOR_WP_X 1
+#define EMMC_DAT3__SPINAND_WP 2
+#define EMMC_DAT3__XGPIOA_27 3
+#define EMMC_CMD__EMMC_CMD 0
+#define EMMC_CMD__SPINOR_MISO 1
+#define EMMC_CMD__SPINAND_MISO 2
+#define EMMC_CMD__XGPIOA_23 3
+#define EMMC_DAT1__EMMC_DAT_1 0
+#define EMMC_DAT1__SPINOR_CS_X 1
+#define EMMC_DAT1__SPINAND_CS 2
+#define EMMC_DAT1__XGPIOA_24 3
+#define JTAG_CPU_TMS__JTAG_CPU_TMS 0
+#define JTAG_CPU_TMS__CAM_MCLK0 1
+#define JTAG_CPU_TMS__PWM_7 2
+#define JTAG_CPU_TMS__XGPIOA_19 3
+#define JTAG_CPU_TMS__UART1_RTS 4
+#define JTAG_CPU_TMS__AUX0 5
+#define JTAG_CPU_TMS__UART1_TX 6
+#define JTAG_CPU_TMS__DBG_9 7
+#define JTAG_CPU_TCK__JTAG_CPU_TCK 0
+#define JTAG_CPU_TCK__CAM_MCLK1 1
+#define JTAG_CPU_TCK__PWM_6 2
+#define JTAG_CPU_TCK__XGPIOA_18 3
+#define JTAG_CPU_TCK__UART1_CTS 4
+#define JTAG_CPU_TCK__AUX1 5
+#define JTAG_CPU_TCK__UART1_RX 6
+#define JTAG_CPU_TCK__DBG_8 7
+#define JTAG_CPU_TRST__JTAG_CPU_TRST 0
+#define JTAG_CPU_TRST__XGPIOA_20 3
+#define IIC0_SCL__IIC0_SCL 0
+#define IIC0_SCL__UART1_TX 1
+#define IIC0_SCL__UART2_TX 2
+#define IIC0_SCL__XGPIOA_28 3
+#define IIC0_SCL__WG0_D0 5
+#define IIC0_SCL__DBG_10 7
+#define IIC0_SDA__IIC0_SDA 0
+#define IIC0_SDA__UART1_RX 1
+#define IIC0_SDA__UART2_RX 2
+#define IIC0_SDA__XGPIOA_29 3
+#define IIC0_SDA__WG0_D1 5
+#define IIC0_SDA__WG1_D0 6
+#define IIC0_SDA__DBG_11 7
+#define AUX0__AUX0 0
+#define AUX0__XGPIOA_30 3
+#define AUX0__IIS1_MCLK 4
+#define AUX0__WG1_D1 6
+#define AUX0__DBG_12 7
+#define PWR_VBAT_DET__PWR_VBAT_DET 0
+#define PWR_RSTN__PWR_RSTN 0
+#define PWR_SEQ1__PWR_SEQ1 0
+#define PWR_SEQ1__PWR_GPIO_3 3
+#define PWR_SEQ2__PWR_SEQ2 0
+#define PWR_SEQ2__PWR_GPIO_4 3
+#define PWR_SEQ3__PWR_SEQ3 0
+#define PWR_SEQ3__PWR_GPIO_5 3
+#define PTEST__PWR_PTEST 0
+#define PWR_WAKEUP0__PWR_WAKEUP0 0
+#define PWR_WAKEUP0__PWR_UART0_RX 2
+#define PWR_WAKEUP0__PWR_GPIO_6 3
+#define PWR_WAKEUP0__UART1_TX 4
+#define PWR_WAKEUP0__IIC4_SCL 5
+#define PWR_WAKEUP0__EPHY_LNK_LED 6
+#define PWR_WAKEUP0__WG2_D0 7
+#define PWR_WAKEUP1__PWR_WAKEUP1 0
+#define PWR_WAKEUP1__PWR_GPIO_7 3
+#define PWR_WAKEUP1__UART1_RX 4
+#define PWR_WAKEUP1__IIC4_SDA 5
+#define PWR_WAKEUP1__EPHY_SPD_LED 6
+#define PWR_WAKEUP1__WG2_D1 7
+#define PWR_BUTTON1__PWR_BUTTON1 0
+#define PWR_BUTTON1__PWR_GPIO_8 3
+#define PWR_BUTTON1__UART1_TX 4
+#define PWR_BUTTON1__IIC4_SCL 5
+#define PWR_BUTTON1__EPHY_LNK_LED 6
+#define PWR_BUTTON1__WG0_D0 7
+#define PWR_ON__PWR_ON 0
+#define PWR_ON__PWR_GPIO_9 3
+#define PWR_ON__UART1_RX 4
+#define PWR_ON__IIC4_SDA 5
+#define PWR_ON__EPHY_SPD_LED 6
+#define PWR_ON__WG0_D1 7
+#define XTAL_XIN__PWR_XTAL_CLKIN 0
+#define PWR_GPIO0__PWR_GPIO_0 0
+#define PWR_GPIO0__UART2_TX 1
+#define PWR_GPIO0__PWR_UART0_TX 2
+#define PWR_GPIO0__PWM_8 4
+#define PWR_GPIO1__PWR_GPIO_1 0
+#define PWR_GPIO1__UART2_RX 1
+#define PWR_GPIO1__EPHY_LNK_LED 3
+#define PWR_GPIO1__PWM_9 4
+#define PWR_GPIO1__PWR_IIC_SCL 5
+#define PWR_GPIO1__IIC2_SCL 6
+#define PWR_GPIO1__PWR_MCU_JTAG_TMS 7
+#define PWR_GPIO2__PWR_GPIO_2 0
+#define PWR_GPIO2__PWR_SECTICK 2
+#define PWR_GPIO2__EPHY_SPD_LED 3
+#define PWR_GPIO2__PWM_10 4
+#define PWR_GPIO2__PWR_IIC_SDA 5
+#define PWR_GPIO2__IIC2_SDA 6
+#define PWR_GPIO2__PWR_MCU_JTAG_TCK 7
+#define CLK32K__CLK32K 0
+#define CLK32K__AUX0 1
+#define CLK32K__PWR_MCU_JTAG_TDI 2
+#define CLK32K__PWR_GPIO_10 3
+#define CLK32K__PWM_2 4
+#define CLK32K__KEY_COL0 5
+#define CLK32K__CAM_MCLK0 6
+#define CLK32K__DBG_0 7
+#define CLK25M__CLK25M 0
+#define CLK25M__AUX1 1
+#define CLK25M__PWR_MCU_JTAG_TDO 2
+#define CLK25M__PWR_GPIO_11 3
+#define CLK25M__PWM_3 4
+#define CLK25M__KEY_COL1 5
+#define CLK25M__CAM_MCLK1 6
+#define CLK25M__DBG_1 7
+#define IIC2_SCL__IIC2_SCL 0
+#define IIC2_SCL__PWM_14 1
+#define IIC2_SCL__PWR_GPIO_12 3
+#define IIC2_SCL__UART2_RX 4
+#define IIC2_SCL__KEY_COL2 7
+#define IIC2_SDA__IIC2_SDA 0
+#define IIC2_SDA__PWM_15 1
+#define IIC2_SDA__PWR_GPIO_13 3
+#define IIC2_SDA__UART2_TX 4
+#define IIC2_SDA__IIS1_MCLK 5
+#define IIC2_SDA__IIS2_MCLK 6
+#define IIC2_SDA__KEY_COL3 7
+#define UART2_TX__UART2_TX 0
+#define UART2_TX__PWM_11 1
+#define UART2_TX__PWR_UART1_TX 2
+#define UART2_TX__PWR_GPIO_14 3
+#define UART2_TX__KEY_ROW3 4
+#define UART2_TX__UART4_TX 5
+#define UART2_TX__IIS2_BCLK 6
+#define UART2_TX__WG2_D0 7
+#define UART2_RTS__UART2_RTS 0
+#define UART2_RTS__PWM_8 1
+#define UART2_RTS__PWR_GPIO_15 3
+#define UART2_RTS__KEY_ROW0 4
+#define UART2_RTS__UART4_RTS 5
+#define UART2_RTS__IIS2_DO 6
+#define UART2_RTS__WG1_D0 7
+#define UART2_RX__UART2_RX 0
+#define UART2_RX__PWM_10 1
+#define UART2_RX__PWR_UART1_RX 2
+#define UART2_RX__PWR_GPIO_16 3
+#define UART2_RX__KEY_COL3 4
+#define UART2_RX__UART4_RX 5
+#define UART2_RX__IIS2_DI 6
+#define UART2_RX__WG2_D1 7
+#define UART2_CTS__UART2_CTS 0
+#define UART2_CTS__PWM_9 1
+#define UART2_CTS__PWR_GPIO_17 3
+#define UART2_CTS__KEY_ROW1 4
+#define UART2_CTS__UART4_CTS 5
+#define UART2_CTS__IIS2_LRCK 6
+#define UART2_CTS__WG1_D1 7
+#define SD1_D3__PWR_SD1_D3 0
+#define SD1_D3__SPI2_CS_X 1
+#define SD1_D3__IIC1_SCL 2
+#define SD1_D3__PWR_GPIO_18 3
+#define SD1_D3__CAM_MCLK0 4
+#define SD1_D3__UART3_CTS 5
+#define SD1_D3__PWR_SPINOR1_CS_X 6
+#define SD1_D3__PWM_4 7
+#define SD1_D2__PWR_SD1_D2 0
+#define SD1_D2__IIC1_SCL 1
+#define SD1_D2__UART2_TX 2
+#define SD1_D2__PWR_GPIO_19 3
+#define SD1_D2__CAM_MCLK0 4
+#define SD1_D2__UART3_TX 5
+#define SD1_D2__PWR_SPINOR1_HOLD_X 6
+#define SD1_D2__PWM_5 7
+#define SD1_D1__PWR_SD1_D1 0
+#define SD1_D1__IIC1_SDA 1
+#define SD1_D1__UART2_RX 2
+#define SD1_D1__PWR_GPIO_20 3
+#define SD1_D1__CAM_MCLK1 4
+#define SD1_D1__UART3_RX 5
+#define SD1_D1__PWR_SPINOR1_WP_X 6
+#define SD1_D1__PWM_6 7
+#define SD1_D0__PWR_SD1_D0 0
+#define SD1_D0__SPI2_SDI 1
+#define SD1_D0__IIC1_SDA 2
+#define SD1_D0__PWR_GPIO_21 3
+#define SD1_D0__CAM_MCLK1 4
+#define SD1_D0__UART3_RTS 5
+#define SD1_D0__PWR_SPINOR1_MISO 6
+#define SD1_D0__PWM_7 7
+#define SD1_CMD__PWR_SD1_CMD 0
+#define SD1_CMD__SPI2_SDO 1
+#define SD1_CMD__IIC3_SCL 2
+#define SD1_CMD__PWR_GPIO_22 3
+#define SD1_CMD__EPHY_LNK_LED 5
+#define SD1_CMD__PWR_SPINOR1_MOSI 6
+#define SD1_CMD__PWM_8 7
+#define SD1_CLK__PWR_SD1_CLK 0
+#define SD1_CLK__SPI2_SCK 1
+#define SD1_CLK__IIC3_SDA 2
+#define SD1_CLK__PWR_GPIO_23 3
+#define SD1_CLK__EPHY_SPD_LED 5
+#define SD1_CLK__PWR_SPINOR1_SCK 6
+#define SD1_CLK__PWM_9 7
+#define RSTN__RSTN 0
+#define PWM0_BUCK__PWM_0 0
+#define PWM0_BUCK__XGPIOB_0 3
+#define ADC3__CAM_MCLK0 1
+#define ADC3__IIC4_SCL 2
+#define ADC3__XGPIOB_1 3
+#define ADC3__PWM_12 4
+#define ADC3__EPHY_LNK_LED 5
+#define ADC3__WG2_D0 6
+#define ADC3__UART3_TX 7
+#define ADC2__CAM_MCLK1 1
+#define ADC2__IIC4_SDA 2
+#define ADC2__XGPIOB_2 3
+#define ADC2__PWM_13 4
+#define ADC2__EPHY_SPD_LED 5
+#define ADC2__WG2_D1 6
+#define ADC2__UART3_RX 7
+#define ADC1__XGPIOB_3 3
+#define ADC1__KEY_COL2 4
+#define USB_ID__USB_ID 0
+#define USB_ID__XGPIOB_4 3
+#define USB_VBUS_EN__USB_VBUS_EN 0
+#define USB_VBUS_EN__XGPIOB_5 3
+#define PKG_TYPE0__PKG_TYPE0 0
+#define USB_VBUS_DET__USB_VBUS_DET 0
+#define USB_VBUS_DET__XGPIOB_6 3
+#define USB_VBUS_DET__CAM_MCLK0 4
+#define USB_VBUS_DET__CAM_MCLK1 5
+#define PKG_TYPE1__PKG_TYPE1 0
+#define PKG_TYPE2__PKG_TYPE2 0
+#define PAD_ETH_TXP__UART3_CTS 1
+#define PAD_ETH_TXP__CAM_MCLK0 2
+#define PAD_ETH_TXP__XGPIOB_10 3
+#define PAD_ETH_TXP__PWM_11 4
+#define PAD_ETH_TXP__KEY_ROW3 5
+#define PAD_ETH_TXP__SPI1_CS_X 6
+#define PAD_ETH_TXP__DBG_16 7
+#define PAD_ETH_TXM__UART3_TX 1
+#define PAD_ETH_TXM__CAM_MCLK1 2
+#define PAD_ETH_TXM__XGPIOB_9 3
+#define PAD_ETH_TXM__PWM_10 4
+#define PAD_ETH_TXM__KEY_ROW2 5
+#define PAD_ETH_TXM__SPI1_SCK 6
+#define PAD_ETH_TXM__DBG_15 7
+#define PAD_ETH_RXP__UART3_RX 1
+#define PAD_ETH_RXP__IIC1_SCL 2
+#define PAD_ETH_RXP__XGPIOB_7 3
+#define PAD_ETH_RXP__PWM_8 4
+#define PAD_ETH_RXP__KEY_COL0 5
+#define PAD_ETH_RXP__SPI1_SDO 6
+#define PAD_ETH_RXP__DBG_13 7
+#define PAD_ETH_RXM__UART3_RTS 1
+#define PAD_ETH_RXM__IIC1_SDA 2
+#define PAD_ETH_RXM__XGPIOB_8 3
+#define PAD_ETH_RXM__PWM_9 4
+#define PAD_ETH_RXM__KEY_COL1 5
+#define PAD_ETH_RXM__SPI1_SDI 6
+#define PAD_ETH_RXM__DBG_14 7
+#define VIVO_D10__PWM_1 0
+#define VIVO_D10__VI1_D_10 1
+#define VIVO_D10__VO_D_23 2
+#define VIVO_D10__XGPIOB_11 3
+#define VIVO_D10__RMII0_IRQ 4
+#define VIVO_D10__CAM_MCLK0 5
+#define VIVO_D10__IIC1_SDA 6
+#define VIVO_D10__UART2_TX 7
+#define VIVO_D9__PWM_2 0
+#define VIVO_D9__VI1_D_9 1
+#define VIVO_D9__VO_D_22 2
+#define VIVO_D9__XGPIOB_12 3
+#define VIVO_D9__CAM_MCLK1 5
+#define VIVO_D9__IIC1_SCL 6
+#define VIVO_D9__UART2_RX 7
+#define VIVO_D8__PWM_3 0
+#define VIVO_D8__VI1_D_8 1
+#define VIVO_D8__VO_D_21 2
+#define VIVO_D8__XGPIOB_13 3
+#define VIVO_D8__RMII0_MDIO 4
+#define VIVO_D8__SPI3_SDO 5
+#define VIVO_D8__IIC2_SCL 6
+#define VIVO_D8__DBG_17 7
+#define VIVO_D7__VI2_D_7 0
+#define VIVO_D7__VI1_D_7 1
+#define VIVO_D7__VO_D_20 2
+#define VIVO_D7__XGPIOB_14 3
+#define VIVO_D7__RMII0_RXD1 4
+#define VIVO_D7__SPI3_SDI 5
+#define VIVO_D7__IIC2_SDA 6
+#define VIVO_D7__DBG_18 7
+#define VIVO_D6__VI2_D_6 0
+#define VIVO_D6__VI1_D_6 1
+#define VIVO_D6__VO_D_19 2
+#define VIVO_D6__XGPIOB_15 3
+#define VIVO_D6__RMII0_REFCLKI 4
+#define VIVO_D6__SPI3_SCK 5
+#define VIVO_D6__UART2_TX 6
+#define VIVO_D6__DBG_19 7
+#define VIVO_D5__VI2_D_5 0
+#define VIVO_D5__VI1_D_5 1
+#define VIVO_D5__VO_D_18 2
+#define VIVO_D5__XGPIOB_16 3
+#define VIVO_D5__RMII0_RXD0 4
+#define VIVO_D5__SPI3_CS_X 5
+#define VIVO_D5__UART2_RX 6
+#define VIVO_D5__DBG_20 7
+#define VIVO_D4__VI2_D_4 0
+#define VIVO_D4__VI1_D_4 1
+#define VIVO_D4__VO_D_17 2
+#define VIVO_D4__XGPIOB_17 3
+#define VIVO_D4__RMII0_MDC 4
+#define VIVO_D4__IIC1_SDA 5
+#define VIVO_D4__UART2_CTS 6
+#define VIVO_D4__DBG_21 7
+#define VIVO_D3__VI2_D_3 0
+#define VIVO_D3__VI1_D_3 1
+#define VIVO_D3__VO_D_16 2
+#define VIVO_D3__XGPIOB_18 3
+#define VIVO_D3__RMII0_TXD0 4
+#define VIVO_D3__IIC1_SCL 5
+#define VIVO_D3__UART2_RTS 6
+#define VIVO_D3__DBG_22 7
+#define VIVO_D2__VI2_D_2 0
+#define VIVO_D2__VI1_D_2 1
+#define VIVO_D2__VO_D_15 2
+#define VIVO_D2__XGPIOB_19 3
+#define VIVO_D2__RMII0_TXD1 4
+#define VIVO_D2__CAM_MCLK1 5
+#define VIVO_D2__PWM_2 6
+#define VIVO_D2__UART2_TX 7
+#define VIVO_D1__VI2_D_1 0
+#define VIVO_D1__VI1_D_1 1
+#define VIVO_D1__VO_D_14 2
+#define VIVO_D1__XGPIOB_20 3
+#define VIVO_D1__RMII0_RXDV 4
+#define VIVO_D1__IIC3_SDA 5
+#define VIVO_D1__PWM_3 6
+#define VIVO_D1__IIC4_SCL 7
+#define VIVO_D0__VI2_D_0 0
+#define VIVO_D0__VI1_D_0 1
+#define VIVO_D0__VO_D_13 2
+#define VIVO_D0__XGPIOB_21 3
+#define VIVO_D0__RMII0_TXCLK 4
+#define VIVO_D0__IIC3_SCL 5
+#define VIVO_D0__WG1_D0 6
+#define VIVO_D0__IIC4_SDA 7
+#define VIVO_CLK__VI2_CLK 0
+#define VIVO_CLK__VI1_CLK 1
+#define VIVO_CLK__VO_CLK1 2
+#define VIVO_CLK__XGPIOB_22 3
+#define VIVO_CLK__RMII0_TXEN 4
+#define VIVO_CLK__CAM_MCLK0 5
+#define VIVO_CLK__WG1_D1 6
+#define VIVO_CLK__UART2_RX 7
+#define PAD_MIPIRX5N__VI1_D_11 1
+#define PAD_MIPIRX5N__VO_D_12 2
+#define PAD_MIPIRX5N__XGPIOC_0 3
+#define PAD_MIPIRX5N__CAM_MCLK0 5
+#define PAD_MIPIRX5N__WG0_D0 6
+#define PAD_MIPIRX5N__DBG_0 7
+#define PAD_MIPIRX5P__VI1_D_12 1
+#define PAD_MIPIRX5P__VO_D_11 2
+#define PAD_MIPIRX5P__XGPIOC_1 3
+#define PAD_MIPIRX5P__IIS1_MCLK 4
+#define PAD_MIPIRX5P__CAM_MCLK1 5
+#define PAD_MIPIRX5P__WG0_D1 6
+#define PAD_MIPIRX5P__DBG_1 7
+#define PAD_MIPIRX4N__VI0_CLK 1
+#define PAD_MIPIRX4N__VI1_D_13 2
+#define PAD_MIPIRX4N__XGPIOC_2 3
+#define PAD_MIPIRX4N__IIC1_SDA 4
+#define PAD_MIPIRX4N__CAM_MCLK0 5
+#define PAD_MIPIRX4N__KEY_ROW0 6
+#define PAD_MIPIRX4N__DBG_2 7
+#define PAD_MIPIRX4P__VI0_D_0 1
+#define PAD_MIPIRX4P__VI1_D_14 2
+#define PAD_MIPIRX4P__XGPIOC_3 3
+#define PAD_MIPIRX4P__IIC1_SCL 4
+#define PAD_MIPIRX4P__CAM_MCLK1 5
+#define PAD_MIPIRX4P__KEY_ROW1 6
+#define PAD_MIPIRX4P__DBG_3 7
+#define PAD_MIPIRX3N__VI0_D_1 1
+#define PAD_MIPIRX3N__VI1_D_15 2
+#define PAD_MIPIRX3N__XGPIOC_4 3
+#define PAD_MIPIRX3N__CAM_MCLK0 4
+#define PAD_MIPIRX3N__DBG_4 7
+#define PAD_MIPIRX3P__VI0_D_2 1
+#define PAD_MIPIRX3P__VI1_D_16 2
+#define PAD_MIPIRX3P__XGPIOC_5 3
+#define PAD_MIPIRX3P__DBG_5 7
+#define PAD_MIPIRX2N__VI0_D_3 1
+#define PAD_MIPIRX2N__VO_D_10 2
+#define PAD_MIPIRX2N__XGPIOC_6 3
+#define PAD_MIPIRX2N__VI1_D_17 4
+#define PAD_MIPIRX2N__IIC4_SCL 5
+#define PAD_MIPIRX2N__DBG_6 7
+#define PAD_MIPIRX2P__VI0_D_4 1
+#define PAD_MIPIRX2P__VO_D_9 2
+#define PAD_MIPIRX2P__XGPIOC_7 3
+#define PAD_MIPIRX2P__VI1_D_18 4
+#define PAD_MIPIRX2P__IIC4_SDA 5
+#define PAD_MIPIRX2P__DBG_7 7
+#define PAD_MIPIRX1N__VI0_D_5 1
+#define PAD_MIPIRX1N__VO_D_8 2
+#define PAD_MIPIRX1N__XGPIOC_8 3
+#define PAD_MIPIRX1N__KEY_ROW3 6
+#define PAD_MIPIRX1N__DBG_8 7
+#define PAD_MIPIRX1P__VI0_D_6 1
+#define PAD_MIPIRX1P__VO_D_7 2
+#define PAD_MIPIRX1P__XGPIOC_9 3
+#define PAD_MIPIRX1P__IIC1_SDA 4
+#define PAD_MIPIRX1P__KEY_ROW2 6
+#define PAD_MIPIRX1P__DBG_9 7
+#define PAD_MIPIRX0N__VI0_D_7 1
+#define PAD_MIPIRX0N__VO_D_6 2
+#define PAD_MIPIRX0N__XGPIOC_10 3
+#define PAD_MIPIRX0N__IIC1_SCL 4
+#define PAD_MIPIRX0N__CAM_MCLK1 5
+#define PAD_MIPIRX0N__DBG_10 7
+#define PAD_MIPIRX0P__VI0_D_8 1
+#define PAD_MIPIRX0P__VO_D_5 2
+#define PAD_MIPIRX0P__XGPIOC_11 3
+#define PAD_MIPIRX0P__CAM_MCLK0 4
+#define PAD_MIPIRX0P__DBG_11 7
+#define PAD_MIPI_TXM4__VO_D_24 2
+#define PAD_MIPI_TXM4__XGPIOC_18 3
+#define PAD_MIPI_TXM4__CAM_MCLK1 4
+#define PAD_MIPI_TXM4__PWM_12 5
+#define PAD_MIPI_TXM4__IIC1_SDA 6
+#define PAD_MIPI_TXM4__DBG_18 7
+#define PAD_MIPI_TXP4__VO_D_25 2
+#define PAD_MIPI_TXP4__XGPIOC_19 3
+#define PAD_MIPI_TXP4__CAM_MCLK0 4
+#define PAD_MIPI_TXP4__PWM_13 5
+#define PAD_MIPI_TXP4__IIC1_SCL 6
+#define PAD_MIPI_TXP4__DBG_19 7
+#define PAD_MIPI_TXM3__VO_D_26 2
+#define PAD_MIPI_TXM3__XGPIOC_20 3
+#define PAD_MIPI_TXM3__IIC2_SDA 4
+#define PAD_MIPI_TXM3__PWM_14 5
+#define PAD_MIPI_TXM3__IIC1_SDA 6
+#define PAD_MIPI_TXM3__DBG_20 7
+#define PAD_MIPI_TXP3__VO_D_27 2
+#define PAD_MIPI_TXP3__XGPIOC_21 3
+#define PAD_MIPI_TXP3__IIC2_SCL 4
+#define PAD_MIPI_TXP3__PWM_15 5
+#define PAD_MIPI_TXP3__IIC1_SCL 6
+#define PAD_MIPI_TXP3__DBG_21 7
+#define PAD_MIPI_TXM2__VI0_D_13 1
+#define PAD_MIPI_TXM2__VO_D_0 2
+#define PAD_MIPI_TXM2__XGPIOC_16 3
+#define PAD_MIPI_TXM2__IIC1_SDA 4
+#define PAD_MIPI_TXM2__PWM_8 5
+#define PAD_MIPI_TXM2__SPI0_SCK 6
+#define PAD_MIPI_TXM2__DBG_16 7
+#define PAD_MIPI_TXP2__VI0_D_14 1
+#define PAD_MIPI_TXP2__VO_CLK0 2
+#define PAD_MIPI_TXP2__XGPIOC_17 3
+#define PAD_MIPI_TXP2__IIC1_SCL 4
+#define PAD_MIPI_TXP2__PWM_9 5
+#define PAD_MIPI_TXP2__SPI0_CS_X 6
+#define PAD_MIPI_TXP2__DBG_17 7
+#define PAD_MIPI_TXM1__VI0_D_11 1
+#define PAD_MIPI_TXM1__VO_D_2 2
+#define PAD_MIPI_TXM1__XGPIOC_14 3
+#define PAD_MIPI_TXM1__IIC2_SDA 4
+#define PAD_MIPI_TXM1__PWM_10 5
+#define PAD_MIPI_TXM1__SPI0_SDO 6
+#define PAD_MIPI_TXM1__DBG_14 7
+#define PAD_MIPI_TXP1__VI0_D_12 1
+#define PAD_MIPI_TXP1__VO_D_1 2
+#define PAD_MIPI_TXP1__XGPIOC_15 3
+#define PAD_MIPI_TXP1__IIC2_SCL 4
+#define PAD_MIPI_TXP1__PWM_11 5
+#define PAD_MIPI_TXP1__SPI0_SDI 6
+#define PAD_MIPI_TXP1__DBG_15 7
+#define PAD_MIPI_TXM0__VI0_D_9 1
+#define PAD_MIPI_TXM0__VO_D_4 2
+#define PAD_MIPI_TXM0__XGPIOC_12 3
+#define PAD_MIPI_TXM0__CAM_MCLK1 4
+#define PAD_MIPI_TXM0__PWM_14 5
+#define PAD_MIPI_TXM0__DBG_12 7
+#define PAD_MIPI_TXP0__VI0_D_10 1
+#define PAD_MIPI_TXP0__VO_D_3 2
+#define PAD_MIPI_TXP0__XGPIOC_13 3
+#define PAD_MIPI_TXP0__CAM_MCLK0 4
+#define PAD_MIPI_TXP0__PWM_15 5
+#define PAD_MIPI_TXP0__DBG_13 7
+#define PAD_AUD_AINL_MIC__XGPIOC_23 3
+#define PAD_AUD_AINL_MIC__IIS1_BCLK 4
+#define PAD_AUD_AINR_MIC__XGPIOC_22 3
+#define PAD_AUD_AINR_MIC__IIS1_DO 4
+#define PAD_AUD_AOUTL__XGPIOC_25 3
+#define PAD_AUD_AOUTL__IIS1_LRCK 4
+#define PAD_AUD_AOUTR__XGPIOC_24 3
+#define PAD_AUD_AOUTR__IIS1_DI 4
diff --git a/drivers/pinctrl/cvitek/cv1822_reg_fmux_gpio.h b/drivers/pinctrl/cvitek/cv1822_reg_fmux_gpio.h
new file mode 100644
index 000000000000..32a4132d8ed9
--- /dev/null
+++ b/drivers/pinctrl/cvitek/cv1822_reg_fmux_gpio.h
@@ -0,0 +1,451 @@
+// $Module: fmux_gpio $
+// $RegisterBank Version: V 1.0.00 $
+// $Author: ghost $
+// $Date: Thu, 28 May 2020 08:53:35 PM $
+//
+
+//GEN REG ADDR/OFFSET/MASK
+#define  FMUX_GPIO_REG_IOCTRL_CAM_MCLK0  0x0
+#define  FMUX_GPIO_REG_IOCTRL_CAM_PD0  0x4
+#define  FMUX_GPIO_REG_IOCTRL_CAM_RST0  0x8
+#define  FMUX_GPIO_REG_IOCTRL_CAM_MCLK1  0xc
+#define  FMUX_GPIO_REG_IOCTRL_CAM_PD1  0x10
+#define  FMUX_GPIO_REG_IOCTRL_IIC3_SCL  0x14
+#define  FMUX_GPIO_REG_IOCTRL_IIC3_SDA  0x18
+#define  FMUX_GPIO_REG_IOCTRL_SD0_CLK  0x1c
+#define  FMUX_GPIO_REG_IOCTRL_SD0_CMD  0x20
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D0  0x24
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D1  0x28
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D2  0x2c
+#define  FMUX_GPIO_REG_IOCTRL_SD0_D3  0x30
+#define  FMUX_GPIO_REG_IOCTRL_SD0_CD  0x34
+#define  FMUX_GPIO_REG_IOCTRL_SD0_PWR_EN  0x38
+#define  FMUX_GPIO_REG_IOCTRL_SPK_EN  0x3c
+#define  FMUX_GPIO_REG_IOCTRL_UART0_TX  0x40
+#define  FMUX_GPIO_REG_IOCTRL_UART0_RX  0x44
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_RSTN  0x48
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_DAT2  0x4c
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_CLK  0x50
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_DAT0  0x54
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_DAT3  0x58
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_CMD  0x5c
+#define  FMUX_GPIO_REG_IOCTRL_EMMC_DAT1  0x60
+#define  FMUX_GPIO_REG_IOCTRL_JTAG_CPU_TMS  0x64
+#define  FMUX_GPIO_REG_IOCTRL_JTAG_CPU_TCK  0x68
+#define  FMUX_GPIO_REG_IOCTRL_JTAG_CPU_TRST  0x6c
+#define  FMUX_GPIO_REG_IOCTRL_IIC0_SCL  0x70
+#define  FMUX_GPIO_REG_IOCTRL_IIC0_SDA  0x74
+#define  FMUX_GPIO_REG_IOCTRL_AUX0  0x78
+#define  FMUX_GPIO_REG_IOCTRL_PWR_VBAT_DET  0x7c
+#define  FMUX_GPIO_REG_IOCTRL_PWR_RSTN  0x80
+#define  FMUX_GPIO_REG_IOCTRL_PWR_SEQ1  0x84
+#define  FMUX_GPIO_REG_IOCTRL_PWR_SEQ2  0x88
+#define  FMUX_GPIO_REG_IOCTRL_PWR_SEQ3  0x8c
+#define  FMUX_GPIO_REG_IOCTRL_PWR_WAKEUP0  0x90
+#define  FMUX_GPIO_REG_IOCTRL_PWR_WAKEUP1  0x94
+#define  FMUX_GPIO_REG_IOCTRL_PWR_BUTTON1  0x98
+#define  FMUX_GPIO_REG_IOCTRL_PWR_ON  0x9c
+#define  FMUX_GPIO_REG_IOCTRL_XTAL_XIN  0xa0
+#define  FMUX_GPIO_REG_IOCTRL_PWR_GPIO0  0xa4
+#define  FMUX_GPIO_REG_IOCTRL_PWR_GPIO1  0xa8
+#define  FMUX_GPIO_REG_IOCTRL_PWR_GPIO2  0xac
+#define  FMUX_GPIO_REG_IOCTRL_CLK32K  0xb0
+#define  FMUX_GPIO_REG_IOCTRL_CLK25M  0xb4
+#define  FMUX_GPIO_REG_IOCTRL_IIC2_SCL  0xb8
+#define  FMUX_GPIO_REG_IOCTRL_IIC2_SDA  0xbc
+#define  FMUX_GPIO_REG_IOCTRL_UART2_TX  0xc0
+#define  FMUX_GPIO_REG_IOCTRL_UART2_RTS  0xc4
+#define  FMUX_GPIO_REG_IOCTRL_UART2_RX  0xc8
+#define  FMUX_GPIO_REG_IOCTRL_UART2_CTS  0xcc
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D3  0xd0
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D2  0xd4
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D1  0xd8
+#define  FMUX_GPIO_REG_IOCTRL_SD1_D0  0xdc
+#define  FMUX_GPIO_REG_IOCTRL_SD1_CMD  0xe0
+#define  FMUX_GPIO_REG_IOCTRL_SD1_CLK  0xe4
+#define  FMUX_GPIO_REG_IOCTRL_RSTN  0xe8
+#define  FMUX_GPIO_REG_IOCTRL_PWM0_BUCK  0xec
+#define  FMUX_GPIO_REG_IOCTRL_ADC3  0xf0
+#define  FMUX_GPIO_REG_IOCTRL_ADC2  0xf4
+#define  FMUX_GPIO_REG_IOCTRL_ADC1  0xf8
+#define  FMUX_GPIO_REG_IOCTRL_USB_ID  0xfc
+#define  FMUX_GPIO_REG_IOCTRL_USB_VBUS_EN  0x100
+#define  FMUX_GPIO_REG_IOCTRL_PKG_TYPE0  0x104
+#define  FMUX_GPIO_REG_IOCTRL_USB_VBUS_DET  0x108
+#define  FMUX_GPIO_REG_IOCTRL_PKG_TYPE1  0x10c
+#define  FMUX_GPIO_REG_IOCTRL_PKG_TYPE2  0x110
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_TXP  0x114
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_TXM  0x118
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_RXP  0x11c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_ETH_RXM  0x120
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D10  0x124
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D9  0x128
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D8  0x12c
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D7  0x130
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D6  0x134
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D5  0x138
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D4  0x13c
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D3  0x140
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D2  0x144
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D1  0x148
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_D0  0x14c
+#define  FMUX_GPIO_REG_IOCTRL_VIVO_CLK  0x150
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX5N  0x154
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX5P  0x158
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX4N  0x15c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX4P  0x160
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX3N  0x164
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX3P  0x168
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX2N  0x16c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX2P  0x170
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX1N  0x174
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX1P  0x178
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX0N  0x17c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPIRX0P  0x180
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM4  0x184
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP4  0x188
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM3  0x18c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP3  0x190
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM2  0x194
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP2  0x198
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM1  0x19c
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP1  0x1a0
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXM0  0x1a4
+#define  FMUX_GPIO_REG_IOCTRL_PAD_MIPI_TXP0  0x1a8
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AINL_MIC  0x1ac
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AINR_MIC  0x1b0
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AOUTL  0x1b4
+#define  FMUX_GPIO_REG_IOCTRL_PAD_AUD_AOUTR  0x1b8
+#define  FMUX_GPIO_FUNCSEL_CAM_MCLK0   0x0
+#define  FMUX_GPIO_FUNCSEL_CAM_MCLK0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CAM_MCLK0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_CAM_PD0   0x4
+#define  FMUX_GPIO_FUNCSEL_CAM_PD0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CAM_PD0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_CAM_RST0   0x8
+#define  FMUX_GPIO_FUNCSEL_CAM_RST0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CAM_RST0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_CAM_MCLK1   0xc
+#define  FMUX_GPIO_FUNCSEL_CAM_MCLK1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CAM_MCLK1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_CAM_PD1   0x10
+#define  FMUX_GPIO_FUNCSEL_CAM_PD1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CAM_PD1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC3_SCL   0x14
+#define  FMUX_GPIO_FUNCSEL_IIC3_SCL_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC3_SCL_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC3_SDA   0x18
+#define  FMUX_GPIO_FUNCSEL_IIC3_SDA_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC3_SDA_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_CLK   0x1c
+#define  FMUX_GPIO_FUNCSEL_SD0_CLK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_CLK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_CMD   0x20
+#define  FMUX_GPIO_FUNCSEL_SD0_CMD_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_CMD_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D0   0x24
+#define  FMUX_GPIO_FUNCSEL_SD0_D0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D1   0x28
+#define  FMUX_GPIO_FUNCSEL_SD0_D1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D2   0x2c
+#define  FMUX_GPIO_FUNCSEL_SD0_D2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_D3   0x30
+#define  FMUX_GPIO_FUNCSEL_SD0_D3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_D3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_CD   0x34
+#define  FMUX_GPIO_FUNCSEL_SD0_CD_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_CD_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD0_PWR_EN   0x38
+#define  FMUX_GPIO_FUNCSEL_SD0_PWR_EN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD0_PWR_EN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SPK_EN   0x3c
+#define  FMUX_GPIO_FUNCSEL_SPK_EN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SPK_EN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART0_TX   0x40
+#define  FMUX_GPIO_FUNCSEL_UART0_TX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART0_TX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART0_RX   0x44
+#define  FMUX_GPIO_FUNCSEL_UART0_RX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART0_RX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_RSTN   0x48
+#define  FMUX_GPIO_FUNCSEL_EMMC_RSTN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_RSTN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT2   0x4c
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_CLK   0x50
+#define  FMUX_GPIO_FUNCSEL_EMMC_CLK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_CLK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT0   0x54
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT3   0x58
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_CMD   0x5c
+#define  FMUX_GPIO_FUNCSEL_EMMC_CMD_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_CMD_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT1   0x60
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_EMMC_DAT1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TMS   0x64
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TMS_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TMS_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TCK   0x68
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TCK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TCK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TRST   0x6c
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TRST_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_JTAG_CPU_TRST_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC0_SCL   0x70
+#define  FMUX_GPIO_FUNCSEL_IIC0_SCL_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC0_SCL_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC0_SDA   0x74
+#define  FMUX_GPIO_FUNCSEL_IIC0_SDA_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC0_SDA_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_AUX0   0x78
+#define  FMUX_GPIO_FUNCSEL_AUX0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_AUX0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_VBAT_DET   0x7c
+#define  FMUX_GPIO_FUNCSEL_PWR_VBAT_DET_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_VBAT_DET_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_RSTN   0x80
+#define  FMUX_GPIO_FUNCSEL_PWR_RSTN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_RSTN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ1   0x84
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ2   0x88
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ3   0x8c
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_SEQ3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP0   0x90
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP1   0x94
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_WAKEUP1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_BUTTON1   0x98
+#define  FMUX_GPIO_FUNCSEL_PWR_BUTTON1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_BUTTON1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_ON   0x9c
+#define  FMUX_GPIO_FUNCSEL_PWR_ON_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_ON_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_XTAL_XIN   0xa0
+#define  FMUX_GPIO_FUNCSEL_XTAL_XIN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_XTAL_XIN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO0   0xa4
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO1   0xa8
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO2   0xac
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWR_GPIO2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_CLK32K   0xb0
+#define  FMUX_GPIO_FUNCSEL_CLK32K_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CLK32K_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_CLK25M   0xb4
+#define  FMUX_GPIO_FUNCSEL_CLK25M_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_CLK25M_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC2_SCL   0xb8
+#define  FMUX_GPIO_FUNCSEL_IIC2_SCL_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC2_SCL_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_IIC2_SDA   0xbc
+#define  FMUX_GPIO_FUNCSEL_IIC2_SDA_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_IIC2_SDA_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART2_TX   0xc0
+#define  FMUX_GPIO_FUNCSEL_UART2_TX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART2_TX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART2_RTS   0xc4
+#define  FMUX_GPIO_FUNCSEL_UART2_RTS_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART2_RTS_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART2_RX   0xc8
+#define  FMUX_GPIO_FUNCSEL_UART2_RX_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART2_RX_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_UART2_CTS   0xcc
+#define  FMUX_GPIO_FUNCSEL_UART2_CTS_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_UART2_CTS_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D3   0xd0
+#define  FMUX_GPIO_FUNCSEL_SD1_D3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D2   0xd4
+#define  FMUX_GPIO_FUNCSEL_SD1_D2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D1   0xd8
+#define  FMUX_GPIO_FUNCSEL_SD1_D1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_D0   0xdc
+#define  FMUX_GPIO_FUNCSEL_SD1_D0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_D0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_CMD   0xe0
+#define  FMUX_GPIO_FUNCSEL_SD1_CMD_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_CMD_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_SD1_CLK   0xe4
+#define  FMUX_GPIO_FUNCSEL_SD1_CLK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_SD1_CLK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_RSTN   0xe8
+#define  FMUX_GPIO_FUNCSEL_RSTN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_RSTN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PWM0_BUCK   0xec
+#define  FMUX_GPIO_FUNCSEL_PWM0_BUCK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PWM0_BUCK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_ADC3   0xf0
+#define  FMUX_GPIO_FUNCSEL_ADC3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_ADC3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_ADC2   0xf4
+#define  FMUX_GPIO_FUNCSEL_ADC2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_ADC2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_ADC1   0xf8
+#define  FMUX_GPIO_FUNCSEL_ADC1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_ADC1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_USB_ID   0xfc
+#define  FMUX_GPIO_FUNCSEL_USB_ID_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_USB_ID_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_EN   0x100
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_EN_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_EN_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE0   0x104
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_DET   0x108
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_DET_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_USB_VBUS_DET_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE1   0x10c
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE2   0x110
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PKG_TYPE2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXP   0x114
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXP_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXP_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXM   0x118
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXM_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_TXM_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXP   0x11c
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXP_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXP_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXM   0x120
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXM_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_ETH_RXM_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D10   0x124
+#define  FMUX_GPIO_FUNCSEL_VIVO_D10_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D10_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D9   0x128
+#define  FMUX_GPIO_FUNCSEL_VIVO_D9_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D9_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D8   0x12c
+#define  FMUX_GPIO_FUNCSEL_VIVO_D8_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D8_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D7   0x130
+#define  FMUX_GPIO_FUNCSEL_VIVO_D7_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D7_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D6   0x134
+#define  FMUX_GPIO_FUNCSEL_VIVO_D6_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D6_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D5   0x138
+#define  FMUX_GPIO_FUNCSEL_VIVO_D5_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D5_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D4   0x13c
+#define  FMUX_GPIO_FUNCSEL_VIVO_D4_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D4_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D3   0x140
+#define  FMUX_GPIO_FUNCSEL_VIVO_D3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D2   0x144
+#define  FMUX_GPIO_FUNCSEL_VIVO_D2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D1   0x148
+#define  FMUX_GPIO_FUNCSEL_VIVO_D1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_D0   0x14c
+#define  FMUX_GPIO_FUNCSEL_VIVO_D0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_D0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_VIVO_CLK   0x150
+#define  FMUX_GPIO_FUNCSEL_VIVO_CLK_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_VIVO_CLK_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX5N   0x154
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX5N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX5N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX5P   0x158
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX5P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX5P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4N   0x15c
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4P   0x160
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX4P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3N   0x164
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3P   0x168
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX3P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2N   0x16c
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2P   0x170
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX2P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1N   0x174
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1P   0x178
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX1P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0N   0x17c
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0N_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0N_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0P   0x180
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0P_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPIRX0P_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM4   0x184
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM4_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM4_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP4   0x188
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP4_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP4_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM3   0x18c
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP3   0x190
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP3_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP3_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM2   0x194
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP2   0x198
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP2_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP2_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM1   0x19c
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP1   0x1a0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP1_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP1_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM0   0x1a4
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXM0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP0   0x1a8
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP0_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_MIPI_TXP0_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINL_MIC   0x1ac
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINL_MIC_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINL_MIC_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINR_MIC   0x1b0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINR_MIC_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AINR_MIC_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTL   0x1b4
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTL_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTL_MASK   0x7
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTR   0x1b8
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTR_OFFSET 0
+#define  FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTR_MASK   0x7
diff --git a/drivers/pinctrl/cvitek/cv1835_pinlist_swconfig.h b/drivers/pinctrl/cvitek/cv1835_pinlist_swconfig.h
new file mode 100644
index 000000000000..c4450bbd0cb6
--- /dev/null
+++ b/drivers/pinctrl/cvitek/cv1835_pinlist_swconfig.h
@@ -0,0 +1,504 @@
+/*
+ * Copyright (c) 2019, Cvitek. All rights reserved.
+ *
+ */
+// Generate Time stamp is : 2019-11-27 20:20:28
+#define JTAG_CPU_TCK__JTAG_CPU_TCK 0
+#define JTAG_CPU_TCK__DBG_1 1
+#define JTAG_CPU_TCK__XGPIOA_0 3
+#define SDIO0_CD__SDIO0_CD 0
+#define SDIO0_CD__DBG_6 1
+#define SDIO0_CD__XGPIOA_1 3
+#define RSTN__RSTN 0
+#define JTAG_CPU_TRST__JTAG_CPU_TRST 0
+#define JTAG_CPU_TRST__DBG_0 1
+#define JTAG_CPU_TRST__XGPIOA_2 3
+#define UART0_RX__UART0_RX 0
+#define UART0_RX__DBG_4 1
+#define UART0_RX__AUX0 2
+#define UART0_RX__XGPIOA_3 3
+#define UART0_RX__H265_UART_RX 4
+#define UART0_RX__H264_UART_RX 5
+#define SDIO0_PWR_EN__SDIO0_PWR_EN 0
+#define SDIO0_PWR_EN__DBG_5 1
+#define SDIO0_PWR_EN__XGPIOA_4 3
+#define UART0_TX__UART0_TX 0
+#define UART0_TX__DBG_3 1
+#define UART0_TX__AUX1 2
+#define UART0_TX__XGPIOA_5 3
+#define UART0_TX__H265_UART_TX 4
+#define UART0_TX__H264_UART_TX 5
+#define JTAG_CPU_TMS__JTAG_CPU_TMS 0
+#define JTAG_CPU_TMS__DBG_2 1
+#define JTAG_CPU_TMS__XGPIOA_6 3
+#define JTAG_CPU_TMS__JTAG_CPU_5W_TMS 4
+#define EMMC_CLK__EMMC_CLK 0
+#define EMMC_CLK__SPINOR_SCK 1
+#define EMMC_CLK__SPINAND_CLK 2
+#define EMMC_CLK__XGPIOA_7 3
+#define EMMC_RSTN__EMMC_RSTN 0
+#define EMMC_RSTN__XGPIOA_8 3
+#define EMMC_RSTN__AUX2 4
+#define EMMC_RSTN__IIS2_MCLK 5
+#define EMMC_CMD__EMMC_CMD 0
+#define EMMC_CMD__SPINOR_SDI 1
+#define EMMC_CMD__SPINAND_DI 2
+#define EMMC_CMD__XGPIOA_9 3
+#define EMMC_DAT1__EMMC_DAT_1 0
+#define EMMC_DAT1__SPINOR_CS_X 1
+#define EMMC_DAT1__SPINAND_CS 2
+#define EMMC_DAT1__XGPIOA_10 3
+#define EMMC_DAT0__EMMC_DAT_0 0
+#define EMMC_DAT0__SPINOR_SDO 1
+#define EMMC_DAT0__SPINAND_DO 2
+#define EMMC_DAT0__XGPIOA_11 3
+#define EMMC_DAT2__EMMC_DAT_2 0
+#define EMMC_DAT2__SPINOR_HOLD_X 1
+#define EMMC_DAT2__SPINAND_HOLD 2
+#define EMMC_DAT2__XGPIOA_12 3
+#define EMMC_DAT3__EMMC_DAT_3 0
+#define EMMC_DAT3__SPINOR_WP_X 1
+#define EMMC_DAT3__SPINAND_WP 2
+#define EMMC_DAT3__XGPIOA_13 3
+#define SDIO0_CMD__SDIO0_CMD 0
+#define SDIO0_CMD__DBG_11 1
+#define SDIO0_CMD__XGPIOA_14 3
+#define SDIO0_CLK__SDIO0_CLK 0
+#define SDIO0_CLK__DBG_12 1
+#define SDIO0_CLK__XGPIOA_15 3
+#define SDIO0_D0__SDIO0_D_0 0
+#define SDIO0_D0__DBG_10 1
+#define SDIO0_D0__XGPIOA_16 3
+#define SDIO0_D1__SDIO0_D_1 0
+#define SDIO0_D1__DBG_9 1
+#define SDIO0_D1__XGPIOA_17 3
+#define SDIO0_D2__SDIO0_D_2 0
+#define SDIO0_D2__DBG_8 1
+#define SDIO0_D2__AUX0 2
+#define SDIO0_D2__XGPIOA_18 3
+#define SDIO0_D3__SDIO0_D_3 0
+#define SDIO0_D3__DBG_7 1
+#define SDIO0_D3__AUX1 2
+#define SDIO0_D3__XGPIOA_19 3
+#define RMII0_TXEN__RMII0_TXEN 0
+#define RMII0_TXEN__UART1_TX 1
+#define RMII0_TXEN__UART2_TX 2
+#define RMII0_TXEN__XGPIOA_20 3
+#define RMII0_TXEN__H265_UART_TX 4
+#define RMII0_TXEN__IIS2_DI 5
+#define RMII0_TXEN__H264_UART_TX 6
+#define RMII0_TXEN__WG1_D0 7
+#define RMII0_TXD1__RMII0_TXD1 0
+#define RMII0_TXD1__UART1_RX 1
+#define RMII0_TXD1__UART2_RX 2
+#define RMII0_TXD1__XGPIOA_21 3
+#define RMII0_TXD1__H265_UART_RX 4
+#define RMII0_TXD1__IIS2_DO 5
+#define RMII0_TXD1__H264_UART_RX 6
+#define RMII0_TXD1__WG1_D1 7
+#define RMII0_TXD0__RMII0_TXD0 0
+#define RMII0_TXD0__UART1_CTS 1
+#define RMII0_TXD0__UART2_CTS 2
+#define RMII0_TXD0__XGPIOA_22 3
+#define RMII0_TXD0__IIS2_LRCK 5
+#define RMII0_TXD0__UART4_TX 6
+#define RMII0_TXD0__EPHY_SPD_LED 7
+#define RMII0_REFCLKI__RMII0_REFCLKI 0
+#define RMII0_REFCLKI__SDIO1_D_0 1
+#define RMII0_REFCLKI__SPI1_SDI 2
+#define RMII0_REFCLKI__XGPIOA_23 3
+#define RMII0_REFCLKI__EPHY_DPX_LED 6
+#define RMII0_MDIO__RMII0_MDIO 0
+#define RMII0_MDIO__SDIO1_CMD 1
+#define RMII0_MDIO__SPI1_SDO 2
+#define RMII0_MDIO__XGPIOA_24 3
+#define RMII0_MDIO__EPHY_SPD_LED 6
+#define RMII0_MDCK__RMII0_MDC 0
+#define RMII0_MDCK__SDIO1_CLK 1
+#define RMII0_MDCK__SPI1_SCK 2
+#define RMII0_MDCK__XGPIOA_25 3
+#define RMII0_MDCK__EPHY_LNK_LED 6
+#define RMII0_RST__UART1_RTS 1
+#define RMII0_RST__UART2_RTS 2
+#define RMII0_RST__XGPIOA_26 3
+#define RMII0_RST__RMII0_IRQ 4
+#define RMII0_RST__IIS2_BCLK 5
+#define RMII0_RST__UART4_RX 6
+#define RMII0_RST__EPHY_LNK_LED 7
+#define RMII0_RXD0__RMII0_RXD0 0
+#define RMII0_RXD0__SDIO1_D_2 1
+#define RMII0_RXD0__XGPIOA_27 3
+#define RMII0_RXD0__H265_UART_TX 4
+#define RMII0_RXD0__EPHY_DPX_LED 6
+#define RMII0_RXD0__H264_UART_TX 7
+#define RMII0_RXD1__RMII0_RXD1 0
+#define RMII0_RXD1__SDIO1_D_1 1
+#define RMII0_RXD1__XGPIOA_28 3
+#define RMII0_RXD1__H265_UART_RX 4
+#define RMII0_RXD1__EPHY_SPD_LED 6
+#define RMII0_RXD1__H264_UART_RX 7
+#define RMII0_RXDV__RMII0_RXDV 0
+#define RMII0_RXDV__SDIO1_D_3 1
+#define RMII0_RXDV__SPI1_CS_X 2
+#define RMII0_RXDV__XGPIOA_29 3
+#define RMII0_RXDV__EPHY_LNK_LED 6
+#define RTC_MODE__RTC_MODE 0
+#define RTC_MODE__XGPIOA_30 3
+#define PWR_WAKEUP0__PWR_WAKEUP0 0
+#define PWR_WAKEUP0__XGPIOA_31 3
+#define PWR_BUTTON1__PWR_BUTTON1 0
+#define PWR_BUTTON1__XGPIOB_0 3
+#define PWR_WAKEUP1__PWR_WAKEUP1 0
+#define PWR_WAKEUP1__XGPIOB_1 3
+#define PWR_BUTTON0__PWR_BUTTON0 0
+#define PWR_BUTTON0__XGPIOD_11 3
+#define PWR_VBAT_DET__PWR_VBAT_DET 0
+#define PWR_ON__PWR_ON 0
+#define PWR_ON__XGPIOB_2 3
+#define PTEST__PTEST 0
+#define PWM2__PWM_2 0
+#define PWM2__IIC1_SCL 1
+#define PWM2__KEY_COL2 2
+#define PWM2__XGPIOB_3 3
+#define PWM2__JTAG_CPU_5W_TDI 4
+#define PWM2__UART3_RX 5
+#define PWM2__WG2_D0 7
+#define PWM0_BUCK__PWM_0 0
+#define PWM0_BUCK__XGPIOB_6 3
+#define PWM3__PWM_3 0
+#define PWM3__IIC1_SDA 1
+#define PWM3__KEY_COL3 2
+#define PWM3__XGPIOB_5 3
+#define PWM3__UART3_TX 5
+#define PWM3__WG2_D1 7
+#define PWM1__PWM_1 0
+#define PWM1__XGPIOB_4 3
+#define PWM1__JTAG_CPU_5W_TDO 4
+#define SPI0_SDI__SPI0_SDI 0
+#define SPI0_SDI__IIC2_SDA 1
+#define SPI0_SDI__PWM_15 2
+#define SPI0_SDI__XGPIOB_8 3
+#define SPI0_SDI__UART3_CTS 4
+#define SPI0_SDI__RMII1_TXD3 5
+#define SPI0_SDI__SPINOR1_SDI 6
+#define SPI0_SDO__SPI0_SDO 0
+#define SPI0_SDO__IIC2_SCL 1
+#define SPI0_SDO__PWM_14 2
+#define SPI0_SDO__XGPIOB_10 3
+#define SPI0_SDO__UART3_RTS 4
+#define SPI0_SDO__RMII1_RXD3 5
+#define SPI0_SDO__SPINOR1_SDO 6
+#define SPI0_SCK__SPI0_SCK 0
+#define SPI0_SCK__IIC4_SCL 1
+#define SPI0_SCK__PWM_12 2
+#define SPI0_SCK__XGPIOB_7 3
+#define SPI0_SCK__UART3_RX 4
+#define SPI0_SCK__RMII1_TXD2 5
+#define SPI0_SCK__SPINOR1_SCK 6
+#define SPI0_CS_X__SPI0_CS_X 0
+#define SPI0_CS_X__IIC4_SDA 1
+#define SPI0_CS_X__PWM_13 2
+#define SPI0_CS_X__XGPIOB_9 3
+#define SPI0_CS_X__UART3_TX 4
+#define SPI0_CS_X__RMII1_RXD2 5
+#define SPI0_CS_X__SPINOR1_CS_X 6
+#define IIC2_SCL__IIC2_SCL 0
+#define IIC2_SCL__PWM_14 1
+#define IIC2_SCL__UART2_RX 2
+#define IIC2_SCL__XGPIOB_11 3
+#define IIC2_SCL__RMII1_MDIO 4
+#define IIC1_SCL__IIC1_SCL 0
+#define IIC1_SCL__PWM_12 1
+#define IIC1_SCL__XGPIOB_12 3
+#define IIC1_SCL__RMII1_RXD1 4
+#define IIC1_SCL__SPINOR1_HOLD_X 6
+#define IIC1_SDA__IIC1_SDA 0
+#define IIC1_SDA__PWM_13 1
+#define IIC1_SDA__XGPIOB_14 3
+#define IIC1_SDA__RMII1_REFCLKI 4
+#define IIC1_SDA__SPINOR1_WP_X 6
+#define UART2_TX__UART2_TX 0
+#define UART2_TX__PWM_11 1
+#define UART2_TX__KEY_ROW3 2
+#define UART2_TX__XGPIOB_15 3
+#define UART2_TX__RMII1_RXD0 4
+#define UART2_TX__WG2_D0 7
+#define IIC2_SDA__IIC2_SDA 0
+#define IIC2_SDA__PWM_15 1
+#define IIC2_SDA__UART2_TX 2
+#define IIC2_SDA__XGPIOB_13 3
+#define IIC2_SDA__RMII1_MDC 4
+#define UART1_RTS__UART1_RTS 0
+#define UART1_RTS__PWM_7 1
+#define UART1_RTS__KEY_COL1 2
+#define UART1_RTS__XGPIOB_16 3
+#define UART1_RTS__RMII1_TXD0 4
+#define UART1_RTS__IIS1_DI 5
+#define UART1_RTS__UART4_TX 7
+#define UART2_RTS__UART2_RTS 0
+#define UART2_RTS__PWM_8 1
+#define UART2_RTS__KEY_ROW0 2
+#define UART2_RTS__XGPIOB_18 3
+#define UART2_RTS__RMII1_TXD1 4
+#define UART2_RTS__IIS1_MCLK 5
+#define UART2_RTS__WG1_D0 7
+#define UART2_RX__UART2_RX 0
+#define UART2_RX__PWM_10 1
+#define UART2_RX__KEY_COL3 2
+#define UART2_RX__XGPIOB_17 3
+#define UART2_RX__RMII1_RXDV 4
+#define UART2_RX__WG2_D1 7
+#define UART1_TX__UART1_TX 0
+#define UART1_TX__PWM_4 1
+#define UART1_TX__KEY_COL2 2
+#define UART1_TX__XGPIOB_21 3
+#define UART1_TX__RMII1_TXCLK 4
+#define UART1_TX__IIS1_BCLK 5
+#define UART1_TX__EPHY_LNK_LED 7
+#define UART1_CTS__UART1_CTS 0
+#define UART1_CTS__PWM_6 1
+#define UART1_CTS__KEY_COL0 2
+#define UART1_CTS__XGPIOB_20 3
+#define UART1_CTS__IIS1_DO 5
+#define UART1_CTS__RMII1_IRQ 6
+#define UART1_CTS__UART4_RX 7
+#define BOOT_MS__BOOT_MS 0
+#define BOOT_MS__XGPIOB_22 3
+#define UART2_CTS__UART2_CTS 0
+#define UART2_CTS__PWM_9 1
+#define UART2_CTS__KEY_ROW1 2
+#define UART2_CTS__XGPIOB_19 3
+#define UART2_CTS__RMII1_TXEN 4
+#define UART2_CTS__WG1_D1 7
+#define ADC1__XGPIOB_24 3
+#define UART1_RX__UART1_RX 0
+#define UART1_RX__PWM_5 1
+#define UART1_RX__KEY_ROW2 2
+#define UART1_RX__XGPIOB_23 3
+#define UART1_RX__IIS1_LRCK 5
+#define UART1_RX__EPHY_SPD_LED 7
+#define USB_ID__USB_ID 0
+#define USB_ID__XGPIOB_26 3
+#define USB_VBUS_DET__USB_VBUS_DET 0
+#define USB_VBUS_DET__XGPIOB_25 3
+#define USB_VBUS_EN__USB_VBUS_EN 0
+#define USB_VBUS_EN__XGPIOB_27 3
+#define CLK32K__CLK32K 0
+#define CLK32K__AUX0 1
+#define CLK32K__DBG_1 2
+#define CLK32K__XGPIOB_29 3
+#define CLK25M__CLK25M 0
+#define CLK25M__AUX1 1
+#define CLK25M__DBG_0 2
+#define CLK25M__XGPIOB_28 3
+#define XTAL_XIN_XI__XTAL_CLKIN 0
+#define VO_DATA1__VO_DATA_1 1
+#define VO_DATA1__XGPIOC_8 3
+#define VO_DATA1__VO_BUS_1 6
+#define VO_DATA0__VO_DATA_0 1
+#define VO_DATA0__XGPIOC_9 3
+#define VO_DATA0__VO_BUS_0 6
+#define PAD_MIPI_TXM4__VO_DATA_10 1
+#define PAD_MIPI_TXM4__DBG_13 2
+#define PAD_MIPI_TXM4__XGPIOB_30 3
+#define PAD_MIPI_TXM4__SPI3_SCK 4
+#define PAD_MIPI_TXM4__PWM_12 5
+#define PAD_MIPI_TXM4__VO_BUS_10 6
+#define PAD_MIPI_TXP4__VO_DATA_9 1
+#define PAD_MIPI_TXP4__DBG_14 2
+#define PAD_MIPI_TXP4__XGPIOB_31 3
+#define PAD_MIPI_TXP4__SPI3_CS_X 4
+#define PAD_MIPI_TXP4__PWM_13 5
+#define PAD_MIPI_TXP4__VO_BUS_9 6
+#define PAD_MIPI_TXM3__VO_DATA_8 1
+#define PAD_MIPI_TXM3__DBG_15 2
+#define PAD_MIPI_TXM3__XGPIOC_0 3
+#define PAD_MIPI_TXM3__SPI3_SDO 4
+#define PAD_MIPI_TXM3__PWM_6 5
+#define PAD_MIPI_TXM3__VO_BUS_8 6
+#define PAD_MIPI_TXP3__VO_DATA_7 1
+#define PAD_MIPI_TXP3__DBG_16 2
+#define PAD_MIPI_TXP3__XGPIOC_1 3
+#define PAD_MIPI_TXP3__SPI3_SDI 4
+#define PAD_MIPI_TXP3__PWM_7 5
+#define PAD_MIPI_TXP3__VO_BUS_7 6
+#define PAD_MIPI_TXM2__VO_DATA_6 1
+#define PAD_MIPI_TXM2__DBG_17 2
+#define PAD_MIPI_TXM2__XGPIOC_2 3
+#define PAD_MIPI_TXM2__KEY_ROW0 4
+#define PAD_MIPI_TXM2__PWM_8 5
+#define PAD_MIPI_TXM2__VO_BUS_6 6
+#define PAD_MIPI_TXP2__VO_DATA_5 1
+#define PAD_MIPI_TXP2__DBG_18 2
+#define PAD_MIPI_TXP2__XGPIOC_3 3
+#define PAD_MIPI_TXP2__KEY_ROW1 4
+#define PAD_MIPI_TXP2__PWM_9 5
+#define PAD_MIPI_TXP2__VO_BUS_5 6
+#define PAD_MIPI_TXM1__VO_DATA_4 1
+#define PAD_MIPI_TXM1__DBG_19 2
+#define PAD_MIPI_TXM1__XGPIOC_4 3
+#define PAD_MIPI_TXM1__KEY_ROW2 4
+#define PAD_MIPI_TXM1__PWM_10 5
+#define PAD_MIPI_TXM1__VO_BUS_4 6
+#define PAD_MIPI_TXP1__VO_DATA_3 1
+#define PAD_MIPI_TXP1__DBG_20 2
+#define PAD_MIPI_TXP1__XGPIOC_5 3
+#define PAD_MIPI_TXP1__KEY_ROW3 4
+#define PAD_MIPI_TXP1__PWM_11 5
+#define PAD_MIPI_TXP1__VO_BUS_3 6
+#define PAD_MIPI_TXM0__VO_DATA_2 1
+#define PAD_MIPI_TXM0__DBG_21 2
+#define PAD_MIPI_TXM0__XGPIOC_6 3
+#define PAD_MIPI_TXM0__KEY_COL0 4
+#define PAD_MIPI_TXM0__PWM_14 5
+#define PAD_MIPI_TXM0__VO_BUS_2 6
+#define PAD_MIPI_TXP0__VO_CLK 1
+#define PAD_MIPI_TXP0__DBG_22 2
+#define PAD_MIPI_TXP0__XGPIOC_7 3
+#define PAD_MIPI_TXP0__KEY_COL1 4
+#define PAD_MIPI_TXP0__PWM_15 5
+#define PAD_MIPI_TXP0__VO_BUS_11 6
+#define MIPIRX1_PAD0P__VI_DATA_0 1
+#define MIPIRX1_PAD0P__DBG_0 2
+#define MIPIRX1_PAD0P__XGPIOC_10 3
+#define MIPIRX1_PAD0P__VO_DATA_11 4
+#define MIPIRX1_PAD0P__VI1_DATA_8 5
+#define MIPIRX1_PAD0P__VO_BUS_12 6
+#define MIPIRX1_PAD0N__VI_DATA_1 1
+#define MIPIRX1_PAD0N__DBG_31 2
+#define MIPIRX1_PAD0N__XGPIOC_11 3
+#define MIPIRX1_PAD0N__VO_DATA_12 4
+#define MIPIRX1_PAD0N__VI1_DATA_7 5
+#define MIPIRX1_PAD0N__VO_BUS_13 6
+#define MIPIRX1_PAD1P__VI_DATA_2 1
+#define MIPIRX1_PAD1P__DBG_30 2
+#define MIPIRX1_PAD1P__XGPIOC_12 3
+#define MIPIRX1_PAD1P__VO_DATA_13 4
+#define MIPIRX1_PAD1P__VI1_DATA_6 5
+#define MIPIRX1_PAD1P__VO_BUS_14 6
+#define MIPIRX1_PAD1N__VI_DATA_3 1
+#define MIPIRX1_PAD1N__DBG_29 2
+#define MIPIRX1_PAD1N__XGPIOC_13 3
+#define MIPIRX1_PAD1N__VO_DATA_14 4
+#define MIPIRX1_PAD1N__VI1_DATA_5 5
+#define MIPIRX1_PAD1N__VO_BUS_15 6
+#define MIPIRX1_PAD2P__VI_DATA_4 1
+#define MIPIRX1_PAD2P__DBG_28 2
+#define MIPIRX1_PAD2P__XGPIOC_14 3
+#define MIPIRX1_PAD2P__VO_DATA_15 4
+#define MIPIRX1_PAD2P__VI1_DATA_4 5
+#define MIPIRX1_PAD2P__VO_BUS_16 6
+#define MIPIRX1_PAD2N__VI_DATA_5 1
+#define MIPIRX1_PAD2N__DBG_27 2
+#define MIPIRX1_PAD2N__XGPIOC_15 3
+#define MIPIRX1_PAD2N__VO_DATA_16 4
+#define MIPIRX1_PAD2N__VI1_DATA_3 5
+#define MIPIRX1_PAD2N__VO_BUS_17 6
+#define MIPIRX1_PAD3P__VI_DATA_6 1
+#define MIPIRX1_PAD3P__DBG_26 2
+#define MIPIRX1_PAD3P__XGPIOC_16 3
+#define MIPIRX1_PAD3P__VO_DATA_17 4
+#define MIPIRX1_PAD3P__VI1_DATA_2 5
+#define MIPIRX1_PAD3P__VO_BUS_18 6
+#define MIPIRX1_PAD3N__VI_DATA_7 1
+#define MIPIRX1_PAD3N__DBG_25 2
+#define MIPIRX1_PAD3N__XGPIOC_17 3
+#define MIPIRX1_PAD3N__VI1_DATA_1 5
+#define MIPIRX1_PAD4P__VI_DATA_8 1
+#define MIPIRX1_PAD4P__DBG_24 2
+#define MIPIRX1_PAD4P__XGPIOC_18 3
+#define MIPIRX1_PAD4P__VI1_DATA_0 5
+#define MIPIRX1_PAD4N__VI_DATA_9 1
+#define MIPIRX1_PAD4N__DBG_23 2
+#define MIPIRX1_PAD4N__XGPIOC_19 3
+#define MIPIRX1_PAD4N__VI1_CLK 5
+#define MIPIRX0_PAD4N__VI_DATA_10 1
+#define MIPIRX0_PAD4N__DBG_1 2
+#define MIPIRX0_PAD4N__XGPIOC_20 3
+#define MIPIRX0_PAD4N__VI1_DATA_9 5
+#define MIPIRX0_PAD4P__VI_DATA_11 1
+#define MIPIRX0_PAD4P__DBG_2 2
+#define MIPIRX0_PAD4P__XGPIOC_21 3
+#define MIPIRX0_PAD3N__VI_DATA_12 1
+#define MIPIRX0_PAD3N__DBG_4 2
+#define MIPIRX0_PAD3N__XGPIOC_23 3
+#define MIPIRX0_PAD3P__VI_CLK 1
+#define MIPIRX0_PAD3P__DBG_3 2
+#define MIPIRX0_PAD3P__XGPIOC_22 3
+#define MIPIRX0_PAD2N__VI_DATA_13 1
+#define MIPIRX0_PAD2N__DBG_5 2
+#define MIPIRX0_PAD2N__XGPIOC_24 3
+#define MIPIRX0_PAD2N__IIC4_SCL 4
+#define MIPIRX0_PAD2P__VI_DATA_14 1
+#define MIPIRX0_PAD2P__DBG_6 2
+#define MIPIRX0_PAD2P__XGPIOC_25 3
+#define MIPIRX0_PAD2P__IIC4_SDA 4
+#define MIPIRX0_PAD1N__VI_DATA_15 1
+#define MIPIRX0_PAD1N__DBG_7 2
+#define MIPIRX0_PAD1N__XGPIOC_26 3
+#define MIPIRX0_PAD1N__KEY_ROW3 4
+#define MIPIRX0_PAD1P__VI_DATA_16 1
+#define MIPIRX0_PAD1P__DBG_8 2
+#define MIPIRX0_PAD1P__XGPIOC_27 3
+#define MIPIRX0_PAD1P__KEY_ROW2 4
+#define MIPIRX0_PAD0N__VI_DATA_17 1
+#define MIPIRX0_PAD0N__DBG_9 2
+#define MIPIRX0_PAD0N__XGPIOC_28 3
+#define MIPIRX0_PAD0P__VI_DATA_18 1
+#define MIPIRX0_PAD0P__DBG_10 2
+#define MIPIRX0_PAD0P__XGPIOC_29 3
+#define VI_DATA22__VI_DATA_22 1
+#define VI_DATA22__DBG_14 2
+#define VI_DATA22__XGPIOC_30 3
+#define VI_DATA22__KEY_COL1 4
+#define VI_DATA22__UART3_TX 5
+#define VI_DATA22__H265_UART_TX 6
+#define VI_DATA22__H264_UART_TX 7
+#define VI_DATA20__VI_DATA_20 1
+#define VI_DATA20__DBG_12 2
+#define VI_DATA20__XGPIOC_31 3
+#define VI_DATA20__KEY_ROW0 4
+#define VI_DATA21__VI_DATA_21 1
+#define VI_DATA21__DBG_13 2
+#define VI_DATA21__XGPIOD_0 3
+#define VI_DATA21__KEY_COL0 4
+#define VI_DATA21__UART3_RX 5
+#define VI_DATA21__H265_UART_RX 6
+#define VI_DATA21__H264_UART_RX 7
+#define CAM_PD0__CAM_MCLK1 0
+#define CAM_PD0__AUX2 2
+#define CAM_PD0__XGPIOD_1 3
+#define VI_DATA19__VI_DATA_19 1
+#define VI_DATA19__DBG_11 2
+#define VI_DATA19__XGPIOD_2 3
+#define VI_DATA19__KEY_ROW1 4
+#define IIC0_SDA__IIC0_SDA 0
+#define IIC0_SDA__SPI2_SDO 1
+#define IIC0_SDA__XGPIOD_3 3
+#define CAM_MCLK0__CAM_MCLK0 0
+#define CAM_MCLK0__AUX3 2
+#define CAM_MCLK0__XGPIOD_4 3
+#define IIC3_SCL__IIC3_SCL 0
+#define IIC3_SCL__SPI2_SCK 1
+#define IIC3_SCL__DBG_17 2
+#define IIC3_SCL__XGPIOD_5 3
+#define IIC3_SCL__IIC4_SCL 4
+#define VI_DATA24__VI_DATA_24 1
+#define VI_DATA24__DBG_16 2
+#define VI_DATA24__XGPIOD_6 3
+#define VI_DATA24__KEY_COL3 4
+#define VI_DATA24__UART3_CTS 5
+#define CAM_RST0__XGPIOD_7 3
+#define VI_DATA23__VI_DATA_23 1
+#define VI_DATA23__DBG_15 2
+#define VI_DATA23__XGPIOD_8 3
+#define VI_DATA23__KEY_COL2 4
+#define VI_DATA23__UART3_RTS 5
+#define IIC3_SDA__IIC3_SDA 0
+#define IIC3_SDA__SPI2_CS_X 1
+#define IIC3_SDA__DBG_18 2
+#define IIC3_SDA__XGPIOD_9 3
+#define IIC3_SDA__IIC4_SDA 4
+#define IIC0_SCL__IIC0_SCL 0
+#define IIC0_SCL__SPI2_SDI 1
+#define IIC0_SCL__XGPIOD_10 3
diff --git a/drivers/pinctrl/cvitek/cv1835_reg_fmux_gpio.h b/drivers/pinctrl/cvitek/cv1835_reg_fmux_gpio.h
new file mode 100644
index 000000000000..8ba0be518d30
--- /dev/null
+++ b/drivers/pinctrl/cvitek/cv1835_reg_fmux_gpio.h
@@ -0,0 +1,449 @@
+/*
+ * Copyright (c) 2019, Cvitek. All rights reserved.
+ *
+ */
+// $Date: Wed, 27 Nov 2019 08:24:45 PM $
+#define  fmux_gpio_REG_IOCTRL_JTAG_CPU_TCK  0x0
+#define  fmux_gpio_REG_IOCTRL_SDIO0_CD  0x4
+#define  fmux_gpio_REG_IOCTRL_RSTN  0x8
+#define  fmux_gpio_REG_IOCTRL_JTAG_CPU_TRST  0xc
+#define  fmux_gpio_REG_IOCTRL_UART0_RX  0x10
+#define  fmux_gpio_REG_IOCTRL_SDIO0_PWR_EN  0x14
+#define  fmux_gpio_REG_IOCTRL_UART0_TX  0x18
+#define  fmux_gpio_REG_IOCTRL_JTAG_CPU_TMS  0x1c
+#define  fmux_gpio_REG_IOCTRL_EMMC_CLK  0x20
+#define  fmux_gpio_REG_IOCTRL_EMMC_RSTN  0x24
+#define  fmux_gpio_REG_IOCTRL_EMMC_CMD  0x28
+#define  fmux_gpio_REG_IOCTRL_EMMC_DAT1  0x2c
+#define  fmux_gpio_REG_IOCTRL_EMMC_DAT0  0x30
+#define  fmux_gpio_REG_IOCTRL_EMMC_DAT2  0x34
+#define  fmux_gpio_REG_IOCTRL_EMMC_DAT3  0x38
+#define  fmux_gpio_REG_IOCTRL_SDIO0_CMD  0x3c
+#define  fmux_gpio_REG_IOCTRL_SDIO0_CLK  0x40
+#define  fmux_gpio_REG_IOCTRL_SDIO0_D0  0x44
+#define  fmux_gpio_REG_IOCTRL_SDIO0_D1  0x48
+#define  fmux_gpio_REG_IOCTRL_SDIO0_D2  0x4c
+#define  fmux_gpio_REG_IOCTRL_SDIO0_D3  0x50
+#define  fmux_gpio_REG_IOCTRL_RMII0_TXEN  0x54
+#define  fmux_gpio_REG_IOCTRL_RMII0_TXD1  0x58
+#define  fmux_gpio_REG_IOCTRL_RMII0_TXD0  0x5c
+#define  fmux_gpio_REG_IOCTRL_RMII0_REFCLKI  0x60
+#define  fmux_gpio_REG_IOCTRL_RMII0_MDIO  0x64
+#define  fmux_gpio_REG_IOCTRL_RMII0_MDCK  0x68
+#define  fmux_gpio_REG_IOCTRL_RMII0_RST  0x6c
+#define  fmux_gpio_REG_IOCTRL_RMII0_RXD0  0x70
+#define  fmux_gpio_REG_IOCTRL_RMII0_RXD1  0x74
+#define  fmux_gpio_REG_IOCTRL_RMII0_RXDV  0x78
+#define  fmux_gpio_REG_IOCTRL_RTC_MODE  0x7c
+#define  fmux_gpio_REG_IOCTRL_PWR_WAKEUP0  0x80
+#define  fmux_gpio_REG_IOCTRL_PWR_BUTTON1  0x84
+#define  fmux_gpio_REG_IOCTRL_PWR_WAKEUP1  0x88
+#define  fmux_gpio_REG_IOCTRL_PWR_BUTTON0  0x8c
+#define  fmux_gpio_REG_IOCTRL_PWR_VBAT_DET  0x90
+#define  fmux_gpio_REG_IOCTRL_PWR_ON  0x94
+#define  fmux_gpio_REG_IOCTRL_PWM2  0x98
+#define  fmux_gpio_REG_IOCTRL_PWM0_BUCK  0x9c
+#define  fmux_gpio_REG_IOCTRL_PWM3  0xa0
+#define  fmux_gpio_REG_IOCTRL_PWM1  0xa4
+#define  fmux_gpio_REG_IOCTRL_SPI0_SDI  0xa8
+#define  fmux_gpio_REG_IOCTRL_SPI0_SDO  0xac
+#define  fmux_gpio_REG_IOCTRL_SPI0_SCK  0xb0
+#define  fmux_gpio_REG_IOCTRL_SPI0_CS_X  0xb4
+#define  fmux_gpio_REG_IOCTRL_IIC2_SCL  0xb8
+#define  fmux_gpio_REG_IOCTRL_IIC1_SCL  0xbc
+#define  fmux_gpio_REG_IOCTRL_IIC1_SDA  0xc0
+#define  fmux_gpio_REG_IOCTRL_UART2_TX  0xc4
+#define  fmux_gpio_REG_IOCTRL_IIC2_SDA  0xc8
+#define  fmux_gpio_REG_IOCTRL_UART1_RTS  0xcc
+#define  fmux_gpio_REG_IOCTRL_UART2_RTS  0xd0
+#define  fmux_gpio_REG_IOCTRL_UART2_RX  0xd4
+#define  fmux_gpio_REG_IOCTRL_UART1_TX  0xd8
+#define  fmux_gpio_REG_IOCTRL_UART1_CTS  0xdc
+#define  fmux_gpio_REG_IOCTRL_BOOT_MS  0xe0
+#define  fmux_gpio_REG_IOCTRL_UART2_CTS  0xe4
+#define  fmux_gpio_REG_IOCTRL_ADC1  0xe8
+#define  fmux_gpio_REG_IOCTRL_UART1_RX  0xec
+#define  fmux_gpio_REG_IOCTRL_USB_ID  0xf0
+#define  fmux_gpio_REG_IOCTRL_USB_VBUS_DET  0xf4
+#define  fmux_gpio_REG_IOCTRL_USB_VBUS_EN  0xf8
+#define  fmux_gpio_REG_IOCTRL_CLK32K  0xfc
+#define  fmux_gpio_REG_IOCTRL_CLK25M  0x100
+#define  fmux_gpio_REG_IOCTRL_XTAL_XIN_XI  0x104
+#define  fmux_gpio_REG_IOCTRL_VO_DATA1  0x108
+#define  fmux_gpio_REG_IOCTRL_VO_DATA0  0x10c
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXM4  0x110
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXP4  0x114
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXM3  0x118
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXP3  0x11c
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXM2  0x120
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXP2  0x124
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXM1  0x128
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXP1  0x12c
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXM0  0x130
+#define  fmux_gpio_REG_IOCTRL_PAD_MIPI_TXP0  0x134
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD0P  0x138
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD0N  0x13c
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD1P  0x140
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD1N  0x144
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD2P  0x148
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD2N  0x14c
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD3P  0x150
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD3N  0x154
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD4P  0x158
+#define  fmux_gpio_REG_IOCTRL_MIPIRX1_PAD4N  0x15c
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD4N  0x160
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD4P  0x164
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD3N  0x168
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD3P  0x16c
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD2N  0x170
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD2P  0x174
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD1N  0x178
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD1P  0x17c
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD0N  0x180
+#define  fmux_gpio_REG_IOCTRL_MIPIRX0_PAD0P  0x184
+#define  fmux_gpio_REG_IOCTRL_VI_DATA22  0x188
+#define  fmux_gpio_REG_IOCTRL_VI_DATA20  0x18c
+#define  fmux_gpio_REG_IOCTRL_VI_DATA21  0x190
+#define  fmux_gpio_REG_IOCTRL_CAM_PD0  0x194
+#define  fmux_gpio_REG_IOCTRL_VI_DATA19  0x198
+#define  fmux_gpio_REG_IOCTRL_IIC0_SDA  0x19c
+#define  fmux_gpio_REG_IOCTRL_CAM_MCLK0  0x1a0
+#define  fmux_gpio_REG_IOCTRL_IIC3_SCL  0x1a4
+#define  fmux_gpio_REG_IOCTRL_VI_DATA24  0x1a8
+#define  fmux_gpio_REG_IOCTRL_CAM_RST0  0x1ac
+#define  fmux_gpio_REG_IOCTRL_VI_DATA23  0x1b0
+#define  fmux_gpio_REG_IOCTRL_IIC3_SDA  0x1b4
+#define  fmux_gpio_REG_IOCTRL_IIC0_SCL  0x1b8
+#define  fmux_gpio_funcsel_JTAG_CPU_TCK   0x0
+#define  fmux_gpio_funcsel_JTAG_CPU_TCK_OFFSET 0
+#define  fmux_gpio_funcsel_JTAG_CPU_TCK_MASK   0x7
+#define  fmux_gpio_funcsel_SDIO0_CD   0x4
+#define  fmux_gpio_funcsel_SDIO0_CD_OFFSET 0
+#define  fmux_gpio_funcsel_SDIO0_CD_MASK   0x7
+#define  fmux_gpio_funcsel_RSTN   0x8
+#define  fmux_gpio_funcsel_RSTN_OFFSET 0
+#define  fmux_gpio_funcsel_RSTN_MASK   0x7
+#define  fmux_gpio_funcsel_JTAG_CPU_TRST   0xc
+#define  fmux_gpio_funcsel_JTAG_CPU_TRST_OFFSET 0
+#define  fmux_gpio_funcsel_JTAG_CPU_TRST_MASK   0x7
+#define  fmux_gpio_funcsel_UART0_RX   0x10
+#define  fmux_gpio_funcsel_UART0_RX_OFFSET 0
+#define  fmux_gpio_funcsel_UART0_RX_MASK   0x7
+#define  fmux_gpio_funcsel_SDIO0_PWR_EN   0x14
+#define  fmux_gpio_funcsel_SDIO0_PWR_EN_OFFSET 0
+#define  fmux_gpio_funcsel_SDIO0_PWR_EN_MASK   0x7
+#define  fmux_gpio_funcsel_UART0_TX   0x18
+#define  fmux_gpio_funcsel_UART0_TX_OFFSET 0
+#define  fmux_gpio_funcsel_UART0_TX_MASK   0x7
+#define  fmux_gpio_funcsel_JTAG_CPU_TMS   0x1c
+#define  fmux_gpio_funcsel_JTAG_CPU_TMS_OFFSET 0
+#define  fmux_gpio_funcsel_JTAG_CPU_TMS_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_CLK   0x20
+#define  fmux_gpio_funcsel_EMMC_CLK_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_CLK_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_RSTN   0x24
+#define  fmux_gpio_funcsel_EMMC_RSTN_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_RSTN_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_CMD   0x28
+#define  fmux_gpio_funcsel_EMMC_CMD_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_CMD_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_DAT1   0x2c
+#define  fmux_gpio_funcsel_EMMC_DAT1_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_DAT1_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_DAT0   0x30
+#define  fmux_gpio_funcsel_EMMC_DAT0_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_DAT0_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_DAT2   0x34
+#define  fmux_gpio_funcsel_EMMC_DAT2_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_DAT2_MASK   0x7
+#define  fmux_gpio_funcsel_EMMC_DAT3   0x38
+#define  fmux_gpio_funcsel_EMMC_DAT3_OFFSET 0
+#define  fmux_gpio_funcsel_EMMC_DAT3_MASK   0x7
+#define  fmux_gpio_funcsel_SDIO0_CMD   0x3c
+#define  fmux_gpio_funcsel_SDIO0_CMD_OFFSET 0
+#define  fmux_gpio_funcsel_SDIO0_CMD_MASK   0x7
+#define  fmux_gpio_funcsel_SDIO0_CLK   0x40
+#define  fmux_gpio_funcsel_SDIO0_CLK_OFFSET 0
+#define  fmux_gpio_funcsel_SDIO0_CLK_MASK   0x7
+#define  fmux_gpio_funcsel_SDIO0_D0   0x44
+#define  fmux_gpio_funcsel_SDIO0_D0_OFFSET 0
+#define  fmux_gpio_funcsel_SDIO0_D0_MASK   0x7
+#define  fmux_gpio_funcsel_SDIO0_D1   0x48
+#define  fmux_gpio_funcsel_SDIO0_D1_OFFSET 0
+#define  fmux_gpio_funcsel_SDIO0_D1_MASK   0x7
+#define  fmux_gpio_funcsel_SDIO0_D2   0x4c
+#define  fmux_gpio_funcsel_SDIO0_D2_OFFSET 0
+#define  fmux_gpio_funcsel_SDIO0_D2_MASK   0x7
+#define  fmux_gpio_funcsel_SDIO0_D3   0x50
+#define  fmux_gpio_funcsel_SDIO0_D3_OFFSET 0
+#define  fmux_gpio_funcsel_SDIO0_D3_MASK   0x7
+#define  fmux_gpio_funcsel_RMII0_TXEN   0x54
+#define  fmux_gpio_funcsel_RMII0_TXEN_OFFSET 0
+#define  fmux_gpio_funcsel_RMII0_TXEN_MASK   0x7
+#define  fmux_gpio_funcsel_RMII0_TXD1   0x58
+#define  fmux_gpio_funcsel_RMII0_TXD1_OFFSET 0
+#define  fmux_gpio_funcsel_RMII0_TXD1_MASK   0x7
+#define  fmux_gpio_funcsel_RMII0_TXD0   0x5c
+#define  fmux_gpio_funcsel_RMII0_TXD0_OFFSET 0
+#define  fmux_gpio_funcsel_RMII0_TXD0_MASK   0x7
+#define  fmux_gpio_funcsel_RMII0_REFCLKI   0x60
+#define  fmux_gpio_funcsel_RMII0_REFCLKI_OFFSET 0
+#define  fmux_gpio_funcsel_RMII0_REFCLKI_MASK   0x7
+#define  fmux_gpio_funcsel_RMII0_MDIO   0x64
+#define  fmux_gpio_funcsel_RMII0_MDIO_OFFSET 0
+#define  fmux_gpio_funcsel_RMII0_MDIO_MASK   0x7
+#define  fmux_gpio_funcsel_RMII0_MDCK   0x68
+#define  fmux_gpio_funcsel_RMII0_MDCK_OFFSET 0
+#define  fmux_gpio_funcsel_RMII0_MDCK_MASK   0x7
+#define  fmux_gpio_funcsel_RMII0_RST   0x6c
+#define  fmux_gpio_funcsel_RMII0_RST_OFFSET 0
+#define  fmux_gpio_funcsel_RMII0_RST_MASK   0x7
+#define  fmux_gpio_funcsel_RMII0_RXD0   0x70
+#define  fmux_gpio_funcsel_RMII0_RXD0_OFFSET 0
+#define  fmux_gpio_funcsel_RMII0_RXD0_MASK   0x7
+#define  fmux_gpio_funcsel_RMII0_RXD1   0x74
+#define  fmux_gpio_funcsel_RMII0_RXD1_OFFSET 0
+#define  fmux_gpio_funcsel_RMII0_RXD1_MASK   0x7
+#define  fmux_gpio_funcsel_RMII0_RXDV   0x78
+#define  fmux_gpio_funcsel_RMII0_RXDV_OFFSET 0
+#define  fmux_gpio_funcsel_RMII0_RXDV_MASK   0x7
+#define  fmux_gpio_funcsel_RTC_MODE   0x7c
+#define  fmux_gpio_funcsel_RTC_MODE_OFFSET 0
+#define  fmux_gpio_funcsel_RTC_MODE_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_WAKEUP0   0x80
+#define  fmux_gpio_funcsel_PWR_WAKEUP0_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_WAKEUP0_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_BUTTON1   0x84
+#define  fmux_gpio_funcsel_PWR_BUTTON1_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_BUTTON1_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_WAKEUP1   0x88
+#define  fmux_gpio_funcsel_PWR_WAKEUP1_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_WAKEUP1_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_BUTTON0   0x8c
+#define  fmux_gpio_funcsel_PWR_BUTTON0_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_BUTTON0_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_VBAT_DET   0x90
+#define  fmux_gpio_funcsel_PWR_VBAT_DET_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_VBAT_DET_MASK   0x7
+#define  fmux_gpio_funcsel_PWR_ON   0x94
+#define  fmux_gpio_funcsel_PWR_ON_OFFSET 0
+#define  fmux_gpio_funcsel_PWR_ON_MASK   0x7
+#define  fmux_gpio_funcsel_PWM2   0x98
+#define  fmux_gpio_funcsel_PWM2_OFFSET 0
+#define  fmux_gpio_funcsel_PWM2_MASK   0x7
+#define  fmux_gpio_funcsel_PWM0_BUCK   0x9c
+#define  fmux_gpio_funcsel_PWM0_BUCK_OFFSET 0
+#define  fmux_gpio_funcsel_PWM0_BUCK_MASK   0x7
+#define  fmux_gpio_funcsel_PWM3   0xa0
+#define  fmux_gpio_funcsel_PWM3_OFFSET 0
+#define  fmux_gpio_funcsel_PWM3_MASK   0x7
+#define  fmux_gpio_funcsel_PWM1   0xa4
+#define  fmux_gpio_funcsel_PWM1_OFFSET 0
+#define  fmux_gpio_funcsel_PWM1_MASK   0x7
+#define  fmux_gpio_funcsel_SPI0_SDI   0xa8
+#define  fmux_gpio_funcsel_SPI0_SDI_OFFSET 0
+#define  fmux_gpio_funcsel_SPI0_SDI_MASK   0x7
+#define  fmux_gpio_funcsel_SPI0_SDO   0xac
+#define  fmux_gpio_funcsel_SPI0_SDO_OFFSET 0
+#define  fmux_gpio_funcsel_SPI0_SDO_MASK   0x7
+#define  fmux_gpio_funcsel_SPI0_SCK   0xb0
+#define  fmux_gpio_funcsel_SPI0_SCK_OFFSET 0
+#define  fmux_gpio_funcsel_SPI0_SCK_MASK   0x7
+#define  fmux_gpio_funcsel_SPI0_CS_X   0xb4
+#define  fmux_gpio_funcsel_SPI0_CS_X_OFFSET 0
+#define  fmux_gpio_funcsel_SPI0_CS_X_MASK   0x7
+#define  fmux_gpio_funcsel_IIC2_SCL   0xb8
+#define  fmux_gpio_funcsel_IIC2_SCL_OFFSET 0
+#define  fmux_gpio_funcsel_IIC2_SCL_MASK   0x7
+#define  fmux_gpio_funcsel_IIC1_SCL   0xbc
+#define  fmux_gpio_funcsel_IIC1_SCL_OFFSET 0
+#define  fmux_gpio_funcsel_IIC1_SCL_MASK   0x7
+#define  fmux_gpio_funcsel_IIC1_SDA   0xc0
+#define  fmux_gpio_funcsel_IIC1_SDA_OFFSET 0
+#define  fmux_gpio_funcsel_IIC1_SDA_MASK   0x7
+#define  fmux_gpio_funcsel_UART2_TX   0xc4
+#define  fmux_gpio_funcsel_UART2_TX_OFFSET 0
+#define  fmux_gpio_funcsel_UART2_TX_MASK   0x7
+#define  fmux_gpio_funcsel_IIC2_SDA   0xc8
+#define  fmux_gpio_funcsel_IIC2_SDA_OFFSET 0
+#define  fmux_gpio_funcsel_IIC2_SDA_MASK   0x7
+#define  fmux_gpio_funcsel_UART1_RTS   0xcc
+#define  fmux_gpio_funcsel_UART1_RTS_OFFSET 0
+#define  fmux_gpio_funcsel_UART1_RTS_MASK   0x7
+#define  fmux_gpio_funcsel_UART2_RTS   0xd0
+#define  fmux_gpio_funcsel_UART2_RTS_OFFSET 0
+#define  fmux_gpio_funcsel_UART2_RTS_MASK   0x7
+#define  fmux_gpio_funcsel_UART2_RX   0xd4
+#define  fmux_gpio_funcsel_UART2_RX_OFFSET 0
+#define  fmux_gpio_funcsel_UART2_RX_MASK   0x7
+#define  fmux_gpio_funcsel_UART1_TX   0xd8
+#define  fmux_gpio_funcsel_UART1_TX_OFFSET 0
+#define  fmux_gpio_funcsel_UART1_TX_MASK   0x7
+#define  fmux_gpio_funcsel_UART1_CTS   0xdc
+#define  fmux_gpio_funcsel_UART1_CTS_OFFSET 0
+#define  fmux_gpio_funcsel_UART1_CTS_MASK   0x7
+#define  fmux_gpio_funcsel_BOOT_MS   0xe0
+#define  fmux_gpio_funcsel_BOOT_MS_OFFSET 0
+#define  fmux_gpio_funcsel_BOOT_MS_MASK   0x7
+#define  fmux_gpio_funcsel_UART2_CTS   0xe4
+#define  fmux_gpio_funcsel_UART2_CTS_OFFSET 0
+#define  fmux_gpio_funcsel_UART2_CTS_MASK   0x7
+#define  fmux_gpio_funcsel_ADC1   0xe8
+#define  fmux_gpio_funcsel_ADC1_OFFSET 0
+#define  fmux_gpio_funcsel_ADC1_MASK   0x7
+#define  fmux_gpio_funcsel_UART1_RX   0xec
+#define  fmux_gpio_funcsel_UART1_RX_OFFSET 0
+#define  fmux_gpio_funcsel_UART1_RX_MASK   0x7
+#define  fmux_gpio_funcsel_USB_ID   0xf0
+#define  fmux_gpio_funcsel_USB_ID_OFFSET 0
+#define  fmux_gpio_funcsel_USB_ID_MASK   0x7
+#define  fmux_gpio_funcsel_USB_VBUS_DET   0xf4
+#define  fmux_gpio_funcsel_USB_VBUS_DET_OFFSET 0
+#define  fmux_gpio_funcsel_USB_VBUS_DET_MASK   0x7
+#define  fmux_gpio_funcsel_USB_VBUS_EN   0xf8
+#define  fmux_gpio_funcsel_USB_VBUS_EN_OFFSET 0
+#define  fmux_gpio_funcsel_USB_VBUS_EN_MASK   0x7
+#define  fmux_gpio_funcsel_CLK32K   0xfc
+#define  fmux_gpio_funcsel_CLK32K_OFFSET 0
+#define  fmux_gpio_funcsel_CLK32K_MASK   0x7
+#define  fmux_gpio_funcsel_CLK25M   0x100
+#define  fmux_gpio_funcsel_CLK25M_OFFSET 0
+#define  fmux_gpio_funcsel_CLK25M_MASK   0x7
+#define  fmux_gpio_funcsel_XTAL_XIN_XI   0x104
+#define  fmux_gpio_funcsel_XTAL_XIN_XI_OFFSET 0
+#define  fmux_gpio_funcsel_XTAL_XIN_XI_MASK   0x7
+#define  fmux_gpio_funcsel_VO_DATA1   0x108
+#define  fmux_gpio_funcsel_VO_DATA1_OFFSET 0
+#define  fmux_gpio_funcsel_VO_DATA1_MASK   0x7
+#define  fmux_gpio_funcsel_VO_DATA0   0x10c
+#define  fmux_gpio_funcsel_VO_DATA0_OFFSET 0
+#define  fmux_gpio_funcsel_VO_DATA0_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM4   0x110
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM4_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM4_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP4   0x114
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP4_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP4_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM3   0x118
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM3_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM3_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP3   0x11c
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP3_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP3_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM2   0x120
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM2_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM2_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP2   0x124
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP2_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP2_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM1   0x128
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM1_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM1_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP1   0x12c
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP1_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP1_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM0   0x130
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM0_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXM0_MASK   0x7
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP0   0x134
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP0_OFFSET 0
+#define  fmux_gpio_funcsel_PAD_MIPI_TXP0_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD0P   0x138
+#define  fmux_gpio_funcsel_MIPIRX1_PAD0P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD0P_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD0N   0x13c
+#define  fmux_gpio_funcsel_MIPIRX1_PAD0N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD0N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD1P   0x140
+#define  fmux_gpio_funcsel_MIPIRX1_PAD1P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD1P_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD1N   0x144
+#define  fmux_gpio_funcsel_MIPIRX1_PAD1N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD1N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD2P   0x148
+#define  fmux_gpio_funcsel_MIPIRX1_PAD2P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD2P_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD2N   0x14c
+#define  fmux_gpio_funcsel_MIPIRX1_PAD2N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD2N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD3P   0x150
+#define  fmux_gpio_funcsel_MIPIRX1_PAD3P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD3P_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD3N   0x154
+#define  fmux_gpio_funcsel_MIPIRX1_PAD3N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD3N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD4P   0x158
+#define  fmux_gpio_funcsel_MIPIRX1_PAD4P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD4P_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX1_PAD4N   0x15c
+#define  fmux_gpio_funcsel_MIPIRX1_PAD4N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX1_PAD4N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD4N   0x160
+#define  fmux_gpio_funcsel_MIPIRX0_PAD4N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD4N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD4P   0x164
+#define  fmux_gpio_funcsel_MIPIRX0_PAD4P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD4P_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD3N   0x168
+#define  fmux_gpio_funcsel_MIPIRX0_PAD3N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD3N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD3P   0x16c
+#define  fmux_gpio_funcsel_MIPIRX0_PAD3P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD3P_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD2N   0x170
+#define  fmux_gpio_funcsel_MIPIRX0_PAD2N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD2N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD2P   0x174
+#define  fmux_gpio_funcsel_MIPIRX0_PAD2P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD2P_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD1N   0x178
+#define  fmux_gpio_funcsel_MIPIRX0_PAD1N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD1N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD1P   0x17c
+#define  fmux_gpio_funcsel_MIPIRX0_PAD1P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD1P_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD0N   0x180
+#define  fmux_gpio_funcsel_MIPIRX0_PAD0N_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD0N_MASK   0x7
+#define  fmux_gpio_funcsel_MIPIRX0_PAD0P   0x184
+#define  fmux_gpio_funcsel_MIPIRX0_PAD0P_OFFSET 0
+#define  fmux_gpio_funcsel_MIPIRX0_PAD0P_MASK   0x7
+#define  fmux_gpio_funcsel_VI_DATA22   0x188
+#define  fmux_gpio_funcsel_VI_DATA22_OFFSET 0
+#define  fmux_gpio_funcsel_VI_DATA22_MASK   0x7
+#define  fmux_gpio_funcsel_VI_DATA20   0x18c
+#define  fmux_gpio_funcsel_VI_DATA20_OFFSET 0
+#define  fmux_gpio_funcsel_VI_DATA20_MASK   0x7
+#define  fmux_gpio_funcsel_VI_DATA21   0x190
+#define  fmux_gpio_funcsel_VI_DATA21_OFFSET 0
+#define  fmux_gpio_funcsel_VI_DATA21_MASK   0x7
+#define  fmux_gpio_funcsel_CAM_PD0   0x194
+#define  fmux_gpio_funcsel_CAM_PD0_OFFSET 0
+#define  fmux_gpio_funcsel_CAM_PD0_MASK   0x7
+#define  fmux_gpio_funcsel_VI_DATA19   0x198
+#define  fmux_gpio_funcsel_VI_DATA19_OFFSET 0
+#define  fmux_gpio_funcsel_VI_DATA19_MASK   0x7
+#define  fmux_gpio_funcsel_IIC0_SDA   0x19c
+#define  fmux_gpio_funcsel_IIC0_SDA_OFFSET 0
+#define  fmux_gpio_funcsel_IIC0_SDA_MASK   0x7
+#define  fmux_gpio_funcsel_CAM_MCLK0   0x1a0
+#define  fmux_gpio_funcsel_CAM_MCLK0_OFFSET 0
+#define  fmux_gpio_funcsel_CAM_MCLK0_MASK   0x7
+#define  fmux_gpio_funcsel_IIC3_SCL   0x1a4
+#define  fmux_gpio_funcsel_IIC3_SCL_OFFSET 0
+#define  fmux_gpio_funcsel_IIC3_SCL_MASK   0x7
+#define  fmux_gpio_funcsel_VI_DATA24   0x1a8
+#define  fmux_gpio_funcsel_VI_DATA24_OFFSET 0
+#define  fmux_gpio_funcsel_VI_DATA24_MASK   0x7
+#define  fmux_gpio_funcsel_CAM_RST0   0x1ac
+#define  fmux_gpio_funcsel_CAM_RST0_OFFSET 0
+#define  fmux_gpio_funcsel_CAM_RST0_MASK   0x7
+#define  fmux_gpio_funcsel_VI_DATA23   0x1b0
+#define  fmux_gpio_funcsel_VI_DATA23_OFFSET 0
+#define  fmux_gpio_funcsel_VI_DATA23_MASK   0x7
+#define  fmux_gpio_funcsel_IIC3_SDA   0x1b4
+#define  fmux_gpio_funcsel_IIC3_SDA_OFFSET 0
+#define  fmux_gpio_funcsel_IIC3_SDA_MASK   0x7
+#define  fmux_gpio_funcsel_IIC0_SCL   0x1b8
+#define  fmux_gpio_funcsel_IIC0_SCL_OFFSET 0
+#define  fmux_gpio_funcsel_IIC0_SCL_MASK   0x7
diff --git a/drivers/pinctrl/cvitek/pinctrl-cv180x.c b/drivers/pinctrl/cvitek/pinctrl-cv180x.c
new file mode 100644
index 000000000000..57ab60d630bf
--- /dev/null
+++ b/drivers/pinctrl/cvitek/pinctrl-cv180x.c
@@ -0,0 +1,108 @@
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include "pinctrl-cv180x.h"
+
+struct cvitek_pinctrl {
+	struct device *dev;
+	void __iomem *regs;
+	size_t regs_size;
+
+	uint32_t *saved_regs;
+};
+
+static int cvi_pinctrl_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct cvitek_pinctrl *pinctrl;
+
+	pinctrl = devm_kzalloc(&pdev->dev, sizeof(*pinctrl), GFP_KERNEL);
+	if (!pinctrl)
+		return -ENOMEM;
+
+	pinctrl->saved_regs =
+		devm_kzalloc(&pdev->dev, CVITEK_PINMUX_REG_LAST, GFP_KERNEL);
+	if (!pinctrl->saved_regs)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "Failed to get pinctrl io resource.\n");
+		return -EINVAL;
+	}
+
+	pinctrl->regs_size = resource_size(res);
+	pinctrl->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (!pinctrl->regs)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, pinctrl);
+
+	dev_info(&pdev->dev, "%s(): reg=%p,%zu CVITEK_PINMUX_REG_LAST=0x%x\n",
+		 __func__, pinctrl->regs, pinctrl->regs_size,
+		 CVITEK_PINMUX_REG_LAST);
+
+	return 0;
+}
+
+static int cvi_pinctrl_remove(struct platform_device *pdev)
+{
+	dev_info(&pdev->dev, "%s()\n", __func__);
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int cvitek_pinctrl_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct cvitek_pinctrl *pinctrl = platform_get_drvdata(pdev);
+
+	dev_info(&pdev->dev, "%s()\n", __func__);
+
+	memcpy_fromio(pinctrl->saved_regs, pinctrl->regs,
+		      CVITEK_PINMUX_REG_LAST);
+
+	return 0;
+}
+
+static int cvitek_pinctrl_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct cvitek_pinctrl *pinctrl = platform_get_drvdata(pdev);
+
+	dev_info(&pdev->dev, "%s()\n", __func__);
+
+	memcpy_toio(pinctrl->regs, pinctrl->saved_regs, CVITEK_PINMUX_REG_LAST);
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static const struct of_device_id cvi_pinctrl_of_match[] = {
+	{ .compatible = "cvitek,pinctrl-cv180x" },
+	{},
+};
+
+static const struct dev_pm_ops cvitek_pinctrl_pm_ops = {
+	SET_LATE_SYSTEM_SLEEP_PM_OPS(cvitek_pinctrl_suspend,
+				     cvitek_pinctrl_resume)
+};
+
+static struct platform_driver cvi_pinctrl_driver = {
+	.probe = cvi_pinctrl_probe,
+	.remove	= cvi_pinctrl_remove,
+	.driver = {
+		.name = "cvitek,pinctrl-cv180x",
+		.of_match_table = cvi_pinctrl_of_match,
+#ifdef CONFIG_PM_SLEEP
+		.pm	= &cvitek_pinctrl_pm_ops,
+#endif
+	},
+};
+
+module_platform_driver(cvi_pinctrl_driver);
+
+MODULE_DESCRIPTION("Cvitek pinctrl");
+MODULE_AUTHOR("Cvitek");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/pinctrl/cvitek/pinctrl-cv180x.h b/drivers/pinctrl/cvitek/pinctrl-cv180x.h
new file mode 100644
index 000000000000..4597d6ec5d89
--- /dev/null
+++ b/drivers/pinctrl/cvitek/pinctrl-cv180x.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ * File Name: pinctrl-cv1822.h
+ * Description:
+ */
+
+#ifndef __PINCTRL_CV180X_H__
+#define __PINCTRL_CV180X_H__
+
+#include "../core.h"
+#include "cv180x_pinlist_swconfig.h"
+#include "cv180x_reg_fmux_gpio.h"
+
+#define CVITEK_PINMUX_REG_LAST (FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTR + 4)
+
+#define PINMUX_BASE 0x03001000
+#define PINMUX_MASK(PIN_NAME) FMUX_GPIO_FUNCSEL_##PIN_NAME##_MASK
+#define PINMUX_OFFSET(PIN_NAME) FMUX_GPIO_FUNCSEL_##PIN_NAME##_OFFSET
+#define PINMUX_VALUE(PIN_NAME, FUNC_NAME) PIN_NAME##__##FUNC_NAME
+#define PINMUX_CONFIG(PIN_NAME, FUNC_NAME) \
+		mmio_clrsetbits_32(PINMUX_BASE + FMUX_GPIO_FUNCSEL_##PIN_NAME, \
+						   PINMUX_MASK(PIN_NAME) << PINMUX_OFFSET(PIN_NAME), \
+						   PINMUX_VALUE(PIN_NAME, FUNC_NAME))
+
+static inline void mmio_clrsetbits_32(uintptr_t addr,
+				      uint32_t clear,
+				      uint32_t set)
+{
+	iowrite32((ioread32(ioremap(addr, 0x4)) & ~clear) | set,
+		  ioremap(addr, 0x4));
+}
+
+#endif /* __PINCTRL_CV180X_H__ */
diff --git a/drivers/pinctrl/cvitek/pinctrl-cv181x.c b/drivers/pinctrl/cvitek/pinctrl-cv181x.c
new file mode 100644
index 000000000000..19ab21d65296
--- /dev/null
+++ b/drivers/pinctrl/cvitek/pinctrl-cv181x.c
@@ -0,0 +1,108 @@
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include "pinctrl-cv181x.h"
+
+struct cvitek_pinctrl {
+	struct device *dev;
+	void __iomem *regs;
+	size_t regs_size;
+
+	uint32_t *saved_regs;
+};
+
+static int cvi_pinctrl_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct cvitek_pinctrl *pinctrl;
+
+	pinctrl = devm_kzalloc(&pdev->dev, sizeof(*pinctrl), GFP_KERNEL);
+	if (!pinctrl)
+		return -ENOMEM;
+
+	pinctrl->saved_regs =
+		devm_kzalloc(&pdev->dev, CVITEK_PINMUX_REG_LAST, GFP_KERNEL);
+	if (!pinctrl->saved_regs)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "Failed to get pinctrl io resource.\n");
+		return -EINVAL;
+	}
+
+	pinctrl->regs_size = resource_size(res);
+	pinctrl->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (!pinctrl->regs)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, pinctrl);
+
+	dev_info(&pdev->dev, "%s(): reg=%p,%zu CVITEK_PINMUX_REG_LAST=0x%x\n",
+		 __func__, pinctrl->regs, pinctrl->regs_size,
+		 CVITEK_PINMUX_REG_LAST);
+
+	return 0;
+}
+
+static int cvi_pinctrl_remove(struct platform_device *pdev)
+{
+	dev_info(&pdev->dev, "%s()\n", __func__);
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int cvitek_pinctrl_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct cvitek_pinctrl *pinctrl = platform_get_drvdata(pdev);
+
+	dev_info(&pdev->dev, "%s()\n", __func__);
+
+	memcpy_fromio(pinctrl->saved_regs, pinctrl->regs,
+		      CVITEK_PINMUX_REG_LAST);
+
+	return 0;
+}
+
+static int cvitek_pinctrl_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct cvitek_pinctrl *pinctrl = platform_get_drvdata(pdev);
+
+	dev_info(&pdev->dev, "%s()\n", __func__);
+
+	memcpy_toio(pinctrl->regs, pinctrl->saved_regs, CVITEK_PINMUX_REG_LAST);
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static const struct of_device_id cvi_pinctrl_of_match[] = {
+	{ .compatible = "cvitek,pinctrl-cv181x" },
+	{},
+};
+
+static const struct dev_pm_ops cvitek_pinctrl_pm_ops = {
+	SET_LATE_SYSTEM_SLEEP_PM_OPS(cvitek_pinctrl_suspend,
+				     cvitek_pinctrl_resume)
+};
+
+static struct platform_driver cvi_pinctrl_driver = {
+	.probe = cvi_pinctrl_probe,
+	.remove	= cvi_pinctrl_remove,
+	.driver = {
+		.name = "cvitek,pinctrl-cv181x",
+		.of_match_table = cvi_pinctrl_of_match,
+#ifdef CONFIG_PM_SLEEP
+		.pm	= &cvitek_pinctrl_pm_ops,
+#endif
+	},
+};
+
+module_platform_driver(cvi_pinctrl_driver);
+
+MODULE_DESCRIPTION("Cvitek pinctrl");
+MODULE_AUTHOR("Cvitek");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/pinctrl/cvitek/pinctrl-cv181x.h b/drivers/pinctrl/cvitek/pinctrl-cv181x.h
new file mode 100644
index 000000000000..11912e767e22
--- /dev/null
+++ b/drivers/pinctrl/cvitek/pinctrl-cv181x.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ * File Name: pinctrl-cv1822.h
+ * Description:
+ */
+
+#ifndef __PINCTRL_CV181X_H__
+#define __PINCTRL_CV181X_H__
+
+#include "../core.h"
+#include "cv181x_pinlist_swconfig.h"
+#include "cv181x_reg_fmux_gpio.h"
+
+#define CVITEK_PINMUX_REG_LAST (FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTR + 4)
+
+#define PINMUX_BASE 0x03001000
+#define PINMUX_MASK(PIN_NAME) FMUX_GPIO_FUNCSEL_##PIN_NAME##_MASK
+#define PINMUX_OFFSET(PIN_NAME) FMUX_GPIO_FUNCSEL_##PIN_NAME##_OFFSET
+#define PINMUX_VALUE(PIN_NAME, FUNC_NAME) PIN_NAME##__##FUNC_NAME
+#define PINMUX_CONFIG(PIN_NAME, FUNC_NAME) \
+		mmio_clrsetbits_32(PINMUX_BASE + FMUX_GPIO_FUNCSEL_##PIN_NAME, \
+						   PINMUX_MASK(PIN_NAME) << PINMUX_OFFSET(PIN_NAME), \
+						   PINMUX_VALUE(PIN_NAME, FUNC_NAME))
+
+static inline void mmio_clrsetbits_32(uintptr_t addr,
+				      uint32_t clear,
+				      uint32_t set)
+{
+	void __iomem *tpreg;
+
+	tpreg = ioremap(addr, 0x4);
+	if (IS_ERR(tpreg)) {
+		pr_err("ioremap %p failed\n", (void *)addr);
+		return;
+	}
+
+	iowrite32((ioread32(tpreg) & ~clear) | set, tpreg);
+
+	iounmap(tpreg);
+}
+
+#endif /* __PINCTRL_CV181X_H__ */
diff --git a/drivers/pinctrl/cvitek/pinctrl-cv1822.h b/drivers/pinctrl/cvitek/pinctrl-cv1822.h
new file mode 100644
index 000000000000..72942ec1df22
--- /dev/null
+++ b/drivers/pinctrl/cvitek/pinctrl-cv1822.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ * File Name: pinctrl-cv1822.h
+ * Description:
+ */
+
+#ifndef __PINCTRL_CV1822_H__
+#define __PINCTRL_CV1822_H__
+
+#include "../core.h"
+#include "cv1822_pinlist_swconfig.h"
+#include "cv1822_reg_fmux_gpio.h"
+
+#define RTC_IO_BASE 0x05027000
+#define CTRL_SELPHY_PWR_ON 0x88
+#define RTC_IO_REG_CNT 20
+
+#define CVITEK_PINMUX_REG_LAST (FMUX_GPIO_FUNCSEL_PAD_AUD_AOUTR + 4)
+
+#define PINMUX_BASE 0x03001000
+#define PINMUX_MASK(PIN_NAME) FMUX_GPIO_FUNCSEL_##PIN_NAME##_MASK
+#define PINMUX_OFFSET(PIN_NAME) FMUX_GPIO_FUNCSEL_##PIN_NAME##_OFFSET
+#define PINMUX_VALUE(PIN_NAME, FUNC_NAME) PIN_NAME##__##FUNC_NAME
+#define PINMUX_CONFIG(PIN_NAME, FUNC_NAME) \
+		mmio_clrsetbits_32(PINMUX_BASE + FMUX_GPIO_FUNCSEL_##PIN_NAME, \
+						   PINMUX_MASK(PIN_NAME) << PINMUX_OFFSET(PIN_NAME), \
+						   PINMUX_VALUE(PIN_NAME, FUNC_NAME))
+
+static inline void mmio_clrsetbits_32(uintptr_t addr,
+				      uint32_t clear,
+				      uint32_t set)
+{
+	void __iomem *tpreg;
+
+	tpreg = ioremap(addr, 0x4);
+	if (IS_ERR(tpreg)) {
+		pr_err("ioremap %p failed\n", (void *)addr);
+		return;
+	}
+
+	iowrite32((ioread32(tpreg) & ~clear) | set, tpreg);
+
+	iounmap(tpreg);
+}
+
+#endif /* __PINCTRL_CV1822_H__ */
diff --git a/drivers/pinctrl/cvitek/pinctrl-cv182x.c b/drivers/pinctrl/cvitek/pinctrl-cv182x.c
new file mode 100644
index 000000000000..ee6e07d53a46
--- /dev/null
+++ b/drivers/pinctrl/cvitek/pinctrl-cv182x.c
@@ -0,0 +1,127 @@
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include "pinctrl-cv1822.h"
+
+struct cvitek_pinctrl {
+	struct device *dev;
+	void __iomem *regs;
+	size_t regs_size;
+
+	uint32_t *saved_regs;
+};
+
+static int cvi_pinctrl_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct cvitek_pinctrl *pinctrl;
+
+	pinctrl = devm_kzalloc(&pdev->dev, sizeof(*pinctrl), GFP_KERNEL);
+	if (!pinctrl)
+		return -ENOMEM;
+
+	pinctrl->saved_regs =
+		devm_kzalloc(&pdev->dev, CVITEK_PINMUX_REG_LAST, GFP_KERNEL);
+	if (!pinctrl->saved_regs)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "Failed to get pinctrl io resource.\n");
+		return -EINVAL;
+	}
+
+	pinctrl->regs_size = resource_size(res);
+	pinctrl->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (!pinctrl->regs)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, pinctrl);
+
+	dev_info(&pdev->dev, "%s(): reg=%p,%zu CVITEK_PINMUX_REG_LAST=0x%x\n",
+		 __func__, pinctrl->regs, pinctrl->regs_size,
+		 CVITEK_PINMUX_REG_LAST);
+
+	return 0;
+}
+
+static int cvi_pinctrl_remove(struct platform_device *pdev)
+{
+	dev_info(&pdev->dev, "%s()\n", __func__);
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int cvitek_pinctrl_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct cvitek_pinctrl *pinctrl = platform_get_drvdata(pdev);
+
+	dev_info(&pdev->dev, "%s()\n", __func__);
+
+	memcpy_fromio(pinctrl->saved_regs, pinctrl->regs,
+		      CVITEK_PINMUX_REG_LAST);
+
+	return 0;
+}
+
+static int cvitek_pinctrl_unlock(void)
+{
+	void __iomem *tpreg;
+	uint32_t i;
+
+	tpreg = ioremap(RTC_IO_BASE, PAGE_SIZE);
+	if (IS_ERR(tpreg))
+		return PTR_ERR(tpreg);
+
+	for (i = 0; i < RTC_IO_REG_CNT; i++)
+		writel(0x11111111, tpreg + CTRL_SELPHY_PWR_ON + i*4);
+
+	iounmap(tpreg);
+
+	return 0;
+}
+
+static int cvitek_pinctrl_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct cvitek_pinctrl *pinctrl = platform_get_drvdata(pdev);
+
+	dev_info(&pdev->dev, "%s()\n", __func__);
+
+	memcpy_toio(pinctrl->regs, pinctrl->saved_regs, CVITEK_PINMUX_REG_LAST);
+
+	cvitek_pinctrl_unlock();
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static const struct of_device_id cvi_pinctrl_of_match[] = {
+	{ .compatible = "cvitek,pinctrl-cv182x" },
+	{},
+};
+
+static const struct dev_pm_ops cvitek_pinctrl_pm_ops = {
+	SET_LATE_SYSTEM_SLEEP_PM_OPS(cvitek_pinctrl_suspend,
+				     cvitek_pinctrl_resume)
+};
+
+static struct platform_driver cvi_pinctrl_driver = {
+	.probe = cvi_pinctrl_probe,
+	.remove	= cvi_pinctrl_remove,
+	.driver = {
+		.name = "cvitek,pinctrl-cv182x",
+		.of_match_table = cvi_pinctrl_of_match,
+#ifdef CONFIG_PM_SLEEP
+		.pm	= &cvitek_pinctrl_pm_ops,
+#endif
+	},
+};
+
+module_platform_driver(cvi_pinctrl_driver);
+
+MODULE_DESCRIPTION("Cvitek pinctrl");
+MODULE_AUTHOR("Cvitek");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/pinctrl/cvitek/pinctrl-cv1835.h b/drivers/pinctrl/cvitek/pinctrl-cv1835.h
new file mode 100644
index 000000000000..b619d26c3832
--- /dev/null
+++ b/drivers/pinctrl/cvitek/pinctrl-cv1835.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ * File Name: pinctrl-cv1835.h
+ * Description:
+ */
+
+#ifndef __PINCTRL_CV1835_H__
+#define __PINCTRL_CV1835_H__
+
+#include "../core.h"
+#include "cv1835_pinlist_swconfig.h"
+#include "cv1835_reg_fmux_gpio.h"
+
+#define  PAD_MIPI_TXM4__MIPI_TXM4 0
+#define  PAD_MIPI_TXP4__MIPI_TXP4 0
+#define  PAD_MIPI_TXM3__MIPI_TXM3 0
+#define  PAD_MIPI_TXP3__MIPI_TXP3 0
+#define  PAD_MIPI_TXM2__MIPI_TXM2 0
+#define  PAD_MIPI_TXP2__MIPI_TXP2 0
+#define  PAD_MIPI_TXM1__MIPI_TXM1 0
+#define  PAD_MIPI_TXP1__MIPI_TXP1 0
+#define  PAD_MIPI_TXM0__MIPI_TXM0 0
+#define  PAD_MIPI_TXP0__MIPI_TXP0 0
+
+#define PINMUX_BASE 0x03001000
+#define PINMUX_MASK(PIN_NAME) fmux_gpio_funcsel_##PIN_NAME##_MASK
+#define PINMUX_OFFSET(PIN_NAME) fmux_gpio_funcsel_##PIN_NAME##_OFFSET
+#define PINMUX_VALUE(PIN_NAME, FUNC_NAME) PIN_NAME##__##FUNC_NAME
+#define PINMUX_CONFIG(PIN_NAME, FUNC_NAME) \
+		mmio_clrsetbits_32(PINMUX_BASE + fmux_gpio_funcsel_##PIN_NAME, \
+		PINMUX_MASK(PIN_NAME) << PINMUX_OFFSET(PIN_NAME), \
+		PINMUX_VALUE(PIN_NAME, FUNC_NAME))
+
+static inline void mmio_clrsetbits_32(uintptr_t addr,
+				      uint32_t clear,
+				      uint32_t set)
+{
+	void __iomem *tpreg;
+
+	tpreg = ioremap(addr, 0x4);
+	if (IS_ERR(tpreg)) {
+		pr_err("ioremap %p failed\n", (void *)addr);
+		return;
+	}
+
+	iowrite32((ioread32(tpreg) & ~clear) | set, tpreg);
+
+	iounmap(tpreg);
+}
+
+#endif /* __PINCTRL_CV1835_H__ */
diff --git a/drivers/pinctrl/cvitek/pinctrl-cv183x.c b/drivers/pinctrl/cvitek/pinctrl-cv183x.c
new file mode 100644
index 000000000000..d1ce4fc5e048
--- /dev/null
+++ b/drivers/pinctrl/cvitek/pinctrl-cv183x.c
@@ -0,0 +1,20 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinconf-generic.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/of.h>
+#include "../pinctrl-utils.h"
+#include "pinctrl-cv1835.h"
+
+
+MODULE_DESCRIPTION("Cvitek pinctrl");
+MODULE_AUTHOR("Cvitek");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/pinctrl/cvitek/pinctrl-cv75x1.c b/drivers/pinctrl/cvitek/pinctrl-cv75x1.c
new file mode 100644
index 000000000000..d1ce4fc5e048
--- /dev/null
+++ b/drivers/pinctrl/cvitek/pinctrl-cv75x1.c
@@ -0,0 +1,20 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinconf-generic.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/of.h>
+#include "../pinctrl-utils.h"
+#include "pinctrl-cv1835.h"
+
+
+MODULE_DESCRIPTION("Cvitek pinctrl");
+MODULE_AUTHOR("Cvitek");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/pinctrl/cvitek/pinctrl-cv952x.c b/drivers/pinctrl/cvitek/pinctrl-cv952x.c
new file mode 100644
index 000000000000..d1ce4fc5e048
--- /dev/null
+++ b/drivers/pinctrl/cvitek/pinctrl-cv952x.c
@@ -0,0 +1,20 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinconf-generic.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/of.h>
+#include "../pinctrl-utils.h"
+#include "pinctrl-cv1835.h"
+
+
+MODULE_DESCRIPTION("Cvitek pinctrl");
+MODULE_AUTHOR("Cvitek");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/power/reset/Makefile b/drivers/power/reset/Makefile
index c51eceba9ea3..290f7d680adc 100644
--- a/drivers/power/reset/Makefile
+++ b/drivers/power/reset/Makefile
@@ -33,3 +33,4 @@ obj-$(CONFIG_REBOOT_MODE) += reboot-mode.o
 obj-$(CONFIG_SYSCON_REBOOT_MODE) += syscon-reboot-mode.o
 obj-$(CONFIG_POWER_RESET_SC27XX) += sc27xx-poweroff.o
 obj-$(CONFIG_NVMEM_REBOOT_MODE) += nvmem-reboot-mode.o
+obj-y += cvi-reboot.o
diff --git a/drivers/power/reset/cvi-reboot.c b/drivers/power/reset/cvi-reboot.c
new file mode 100644
index 000000000000..05b502e83bfa
--- /dev/null
+++ b/drivers/power/reset/cvi-reboot.c
@@ -0,0 +1,112 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/reboot.h>
+
+#define RTC_CTRL0_UNLOCKKEY		0x4
+#define RTC_CTRL0				0x8
+#define RTC_CTRL0_STATUS0		0xC
+#define RTC_EN_PWR_WAKEUP		0xBC
+#define RTC_EN_SHDN_REQ			0xC0
+#define RTC_EN_PWR_CYC_REQ		0xC8
+#define RTC_EN_WARM_RST_REQ		0xCC
+#define RTC_EN_WDT_RST_REQ		0xE0
+#define RTC_EN_SUSPEND_REQ		0xE4
+#define RSM_STATE				0xD4
+#define ST_ON					0x3
+
+static void __iomem *base;
+
+static int cvi_restart_handler(struct notifier_block *this,
+				unsigned long mode, void *cmd)
+{
+	void __iomem *REG_RTC_CTRL_BASE = base;
+	void __iomem *REG_RTC_BASE = base + 0x1000;
+
+	/* Enable power suspend wakeup source mask */
+	writel(0x1, REG_RTC_BASE + 0x3C); // 1 = select prdata from 32K domain
+
+	writel(0xAB18, REG_RTC_CTRL_BASE + RTC_CTRL0_UNLOCKKEY);
+
+	writel(0x1, REG_RTC_BASE + RTC_EN_WARM_RST_REQ);
+
+	while (readl(REG_RTC_BASE + RTC_EN_WARM_RST_REQ) != 0x01)
+		;
+
+	while (readl(REG_RTC_BASE + RSM_STATE) != ST_ON)
+		;
+
+	writel(0xFFFF0800 | (0x1 << 4), REG_RTC_CTRL_BASE + RTC_CTRL0);
+
+	return NOTIFY_DONE;
+}
+
+static void cvi_do_pwroff(void)
+{
+	void __iomem *REG_RTC_CTRL_BASE = base;
+	void __iomem *REG_RTC_BASE = base + 0x1000;
+
+	/* Enable power suspend wakeup source mask */
+	writel(0x1, REG_RTC_BASE + 0x3C); // 1 = select prdata from 32K domain
+
+	writel(0xAB18, REG_RTC_CTRL_BASE + RTC_CTRL0_UNLOCKKEY);
+
+	writel(0x1, REG_RTC_BASE + RTC_EN_SHDN_REQ);
+
+	while (readl(REG_RTC_BASE + RTC_EN_SHDN_REQ) != 0x01)
+		;
+
+	writel(0xFFFF0800 | (0x1 << 0), REG_RTC_CTRL_BASE + RTC_CTRL0);
+
+	/* Wait some time until system down, otherwise, notice with a warn */
+	mdelay(1000);
+
+	WARN_ONCE(1, "Unable to power off system\n");
+}
+
+static struct notifier_block cvi_restart_nb = {
+	.notifier_call = cvi_restart_handler,
+	.priority = 128,
+};
+
+static int cvi_reboot_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	int err;
+
+	base = of_iomap(np, 0);
+	if (!base) {
+		WARN(1, "failed to map base address");
+		return -ENODEV;
+	}
+
+	err = register_restart_handler(&cvi_restart_nb);
+	if (err) {
+		dev_err(&pdev->dev, "cannot register restart handler (err=%d)\n",
+			err);
+		iounmap(base);
+	}
+
+	pm_power_off = &cvi_do_pwroff;
+
+	return err;
+}
+
+static const struct of_device_id cvi_reboot_of_match[] = {
+	{ .compatible = "cvitek,restart" },
+	{}
+};
+
+static struct platform_driver cvi_reboot_driver = {
+	.probe = cvi_reboot_probe,
+	.driver = {
+		.name = "cvi-reboot",
+		.of_match_table = cvi_reboot_of_match,
+	},
+};
+module_platform_driver(cvi_reboot_driver);
diff --git a/drivers/reset/Makefile b/drivers/reset/Makefile
index 16947610cc3b..9843f77974ad 100644
--- a/drivers/reset/Makefile
+++ b/drivers/reset/Makefile
@@ -33,4 +33,5 @@ obj-$(CONFIG_RESET_UNIPHIER) += reset-uniphier.o
 obj-$(CONFIG_RESET_UNIPHIER_GLUE) += reset-uniphier-glue.o
 obj-$(CONFIG_RESET_ZYNQ) += reset-zynq.o
 obj-$(CONFIG_ARCH_ZYNQMP) += reset-zynqmp.o
-
+obj-$(CONFIG_ARCH_CVITEK) += reset-cvitek.o
+obj-$(CONFIG_ARCH_CVITEK) += clk-reset-cvitek.o
diff --git a/drivers/reset/clk-reset-cvitek.c b/drivers/reset/clk-reset-cvitek.c
new file mode 100644
index 000000000000..e1121402ac79
--- /dev/null
+++ b/drivers/reset/clk-reset-cvitek.c
@@ -0,0 +1,125 @@
+/*
+ * Bitmain SoCs Reset Controller driver
+ *
+ * Copyright (c) 2018 Bitmain Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/reset-controller.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+
+#define BITS_PER_REG	32
+
+struct bm_reset_data {
+	spinlock_t			lock;
+	void __iomem			*membase;
+	struct reset_controller_dev	rcdev;
+};
+
+static int bm_reset_assert(struct reset_controller_dev *rcdev,
+			      unsigned long id)
+{
+	struct bm_reset_data *data = container_of(rcdev,
+						     struct bm_reset_data,
+						     rcdev);
+	int bank = id / BITS_PER_REG;
+	int offset = id % BITS_PER_REG;
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&data->lock, flags);
+
+	reg = readl(data->membase + (bank * 4));
+	writel(reg & ~BIT(offset), data->membase + (bank * 4));
+
+	spin_unlock_irqrestore(&data->lock, flags);
+
+	return 0;
+}
+
+static int bm_reset_deassert(struct reset_controller_dev *rcdev,
+				unsigned long id)
+{
+	struct bm_reset_data *data = container_of(rcdev,
+						     struct bm_reset_data,
+						     rcdev);
+	int bank = id / BITS_PER_REG;
+	int offset = id % BITS_PER_REG;
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&data->lock, flags);
+
+	reg = readl(data->membase + (bank * 4));
+	writel(reg | BIT(offset), data->membase + (bank * 4));
+
+	spin_unlock_irqrestore(&data->lock, flags);
+
+	return 0;
+}
+
+static const struct reset_control_ops bm_reset_ops = {
+	.assert		= bm_reset_assert,
+	.deassert	= bm_reset_deassert,
+};
+
+static const struct of_device_id bm_reset_dt_ids[] = {
+	 { .compatible = "cvitek,clk-reset", },
+	 { /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, bm_reset_dt_ids);
+
+static int bm_reset_probe(struct platform_device *pdev)
+{
+	struct bm_reset_data *data;
+	struct resource *res;
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	data->membase = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(data->membase))
+		return PTR_ERR(data->membase);
+
+	spin_lock_init(&data->lock);
+
+	data->rcdev.owner = THIS_MODULE;
+	data->rcdev.nr_resets = (resource_size(res)>>2) * 32;
+	pr_info("clk reset: nr_reset=%d resource_size=%lld\n", data->rcdev.nr_resets, resource_size(res));
+	data->rcdev.ops = &bm_reset_ops;
+	data->rcdev.of_node = pdev->dev.of_node;
+
+	return devm_reset_controller_register(&pdev->dev, &data->rcdev);
+}
+
+static struct platform_driver bm_reset_driver = {
+	.probe	= bm_reset_probe,
+	.driver = {
+		.name		= "bm-clock-reset",
+		.of_match_table	= bm_reset_dt_ids,
+	},
+};
+
+static int __init bm_clk_reset_init(void)
+{
+	return platform_driver_register(&bm_reset_driver);
+}
+postcore_initcall(bm_clk_reset_init);
+
+MODULE_AUTHOR("Wei Huang<wei.huang01@bitmain.com>");
+MODULE_DESCRIPTION("Cvitek SoC Clock Reset Controoler Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/reset/reset-cvitek.c b/drivers/reset/reset-cvitek.c
new file mode 100644
index 000000000000..4b49f588c1d8
--- /dev/null
+++ b/drivers/reset/reset-cvitek.c
@@ -0,0 +1,128 @@
+/*
+ * CVITEK SoCs Reset Controller driver
+ *
+ * Copyright (c) 2019 CVITEK Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/reset-controller.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+
+#define BITS_PER_REG	32
+
+struct bm_reset_data {
+	spinlock_t			lock;
+	void __iomem			*membase;
+	struct reset_controller_dev	rcdev;
+};
+
+static int bm_reset_assert(struct reset_controller_dev *rcdev,
+			      unsigned long id)
+{
+	struct bm_reset_data *data = container_of(rcdev,
+						     struct bm_reset_data,
+						     rcdev);
+	int bank = id / BITS_PER_REG;
+	int offset = id % BITS_PER_REG;
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&data->lock, flags);
+	reg = readl(data->membase + (bank * 4));
+	writel(reg & ~BIT(offset), data->membase + (bank * 4));
+
+	spin_unlock_irqrestore(&data->lock, flags);
+
+	return 0;
+}
+
+static int bm_reset_deassert(struct reset_controller_dev *rcdev,
+				unsigned long id)
+{
+	struct bm_reset_data *data = container_of(rcdev,
+						     struct bm_reset_data,
+						     rcdev);
+	int bank = id / BITS_PER_REG;
+	int offset = id % BITS_PER_REG;
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&data->lock, flags);
+	reg = readl(data->membase + (bank * 4));
+	writel(reg | BIT(offset), data->membase + (bank * 4));
+	spin_unlock_irqrestore(&data->lock, flags);
+
+	return 0;
+}
+
+static const struct reset_control_ops bm_reset_ops = {
+	.assert		= bm_reset_assert,
+	.deassert	= bm_reset_deassert,
+};
+
+static const struct of_device_id bm_reset_dt_ids[] = {
+	 { .compatible = "cvitek,reset", },
+	 { /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, bm_reset_dt_ids);
+
+static int bm_reset_probe(struct platform_device *pdev)
+{
+	struct bm_reset_data *data;
+	int ret = 0;
+	struct resource *res;
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	data->membase = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(data->membase))
+		goto out_free_devm;
+	data->rcdev.nr_resets = resource_size(res) * 32;
+
+	spin_lock_init(&data->lock);
+
+	data->rcdev.owner = THIS_MODULE;
+	data->rcdev.ops = &bm_reset_ops;
+	data->rcdev.of_node = pdev->dev.of_node;
+
+	ret = devm_reset_controller_register(&pdev->dev, &data->rcdev);
+	if (!ret)
+		return 0;
+
+out_free_devm:
+	devm_kfree(&pdev->dev, data);
+	return ret;
+}
+
+static struct platform_driver bm_reset_driver = {
+	.probe	= bm_reset_probe,
+	.driver = {
+		.name		= "bm-reset",
+		.of_match_table	= bm_reset_dt_ids,
+	},
+};
+
+static int __init bm_reset_init(void)
+{
+	return platform_driver_register(&bm_reset_driver);
+}
+postcore_initcall(bm_reset_init);
+
+MODULE_AUTHOR("Wei Huang<wei.huang01@bitmain.com>");
+MODULE_DESCRIPTION("Cvitek SoC Reset Controoler Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/soc/Kconfig b/drivers/soc/Kconfig
index 425ab6f7e375..a556aa95f04b 100644
--- a/drivers/soc/Kconfig
+++ b/drivers/soc/Kconfig
@@ -23,5 +23,6 @@ source "drivers/soc/versatile/Kconfig"
 source "drivers/soc/xilinx/Kconfig"
 source "drivers/soc/zte/Kconfig"
 source "drivers/soc/kendryte/Kconfig"
+source "drivers/soc/cvitek/Kconfig"
 
 endmenu
diff --git a/drivers/soc/Makefile b/drivers/soc/Makefile
index 36452bed86ef..09a9d15e9b0f 100644
--- a/drivers/soc/Makefile
+++ b/drivers/soc/Makefile
@@ -29,3 +29,4 @@ obj-$(CONFIG_PLAT_VERSATILE)	+= versatile/
 obj-y				+= xilinx/
 obj-$(CONFIG_ARCH_ZX)		+= zte/
 obj-$(CONFIG_SOC_KENDRYTE)	+= kendryte/
+obj-$(CONFIG_ARCH_CVITEK)   += cvitek/
diff --git a/drivers/soc/cvitek/Kconfig b/drivers/soc/cvitek/Kconfig
new file mode 100644
index 000000000000..b9c128724f83
--- /dev/null
+++ b/drivers/soc/cvitek/Kconfig
@@ -0,0 +1,33 @@
+#
+# CVITEK SoC drivers
+#
+menu "CVITEK SoC drivers"
+
+config CV1835_SYSDMA_REMAP
+	bool "CVITEK SoC sysdma remap driver"
+	depends on ARCH_CVITEK
+	help
+	  Enables driver for sysdma remap on CV1835 SoC.
+	  If someone need to use sysDMA of CV1835, they
+	  need to set src select value of related devices
+	  in this top register.
+
+config CVI_WIFI_PIN
+	bool "CVITEK SoC wifi specific pin definition"
+	depends on ARCH_CVITEK
+	help
+	  Enables driver for wifi specify pin on CviTek SoC.
+	  Enable this configuration to enable API to get
+	  GPIO number to do certain action, ex. power on
+	  or wakeup pin.
+
+config CVI_BT_PIN
+	bool "CVITEK SoC BT specific pin definition"
+	depends on ARCH_CVITEK
+	help
+	  Enables driver for BT specify pin on CviTek SoC.
+	  Enable this configuration to enable API to get
+	  GPIO number to do certain action, ex. power on
+	  or wakeup pin.
+
+endmenu
diff --git a/drivers/soc/cvitek/Makefile b/drivers/soc/cvitek/Makefile
new file mode 100644
index 000000000000..0f7fd8c47622
--- /dev/null
+++ b/drivers/soc/cvitek/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_CV1835_SYSDMA_REMAP)	+= sysdma/cv1835_dma_remap.o
+obj-$(CONFIG_CVI_WIFI_PIN)	+= wifi_pin/cvi_wifi_pin.o
+obj-$(CONFIG_CVI_BT_PIN)	+= bt_pin/cvi_bt_pin.o
\ No newline at end of file
diff --git a/drivers/soc/cvitek/bt_pin/cvi_bt_pin.c b/drivers/soc/cvitek/bt_pin/cvi_bt_pin.c
new file mode 100644
index 000000000000..8ab1e18281a2
--- /dev/null
+++ b/drivers/soc/cvitek/bt_pin/cvi_bt_pin.c
@@ -0,0 +1,77 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * CVITEK Bluetooth pin definition driver
+ *
+ * Copyright 2020 CVITEK Inc.
+ *
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+
+struct cvi_bt_pin_dev {
+	struct device *dev;
+	unsigned int power_gpio;
+};
+
+static struct cvi_bt_pin_dev *bt_dev;
+
+int cvi_get_bt_pwr_on_gpio(void)
+{
+	if (bt_dev) {
+		if (bt_dev->power_gpio > 0)
+			return bt_dev->power_gpio;
+
+		pr_err("Bluetooth power pin is not available, plz check dts\n");
+		return 0;
+	}
+
+	pr_err("Bluetooth power pin is not available, plz check bt_pin node in dts\n");
+	return 0;
+}
+EXPORT_SYMBOL_GPL(cvi_get_bt_pwr_on_gpio);
+
+static int cvi_bt_pin_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+
+	dev_dbg(&pdev->dev, "%s, dev name=%s\n", __func__, dev_name(&pdev->dev));
+
+	bt_dev = devm_kzalloc(&pdev->dev, sizeof(*bt_dev), GFP_KERNEL);
+	if (!bt_dev)
+		return -ENOMEM;
+
+	if (np)
+		bt_dev->power_gpio = of_get_named_gpio(np, "poweron-gpio", 0);
+
+	return 0;
+}
+
+static const struct of_device_id cvi_bt_pin_id_match[] = {
+	{
+		.compatible = "cvitek,bt-pin",
+	},
+	{},
+};
+
+static struct platform_driver cvi_bt_pin_driver = {
+	.driver = {
+		.name = "cvi_bt_pin",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(cvi_bt_pin_id_match),
+	},
+	.probe = cvi_bt_pin_probe,
+};
+
+static int __init cvi_bt_pin_init(void)
+{
+	return platform_driver_register(&cvi_bt_pin_driver);
+}
+
+late_initcall(cvi_bt_pin_init);
diff --git a/drivers/soc/cvitek/sysdma/cv1835_dma_remap.c b/drivers/soc/cvitek/sysdma/cv1835_dma_remap.c
new file mode 100644
index 000000000000..9bc0cb8c1e24
--- /dev/null
+++ b/drivers/soc/cvitek/sysdma/cv1835_dma_remap.c
@@ -0,0 +1,135 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/delay.h>
+
+#define UPDATE_REMAP	(1 << 31)
+void __iomem *remap_subsys_base;
+u32 ch_remap[8] = {0};
+
+struct cvi_sysdma_remap_dev {
+	void __iomem *subsys_base;
+	struct device *dev;
+};
+
+static int cv1835_sysdma_remap_probe(struct platform_device *pdev)
+{
+	struct cvi_sysdma_remap_dev *dev;
+	struct resource *res;
+	u32 val;
+
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dev->subsys_base = devm_ioremap_resource(&pdev->dev, res);
+	remap_subsys_base = dev->subsys_base;
+
+	if (IS_ERR(dev->subsys_base))
+		return PTR_ERR(dev->subsys_base);
+	dev->dev = &pdev->dev;
+
+	device_property_read_u32_array(&pdev->dev, "ch-remap", ch_remap, 8);
+
+	val = UPDATE_REMAP
+		| (ch_remap[0])
+		| (ch_remap[1] << 8)
+		| (ch_remap[2] << 16)
+		| (ch_remap[3] << 24);
+
+	writel(val, dev->subsys_base);
+
+	val = UPDATE_REMAP
+		| (ch_remap[4])
+		| (ch_remap[5] << 8)
+		| (ch_remap[6] << 16)
+		| (ch_remap[7] << 24);
+
+	writel(val, dev->subsys_base + 0x4);
+
+	if (device_property_present(&pdev->dev, "int_mux_base") &&
+		device_property_present(&pdev->dev, "int_mux")) {
+		u32 int_mux_base = 0;
+		u32 int_mux = 0;
+		void __iomem *int_mux_reg;
+
+		/* Set sysDMA interrupt receiver of IC after CV181X */
+		device_property_read_u32(&pdev->dev, "int_mux_base", &int_mux_base);
+		if (int_mux_base != 0x0) {
+			int_mux_reg = ioremap(int_mux_base, 0x4);
+			device_property_read_u32(&pdev->dev, "int_mux", &int_mux);
+			writel(int_mux, int_mux_reg);
+			iounmap(int_mux_reg);
+		}
+	}
+
+	return 0;
+}
+
+static const struct of_device_id cv1835_sysdma_remap_id_match[] = {
+	{
+		.compatible = "cvitek,sysdma_remap",
+	},
+	{},
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int dma_remap_suspend_late(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	return 0;
+}
+
+static int dma_remap_resume_early(struct device *dev)
+{
+	u32 val;
+
+	val = UPDATE_REMAP
+		| (ch_remap[0])
+		| (ch_remap[1] << 8)
+		| (ch_remap[2] << 16)
+		| (ch_remap[3] << 24);
+
+	writel(val, remap_subsys_base);
+
+	val = UPDATE_REMAP
+		| (ch_remap[4])
+		| (ch_remap[5] << 8)
+		| (ch_remap[6] << 16)
+		| (ch_remap[7] << 24);
+
+	writel(val, remap_subsys_base + 0x4);
+
+	return 0;
+}
+#else
+#define dma_remap_suspend_late	NULL
+#define dma_remap_resume_early	NULL
+#endif /* CONFIG_PM_SLEEP */
+
+static const struct dev_pm_ops dma_remap_pm_ops = {
+	SET_LATE_SYSTEM_SLEEP_PM_OPS(dma_remap_suspend_late, dma_remap_resume_early)
+};
+
+static struct platform_driver cv1835_sysdma_remap_driver = {
+	.driver = {
+		.name = "cv1835-sysdma-remap",
+		.owner = THIS_MODULE,
+		.pm = &dma_remap_pm_ops,
+		.of_match_table = of_match_ptr(cv1835_sysdma_remap_id_match),
+	},
+	.probe = cv1835_sysdma_remap_probe,
+};
+
+static int __init cv1835_sysdma_remap_init(void)
+{
+	return platform_driver_register(&cv1835_sysdma_remap_driver);
+}
+
+arch_initcall(cv1835_sysdma_remap_init);
diff --git a/drivers/soc/cvitek/wifi_pin/cvi_wifi_pin.c b/drivers/soc/cvitek/wifi_pin/cvi_wifi_pin.c
new file mode 100644
index 000000000000..ae0ad8d42a46
--- /dev/null
+++ b/drivers/soc/cvitek/wifi_pin/cvi_wifi_pin.c
@@ -0,0 +1,96 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * CVITEK Wifi pin definition driver
+ *
+ * Copyright 2020 CVITEK Inc.
+ *
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+
+struct cvi_wifi_pin_dev {
+	struct device *dev;
+	int power_gpio;
+	int wakeup_gpio;
+};
+
+static struct cvi_wifi_pin_dev *wifi_dev;
+
+int cvi_get_wifi_pwr_on_gpio(void)
+{
+	if (wifi_dev) {
+		if (wifi_dev->power_gpio > 0)
+			return wifi_dev->power_gpio;
+
+		pr_err("Wifi power pin is not available, plz check dts\n");
+		return 0;
+	}
+
+	pr_err("Wifi power pin is not available, plz check wifi_pin node in dts\n");
+	return 0;
+}
+EXPORT_SYMBOL_GPL(cvi_get_wifi_pwr_on_gpio);
+
+int cvi_get_wifi_wakeup_gpio(void)
+{
+	if (wifi_dev) {
+		if (wifi_dev->wakeup_gpio > 0)
+			return wifi_dev->wakeup_gpio;
+
+		pr_err("Wifi wakeup pin is not available, plz check dts\n");
+		return 0;
+	}
+
+	pr_err("Wifi wakeup pin is not available, plz check wifi_pin node in dts\n");
+	return 0;
+}
+EXPORT_SYMBOL_GPL(cvi_get_wifi_wakeup_gpio);
+
+static int cvi_wifi_pin_probe(struct platform_device *pdev)
+{
+
+	struct device_node *np = pdev->dev.of_node;
+
+	dev_dbg(&pdev->dev, "%s, dev name=%s\n", __func__, dev_name(&pdev->dev));
+
+	wifi_dev = devm_kzalloc(&pdev->dev, sizeof(*wifi_dev), GFP_KERNEL);
+	if (!wifi_dev)
+		return -ENOMEM;
+
+	if (np) {
+		wifi_dev->power_gpio = of_get_named_gpio(np, "poweron-gpio", 0);
+		wifi_dev->wakeup_gpio = of_get_named_gpio(np, "wakeup-gpio", 0);
+	}
+
+	return 0;
+}
+
+static const struct of_device_id cvi_wifi_pin_id_match[] = {
+	{
+		.compatible = "cvitek,wifi-pin",
+	},
+	{},
+};
+
+static struct platform_driver cvi_wifi_pin_driver = {
+	.driver = {
+		.name = "cvi_wifi_pin",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(cvi_wifi_pin_id_match),
+	},
+	.probe = cvi_wifi_pin_probe,
+};
+
+static int __init cvi_wifi_pin_init(void)
+{
+	return platform_driver_register(&cvi_wifi_pin_driver);
+}
+
+late_initcall(cvi_wifi_pin_init);
diff --git a/drivers/tee/Makefile b/drivers/tee/Makefile
index 68da044afbfa..7f55226ee178 100644
--- a/drivers/tee/Makefile
+++ b/drivers/tee/Makefile
@@ -3,5 +3,6 @@ obj-$(CONFIG_TEE) += tee.o
 tee-objs += tee_core.o
 tee-objs += tee_shm.o
 tee-objs += tee_shm_pool.o
+obj-$(CONFIG_ARCH_CVITEK) += tee_cv_private.o
 obj-$(CONFIG_OPTEE) += optee/
 obj-$(CONFIG_AMDTEE) += amdtee/
diff --git a/drivers/tee/optee/core.c b/drivers/tee/optee/core.c
index 6ea80add7378..afc7028d13c6 100644
--- a/drivers/tee/optee/core.c
+++ b/drivers/tee/optee/core.c
@@ -536,7 +536,11 @@ optee_config_shm_memremap(optee_invoke_fn *invoke_fn, void **memremaped_shm)
 }
 
 /* Simple wrapper functions to be able to use a function pointer */
+#ifdef CONFIG_ARCH_CVITEK
+void optee_smccc_smc(unsigned long a0, unsigned long a1,
+#else
 static void optee_smccc_smc(unsigned long a0, unsigned long a1,
+#endif
 			    unsigned long a2, unsigned long a3,
 			    unsigned long a4, unsigned long a5,
 			    unsigned long a6, unsigned long a7,
@@ -544,6 +548,9 @@ static void optee_smccc_smc(unsigned long a0, unsigned long a1,
 {
 	arm_smccc_smc(a0, a1, a2, a3, a4, a5, a6, a7, res);
 }
+#ifdef CONFIG_ARCH_CVITEK
+EXPORT_SYMBOL(optee_smccc_smc);
+#endif
 
 static void optee_smccc_hvc(unsigned long a0, unsigned long a1,
 			    unsigned long a2, unsigned long a3,
diff --git a/drivers/tee/tee_core.c b/drivers/tee/tee_core.c
index 9cc4a7b63b0d..9bebebcb91e5 100644
--- a/drivers/tee/tee_core.c
+++ b/drivers/tee/tee_core.c
@@ -16,6 +16,7 @@
 #include <crypto/hash.h>
 #include <crypto/sha.h>
 #include "tee_private.h"
+#include "tee_cv_private.h"
 
 #define TEE_NUM_DEVICES	32
 
@@ -980,6 +981,8 @@ static DEVICE_ATTR_RO(implementation_id);
 
 static struct attribute *tee_dev_attrs[] = {
 	&dev_attr_implementation_id.attr,
+	&dev_attr_aimodel_keyfile_path.attr,
+	&dev_attr_cv_debug.attr,
 	NULL
 };
 
@@ -1257,11 +1260,14 @@ static int __init tee_init(void)
 	class_destroy(tee_class);
 	tee_class = NULL;
 
+	tee_cv_init();
+
 	return rc;
 }
 
 static void __exit tee_exit(void)
 {
+	tee_cv_exit();
 	bus_unregister(&tee_bus_type);
 	unregister_chrdev_region(tee_devt, TEE_NUM_DEVICES);
 	class_destroy(tee_class);
diff --git a/drivers/tee/tee_cv_private.c b/drivers/tee/tee_cv_private.c
new file mode 100644
index 000000000000..c9907b63472c
--- /dev/null
+++ b/drivers/tee/tee_cv_private.c
@@ -0,0 +1,629 @@
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/buffer_head.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/ioctl.h>
+#include <linux/kdev_t.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/sizes.h>
+#include <linux/slab.h>
+#include <linux/tee_drv.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+#include <linux/arm-smccc.h>
+#include <asm/cacheflush.h>
+#include <linux/kernel_read_file.h>
+#include <linux/uaccess.h>
+#include <linux/clk.h>
+
+#include "tee_cv_private.h"
+
+#define TEE_CV_DEBUG 0
+
+#ifdef CONFIG_ARM
+#define FLUSH_DCACHE __cpuc_flush_dcache_area
+#else
+#define FLUSH_DCACHE __flush_dcache_area
+#endif
+static struct clk *clk_efuse;
+
+static char aimodel_keyfile_path[PAGE_SIZE] = "/mnt/data/aimodel.keys";
+static char debug_info[PAGE_SIZE] = "(nothing)";
+
+#if TEE_CV_DEBUG
+/*
+ * /memreserve/	0x0000000138000000 0x0000000008000000; // TEE buffer 896MB ~ 1024MB (128MB)
+ */
+static phys_addr_t large_buf_phys = 0x0000000138000000;
+static const size_t large_buf_maxsize = 0x04000000;
+static size_t large_buf_size;
+static void *large_buf;
+#endif
+
+static int64_t plat_efuse_read_safe(uint32_t addr);
+static int plat_efuse_write_safe(uint32_t addr, uint32_t value);
+
+static inline void mmio_write_32(void __iomem *addr, uint32_t value)
+{
+	iowrite32(value, addr);
+}
+
+static inline void mmio_setbits_32(void __iomem *addr, uint32_t set)
+{
+	mmio_write_32(addr, ioread32(addr) | set);
+}
+
+static void do_smccc_smc(unsigned long a0, unsigned long a1, unsigned long a2,
+			 unsigned long a3, unsigned long a4, unsigned long a5,
+			 unsigned long a6, unsigned long a7,
+			 struct arm_smccc_res *res)
+{
+	int err;
+
+	err = clk_prepare_enable(clk_efuse);
+	if (err) {
+		pr_err("clk_efuse: clock failed to prepare+enable: %d\n", err);
+		return;
+	}
+	pr_info("do_smccc_smc: a=0x%lx 0x%lx 0x%lx\n", a0, a1, a2);
+	arm_smccc_smc(a0, a1, a2, a3, a4, a5, a6, a7, res);
+	pr_info("do_smccc_smc: r=0x%lx 0x%lx\n", res->a0, res->a1);
+	clk_disable_unprepare(clk_efuse);
+}
+
+int tee_cv_aimodel_keyfile_send(const char *path)
+{
+	int err = 0;
+	struct arm_smccc_res res = { 0 };
+
+	void *key_buf = 0;
+	void *key_cont = 0;
+	phys_addr_t key_cont_phy = 0;
+	size_t key_size = 0;
+
+	pr_info("aimodel_keyfile_path=%s\n", path);
+	err = kernel_read_file_from_path(aimodel_keyfile_path, 0, &key_buf,
+					  TEE_TPU_MAX_KEYFILE_SIZE, 
+					  &key_size, READING_FIRMWARE);
+	if (err < 0)
+		return err;
+
+	// Copy to contiguous physical memory
+	key_cont = kzalloc(key_size, GFP_KERNEL);
+	if (!key_cont) {
+		vfree(key_buf);
+		return -ENOMEM;
+	}
+
+	memcpy(key_cont, key_buf, key_size);
+	vfree(key_buf);
+
+	key_cont_phy = virt_to_phys(key_cont);
+	FLUSH_DCACHE(key_cont, key_size);
+
+	pr_info("key_size=%zu %pa |%16ph|\n", key_size, &key_cont_phy,
+		key_cont);
+	do_smccc_smc(OPTEE_SMC_CALL_CV_TPU_SEND_KEYS, key_cont_phy, key_size, 0,
+		     0, 0, 0, 0, &res);
+	kfree(key_cont);
+
+	return res.a0;
+}
+EXPORT_SYMBOL(tee_cv_aimodel_keyfile_send);
+
+/*
+ * Flush cmd_phys and weight_phys before calling
+ */
+int tee_cv_aimodel_load(phys_addr_t cmd_phys, size_t cmd_size,
+			phys_addr_t weight_phys, size_t weight_size,
+			phys_addr_t neuron_phys, bool decrypt_cmd,
+			bool decrypt_weight, struct arm_smccc_res *res)
+{
+	uint32_t flag = 0;
+
+	pr_info("%s(): cmd_phys=0x%llx cmd_size=%zu weight_phys=0x%llx weight_size=%zu neuron_phys=0x%llx\n",
+		__func__, cmd_phys, cmd_size, weight_phys, weight_size,
+		neuron_phys);
+
+	if (decrypt_cmd)
+		flag |= CV_DECRYPT_CMD;
+
+	if (decrypt_weight)
+		flag |= CV_DECRYPT_WEIGHT;
+
+	tee_cv_aimodel_keyfile_send(aimodel_keyfile_path);
+	do_smccc_smc(OPTEE_SMC_CALL_CV_TPU_LOAD_MODEL, cmd_phys, cmd_size,
+		     weight_phys, weight_size, neuron_phys, flag, 0, res);
+
+	return res->a0;
+}
+EXPORT_SYMBOL(tee_cv_aimodel_load);
+
+int tee_cv_aimodel_run(phys_addr_t dmabuf_phys, phys_addr_t gaddr_base2,
+		       phys_addr_t gaddr_base3, phys_addr_t gaddr_base4,
+		       phys_addr_t gaddr_base5, phys_addr_t gaddr_base6,
+		       phys_addr_t gaddr_base7, struct arm_smccc_res *res)
+{
+	pr_info("%s():\n", __func__);
+	do_smccc_smc(OPTEE_SMC_CALL_CV_TPU_RUN, dmabuf_phys, gaddr_base2,
+		     gaddr_base3, gaddr_base4, gaddr_base5, gaddr_base6, gaddr_base7, res);
+
+	return res->a0;
+}
+EXPORT_SYMBOL(tee_cv_aimodel_run);
+
+int tee_cv_aimodel_wait(uint64_t arg, struct arm_smccc_res *res)
+{
+	pr_info("%s():\n", __func__);
+	do_smccc_smc(OPTEE_SMC_CALL_CV_TPU_WAIT, arg, 0, 0, 0, 0, 0, 0, res);
+
+	return res->a0;
+}
+EXPORT_SYMBOL(tee_cv_aimodel_wait);
+
+int tee_cv_aimodel_set_prot_range(phys_addr_t addr, uint32_t size, struct arm_smccc_res *res)
+{
+	pr_info("%s(): addr=0x%llx size=0x%x\n", __func__, addr, size);
+
+	do_smccc_smc(OPTEE_SMC_CALL_CV_TPU_SET_PROT_RANGE, addr, size, 0, 0, 0, 0, 0, res);
+
+	return res->a0;
+}
+EXPORT_SYMBOL(tee_cv_aimodel_set_prot_range);
+
+int tee_cv_aimodel_clear_prot_range(phys_addr_t addr, uint32_t size, struct arm_smccc_res *res)
+{
+	pr_info("%s(): addr=0x%llx size=0x%x\n", __func__, addr, size);
+
+	do_smccc_smc(OPTEE_SMC_CALL_CV_TPU_CLEAR_PROT_RANGE, addr, size, 0, 0, 0, 0, 0, res);
+
+	return res->a0;
+}
+EXPORT_SYMBOL(tee_cv_aimodel_clear_prot_range);
+
+static ssize_t aimodel_keyfile_path_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "%s\n", aimodel_keyfile_path);
+}
+
+static ssize_t aimodel_keyfile_path_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	char *p = 0;
+
+	strlcpy(aimodel_keyfile_path, buf, PAGE_SIZE - 1);
+	p = strpbrk(aimodel_keyfile_path, "\n\r");
+	if (p)
+		*p = '\0';
+
+	tee_cv_aimodel_keyfile_send(aimodel_keyfile_path);
+
+	return count;
+}
+
+#if TEE_CV_DEBUG
+static int read_file(char *path, void *buf, size_t *size)
+{
+	int err = 0;
+	void *vbuf;
+	loff_t read_size = 0;
+
+	err = kernel_read_file_from_path(path, &vbuf, &read_size,
+					 large_buf_size, READING_FIRMWARE);
+	if (err < 0)
+		return err;
+
+	if (read_size <= *size)
+		*size = read_size;
+
+	memcpy(buf, vbuf, *size);
+	vfree(vbuf);
+
+	return err;
+}
+
+static void tpu_load_debug(void)
+{
+	void *cmd, *weight;
+	size_t cmd_size, weight_size;
+	struct arm_smccc_res res = { 0 };
+
+	pr_info("tpu_load_debug:\n");
+
+	large_buf = memremap(large_buf_phys, large_buf_maxsize, MEMREMAP_WB);
+	if (!large_buf) {
+		pr_err("[%s] memremap fail.\n", __func__);
+		return;
+	}
+	large_buf_size = large_buf_maxsize;
+
+	cmd = large_buf;
+	cmd_size = large_buf_size;
+	read_file("/mnt/data/cmd.bin.enc", cmd, &cmd_size);
+	pr_info("cmd=%p(%lu) |%32ph|\n", cmd, cmd_size, cmd);
+
+	large_buf += roundup(cmd_size, 16);
+	large_buf_size -= roundup(cmd_size, 16);
+
+	weight = large_buf;
+	weight_size = large_buf_size;
+	read_file("/mnt/data/weight.bin.enc", weight, &weight_size);
+	pr_info("weight=%p(%lu) |%32ph|\n", weight, weight_size, weight);
+
+	FLUSH_DCACHE(cmd, cmd_size);
+	FLUSH_DCACHE(weight, weight_size);
+
+	tee_cv_aimodel_load(virt_to_phys(cmd), cmd_size, virt_to_phys(weight),
+			    weight_size, virt_to_phys(weight), &res);
+}
+
+static void tpu_set_prot_debug(void)
+{
+	phys_addr_t cmd, weight;
+	size_t cmd_size, weight_size;
+	struct arm_smccc_res res = { 0 };
+
+	pr_info("%s()\n", __func__);
+
+	cmd = large_buf_phys;
+	cmd_size = 0x1000;
+	weight = cmd + roundup(cmd_size, 16);
+	weight_size = 0x1400000;
+
+	tee_cv_aimodel_set_prot_range(weight, weight_size, &res);
+}
+
+static void tpu_clear_prot_debug(void)
+{
+	phys_addr_t cmd, weight;
+	size_t cmd_size, weight_size;
+	struct arm_smccc_res res = { 0 };
+
+	pr_info("%s()\n", __func__);
+
+	cmd = large_buf_phys;
+	cmd_size = 0x1000;
+	weight = cmd + roundup(cmd_size, 16);
+	weight_size = 0x2000;
+
+	tee_cv_aimodel_clear_prot_range(weight, weight_size, &res);
+}
+
+#else /* TEE_CV_DEBUG */
+static void tpu_load_debug(void)
+{
+}
+
+static void tpu_clear_prot_debug(void)
+{
+}
+
+static void tpu_set_prot_debug(void)
+{
+}
+#endif /* TEE_CV_DEBUG */
+
+static ssize_t cv_debug_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "%s\n", debug_info);
+}
+
+static ssize_t cv_debug_store(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	char *p = 0;
+	struct arm_smccc_res res = { 0 };
+	phys_addr_t debug_info_phy = 0;
+
+	memset(debug_info, 0, sizeof(debug_info));
+	memcpy(debug_info, buf, count);
+	debug_info[sizeof(debug_info) - 1] = '\0';
+	p = strpbrk(debug_info, "\n\r");
+	if (p)
+		*p = '\0';
+
+	pr_info("cv_debug_info=0x%09llx(%zu) |%16ph|\n", debug_info_phy,
+		sizeof(debug_info), debug_info);
+
+	if (strncmp("tpu_load", debug_info, sizeof(debug_info)) == 0) {
+		tpu_load_debug();
+	} else if (strncmp("tpu_set_prot", debug_info, sizeof(debug_info)) == 0) {
+		tpu_set_prot_debug();
+	} else if (strncmp("tpu_clear_prot", debug_info, sizeof(debug_info)) == 0) {
+		tpu_clear_prot_debug();
+	} else if (strncmp("console_on", debug_info, sizeof(debug_info)) == 0) {
+		pr_info("Enable BL32 console output\n");
+		do_smccc_smc(OPTEE_SMC_CALL_CV_DEBUG, 0x7F000001, 2, 0, 0, 0, 0, 0, &res);
+	} else {
+		debug_info_phy = virt_to_phys(debug_info);
+		FLUSH_DCACHE(debug_info, sizeof(debug_info));
+
+		do_smccc_smc(OPTEE_SMC_CALL_CV_DEBUG, 0x1F000000,
+			     debug_info_phy, sizeof(debug_info), 0, 0, 0, 0,
+			     &res);
+	}
+
+	return count;
+}
+
+/*
+ * /sys/devices/virtual/tee/tee0/aimodel_keyfile_path
+ * /sys/devices/virtual/tee/tee0/cv_debug
+ */
+DEVICE_ATTR_RW(aimodel_keyfile_path);
+DEVICE_ATTR_RW(cv_debug);
+
+#define EFUSE_BASE (0x03000000 + 0x00050000)
+#define EFUSE_REG_BANK_SIZE 0x1000
+#define EFUSE_SIZE 0x100
+
+#define EFUSE_SHADOW_REG (efuse_base + 0x100)
+#define EFUSE_MODE (efuse_base + 0x0)
+#define EFUSE_ADR (efuse_base + 0x4)
+#define EFUSE_DIR_CMD (efuse_base + 0x8)
+#define EFUSE_RD_DATA (efuse_base + 0xC)
+#define EFUSE_STATUS (efuse_base + 0x10)
+#define EFUSE_ONE_WAY (efuse_base + 0x14)
+
+#define BIT_AREAD (1 << 0)
+#define BIT_MREAD (1 << 1)
+#define BIT_PRG (1 << 2)
+#define BIT_PWR_DN (1 << 3)
+#define BIT_CMD (1 << 4)
+#define BIT_BUSY (1 << 0)
+#define CMD_REFRESH (0x30)
+
+enum EFUSE_READ_TYPE { AREAD, MREAD };
+
+static void __iomem *efuse_base;
+
+int tee_cv_init(void)
+{
+	pr_info("%s\n", __func__);
+
+	clk_efuse = clk_get_sys(NULL, "clk_efuse");
+	if (IS_ERR(clk_efuse)) {
+		pr_err("clk_efuse: clock not found %ld\n", PTR_ERR(clk_efuse));
+		return PTR_ERR(clk_efuse);
+	}
+
+	efuse_base = ioremap(EFUSE_BASE, EFUSE_REG_BANK_SIZE);
+
+	return 0;
+}
+
+void tee_cv_exit(void)
+{
+	iounmap(efuse_base);
+}
+
+int tee_cv_efuse_read(uint32_t addr, size_t size, void *buf)
+{
+	long ret = -1;
+	struct arm_smccc_res res = { 0 };
+
+	void *efuse_buf;
+	phys_addr_t efuse_buf_phys;
+
+	size_t i;
+	uint32_t v;
+
+	if (addr % 4 || size % 4 || !size)
+		return -EFAULT;
+
+	efuse_buf = kzalloc(size, GFP_KERNEL);
+	if (!efuse_buf)
+		return -ENOMEM;
+
+	FLUSH_DCACHE(efuse_buf, size);
+	efuse_buf_phys = virt_to_phys(efuse_buf);
+
+	pr_debug("%s(): 0x%x(%zu) to %p(0x%llx)\n", __func__, addr, size,
+		 efuse_buf, efuse_buf_phys);
+	do_smccc_smc(OPTEE_SMC_CALL_CV_EFUSE_READ, addr, size, efuse_buf_phys,
+		     0, 0, 0, 0, &res);
+	ret = (typeof(ret))res.a0;
+	pr_debug("%s(): ret=0x%lx\n", __func__, ret);
+
+	if (ret >= 0)
+		memcpy(buf, efuse_buf, min((typeof(res.a0))size, res.a0));
+
+	kfree(efuse_buf);
+
+	if (ret < 0) {
+		for (i = 0; i < size && (addr + i) < EFUSE_SIZE; i += 4) {
+			v = plat_efuse_read_safe(addr + i);
+			memcpy(buf + i, &v, sizeof(v));
+		}
+
+		return i;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(tee_cv_efuse_read);
+
+int tee_cv_efuse_write(uint32_t addr, uint32_t value)
+{
+	long ret = -1;
+	struct arm_smccc_res res = { 0 };
+
+	pr_debug("%s(): 0x%4x=0x%08x\n", __func__, addr, value);
+	do_smccc_smc(OPTEE_SMC_CALL_CV_EFUSE_WRITE, addr, value, 0, 0, 0, 0, 0,
+		     &res);
+
+	ret = (typeof(ret))res.a0;
+	if (ret < 0)
+		return plat_efuse_write_safe(addr, value);
+
+	return ret;
+}
+EXPORT_SYMBOL(tee_cv_efuse_write);
+
+static int64_t plat_efuse_read_safe(uint32_t addr)
+{
+	int err;
+	uint32_t v;
+
+	if (addr >= EFUSE_SIZE)
+		return -EFAULT;
+
+	if (addr % 4 != 0)
+		return -EFAULT;
+
+	err = clk_prepare_enable(clk_efuse);
+	if (err) {
+		pr_err("clk_efuse: clock failed to prepare+enable: %d\n", err);
+		return -EIO;
+	}
+
+	v = ioread32(EFUSE_SHADOW_REG + addr);
+	clk_disable_unprepare(clk_efuse);
+	return v;
+}
+
+static void efuse_wait_for_ready(void)
+{
+	while (ioread32(EFUSE_STATUS) & BIT_BUSY)
+		;
+}
+
+static void efuse_power_on(uint32_t on)
+{
+	if (on)
+		mmio_setbits_32(EFUSE_MODE, BIT_CMD);
+	else
+		mmio_setbits_32(EFUSE_MODE, BIT_PWR_DN | BIT_CMD);
+}
+
+static void efuse_refresh(void)
+{
+	mmio_write_32(EFUSE_MODE, CMD_REFRESH);
+}
+
+static void efuse_prog_bit(uint32_t word_addr, uint32_t bit_addr,
+			   uint32_t high_row)
+{
+	uint32_t phy_addr;
+
+	// word_addr: virtual addr, take "lower 6-bits" from 7-bits (0-127)
+	// bit_addr: virtual addr, 5-bits (0-31)
+
+	// composite physical addr[11:0] = [11:7]bit_addr + [6:0]word_addr
+	phy_addr =
+		((bit_addr & 0x1F) << 7) | ((word_addr & 0x3F) << 1) | high_row;
+
+	efuse_wait_for_ready();
+
+	// send efuse program cmd
+	mmio_write_32(EFUSE_ADR, phy_addr);
+	mmio_write_32(EFUSE_MODE, BIT_PRG | BIT_CMD);
+}
+
+static uint32_t efuse_read_word(uint32_t phy_word_addr,
+				enum EFUSE_READ_TYPE type)
+{
+	// power on efuse macro
+	efuse_power_on(1);
+
+	efuse_wait_for_ready();
+
+	mmio_write_32(EFUSE_ADR, phy_word_addr);
+
+	if (type == AREAD) // array read
+		mmio_write_32(EFUSE_MODE, BIT_AREAD | BIT_CMD);
+	else if (type == MREAD) // margin read
+		mmio_write_32(EFUSE_MODE, BIT_MREAD | BIT_CMD);
+	else
+		pr_err("EFUSE: Unsupported read type!");
+
+	efuse_wait_for_ready();
+	return ioread32(EFUSE_RD_DATA);
+}
+
+static int plat_bm_efuse_write(uint32_t vir_word_addr, uint32_t val)
+{
+	uint32_t i, j, row_val, zero_bit;
+	uint32_t new_value;
+	int err_cnt = 0;
+
+	for (j = 0; j < 2; j++) {
+		pr_debug("EFUSE: Program physical word addr #%d\n",
+			 (vir_word_addr << 1) | j);
+
+		// array read by word address
+		row_val = efuse_read_word((vir_word_addr << 1) | j,
+					  AREAD); // read low word of word_addr
+		zero_bit = val & (~row_val); // only program zero bit
+
+		// program row which bit is zero
+		for (i = 0; i < 32; i++) {
+			if ((zero_bit >> i) & 1)
+				efuse_prog_bit(vir_word_addr, i, j);
+		}
+
+		// check by margin read
+		new_value = efuse_read_word((vir_word_addr << 1) | j, MREAD);
+		pr_debug("%s(): val=0x%x new_value=0x%x\n", __func__, val,
+			 new_value);
+		if ((val & new_value) != val) {
+			err_cnt += 1;
+			pr_err("EFUSE: Program bits check failed (%d)!\n",
+			       err_cnt);
+		}
+	}
+
+	efuse_refresh();
+
+	return err_cnt >= 2 ? -EIO : 0;
+}
+
+static void plat_bm_efuse_init(void)
+{
+	// power on efuse macro
+	efuse_power_on(1);
+
+	// send refresh cmd to reload all eFuse values to shadow registers
+	efuse_refresh();
+
+	// efuse macro will be auto powered off after refresh cmd, so don't
+	// need to turn it off manually
+}
+
+static int plat_efuse_write_safe(uint32_t addr, uint32_t value)
+{
+	int ret;
+
+	pr_debug("%s(): 0x%x = 0x%x\n", __func__, addr, value);
+
+	if (addr >= EFUSE_SIZE)
+		return -EFAULT;
+
+	if (addr % 4 != 0)
+		return -EFAULT;
+
+	ret = clk_prepare_enable(clk_efuse);
+	if (ret) {
+		pr_err("clk_efuse: clock failed to prepare+enable: %d\n", ret);
+		return -EIO;
+	}
+
+	ret = plat_bm_efuse_write(addr / 4, value);
+	pr_debug("%s(): ret=%d\n", __func__, ret);
+	plat_bm_efuse_init();
+	efuse_wait_for_ready();
+
+	clk_disable_unprepare(clk_efuse);
+
+	return ret;
+}
diff --git a/drivers/tee/tee_cv_private.h b/drivers/tee/tee_cv_private.h
new file mode 100644
index 000000000000..099cfdacaadd
--- /dev/null
+++ b/drivers/tee/tee_cv_private.h
@@ -0,0 +1,87 @@
+
+#ifndef TEE_CV_PRIVATE_H
+#define TEE_CV_PRIVATE_H
+
+#include <linux/arm-smccc.h>
+
+#define TEE_TPU_MAX_KEYFILE_SIZE 0x100000
+
+extern struct device_attribute dev_attr_aimodel_keyfile_path;
+extern struct device_attribute dev_attr_cv_debug;
+
+enum {
+	CV_DECRYPT_CMD = 1 << 0,
+	CV_DECRYPT_WEIGHT = 1 << 1
+};
+
+/*
+ * Cvitek's private SMC call
+ */
+#define OPTEE_SMC_FUNID_CV_DEBUG 0x01
+
+#define OPTEE_SMC_FUNID_CV_TPU_SEND_KEYS 0x02
+#define OPTEE_SMC_FUNID_CV_TPU_LOAD_MODEL 0x03
+#define OPTEE_SMC_FUNID_CV_TPU_RUN 0x04
+#define OPTEE_SMC_FUNID_CV_TPU_WAIT 0x05
+#define OPTEE_SMC_FUNID_CV_TPU_SET_PROT_RANGE 0x08
+#define OPTEE_SMC_FUNID_CV_TPU_CLEAR_PROT_RANGE 0x09
+
+#define OPTEE_SMC_FUNID_CV_EFUSE_READ 0x06
+#define OPTEE_SMC_FUNID_CV_EFUSE_WRITE 0x07
+
+#define OPTEE_SMC_CALL_CV_DEBUG                                                \
+	ARM_SMCCC_CALL_VAL(ARM_SMCCC_STD_CALL, ARM_SMCCC_SMC_32,               \
+			   ARM_SMCCC_OWNER_OEM, OPTEE_SMC_FUNID_CV_DEBUG)
+
+#define OPTEE_SMC_CALL_CV_TPU_SEND_KEYS                                        \
+	ARM_SMCCC_CALL_VAL(ARM_SMCCC_STD_CALL, ARM_SMCCC_SMC_32,               \
+			   ARM_SMCCC_OWNER_OEM,                                \
+			   OPTEE_SMC_FUNID_CV_TPU_SEND_KEYS)
+
+#define OPTEE_SMC_CALL_CV_TPU_LOAD_MODEL                                       \
+	ARM_SMCCC_CALL_VAL(ARM_SMCCC_STD_CALL, ARM_SMCCC_SMC_32,               \
+			   ARM_SMCCC_OWNER_OEM,                                \
+			   OPTEE_SMC_FUNID_CV_TPU_LOAD_MODEL)
+
+#define OPTEE_SMC_CALL_CV_TPU_RUN                                              \
+	ARM_SMCCC_CALL_VAL(ARM_SMCCC_STD_CALL, ARM_SMCCC_SMC_32,               \
+			   ARM_SMCCC_OWNER_OEM, OPTEE_SMC_FUNID_CV_TPU_RUN)
+
+#define OPTEE_SMC_CALL_CV_TPU_WAIT                                             \
+	ARM_SMCCC_CALL_VAL(ARM_SMCCC_STD_CALL, ARM_SMCCC_SMC_32,               \
+			   ARM_SMCCC_OWNER_OEM, OPTEE_SMC_FUNID_CV_TPU_WAIT)
+
+#define OPTEE_SMC_CALL_CV_TPU_SET_PROT_RANGE                                   \
+	ARM_SMCCC_CALL_VAL(ARM_SMCCC_STD_CALL, ARM_SMCCC_SMC_32,               \
+			   ARM_SMCCC_OWNER_OEM, OPTEE_SMC_FUNID_CV_TPU_SET_PROT_RANGE)
+
+#define OPTEE_SMC_CALL_CV_TPU_CLEAR_PROT_RANGE                                 \
+	ARM_SMCCC_CALL_VAL(ARM_SMCCC_STD_CALL, ARM_SMCCC_SMC_32,               \
+			   ARM_SMCCC_OWNER_OEM, OPTEE_SMC_FUNID_CV_TPU_CLEAR_PROT_RANGE)
+
+#define OPTEE_SMC_CALL_CV_EFUSE_READ                                           \
+	ARM_SMCCC_CALL_VAL(ARM_SMCCC_STD_CALL, ARM_SMCCC_SMC_32,               \
+			   ARM_SMCCC_OWNER_OEM, OPTEE_SMC_FUNID_CV_EFUSE_READ)
+
+#define OPTEE_SMC_CALL_CV_EFUSE_WRITE                                          \
+	ARM_SMCCC_CALL_VAL(ARM_SMCCC_STD_CALL, ARM_SMCCC_SMC_32,               \
+			   ARM_SMCCC_OWNER_OEM, OPTEE_SMC_FUNID_CV_EFUSE_WRITE)
+
+int tee_cv_aimodel_load(phys_addr_t cmd_phys, size_t cmd_size,
+			phys_addr_t weight_phys, size_t weight_size,
+			phys_addr_t neuron_phys, bool decrypt_cmd,
+			bool decrypt_weight, struct arm_smccc_res *res);
+int tee_cv_aimodel_run(phys_addr_t dmabuf_phys, phys_addr_t gaddr_base2,
+		       phys_addr_t gaddr_base3, phys_addr_t gaddr_base4,
+		       phys_addr_t gaddr_base5, phys_addr_t gaddr_base6,
+		       phys_addr_t gaddr_base7, struct arm_smccc_res *res);
+int tee_cv_aimodel_wait(uint64_t arg, struct arm_smccc_res *res);
+int tee_cv_aimodel_set_prot_range(phys_addr_t addr, uint32_t size, struct arm_smccc_res *res);
+int tee_cv_aimodel_clear_prot_range(phys_addr_t addr, uint32_t size, struct arm_smccc_res *res);
+int tee_cv_init(void);
+void tee_cv_exit(void);
+
+int tee_cv_efuse_read(uint32_t addr, size_t size, void *buf);
+int tee_cv_efuse_write(uint32_t addr, uint32_t value);
+
+#endif /* TEE_CV_PRIVATE_H */
diff --git a/drivers/thermal/Kconfig b/drivers/thermal/Kconfig
index 7edc8dc6bbab..f91f06d425fd 100644
--- a/drivers/thermal/Kconfig
+++ b/drivers/thermal/Kconfig
@@ -412,6 +412,50 @@ config MTK_THERMAL
 	  Enable this option if you want to have support for thermal management
 	  controller present in Mediatek SoCs
 
+config CV1835_THERMAL
+	tristate "Temperature sensor driver for CVITEK CV1835"
+	depends on ARCH_CV183X || COMPILE_TEST
+	default y
+	help
+	  Select this driver for CVITEK CV1835 temperature sensor monitoring
+	  system temperature measurements and alerts.
+	  This driver is used for monitoring the temperature sensor and handles
+	  the alert trip point interrupts and notifies the thermal framework with
+	  the trip point and temperature details of the zone.
+
+config CV182X_THERMAL
+	tristate "Temperature sensor driver for CVITEK CV182X"
+	depends on ARCH_CV182X || COMPILE_TEST
+	default y
+	help
+	  Select this driver for CVITEK CV182X temperature sensor monitoring
+	  system temperature measurements and alerts.
+	  This driver is used for monitoring the temperature sensor and handles
+	  the alert trip point interrupts and notifies the thermal framework with
+	  the trip point and temperature details of the zone.
+
+config CV181X_THERMAL
+	tristate "Temperature sensor driver for CVITEK CV181X"
+	depends on ARCH_CV181X || COMPILE_TEST
+	default y
+	help
+	  Select this driver for CVITEK CV181X temperature sensor monitoring
+	  system temperature measurements and alerts.
+	  This driver is used for monitoring the temperature sensor and handles
+	  the alert trip point interrupts and notifies the thermal framework with
+	  the trip point and temperature details of the zone.
+
+config CV180X_THERMAL
+	tristate "Temperature sensor driver for CVITEK CV180X"
+	depends on ARCH_CV180X || COMPILE_TEST
+	default y
+	help
+	  Select this driver for CVITEK CV180X temperature sensor monitoring
+	  system temperature measurements and alerts.
+	  This driver is used for monitoring the temperature sensor and handles
+	  the alert trip point interrupts and notifies the thermal framework with
+	  the trip point and temperature details of the zone.
+
 config AMLOGIC_THERMAL
 	tristate "Amlogic Thermal Support"
 	default ARCH_MESON
diff --git a/drivers/thermal/Makefile b/drivers/thermal/Makefile
index b64dd50a6629..e35f57cc2000 100644
--- a/drivers/thermal/Makefile
+++ b/drivers/thermal/Makefile
@@ -62,3 +62,7 @@ obj-$(CONFIG_UNIPHIER_THERMAL)	+= uniphier_thermal.o
 obj-$(CONFIG_AMLOGIC_THERMAL)     += amlogic_thermal.o
 obj-$(CONFIG_SPRD_THERMAL)	+= sprd_thermal.o
 obj-$(CONFIG_KHADAS_MCU_FAN_THERMAL)	+= khadas_mcu_fan.o
+obj-$(CONFIG_CV181X_THERMAL)	+= cv181x_thermal.o
+obj-$(CONFIG_CV180X_THERMAL)	+= cv180x_thermal.o
+obj-$(CONFIG_CV1835_THERMAL)    += cv1835_thermal.o
+obj-$(CONFIG_CV182X_THERMAL)    += cv182x_thermal.o
diff --git a/drivers/thermal/cv180x_thermal.c b/drivers/thermal/cv180x_thermal.c
new file mode 100644
index 000000000000..6a45d9c06ff6
--- /dev/null
+++ b/drivers/thermal/cv180x_thermal.c
@@ -0,0 +1,486 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * CVITEK Mars thermal driver
+ *
+ * Copyright 2021 CVITEK Inc.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/thermal.h>
+#include <linux/types.h>
+
+#define tempsen_top_tempsen_version				0x0
+#define tempsen_top_tempsen_ctrl				0x4
+#define tempsen_top_tempsen_status				0x8
+#define tempsen_top_tempsen_set					0xc
+#define tempsen_top_tempsen_intr_en				0x10
+#define tempsen_top_tempsen_intr_clr				0x14
+#define tempsen_top_tempsen_intr_sta				0x18
+#define tempsen_top_tempsen_intr_raw				0x1c
+#define tempsen_top_tempsen_ch0_result				0x20
+#define tempsen_top_tempsen_ch1_result				0x24
+#define tempsen_top_tempsen_ch2_result				0x28
+#define tempsen_top_tempsen_ch3_result				0x2c
+#define tempsen_top_tempsen_ddr_temp_ctrl			0x30
+#define tempsen_top_tempsen_ddr_temp_th				0x34
+#define tempsen_top_tempsen_ch0_temp_th				0x40
+#define tempsen_top_tempsen_ch1_temp_th				0x44
+#define tempsen_top_tempsen_ch2_temp_th				0x48
+#define tempsen_top_tempsen_ch3_temp_th				0x4c
+#define tempsen_top_Overheat_th					0x60
+#define tempsen_top_tempsen_auto_cycle				0x64
+#define tempsen_top_tempsen_auto_prediv				0x64
+#define tempsen_top_tempsen_overheat_ctrl			0x68
+#define tempsen_top_tempsen_overheat_countdown			0x6c
+#define tempsen_top_tempsen_ch0_temp_th_cnt			0x70
+#define tempsen_top_tempsen_ch1_temp_th_cnt			0x74
+#define tempsen_top_tempsen_ch2_temp_th_cnt			0x78
+#define tempsen_top_tempsen_ch3_temp_th_cnt			0x7c
+#define tempsen_top_tempsen_test_force				0x80
+#define tempsen_top_reg_ip_version				0x0
+#define tempsen_top_reg_ip_version_OFFSET			0
+#define tempsen_top_reg_ip_version_MASK				0xffffffff
+#define tempsen_top_reg_tempsen_en				0x4
+#define tempsen_top_reg_tempsen_en_OFFSET			0
+#define tempsen_top_reg_tempsen_en_MASK				0x1
+#define tempsen_top_reg_tempsen_sel				0x4
+#define tempsen_top_reg_tempsen_sel_OFFSET			4
+#define tempsen_top_reg_tempsen_sel_MASK			0xf0
+#define tempsen_top_reg_tempsen_ovhl_cnt_to_irq			0x4
+#define tempsen_top_reg_tempsen_ovhl_cnt_to_irq_OFFSET		16
+#define tempsen_top_reg_tempsen_ovhl_cnt_to_irq_MASK		0xff0000
+#define tempsen_top_reg_tempsen_udll_cnt_to_irq			0x4
+#define tempsen_top_reg_tempsen_udll_cnt_to_irq_OFFSET		24
+#define tempsen_top_reg_tempsen_udll_cnt_to_irq_MASK		0xff000000
+#define tempsen_top_sta_tempsen_busy				0x8
+#define tempsen_top_sta_tempsen_busy_OFFSET			0
+#define tempsen_top_sta_tempsen_busy_MASK			0x1
+#define tempsen_top_reg_tempsen_bgen				0xc
+#define tempsen_top_reg_tempsen_bgen_OFFSET			0
+#define tempsen_top_reg_tempsen_bgen_MASK			0x1
+#define tempsen_top_reg_tempsen_chopen				0xc
+#define tempsen_top_reg_tempsen_chopen_OFFSET			1
+#define tempsen_top_reg_tempsen_chopen_MASK			0x2
+#define tempsen_top_reg_tempsen_choppol				0xc
+#define tempsen_top_reg_tempsen_choppol_OFFSET			2
+#define tempsen_top_reg_tempsen_choppol_MASK			0x4
+#define tempsen_top_reg_tempsen_clkpol				0xc
+#define tempsen_top_reg_tempsen_clkpol_OFFSET			3
+#define tempsen_top_reg_tempsen_clkpol_MASK			0x8
+#define tempsen_top_reg_tempsen_chopsel				0xc
+#define tempsen_top_reg_tempsen_chopsel_OFFSET			4
+#define tempsen_top_reg_tempsen_chopsel_MASK			0x30
+#define tempsen_top_reg_tempsen_accsel				0xc
+#define tempsen_top_reg_tempsen_accsel_OFFSET			6
+#define tempsen_top_reg_tempsen_accsel_MASK			0xc0
+#define tempsen_top_reg_tempsen_cyc_clkdiv			0xc
+#define tempsen_top_reg_tempsen_cyc_clkdiv_OFFSET		8
+#define tempsen_top_reg_tempsen_cyc_clkdiv_MASK			0xff00
+#define tempsen_top_reg_tempsen_tsel				0xc
+#define tempsen_top_reg_tempsen_tsel_OFFSET			16
+#define tempsen_top_reg_tempsen_tsel_MASK			0x30000
+#define tempsen_top_sta_tempsen_intr_en				0x10
+#define tempsen_top_sta_tempsen_intr_en_OFFSET			0
+#define tempsen_top_sta_tempsen_intr_en_MASK			0xffffffff
+#define tempsen_top_sta_tempsen_intr_clr			0x14
+#define tempsen_top_sta_tempsen_intr_clr_OFFSET			0
+#define tempsen_top_sta_tempsen_intr_clr_MASK			0xffffffff
+#define tempsen_top_sta_tempsen_intr_sta			0x18
+#define tempsen_top_sta_tempsen_intr_sta_OFFSET			0
+#define tempsen_top_sta_tempsen_intr_sta_MASK			0xffffffff
+#define tempsen_top_sta_tempsen_intr_raw			0x1c
+#define tempsen_top_sta_tempsen_intr_raw_OFFSET			0
+#define tempsen_top_sta_tempsen_intr_raw_MASK			0xffffffff
+#define tempsen_top_sta_tempsen_ch0_result			0x20
+#define tempsen_top_sta_tempsen_ch0_result_OFFSET		0
+#define tempsen_top_sta_tempsen_ch0_result_MASK			0x1fff
+#define tempsen_top_sta_tempsen_ch0_max_result			0x20
+#define tempsen_top_sta_tempsen_ch0_max_result_OFFSET		16
+#define tempsen_top_sta_tempsen_ch0_max_result_MASK		0x1fff0000
+#define tempsen_top_clr_tempsen_ch0_max_result			0x20
+#define tempsen_top_clr_tempsen_ch0_max_result_OFFSET		31
+#define tempsen_top_clr_tempsen_ch0_max_result_MASK		0x80000000
+#define tempsen_top_sta_tempsen_ch1_result			0x24
+#define tempsen_top_sta_tempsen_ch1_result_OFFSET		0
+#define tempsen_top_sta_tempsen_ch1_result_MASK			0x1fff
+#define tempsen_top_sta_tempsen_ch1_max_result			0x24
+#define tempsen_top_sta_tempsen_ch1_max_result_OFFSET		16
+#define tempsen_top_sta_tempsen_ch1_max_result_MASK		0x1fff0000
+#define tempsen_top_clr_tempsen_ch1_max_result			0x24
+#define tempsen_top_clr_tempsen_ch1_max_result_OFFSET		31
+#define tempsen_top_clr_tempsen_ch1_max_result_MASK		0x80000000
+#define tempsen_top_sta_tempsen_ch2_result			0x28
+#define tempsen_top_sta_tempsen_ch2_result_OFFSET		0
+#define tempsen_top_sta_tempsen_ch2_result_MASK			0x1fff
+#define tempsen_top_sta_tempsen_ch2_max_result			0x28
+#define tempsen_top_sta_tempsen_ch2_max_result_OFFSET		16
+#define tempsen_top_sta_tempsen_ch2_max_result_MASK		0x1fff0000
+#define tempsen_top_clr_tempsen_ch2_max_result			0x28
+#define tempsen_top_clr_tempsen_ch2_max_result_OFFSET		31
+#define tempsen_top_clr_tempsen_ch2_max_result_MASK		0x80000000
+#define tempsen_top_sta_tempsen_ch3_result			0x2c
+#define tempsen_top_sta_tempsen_ch3_result_OFFSET		0
+#define tempsen_top_sta_tempsen_ch3_result_MASK			0x1fff
+#define tempsen_top_sta_tempsen_ch3_max_result			0x2c
+#define tempsen_top_sta_tempsen_ch3_max_result_OFFSET		16
+#define tempsen_top_sta_tempsen_ch3_max_result_MASK		0x1fff0000
+#define tempsen_top_clr_tempsen_ch3_max_result			0x2c
+#define tempsen_top_clr_tempsen_ch3_max_result_OFFSET		31
+#define tempsen_top_clr_tempsen_ch3_max_result_MASK		0x80000000
+#define tempsen_top_reg_tempsen_ddr_out_en			0x30
+#define tempsen_top_reg_tempsen_ddr_out_en_OFFSET		0
+#define tempsen_top_reg_tempsen_ddr_out_en_MASK			0x1
+#define tempsen_top_reg_tempsen_ddr_ow_en			0x30
+#define tempsen_top_reg_tempsen_ddr_ow_en_OFFSET		1
+#define tempsen_top_reg_tempsen_ddr_ow_en_MASK			0x2
+#define tempsen_top_reg_tempsen_ddr_ow_val			0x30
+#define tempsen_top_reg_tempsen_ddr_ow_val_OFFSET		2
+#define tempsen_top_reg_tempsen_ddr_ow_val_MASK			0x4
+#define tempsen_top_sta_tempsen_ddr_high_temp_raw		0x30
+#define tempsen_top_sta_tempsen_ddr_high_temp_raw_OFFSET	8
+#define tempsen_top_sta_tempsen_ddr_high_temp_raw_MASK		0xf00
+#define tempsen_top_sta_tempsen_ddr_high_temp_o			0x30
+#define tempsen_top_sta_tempsen_ddr_high_temp_o_OFFSET		12
+#define tempsen_top_sta_tempsen_ddr_high_temp_o_MASK		0xf000
+#define tempsen_top_reg_tempsen_ddr_hi_th			0x34
+#define tempsen_top_reg_tempsen_ddr_hi_th_OFFSET		0
+#define tempsen_top_reg_tempsen_ddr_hi_th_MASK			0x1fff
+#define tempsen_top_reg_tempsen_ddr_lo_th			0x34
+#define tempsen_top_reg_tempsen_ddr_lo_th_OFFSET		16
+#define tempsen_top_reg_tempsen_ddr_lo_th_MASK			0x1fff0000
+#define tempsen_top_reg_tempsen_ch0_hi_th			0x40
+#define tempsen_top_reg_tempsen_ch0_hi_th_OFFSET		0
+#define tempsen_top_reg_tempsen_ch0_hi_th_MASK			0x1fff
+#define tempsen_top_reg_tempsen_ch0_lo_th			0x40
+#define tempsen_top_reg_tempsen_ch0_lo_th_OFFSET		16
+#define tempsen_top_reg_tempsen_ch0_lo_th_MASK			0x1fff0000
+#define tempsen_top_reg_tempsen_ch1_hi_th			0x44
+#define tempsen_top_reg_tempsen_ch1_hi_th_OFFSET		0
+#define tempsen_top_reg_tempsen_ch1_hi_th_MASK			0x1fff
+#define tempsen_top_reg_tempsen_ch1_lo_th			0x44
+#define tempsen_top_reg_tempsen_ch1_lo_th_OFFSET		16
+#define tempsen_top_reg_tempsen_ch1_lo_th_MASK			0x1fff0000
+#define tempsen_top_reg_tempsen_ch2_hi_th			0x48
+#define tempsen_top_reg_tempsen_ch2_hi_th_OFFSET		0
+#define tempsen_top_reg_tempsen_ch2_hi_th_MASK			0x1fff
+#define tempsen_top_reg_tempsen_ch2_lo_th			0x48
+#define tempsen_top_reg_tempsen_ch2_lo_th_OFFSET		16
+#define tempsen_top_reg_tempsen_ch2_lo_th_MASK			0x1fff0000
+#define tempsen_top_reg_tempsen_ch3_hi_th			0x4c
+#define tempsen_top_reg_tempsen_ch3_hi_th_OFFSET		0
+#define tempsen_top_reg_tempsen_ch3_hi_th_MASK			0x1fff
+#define tempsen_top_reg_tempsen_ch3_lo_th			0x4c
+#define tempsen_top_reg_tempsen_ch3_lo_th_OFFSET		16
+#define tempsen_top_reg_tempsen_ch3_lo_th_MASK			0x1fff0000
+#define tempsen_top_reg_tempsen_overheat_th			0x60
+#define tempsen_top_reg_tempsen_overheat_th_OFFSET		0
+#define tempsen_top_reg_tempsen_overheat_th_MASK		0x1fff
+#define tempsen_top_reg_tempsen_auto_cycle			0x64
+#define tempsen_top_reg_tempsen_auto_cycle_OFFSET		0
+#define tempsen_top_reg_tempsen_auto_cycle_MASK			0xffffff
+#define tempsen_top_reg_tempsen_auto_prediv			0x64
+#define tempsen_top_reg_tempsen_auto_prediv_OFFSET		24
+#define tempsen_top_reg_tempsen_auto_prediv_MASK		0xff000000
+#define tempsen_top_reg_tempsen_overheat_cycle			0x68
+#define tempsen_top_reg_tempsen_overheat_cycle_OFFSET		0
+#define tempsen_top_reg_tempsen_overheat_cycle_MASK		0x3fffffff
+#define tempsen_top_reg_overheat_reset_clr			0x68
+#define tempsen_top_reg_overheat_reset_clr_OFFSET		30
+#define tempsen_top_reg_overheat_reset_clr_MASK			0x40000000
+#define tempsen_top_reg_overheat_reset_en			0x68
+#define tempsen_top_reg_overheat_reset_en_OFFSET		31
+#define tempsen_top_reg_overheat_reset_en_MASK			0x80000000
+#define tempsen_top_sta_tempsen_overheat_countdown		0x6c
+#define tempsen_top_sta_tempsen_overheat_countdown_OFFSET	0
+#define tempsen_top_sta_tempsen_overheat_countdown_MASK		0x3fffffff
+#define tempsen_top_sta_overheat_reset				0x6c
+#define tempsen_top_sta_overheat_reset_OFFSET			31
+#define tempsen_top_sta_overheat_reset_MASK			0x80000000
+#define tempsen_top_sta_ch0_over_hi_temp_th_cnt			0x70
+#define tempsen_top_sta_ch0_over_hi_temp_th_cnt_OFFSET		0
+#define tempsen_top_sta_ch0_over_hi_temp_th_cnt_MASK		0xff
+#define tempsen_top_sta_ch0_under_lo_temp_th_cnt		0x70
+#define tempsen_top_sta_ch0_under_lo_temp_th_cnt_OFFSET		8
+#define tempsen_top_sta_ch0_under_lo_temp_th_cnt_MASK		0xff00
+#define tempsen_top_reg_ch0_temp_th_cnt_clr			0x70
+#define tempsen_top_reg_ch0_temp_th_cnt_clr_OFFSET		16
+#define tempsen_top_reg_ch0_temp_th_cnt_clr_MASK		0x10000
+#define tempsen_top_sta_ch1_over_hi_temp_th_cnt			0x74
+#define tempsen_top_sta_ch1_over_hi_temp_th_cnt_OFFSET		0
+#define tempsen_top_sta_ch1_over_hi_temp_th_cnt_MASK		0xff
+#define tempsen_top_sta_ch1_under_lo_temp_th_cnt		0x74
+#define tempsen_top_sta_ch1_under_lo_temp_th_cnt_OFFSET		8
+#define tempsen_top_sta_ch1_under_lo_temp_th_cnt_MASK		0xff00
+#define tempsen_top_reg_ch1_temp_th_cnt_clr			0x74
+#define tempsen_top_reg_ch1_temp_th_cnt_clr_OFFSET		16
+#define tempsen_top_reg_ch1_temp_th_cnt_clr_MASK		0x10000
+#define tempsen_top_sta_ch2_over_hi_temp_th_cnt			0x78
+#define tempsen_top_sta_ch2_over_hi_temp_th_cnt_OFFSET		0
+#define tempsen_top_sta_ch2_over_hi_temp_th_cnt_MASK		0xff
+#define tempsen_top_sta_ch2_under_lo_temp_th_cnt		0x78
+#define tempsen_top_sta_ch2_under_lo_temp_th_cnt_OFFSET		8
+#define tempsen_top_sta_ch2_under_lo_temp_th_cnt_MASK		0xff00
+#define tempsen_top_reg_ch2_temp_th_cnt_clr			0x78
+#define tempsen_top_reg_ch2_temp_th_cnt_clr_OFFSET		16
+#define tempsen_top_reg_ch2_temp_th_cnt_clr_MASK		0x10000
+#define tempsen_top_sta_ch3_over_hi_temp_th_cnt			0x7c
+#define tempsen_top_sta_ch3_over_hi_temp_th_cnt_OFFSET		0
+#define tempsen_top_sta_ch3_over_hi_temp_th_cnt_MASK		0xff
+#define tempsen_top_sta_ch3_under_lo_temp_th_cnt		0x7c
+#define tempsen_top_sta_ch3_under_lo_temp_th_cnt_OFFSET		8
+#define tempsen_top_sta_ch3_under_lo_temp_th_cnt_MASK		0xff00
+#define tempsen_top_reg_ch3_temp_th_cnt_clr			0x7c
+#define tempsen_top_reg_ch3_temp_th_cnt_clr_OFFSET		16
+#define tempsen_top_reg_ch3_temp_th_cnt_clr_MASK		0x10000
+#define tempsen_top_reg_tempsen_force_result			0x80
+#define tempsen_top_reg_tempsen_force_result_OFFSET		0
+#define tempsen_top_reg_tempsen_force_result_MASK		0x1fff
+#define tempsen_top_reg_tempsen_force_valid			0x80
+#define tempsen_top_reg_tempsen_force_valid_OFFSET		13
+#define tempsen_top_reg_tempsen_force_valid_MASK		0x2000
+#define tempsen_top_reg_tempsen_force_busy			0x80
+#define tempsen_top_reg_tempsen_force_busy_OFFSET		14
+#define tempsen_top_reg_tempsen_force_busy_MASK			0x4000
+#define tempsen_top_reg_tempsen_force_en			0x80
+#define tempsen_top_reg_tempsen_force_en_OFFSET			15
+#define tempsen_top_reg_tempsen_force_en_MASK			0x8000
+
+#define TEMPSEN_MASK(REG_NAME) tempsen_top_##REG_NAME##_MASK
+#define TEMPSEN_OFFSET(REG_NAME) tempsen_top_##REG_NAME##_OFFSET
+#define TEMPSEN_SET(BASE_ADDR, REG_NAME, VAL) \
+	clrsetbits(BASE_ADDR + tempsen_top_##REG_NAME, \
+	TEMPSEN_MASK(REG_NAME), (VAL) << TEMPSEN_OFFSET(REG_NAME))
+#define TEMPSEN_GET(BASE_ADDR, REG_NAME) \
+	((readl(BASE_ADDR + tempsen_top_##REG_NAME) & \
+	TEMPSEN_MASK(REG_NAME)) >> TEMPSEN_OFFSET(REG_NAME))
+
+static void __maybe_unused clrsetbits(void __iomem *reg, u32 clrval, u32 setval)
+{
+	u32 regval;
+
+	regval = readl(reg);
+	regval &= ~(clrval);
+	regval |= setval;
+	writel(regval, reg);
+}
+
+struct cv180x_thermal_zone {
+	unsigned int ch;
+	void __iomem *base;
+	struct cv180x_thermal *ct;
+};
+
+struct cv180x_thermal {
+	struct device *dev;
+	void __iomem *base;
+	struct clk *clk_tempsen;
+};
+
+static void cv180x_thermal_init(struct cv180x_thermal *ct)
+{
+	void __iomem *base = ct->base;
+	u32 regval;
+
+	/* clear all interrupt status */
+	regval = TEMPSEN_GET(base, sta_tempsen_intr_raw);
+	TEMPSEN_SET(base, sta_tempsen_intr_clr, regval);
+
+	/* clear max result */
+	TEMPSEN_SET(base, clr_tempsen_ch0_max_result, 1);
+	TEMPSEN_SET(base, clr_tempsen_ch1_max_result, 1);
+
+	/* set chop period to 3:1024T */
+	TEMPSEN_SET(base, reg_tempsen_chopsel, 0x3);
+
+	/* set acc period to 2:2048T*/
+	TEMPSEN_SET(base, reg_tempsen_accsel, 0x2);
+
+	/* set tempsen clock divider to 25M/(0x31+1)= 0.5M ,T=2us */
+	TEMPSEN_SET(base, reg_tempsen_cyc_clkdiv, 0x31);
+
+	/* set reg_tempsen_auto_cycle */
+	TEMPSEN_SET(base, reg_tempsen_auto_cycle, 0x100000);
+
+	/* set ddr hi/lo threshold */
+	TEMPSEN_SET(base, reg_tempsen_ddr_hi_th, 0x400); //85 C
+	TEMPSEN_SET(base, reg_tempsen_ddr_lo_th, 0x3E4); //75 C
+
+	/* enable ddr auto refresh rate ctrl signal output */
+	TEMPSEN_SET(base, reg_tempsen_ddr_out_en, 1);
+
+	/* enable tempsen channel */
+	TEMPSEN_SET(base, reg_tempsen_sel, 0x1);
+	TEMPSEN_SET(base, reg_tempsen_en, 1);
+}
+
+static void cv180x_thermal_uninit(struct cv180x_thermal *ct)
+{
+	void __iomem *base = ct->base;
+	u32 regval;
+
+	/* disable all tempsen channel */
+	TEMPSEN_SET(base, reg_tempsen_sel, 0);
+	TEMPSEN_SET(base, reg_tempsen_en, 0);
+
+	/* clear all interrupt status */
+	regval = TEMPSEN_GET(base, sta_tempsen_intr_raw);
+	TEMPSEN_SET(base, sta_tempsen_intr_clr, regval);
+}
+
+static int calc_temp(uint32_t result)
+{
+	return ((result * 1000) * 716 / 2048 - 273000);
+
+	/* Original calculation formula */
+	// return ((result * 1000) / 2048 * 716 - 273000);
+}
+
+static int cv180x_read_temp(void *data, int *temperature)
+{
+	struct cv180x_thermal_zone *ctz = data;
+	void __iomem *base = ctz->base;
+	unsigned int ch = ctz->ch;
+	u32 result;
+
+	/* read temperature */
+	switch (ch) {
+	case 0:
+		result = TEMPSEN_GET(base, sta_tempsen_ch0_result); break;
+	default:
+		result = 0;
+	}
+	*temperature = calc_temp(result);
+	pr_debug("ch%d temp = %d mC(0x%x)\n", ch, *temperature, result);
+
+	return 0;
+}
+
+static const struct thermal_zone_of_device_ops cv180x_thermal_ops = {
+	.get_temp = cv180x_read_temp,
+};
+
+static const struct of_device_id cv180x_thermal_of_match[] = {
+	{
+		.compatible = "cvitek,cv180x-thermal",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, cv180x_thermal_of_match);
+
+static int cv180x_thermal_probe(struct platform_device *pdev)
+{
+	struct cv180x_thermal *ct;
+	struct cv180x_thermal_zone *ctz;
+	struct resource *res;
+	struct thermal_zone_device *tz;
+	int i;
+
+	ct = devm_kzalloc(&pdev->dev, sizeof(*ct), GFP_KERNEL);
+	if (!ct)
+		return -ENOMEM;
+
+	ct->clk_tempsen = devm_clk_get(&pdev->dev, "clk_tempsen");
+	if (IS_ERR(ct->clk_tempsen)) {
+		dev_err(&pdev->dev, "failed to get clk_tempsen\n");
+		return PTR_ERR(ct->clk_tempsen);
+	}
+
+	/* enable clk_tempsen */
+	clk_prepare_enable(ct->clk_tempsen);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	ct->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(ct->base)) {
+		dev_err(&pdev->dev, "failed to map tempsen registers\n");
+		return PTR_ERR(ct->base);
+	}
+
+	ct->dev = &pdev->dev;
+
+	cv180x_thermal_init(ct);
+
+	platform_set_drvdata(pdev, ct);
+
+	for (i = 0; i < 1; i++) {
+		ctz = devm_kzalloc(&pdev->dev, sizeof(*ctz), GFP_KERNEL);
+		if (!ctz)
+			return -ENOMEM;
+
+		ctz->base = ct->base;
+		ctz->ct = ct;
+		ctz->ch = i;
+		tz = devm_thermal_zone_of_sensor_register(&pdev->dev, i, ctz,
+							  &cv180x_thermal_ops);
+		if (IS_ERR(tz)) {
+			dev_err(&pdev->dev, "failed to register thermal zone %d\n", i);
+			return PTR_ERR(tz);
+		}
+	}
+
+	return 0;
+}
+
+static int cv180x_thermal_remove(struct platform_device *pdev)
+{
+	struct cv180x_thermal *ct = platform_get_drvdata(pdev);
+
+	cv180x_thermal_uninit(ct);
+
+	clk_disable_unprepare(ct->clk_tempsen);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int cv180x_thermal_suspend(struct device *dev)
+{
+	struct cv180x_thermal *ct = dev_get_drvdata(dev);
+
+	cv180x_thermal_uninit(ct);
+
+	clk_disable_unprepare(ct->clk_tempsen);
+
+	return 0;
+}
+
+static int cv180x_thermal_resume(struct device *dev)
+{
+	struct cv180x_thermal *ct = dev_get_drvdata(dev);
+
+	/* enable clk_tempsen */
+	clk_prepare_enable(ct->clk_tempsen);
+
+	cv180x_thermal_init(ct);
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static SIMPLE_DEV_PM_OPS(cv180x_thermal_pm_ops,
+			 cv180x_thermal_suspend, cv180x_thermal_resume);
+
+static struct platform_driver cv180x_thermal_driver = {
+	.probe = cv180x_thermal_probe,
+	.remove = cv180x_thermal_remove,
+	.driver = {
+		.name = "cv180x-thermal",
+		.pm = &cv180x_thermal_pm_ops,
+		.of_match_table = cv180x_thermal_of_match,
+	},
+};
+
+module_platform_driver(cv180x_thermal_driver);
+
+MODULE_AUTHOR("fisher.cheng@cvitek.com");
+MODULE_DESCRIPTION("cv180x thermal driver");
+MODULE_LICENSE("GPL");
\ No newline at end of file
diff --git a/drivers/thermal/cv181x_thermal.c b/drivers/thermal/cv181x_thermal.c
new file mode 100644
index 000000000000..8959a47c142d
--- /dev/null
+++ b/drivers/thermal/cv181x_thermal.c
@@ -0,0 +1,483 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * CVITEK cv181x thermal driver
+ *
+ * Copyright 2021 CVITEK Inc.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/thermal.h>
+#include <linux/types.h>
+
+#define tempsen_top_tempsen_version				0x0
+#define tempsen_top_tempsen_ctrl				0x4
+#define tempsen_top_tempsen_status				0x8
+#define tempsen_top_tempsen_set					0xc
+#define tempsen_top_tempsen_intr_en				0x10
+#define tempsen_top_tempsen_intr_clr				0x14
+#define tempsen_top_tempsen_intr_sta				0x18
+#define tempsen_top_tempsen_intr_raw				0x1c
+#define tempsen_top_tempsen_ch0_result				0x20
+#define tempsen_top_tempsen_ch1_result				0x24
+#define tempsen_top_tempsen_ch2_result				0x28
+#define tempsen_top_tempsen_ch3_result				0x2c
+#define tempsen_top_tempsen_ddr_temp_ctrl			0x30
+#define tempsen_top_tempsen_ddr_temp_th				0x34
+#define tempsen_top_tempsen_ch0_temp_th				0x40
+#define tempsen_top_tempsen_ch1_temp_th				0x44
+#define tempsen_top_tempsen_ch2_temp_th				0x48
+#define tempsen_top_tempsen_ch3_temp_th				0x4c
+#define tempsen_top_Overheat_th					0x60
+#define tempsen_top_tempsen_auto_cycle				0x64
+#define tempsen_top_tempsen_auto_prediv				0x64
+#define tempsen_top_tempsen_overheat_ctrl			0x68
+#define tempsen_top_tempsen_overheat_countdown			0x6c
+#define tempsen_top_tempsen_ch0_temp_th_cnt			0x70
+#define tempsen_top_tempsen_ch1_temp_th_cnt			0x74
+#define tempsen_top_tempsen_ch2_temp_th_cnt			0x78
+#define tempsen_top_tempsen_ch3_temp_th_cnt			0x7c
+#define tempsen_top_tempsen_test_force				0x80
+#define tempsen_top_reg_ip_version				0x0
+#define tempsen_top_reg_ip_version_OFFSET			0
+#define tempsen_top_reg_ip_version_MASK				0xffffffff
+#define tempsen_top_reg_tempsen_en				0x4
+#define tempsen_top_reg_tempsen_en_OFFSET			0
+#define tempsen_top_reg_tempsen_en_MASK				0x1
+#define tempsen_top_reg_tempsen_sel				0x4
+#define tempsen_top_reg_tempsen_sel_OFFSET			4
+#define tempsen_top_reg_tempsen_sel_MASK			0xf0
+#define tempsen_top_reg_tempsen_ovhl_cnt_to_irq			0x4
+#define tempsen_top_reg_tempsen_ovhl_cnt_to_irq_OFFSET		16
+#define tempsen_top_reg_tempsen_ovhl_cnt_to_irq_MASK		0xff0000
+#define tempsen_top_reg_tempsen_udll_cnt_to_irq			0x4
+#define tempsen_top_reg_tempsen_udll_cnt_to_irq_OFFSET		24
+#define tempsen_top_reg_tempsen_udll_cnt_to_irq_MASK		0xff000000
+#define tempsen_top_sta_tempsen_busy				0x8
+#define tempsen_top_sta_tempsen_busy_OFFSET			0
+#define tempsen_top_sta_tempsen_busy_MASK			0x1
+#define tempsen_top_reg_tempsen_bgen				0xc
+#define tempsen_top_reg_tempsen_bgen_OFFSET			0
+#define tempsen_top_reg_tempsen_bgen_MASK			0x1
+#define tempsen_top_reg_tempsen_chopen				0xc
+#define tempsen_top_reg_tempsen_chopen_OFFSET			1
+#define tempsen_top_reg_tempsen_chopen_MASK			0x2
+#define tempsen_top_reg_tempsen_choppol				0xc
+#define tempsen_top_reg_tempsen_choppol_OFFSET			2
+#define tempsen_top_reg_tempsen_choppol_MASK			0x4
+#define tempsen_top_reg_tempsen_clkpol				0xc
+#define tempsen_top_reg_tempsen_clkpol_OFFSET			3
+#define tempsen_top_reg_tempsen_clkpol_MASK			0x8
+#define tempsen_top_reg_tempsen_chopsel				0xc
+#define tempsen_top_reg_tempsen_chopsel_OFFSET			4
+#define tempsen_top_reg_tempsen_chopsel_MASK			0x30
+#define tempsen_top_reg_tempsen_accsel				0xc
+#define tempsen_top_reg_tempsen_accsel_OFFSET			6
+#define tempsen_top_reg_tempsen_accsel_MASK			0xc0
+#define tempsen_top_reg_tempsen_cyc_clkdiv			0xc
+#define tempsen_top_reg_tempsen_cyc_clkdiv_OFFSET		8
+#define tempsen_top_reg_tempsen_cyc_clkdiv_MASK			0xff00
+#define tempsen_top_reg_tempsen_tsel				0xc
+#define tempsen_top_reg_tempsen_tsel_OFFSET			16
+#define tempsen_top_reg_tempsen_tsel_MASK			0x30000
+#define tempsen_top_sta_tempsen_intr_en				0x10
+#define tempsen_top_sta_tempsen_intr_en_OFFSET			0
+#define tempsen_top_sta_tempsen_intr_en_MASK			0xffffffff
+#define tempsen_top_sta_tempsen_intr_clr			0x14
+#define tempsen_top_sta_tempsen_intr_clr_OFFSET			0
+#define tempsen_top_sta_tempsen_intr_clr_MASK			0xffffffff
+#define tempsen_top_sta_tempsen_intr_sta			0x18
+#define tempsen_top_sta_tempsen_intr_sta_OFFSET			0
+#define tempsen_top_sta_tempsen_intr_sta_MASK			0xffffffff
+#define tempsen_top_sta_tempsen_intr_raw			0x1c
+#define tempsen_top_sta_tempsen_intr_raw_OFFSET			0
+#define tempsen_top_sta_tempsen_intr_raw_MASK			0xffffffff
+#define tempsen_top_sta_tempsen_ch0_result			0x20
+#define tempsen_top_sta_tempsen_ch0_result_OFFSET		0
+#define tempsen_top_sta_tempsen_ch0_result_MASK			0x1fff
+#define tempsen_top_sta_tempsen_ch0_max_result			0x20
+#define tempsen_top_sta_tempsen_ch0_max_result_OFFSET		16
+#define tempsen_top_sta_tempsen_ch0_max_result_MASK		0x1fff0000
+#define tempsen_top_clr_tempsen_ch0_max_result			0x20
+#define tempsen_top_clr_tempsen_ch0_max_result_OFFSET		31
+#define tempsen_top_clr_tempsen_ch0_max_result_MASK		0x80000000
+#define tempsen_top_sta_tempsen_ch1_result			0x24
+#define tempsen_top_sta_tempsen_ch1_result_OFFSET		0
+#define tempsen_top_sta_tempsen_ch1_result_MASK			0x1fff
+#define tempsen_top_sta_tempsen_ch1_max_result			0x24
+#define tempsen_top_sta_tempsen_ch1_max_result_OFFSET		16
+#define tempsen_top_sta_tempsen_ch1_max_result_MASK		0x1fff0000
+#define tempsen_top_clr_tempsen_ch1_max_result			0x24
+#define tempsen_top_clr_tempsen_ch1_max_result_OFFSET		31
+#define tempsen_top_clr_tempsen_ch1_max_result_MASK		0x80000000
+#define tempsen_top_sta_tempsen_ch2_result			0x28
+#define tempsen_top_sta_tempsen_ch2_result_OFFSET		0
+#define tempsen_top_sta_tempsen_ch2_result_MASK			0x1fff
+#define tempsen_top_sta_tempsen_ch2_max_result			0x28
+#define tempsen_top_sta_tempsen_ch2_max_result_OFFSET		16
+#define tempsen_top_sta_tempsen_ch2_max_result_MASK		0x1fff0000
+#define tempsen_top_clr_tempsen_ch2_max_result			0x28
+#define tempsen_top_clr_tempsen_ch2_max_result_OFFSET		31
+#define tempsen_top_clr_tempsen_ch2_max_result_MASK		0x80000000
+#define tempsen_top_sta_tempsen_ch3_result			0x2c
+#define tempsen_top_sta_tempsen_ch3_result_OFFSET		0
+#define tempsen_top_sta_tempsen_ch3_result_MASK			0x1fff
+#define tempsen_top_sta_tempsen_ch3_max_result			0x2c
+#define tempsen_top_sta_tempsen_ch3_max_result_OFFSET		16
+#define tempsen_top_sta_tempsen_ch3_max_result_MASK		0x1fff0000
+#define tempsen_top_clr_tempsen_ch3_max_result			0x2c
+#define tempsen_top_clr_tempsen_ch3_max_result_OFFSET		31
+#define tempsen_top_clr_tempsen_ch3_max_result_MASK		0x80000000
+#define tempsen_top_reg_tempsen_ddr_out_en			0x30
+#define tempsen_top_reg_tempsen_ddr_out_en_OFFSET		0
+#define tempsen_top_reg_tempsen_ddr_out_en_MASK			0x1
+#define tempsen_top_reg_tempsen_ddr_ow_en			0x30
+#define tempsen_top_reg_tempsen_ddr_ow_en_OFFSET		1
+#define tempsen_top_reg_tempsen_ddr_ow_en_MASK			0x2
+#define tempsen_top_reg_tempsen_ddr_ow_val			0x30
+#define tempsen_top_reg_tempsen_ddr_ow_val_OFFSET		2
+#define tempsen_top_reg_tempsen_ddr_ow_val_MASK			0x4
+#define tempsen_top_sta_tempsen_ddr_high_temp_raw		0x30
+#define tempsen_top_sta_tempsen_ddr_high_temp_raw_OFFSET	8
+#define tempsen_top_sta_tempsen_ddr_high_temp_raw_MASK		0xf00
+#define tempsen_top_sta_tempsen_ddr_high_temp_o			0x30
+#define tempsen_top_sta_tempsen_ddr_high_temp_o_OFFSET		12
+#define tempsen_top_sta_tempsen_ddr_high_temp_o_MASK		0xf000
+#define tempsen_top_reg_tempsen_ddr_hi_th			0x34
+#define tempsen_top_reg_tempsen_ddr_hi_th_OFFSET		0
+#define tempsen_top_reg_tempsen_ddr_hi_th_MASK			0x1fff
+#define tempsen_top_reg_tempsen_ddr_lo_th			0x34
+#define tempsen_top_reg_tempsen_ddr_lo_th_OFFSET		16
+#define tempsen_top_reg_tempsen_ddr_lo_th_MASK			0x1fff0000
+#define tempsen_top_reg_tempsen_ch0_hi_th			0x40
+#define tempsen_top_reg_tempsen_ch0_hi_th_OFFSET		0
+#define tempsen_top_reg_tempsen_ch0_hi_th_MASK			0x1fff
+#define tempsen_top_reg_tempsen_ch0_lo_th			0x40
+#define tempsen_top_reg_tempsen_ch0_lo_th_OFFSET		16
+#define tempsen_top_reg_tempsen_ch0_lo_th_MASK			0x1fff0000
+#define tempsen_top_reg_tempsen_ch1_hi_th			0x44
+#define tempsen_top_reg_tempsen_ch1_hi_th_OFFSET		0
+#define tempsen_top_reg_tempsen_ch1_hi_th_MASK			0x1fff
+#define tempsen_top_reg_tempsen_ch1_lo_th			0x44
+#define tempsen_top_reg_tempsen_ch1_lo_th_OFFSET		16
+#define tempsen_top_reg_tempsen_ch1_lo_th_MASK			0x1fff0000
+#define tempsen_top_reg_tempsen_ch2_hi_th			0x48
+#define tempsen_top_reg_tempsen_ch2_hi_th_OFFSET		0
+#define tempsen_top_reg_tempsen_ch2_hi_th_MASK			0x1fff
+#define tempsen_top_reg_tempsen_ch2_lo_th			0x48
+#define tempsen_top_reg_tempsen_ch2_lo_th_OFFSET		16
+#define tempsen_top_reg_tempsen_ch2_lo_th_MASK			0x1fff0000
+#define tempsen_top_reg_tempsen_ch3_hi_th			0x4c
+#define tempsen_top_reg_tempsen_ch3_hi_th_OFFSET		0
+#define tempsen_top_reg_tempsen_ch3_hi_th_MASK			0x1fff
+#define tempsen_top_reg_tempsen_ch3_lo_th			0x4c
+#define tempsen_top_reg_tempsen_ch3_lo_th_OFFSET		16
+#define tempsen_top_reg_tempsen_ch3_lo_th_MASK			0x1fff0000
+#define tempsen_top_reg_tempsen_overheat_th			0x60
+#define tempsen_top_reg_tempsen_overheat_th_OFFSET		0
+#define tempsen_top_reg_tempsen_overheat_th_MASK		0x1fff
+#define tempsen_top_reg_tempsen_auto_cycle			0x64
+#define tempsen_top_reg_tempsen_auto_cycle_OFFSET		0
+#define tempsen_top_reg_tempsen_auto_cycle_MASK			0xffffff
+#define tempsen_top_reg_tempsen_auto_prediv			0x64
+#define tempsen_top_reg_tempsen_auto_prediv_OFFSET		24
+#define tempsen_top_reg_tempsen_auto_prediv_MASK		0xff000000
+#define tempsen_top_reg_tempsen_overheat_cycle			0x68
+#define tempsen_top_reg_tempsen_overheat_cycle_OFFSET		0
+#define tempsen_top_reg_tempsen_overheat_cycle_MASK		0x3fffffff
+#define tempsen_top_reg_overheat_reset_clr			0x68
+#define tempsen_top_reg_overheat_reset_clr_OFFSET		30
+#define tempsen_top_reg_overheat_reset_clr_MASK			0x40000000
+#define tempsen_top_reg_overheat_reset_en			0x68
+#define tempsen_top_reg_overheat_reset_en_OFFSET		31
+#define tempsen_top_reg_overheat_reset_en_MASK			0x80000000
+#define tempsen_top_sta_tempsen_overheat_countdown		0x6c
+#define tempsen_top_sta_tempsen_overheat_countdown_OFFSET	0
+#define tempsen_top_sta_tempsen_overheat_countdown_MASK		0x3fffffff
+#define tempsen_top_sta_overheat_reset				0x6c
+#define tempsen_top_sta_overheat_reset_OFFSET			31
+#define tempsen_top_sta_overheat_reset_MASK			0x80000000
+#define tempsen_top_sta_ch0_over_hi_temp_th_cnt			0x70
+#define tempsen_top_sta_ch0_over_hi_temp_th_cnt_OFFSET		0
+#define tempsen_top_sta_ch0_over_hi_temp_th_cnt_MASK		0xff
+#define tempsen_top_sta_ch0_under_lo_temp_th_cnt		0x70
+#define tempsen_top_sta_ch0_under_lo_temp_th_cnt_OFFSET		8
+#define tempsen_top_sta_ch0_under_lo_temp_th_cnt_MASK		0xff00
+#define tempsen_top_reg_ch0_temp_th_cnt_clr			0x70
+#define tempsen_top_reg_ch0_temp_th_cnt_clr_OFFSET		16
+#define tempsen_top_reg_ch0_temp_th_cnt_clr_MASK		0x10000
+#define tempsen_top_sta_ch1_over_hi_temp_th_cnt			0x74
+#define tempsen_top_sta_ch1_over_hi_temp_th_cnt_OFFSET		0
+#define tempsen_top_sta_ch1_over_hi_temp_th_cnt_MASK		0xff
+#define tempsen_top_sta_ch1_under_lo_temp_th_cnt		0x74
+#define tempsen_top_sta_ch1_under_lo_temp_th_cnt_OFFSET		8
+#define tempsen_top_sta_ch1_under_lo_temp_th_cnt_MASK		0xff00
+#define tempsen_top_reg_ch1_temp_th_cnt_clr			0x74
+#define tempsen_top_reg_ch1_temp_th_cnt_clr_OFFSET		16
+#define tempsen_top_reg_ch1_temp_th_cnt_clr_MASK		0x10000
+#define tempsen_top_sta_ch2_over_hi_temp_th_cnt			0x78
+#define tempsen_top_sta_ch2_over_hi_temp_th_cnt_OFFSET		0
+#define tempsen_top_sta_ch2_over_hi_temp_th_cnt_MASK		0xff
+#define tempsen_top_sta_ch2_under_lo_temp_th_cnt		0x78
+#define tempsen_top_sta_ch2_under_lo_temp_th_cnt_OFFSET		8
+#define tempsen_top_sta_ch2_under_lo_temp_th_cnt_MASK		0xff00
+#define tempsen_top_reg_ch2_temp_th_cnt_clr			0x78
+#define tempsen_top_reg_ch2_temp_th_cnt_clr_OFFSET		16
+#define tempsen_top_reg_ch2_temp_th_cnt_clr_MASK		0x10000
+#define tempsen_top_sta_ch3_over_hi_temp_th_cnt			0x7c
+#define tempsen_top_sta_ch3_over_hi_temp_th_cnt_OFFSET		0
+#define tempsen_top_sta_ch3_over_hi_temp_th_cnt_MASK		0xff
+#define tempsen_top_sta_ch3_under_lo_temp_th_cnt		0x7c
+#define tempsen_top_sta_ch3_under_lo_temp_th_cnt_OFFSET		8
+#define tempsen_top_sta_ch3_under_lo_temp_th_cnt_MASK		0xff00
+#define tempsen_top_reg_ch3_temp_th_cnt_clr			0x7c
+#define tempsen_top_reg_ch3_temp_th_cnt_clr_OFFSET		16
+#define tempsen_top_reg_ch3_temp_th_cnt_clr_MASK		0x10000
+#define tempsen_top_reg_tempsen_force_result			0x80
+#define tempsen_top_reg_tempsen_force_result_OFFSET		0
+#define tempsen_top_reg_tempsen_force_result_MASK		0x1fff
+#define tempsen_top_reg_tempsen_force_valid			0x80
+#define tempsen_top_reg_tempsen_force_valid_OFFSET		13
+#define tempsen_top_reg_tempsen_force_valid_MASK		0x2000
+#define tempsen_top_reg_tempsen_force_busy			0x80
+#define tempsen_top_reg_tempsen_force_busy_OFFSET		14
+#define tempsen_top_reg_tempsen_force_busy_MASK			0x4000
+#define tempsen_top_reg_tempsen_force_en			0x80
+#define tempsen_top_reg_tempsen_force_en_OFFSET			15
+#define tempsen_top_reg_tempsen_force_en_MASK			0x8000
+
+#define TEMPSEN_MASK(REG_NAME) tempsen_top_##REG_NAME##_MASK
+#define TEMPSEN_OFFSET(REG_NAME) tempsen_top_##REG_NAME##_OFFSET
+#define TEMPSEN_SET(BASE_ADDR, REG_NAME, VAL) \
+	clrsetbits(BASE_ADDR + tempsen_top_##REG_NAME, \
+	TEMPSEN_MASK(REG_NAME), (VAL) << TEMPSEN_OFFSET(REG_NAME))
+#define TEMPSEN_GET(BASE_ADDR, REG_NAME) \
+	((readl(BASE_ADDR + tempsen_top_##REG_NAME) & \
+	TEMPSEN_MASK(REG_NAME)) >> TEMPSEN_OFFSET(REG_NAME))
+
+static void __maybe_unused clrsetbits(void __iomem *reg, u32 clrval, u32 setval)
+{
+	u32 regval;
+
+	regval = readl(reg);
+	regval &= ~(clrval);
+	regval |= setval;
+	writel(regval, reg);
+}
+
+struct cv181x_thermal_zone {
+	unsigned int ch;
+	void __iomem *base;
+	struct cv181x_thermal *ct;
+};
+
+struct cv181x_thermal {
+	struct device *dev;
+	void __iomem *base;
+	struct clk *clk_tempsen;
+};
+
+static void cv181x_thermal_init(struct cv181x_thermal *ct)
+{
+	void __iomem *base = ct->base;
+	u32 regval;
+
+	/* clear all interrupt status */
+	regval = TEMPSEN_GET(base, sta_tempsen_intr_raw);
+	TEMPSEN_SET(base, sta_tempsen_intr_clr, regval);
+
+	/* clear max result */
+	TEMPSEN_SET(base, clr_tempsen_ch0_max_result, 1);
+	TEMPSEN_SET(base, clr_tempsen_ch1_max_result, 1);
+
+	/* set chop period to 3:1024T */
+	TEMPSEN_SET(base, reg_tempsen_chopsel, 0x3);
+
+	/* set acc period to 2:2048T*/
+	TEMPSEN_SET(base, reg_tempsen_accsel, 0x2);
+
+	/* set tempsen clock divider to 25M/(0x31+1)= 0.5M ,T=2us */
+	TEMPSEN_SET(base, reg_tempsen_cyc_clkdiv, 0x31);
+
+	/* set reg_tempsen_auto_cycle */
+	TEMPSEN_SET(base, reg_tempsen_auto_cycle, 0x100000);
+
+	/* set ddr hi/lo threshold */
+	TEMPSEN_SET(base, reg_tempsen_ddr_hi_th, 0x400); //85 C
+	TEMPSEN_SET(base, reg_tempsen_ddr_lo_th, 0x3E4); //75 C
+
+	/* enable ddr auto refresh rate ctrl signal output */
+	TEMPSEN_SET(base, reg_tempsen_ddr_out_en, 1);
+
+	/* enable tempsen channel */
+	TEMPSEN_SET(base, reg_tempsen_sel, 0x1);
+	TEMPSEN_SET(base, reg_tempsen_en, 1);
+}
+
+static void cv181x_thermal_uninit(struct cv181x_thermal *ct)
+{
+	void __iomem *base = ct->base;
+	u32 regval;
+
+	/* disable all tempsen channel */
+	TEMPSEN_SET(base, reg_tempsen_sel, 0);
+	TEMPSEN_SET(base, reg_tempsen_en, 0);
+
+	/* clear all interrupt status */
+	regval = TEMPSEN_GET(base, sta_tempsen_intr_raw);
+	TEMPSEN_SET(base, sta_tempsen_intr_clr, regval);
+}
+
+static int calc_temp(uint32_t result)
+{
+	return ((result * 1000) * 716 / 2048 - 273000);
+
+	/* Original calculation formula */
+	// return ((result * 1000) / 2048 * 716 - 273000);
+}
+
+static int cv181x_read_temp(void *data, int *temperature)
+{
+	struct cv181x_thermal_zone *ctz = data;
+	void __iomem *base = ctz->base;
+	unsigned int ch = ctz->ch;
+	u32 result;
+
+	/* read temperature */
+	switch (ch) {
+	case 0:
+		result = TEMPSEN_GET(base, sta_tempsen_ch0_result); break;
+	default:
+		result = 0;
+	}
+	*temperature = calc_temp(result);
+	pr_debug("ch%d temp = %d mC(0x%x)\n", ch, *temperature, result);
+
+	return 0;
+}
+
+static const struct thermal_zone_of_device_ops cv181x_thermal_ops = {
+	.get_temp = cv181x_read_temp,
+};
+
+static const struct of_device_id cv181x_thermal_of_match[] = {
+	{
+		.compatible = "cvitek,cv181x-thermal",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, cv181x_thermal_of_match);
+
+static int cv181x_thermal_probe(struct platform_device *pdev)
+{
+	struct cv181x_thermal *ct;
+	struct cv181x_thermal_zone *ctz;
+	struct resource *res;
+	struct thermal_zone_device *tz;
+	int i;
+
+	ct = devm_kzalloc(&pdev->dev, sizeof(*ct), GFP_KERNEL);
+	if (!ct)
+		return -ENOMEM;
+
+	ct->clk_tempsen = devm_clk_get(&pdev->dev, "clk_tempsen");
+	if (IS_ERR(ct->clk_tempsen)) {
+		dev_err(&pdev->dev, "failed to get clk_tempsen\n");
+		return PTR_ERR(ct->clk_tempsen);
+	}
+
+	/* enable clk_tempsen */
+	clk_prepare_enable(ct->clk_tempsen);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	ct->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(ct->base)) {
+		dev_err(&pdev->dev, "failed to map tempsen registers\n");
+		return PTR_ERR(ct->base);
+	}
+
+	ct->dev = &pdev->dev;
+
+	cv181x_thermal_init(ct);
+
+	platform_set_drvdata(pdev, ct);
+
+	for (i = 0; i < 1; i++) {
+		ctz = devm_kzalloc(&pdev->dev, sizeof(*ctz), GFP_KERNEL);
+		if (!ctz)
+			return -ENOMEM;
+
+		ctz->base = ct->base;
+		ctz->ct = ct;
+		ctz->ch = i;
+		tz = devm_thermal_zone_of_sensor_register(&pdev->dev, i, ctz,
+							  &cv181x_thermal_ops);
+		if (IS_ERR(tz)) {
+			dev_err(&pdev->dev, "failed to register thermal zone %d\n", i);
+			return PTR_ERR(tz);
+		}
+	}
+
+	return 0;
+}
+
+static int cv181x_thermal_remove(struct platform_device *pdev)
+{
+	struct cv181x_thermal *ct = platform_get_drvdata(pdev);
+
+	cv181x_thermal_uninit(ct);
+
+	clk_disable_unprepare(ct->clk_tempsen);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int cv181x_thermal_suspend(struct device *dev)
+{
+	struct cv181x_thermal *ct = dev_get_drvdata(dev);
+
+	cv181x_thermal_uninit(ct);
+
+	clk_disable_unprepare(ct->clk_tempsen);
+
+	return 0;
+}
+
+static int cv181x_thermal_resume(struct device *dev)
+{
+	struct cv181x_thermal *ct = dev_get_drvdata(dev);
+
+	/* enable clk_tempsen */
+	clk_prepare_enable(ct->clk_tempsen);
+
+	cv181x_thermal_init(ct);
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static SIMPLE_DEV_PM_OPS(cv181x_thermal_pm_ops,
+			 cv181x_thermal_suspend, cv181x_thermal_resume);
+
+static struct platform_driver cv181x_thermal_driver = {
+	.probe = cv181x_thermal_probe,
+	.remove = cv181x_thermal_remove,
+	.driver = {
+		.name = "cv181x-thermal",
+		.pm = &cv181x_thermal_pm_ops,
+		.of_match_table = cv181x_thermal_of_match,
+	},
+};
+
+module_platform_driver(cv181x_thermal_driver);
+MODULE_DESCRIPTION("cv181x thermal driver");
diff --git a/drivers/thermal/cv182x_thermal.c b/drivers/thermal/cv182x_thermal.c
new file mode 100644
index 000000000000..301473b755ff
--- /dev/null
+++ b/drivers/thermal/cv182x_thermal.c
@@ -0,0 +1,453 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * CVITEK CV182X thermal driver
+ *
+ * Copyright 2021 CVITEK Inc.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/thermal.h>
+#include <linux/types.h>
+
+#define tempsen_top_tempsen_version				0x0
+#define tempsen_top_tempsen_ctrl				0x4
+#define tempsen_top_tempsen_status				0x8
+#define tempsen_top_tempsen_set					0xc
+#define tempsen_top_tempsen_intr_en				0x10
+#define tempsen_top_tempsen_intr_clr				0x14
+#define tempsen_top_tempsen_intr_sta				0x18
+#define tempsen_top_tempsen_intr_raw				0x1c
+#define tempsen_top_tempsen_ch0_result				0x20
+#define tempsen_top_tempsen_ch1_result				0x24
+#define tempsen_top_tempsen_ch2_result				0x28
+#define tempsen_top_tempsen_ch3_result				0x2c
+#define tempsen_top_tempsen_ch0_temp_th				0x40
+#define tempsen_top_tempsen_ch1_temp_th				0x44
+#define tempsen_top_tempsen_ch2_temp_th				0x48
+#define tempsen_top_tempsen_ch3_temp_th				0x4c
+#define tempsen_top_Overheat_th					0x60
+#define tempsen_top_tempsen_auto_cycle				0x64
+#define tempsen_top_tempsen_auto_prediv				0x64
+#define tempsen_top_tempsen_overheat_ctrl			0x68
+#define tempsen_top_tempsen_overheat_countdown			0x6c
+#define tempsen_top_tempsen_ch0_temp_th_cnt			0x70
+#define tempsen_top_tempsen_ch1_temp_th_cnt			0x74
+#define tempsen_top_tempsen_ch2_temp_th_cnt			0x78
+#define tempsen_top_tempsen_ch3_temp_th_cnt			0x7c
+#define tempsen_top_tempsen_test_force				0x80
+#define tempsen_top_reg_ip_version				0x0
+#define tempsen_top_reg_ip_version_OFFSET			0
+#define tempsen_top_reg_ip_version_MASK				0xffffffff
+#define tempsen_top_reg_tempsen_en				0x4
+#define tempsen_top_reg_tempsen_en_OFFSET			0
+#define tempsen_top_reg_tempsen_en_MASK				0x1
+#define tempsen_top_reg_tempsen_sel				0x4
+#define tempsen_top_reg_tempsen_sel_OFFSET			4
+#define tempsen_top_reg_tempsen_sel_MASK			0xf0
+#define tempsen_top_reg_tempsen_ovhl_cnt_to_irq			0x4
+#define tempsen_top_reg_tempsen_ovhl_cnt_to_irq_OFFSET		16
+#define tempsen_top_reg_tempsen_ovhl_cnt_to_irq_MASK		0xff0000
+#define tempsen_top_reg_tempsen_udll_cnt_to_irq			0x4
+#define tempsen_top_reg_tempsen_udll_cnt_to_irq_OFFSET		24
+#define tempsen_top_reg_tempsen_udll_cnt_to_irq_MASK		0xff000000
+#define tempsen_top_sta_tempsen_busy				0x8
+#define tempsen_top_sta_tempsen_busy_OFFSET			0
+#define tempsen_top_sta_tempsen_busy_MASK			0x1
+#define tempsen_top_reg_tempsen_bgen				0xc
+#define tempsen_top_reg_tempsen_bgen_OFFSET			0
+#define tempsen_top_reg_tempsen_bgen_MASK			0x1
+#define tempsen_top_reg_tempsen_chopen				0xc
+#define tempsen_top_reg_tempsen_chopen_OFFSET			1
+#define tempsen_top_reg_tempsen_chopen_MASK			0x2
+#define tempsen_top_reg_tempsen_choppol				0xc
+#define tempsen_top_reg_tempsen_choppol_OFFSET			2
+#define tempsen_top_reg_tempsen_choppol_MASK			0x4
+#define tempsen_top_reg_tempsen_clkpol				0xc
+#define tempsen_top_reg_tempsen_clkpol_OFFSET			3
+#define tempsen_top_reg_tempsen_clkpol_MASK			0x8
+#define tempsen_top_reg_tempsen_chopsel				0xc
+#define tempsen_top_reg_tempsen_chopsel_OFFSET			4
+#define tempsen_top_reg_tempsen_chopsel_MASK			0x30
+#define tempsen_top_reg_tempsen_accsel				0xc
+#define tempsen_top_reg_tempsen_accsel_OFFSET			6
+#define tempsen_top_reg_tempsen_accsel_MASK			0xc0
+#define tempsen_top_reg_tempsen_cyc_clkdiv			0xc
+#define tempsen_top_reg_tempsen_cyc_clkdiv_OFFSET		8
+#define tempsen_top_reg_tempsen_cyc_clkdiv_MASK			0xff00
+#define tempsen_top_reg_tempsen_tsel				0xc
+#define tempsen_top_reg_tempsen_tsel_OFFSET			16
+#define tempsen_top_reg_tempsen_tsel_MASK			0x30000
+#define tempsen_top_sta_tempsen_intr_en				0x10
+#define tempsen_top_sta_tempsen_intr_en_OFFSET			0
+#define tempsen_top_sta_tempsen_intr_en_MASK			0xffffffff
+#define tempsen_top_sta_tempsen_intr_clr			0x14
+#define tempsen_top_sta_tempsen_intr_clr_OFFSET			0
+#define tempsen_top_sta_tempsen_intr_clr_MASK			0xffffffff
+#define tempsen_top_sta_tempsen_intr_sta			0x18
+#define tempsen_top_sta_tempsen_intr_sta_OFFSET			0
+#define tempsen_top_sta_tempsen_intr_sta_MASK			0xffffffff
+#define tempsen_top_sta_tempsen_intr_raw			0x1c
+#define tempsen_top_sta_tempsen_intr_raw_OFFSET			0
+#define tempsen_top_sta_tempsen_intr_raw_MASK			0xffffffff
+#define tempsen_top_sta_tempsen_ch0_result			0x20
+#define tempsen_top_sta_tempsen_ch0_result_OFFSET		0
+#define tempsen_top_sta_tempsen_ch0_result_MASK			0x1fff
+#define tempsen_top_sta_tempsen_ch0_max_result			0x20
+#define tempsen_top_sta_tempsen_ch0_max_result_OFFSET		16
+#define tempsen_top_sta_tempsen_ch0_max_result_MASK		0x1fff0000
+#define tempsen_top_clr_tempsen_ch0_max_result			0x20
+#define tempsen_top_clr_tempsen_ch0_max_result_OFFSET		31
+#define tempsen_top_clr_tempsen_ch0_max_result_MASK		0x80000000
+#define tempsen_top_sta_tempsen_ch1_result			0x24
+#define tempsen_top_sta_tempsen_ch1_result_OFFSET		0
+#define tempsen_top_sta_tempsen_ch1_result_MASK			0x1fff
+#define tempsen_top_sta_tempsen_ch1_max_result			0x24
+#define tempsen_top_sta_tempsen_ch1_max_result_OFFSET		16
+#define tempsen_top_sta_tempsen_ch1_max_result_MASK		0x1fff0000
+#define tempsen_top_clr_tempsen_ch1_max_result			0x24
+#define tempsen_top_clr_tempsen_ch1_max_result_OFFSET		31
+#define tempsen_top_clr_tempsen_ch1_max_result_MASK		0x80000000
+#define tempsen_top_sta_tempsen_ch2_result			0x28
+#define tempsen_top_sta_tempsen_ch2_result_OFFSET		0
+#define tempsen_top_sta_tempsen_ch2_result_MASK			0x1fff
+#define tempsen_top_sta_tempsen_ch2_max_result			0x28
+#define tempsen_top_sta_tempsen_ch2_max_result_OFFSET		16
+#define tempsen_top_sta_tempsen_ch2_max_result_MASK		0x1fff0000
+#define tempsen_top_clr_tempsen_ch2_max_result			0x28
+#define tempsen_top_clr_tempsen_ch2_max_result_OFFSET		31
+#define tempsen_top_clr_tempsen_ch2_max_result_MASK		0x80000000
+#define tempsen_top_sta_tempsen_ch3_result			0x2c
+#define tempsen_top_sta_tempsen_ch3_result_OFFSET		0
+#define tempsen_top_sta_tempsen_ch3_result_MASK			0x1fff
+#define tempsen_top_sta_tempsen_ch3_max_result			0x2c
+#define tempsen_top_sta_tempsen_ch3_max_result_OFFSET		16
+#define tempsen_top_sta_tempsen_ch3_max_result_MASK		0x1fff0000
+#define tempsen_top_clr_tempsen_ch3_max_result			0x2c
+#define tempsen_top_clr_tempsen_ch3_max_result_OFFSET		31
+#define tempsen_top_clr_tempsen_ch3_max_result_MASK		0x80000000
+#define tempsen_top_reg_tempsen_ch0_hi_th			0x40
+#define tempsen_top_reg_tempsen_ch0_hi_th_OFFSET		0
+#define tempsen_top_reg_tempsen_ch0_hi_th_MASK			0x1fff
+#define tempsen_top_reg_tempsen_ch0_lo_th			0x40
+#define tempsen_top_reg_tempsen_ch0_lo_th_OFFSET		16
+#define tempsen_top_reg_tempsen_ch0_lo_th_MASK			0x1fff0000
+#define tempsen_top_reg_tempsen_ch1_hi_th			0x44
+#define tempsen_top_reg_tempsen_ch1_hi_th_OFFSET		0
+#define tempsen_top_reg_tempsen_ch1_hi_th_MASK			0x1fff
+#define tempsen_top_reg_tempsen_ch1_lo_th			0x44
+#define tempsen_top_reg_tempsen_ch1_lo_th_OFFSET		16
+#define tempsen_top_reg_tempsen_ch1_lo_th_MASK			0x1fff0000
+#define tempsen_top_reg_tempsen_ch2_hi_th			0x48
+#define tempsen_top_reg_tempsen_ch2_hi_th_OFFSET		0
+#define tempsen_top_reg_tempsen_ch2_hi_th_MASK			0x1fff
+#define tempsen_top_reg_tempsen_ch2_lo_th			0x48
+#define tempsen_top_reg_tempsen_ch2_lo_th_OFFSET		16
+#define tempsen_top_reg_tempsen_ch2_lo_th_MASK			0x1fff0000
+#define tempsen_top_reg_tempsen_ch3_hi_th			0x4c
+#define tempsen_top_reg_tempsen_ch3_hi_th_OFFSET		0
+#define tempsen_top_reg_tempsen_ch3_hi_th_MASK			0x1fff
+#define tempsen_top_reg_tempsen_ch3_lo_th			0x4c
+#define tempsen_top_reg_tempsen_ch3_lo_th_OFFSET		16
+#define tempsen_top_reg_tempsen_ch3_lo_th_MASK			0x1fff0000
+#define tempsen_top_reg_tempsen_overheat_th			0x60
+#define tempsen_top_reg_tempsen_overheat_th_OFFSET		0
+#define tempsen_top_reg_tempsen_overheat_th_MASK		0x1fff
+#define tempsen_top_reg_tempsen_auto_cycle			0x64
+#define tempsen_top_reg_tempsen_auto_cycle_OFFSET		0
+#define tempsen_top_reg_tempsen_auto_cycle_MASK			0xffffff
+#define tempsen_top_reg_tempsen_auto_prediv			0x64
+#define tempsen_top_reg_tempsen_auto_prediv_OFFSET		24
+#define tempsen_top_reg_tempsen_auto_prediv_MASK		0xff000000
+#define tempsen_top_reg_tempsen_overheat_cycle			0x68
+#define tempsen_top_reg_tempsen_overheat_cycle_OFFSET		0
+#define tempsen_top_reg_tempsen_overheat_cycle_MASK		0x3fffffff
+#define tempsen_top_reg_overheat_reset_clr			0x68
+#define tempsen_top_reg_overheat_reset_clr_OFFSET		30
+#define tempsen_top_reg_overheat_reset_clr_MASK			0x40000000
+#define tempsen_top_reg_overheat_reset_en			0x68
+#define tempsen_top_reg_overheat_reset_en_OFFSET		31
+#define tempsen_top_reg_overheat_reset_en_MASK			0x80000000
+#define tempsen_top_sta_tempsen_overheat_countdown		0x6c
+#define tempsen_top_sta_tempsen_overheat_countdown_OFFSET	0
+#define tempsen_top_sta_tempsen_overheat_countdown_MASK		0x3fffffff
+#define tempsen_top_sta_overheat_reset				0x6c
+#define tempsen_top_sta_overheat_reset_OFFSET			31
+#define tempsen_top_sta_overheat_reset_MASK			0x80000000
+#define tempsen_top_sta_ch0_over_hi_temp_th_cnt			0x70
+#define tempsen_top_sta_ch0_over_hi_temp_th_cnt_OFFSET		0
+#define tempsen_top_sta_ch0_over_hi_temp_th_cnt_MASK		0xff
+#define tempsen_top_sta_ch0_under_lo_temp_th_cnt		0x70
+#define tempsen_top_sta_ch0_under_lo_temp_th_cnt_OFFSET		8
+#define tempsen_top_sta_ch0_under_lo_temp_th_cnt_MASK		0xff00
+#define tempsen_top_reg_ch0_temp_th_cnt_clr			0x70
+#define tempsen_top_reg_ch0_temp_th_cnt_clr_OFFSET		16
+#define tempsen_top_reg_ch0_temp_th_cnt_clr_MASK		0x10000
+#define tempsen_top_sta_ch1_over_hi_temp_th_cnt			0x74
+#define tempsen_top_sta_ch1_over_hi_temp_th_cnt_OFFSET		0
+#define tempsen_top_sta_ch1_over_hi_temp_th_cnt_MASK		0xff
+#define tempsen_top_sta_ch1_under_lo_temp_th_cnt		0x74
+#define tempsen_top_sta_ch1_under_lo_temp_th_cnt_OFFSET		8
+#define tempsen_top_sta_ch1_under_lo_temp_th_cnt_MASK		0xff00
+#define tempsen_top_reg_ch1_temp_th_cnt_clr			0x74
+#define tempsen_top_reg_ch1_temp_th_cnt_clr_OFFSET		16
+#define tempsen_top_reg_ch1_temp_th_cnt_clr_MASK		0x10000
+#define tempsen_top_sta_ch2_over_hi_temp_th_cnt			0x78
+#define tempsen_top_sta_ch2_over_hi_temp_th_cnt_OFFSET		0
+#define tempsen_top_sta_ch2_over_hi_temp_th_cnt_MASK		0xff
+#define tempsen_top_sta_ch2_under_lo_temp_th_cnt		0x78
+#define tempsen_top_sta_ch2_under_lo_temp_th_cnt_OFFSET		8
+#define tempsen_top_sta_ch2_under_lo_temp_th_cnt_MASK		0xff00
+#define tempsen_top_reg_ch2_temp_th_cnt_clr			0x78
+#define tempsen_top_reg_ch2_temp_th_cnt_clr_OFFSET		16
+#define tempsen_top_reg_ch2_temp_th_cnt_clr_MASK		0x10000
+#define tempsen_top_sta_ch3_over_hi_temp_th_cnt			0x7c
+#define tempsen_top_sta_ch3_over_hi_temp_th_cnt_OFFSET		0
+#define tempsen_top_sta_ch3_over_hi_temp_th_cnt_MASK		0xff
+#define tempsen_top_sta_ch3_under_lo_temp_th_cnt		0x7c
+#define tempsen_top_sta_ch3_under_lo_temp_th_cnt_OFFSET		8
+#define tempsen_top_sta_ch3_under_lo_temp_th_cnt_MASK		0xff00
+#define tempsen_top_reg_ch3_temp_th_cnt_clr			0x7c
+#define tempsen_top_reg_ch3_temp_th_cnt_clr_OFFSET		16
+#define tempsen_top_reg_ch3_temp_th_cnt_clr_MASK		0x10000
+#define tempsen_top_reg_tempsen_force_result			0x80
+#define tempsen_top_reg_tempsen_force_result_OFFSET		0
+#define tempsen_top_reg_tempsen_force_result_MASK		0x1fff
+#define tempsen_top_reg_tempsen_force_valid			0x80
+#define tempsen_top_reg_tempsen_force_valid_OFFSET		13
+#define tempsen_top_reg_tempsen_force_valid_MASK		0x2000
+#define tempsen_top_reg_tempsen_force_busy			0x80
+#define tempsen_top_reg_tempsen_force_busy_OFFSET		14
+#define tempsen_top_reg_tempsen_force_busy_MASK			0x4000
+#define tempsen_top_reg_tempsen_force_en			0x80
+#define tempsen_top_reg_tempsen_force_en_OFFSET			15
+#define tempsen_top_reg_tempsen_force_en_MASK			0x8000
+
+#define TEMPSEN_MASK(REG_NAME) tempsen_top_##REG_NAME##_MASK
+#define TEMPSEN_OFFSET(REG_NAME) tempsen_top_##REG_NAME##_OFFSET
+#define TEMPSEN_SET(BASE_ADDR, REG_NAME, VAL) \
+	clrsetbits(BASE_ADDR + tempsen_top_##REG_NAME, \
+	TEMPSEN_MASK(REG_NAME), (VAL) << TEMPSEN_OFFSET(REG_NAME))
+#define TEMPSEN_GET(BASE_ADDR, REG_NAME) \
+	((readl(BASE_ADDR + tempsen_top_##REG_NAME) & \
+	TEMPSEN_MASK(REG_NAME)) >> TEMPSEN_OFFSET(REG_NAME))
+
+static void __maybe_unused clrsetbits(void __iomem *reg, u32 clrval, u32 setval)
+{
+	u32 regval;
+
+	regval = readl(reg);
+	regval &= ~(clrval);
+	regval |= setval;
+	writel(regval, reg);
+}
+
+struct cv182x_thermal_zone {
+	unsigned int ch;
+	void __iomem *base;
+	struct cv182x_thermal *ct;
+};
+
+struct cv182x_thermal {
+	struct device *dev;
+	void __iomem *base;
+	struct clk *clk_tempsen;
+};
+
+static void cv182x_thermal_init(struct cv182x_thermal *ct)
+{
+	void __iomem *base = ct->base;
+	u32 regval;
+
+	/* clear all interrupt status */
+	regval = TEMPSEN_GET(base, sta_tempsen_intr_raw);
+	TEMPSEN_SET(base, sta_tempsen_intr_clr, regval);
+
+	/* clear max result */
+	TEMPSEN_SET(base, clr_tempsen_ch0_max_result, 1);
+	TEMPSEN_SET(base, clr_tempsen_ch1_max_result, 1);
+
+	/* set chop period to 3:1024T */
+	TEMPSEN_SET(base, reg_tempsen_chopsel, 0x3);
+
+	/* set acc period to 2:2048T*/
+	TEMPSEN_SET(base, reg_tempsen_accsel, 0x2);
+
+	/* set tempsen clock divider to 25M/(0x31+1)= 0.5M ,T=2us */
+	TEMPSEN_SET(base, reg_tempsen_cyc_clkdiv, 0x31);
+
+	/* set reg_tempsen_auto_cycle */
+	TEMPSEN_SET(base, reg_tempsen_auto_cycle, 0x100000);
+
+	/* enable tempsen channel */
+	TEMPSEN_SET(base, reg_tempsen_sel, 0x1);
+	TEMPSEN_SET(base, reg_tempsen_en, 1);
+}
+
+static void cv182x_thermal_uninit(struct cv182x_thermal *ct)
+{
+	void __iomem *base = ct->base;
+	u32 regval;
+
+	/* disable all tempsen channel */
+	TEMPSEN_SET(base, reg_tempsen_sel, 0);
+	TEMPSEN_SET(base, reg_tempsen_en, 0);
+
+	/* clear all interrupt status */
+	regval = TEMPSEN_GET(base, sta_tempsen_intr_raw);
+	TEMPSEN_SET(base, sta_tempsen_intr_clr, regval);
+}
+
+static int calc_temp(uint32_t result)
+{
+	return ((result * 1000) * 716 / 2048 - 273000);
+
+	/* Original calculation formula */
+	// return ((result * 1000) / 2048 * 716 - 273000);
+}
+
+static int cv182x_read_temp(void *data, int *temperature)
+{
+	struct cv182x_thermal_zone *ctz = data;
+	void __iomem *base = ctz->base;
+	unsigned int ch = ctz->ch;
+	u32 result;
+
+	/* read temperature */
+	switch (ch) {
+	case 0:
+		result = TEMPSEN_GET(base, sta_tempsen_ch0_result); break;
+	default:
+		result = 0;
+	}
+	*temperature = calc_temp(result);
+	pr_debug("ch%d temp = %d mC(0x%x)\n", ch, *temperature, result);
+
+	return 0;
+}
+
+static const struct thermal_zone_of_device_ops cv182x_thermal_ops = {
+	.get_temp = cv182x_read_temp,
+};
+
+static const struct of_device_id cv182x_thermal_of_match[] = {
+	{
+		.compatible = "cvitek,cv182x-thermal",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, cv182x_thermal_of_match);
+
+static int cv182x_thermal_probe(struct platform_device *pdev)
+{
+	struct cv182x_thermal *ct;
+	struct cv182x_thermal_zone *ctz;
+	struct resource *res;
+	struct thermal_zone_device *tz;
+	int i;
+
+	ct = devm_kzalloc(&pdev->dev, sizeof(*ct), GFP_KERNEL);
+	if (!ct)
+		return -ENOMEM;
+
+	ct->clk_tempsen = devm_clk_get(&pdev->dev, "clk_tempsen");
+	if (IS_ERR(ct->clk_tempsen)) {
+		dev_err(&pdev->dev, "failed to get clk_tempsen\n");
+		return PTR_ERR(ct->clk_tempsen);
+	}
+
+	/* enable clk_tempsen */
+	clk_prepare_enable(ct->clk_tempsen);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	ct->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(ct->base)) {
+		dev_err(&pdev->dev, "failed to map tempsen registers\n");
+		return PTR_ERR(ct->base);
+	}
+
+	ct->dev = &pdev->dev;
+
+	cv182x_thermal_init(ct);
+
+	platform_set_drvdata(pdev, ct);
+
+	for (i = 0; i < 1; i++) {
+		ctz = devm_kzalloc(&pdev->dev, sizeof(*ctz), GFP_KERNEL);
+		if (!ctz)
+			return -ENOMEM;
+
+		ctz->base = ct->base;
+		ctz->ct = ct;
+		ctz->ch = i;
+		tz = devm_thermal_zone_of_sensor_register(&pdev->dev, i, ctz,
+							  &cv182x_thermal_ops);
+		if (IS_ERR(tz)) {
+			dev_err(&pdev->dev, "failed to register thermal zone %d\n", i);
+			return PTR_ERR(tz);
+		}
+	}
+
+	return 0;
+}
+
+static int cv182x_thermal_remove(struct platform_device *pdev)
+{
+	struct cv182x_thermal *ct = platform_get_drvdata(pdev);
+
+	cv182x_thermal_uninit(ct);
+
+	clk_disable_unprepare(ct->clk_tempsen);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int cv182x_thermal_suspend(struct device *dev)
+{
+	struct cv182x_thermal *ct = dev_get_drvdata(dev);
+
+	cv182x_thermal_uninit(ct);
+
+	clk_disable_unprepare(ct->clk_tempsen);
+
+	return 0;
+}
+
+static int cv182x_thermal_resume(struct device *dev)
+{
+	struct cv182x_thermal *ct = dev_get_drvdata(dev);
+
+	/* enable clk_tempsen */
+	clk_prepare_enable(ct->clk_tempsen);
+
+	cv182x_thermal_init(ct);
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static SIMPLE_DEV_PM_OPS(cv182x_thermal_pm_ops,
+			 cv182x_thermal_suspend, cv182x_thermal_resume);
+
+static struct platform_driver cv182x_thermal_driver = {
+	.probe = cv182x_thermal_probe,
+	.remove = cv182x_thermal_remove,
+	.driver = {
+		.name = "cv182x-thermal",
+		.pm = &cv182x_thermal_pm_ops,
+		.of_match_table = cv182x_thermal_of_match,
+	},
+};
+
+module_platform_driver(cv182x_thermal_driver);
+MODULE_DESCRIPTION("CV182X thermal driver");
diff --git a/drivers/thermal/cv1835_thermal.c b/drivers/thermal/cv1835_thermal.c
new file mode 100644
index 000000000000..4c283c80b200
--- /dev/null
+++ b/drivers/thermal/cv1835_thermal.c
@@ -0,0 +1,426 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * CVITEK CV1835 thermal driver
+ *
+ * Copyright 2020 CVITEK Inc.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/thermal.h>
+#include <linux/types.h>
+
+#define tempsen_top_tempsen_version				0x0
+#define tempsen_top_tempsen_ctrl				0x4
+#define tempsen_top_tempsen_status				0x8
+#define tempsen_top_tempsen_set					0xc
+#define tempsen_top_tempsen_intr_en				0x10
+#define tempsen_top_tempsen_intr_clr				0x14
+#define tempsen_top_tempsen_intr_sta				0x18
+#define tempsen_top_tempsen_intr_raw				0x1c
+#define tempsen_top_tempsen_ch0_result				0x20
+#define tempsen_top_tempsen_ch1_result				0x24
+#define tempsen_top_tempsen_ch2_result				0x28
+#define tempsen_top_tempsen_ch3_result				0x2c
+#define tempsen_top_tempsen_ch0_temp_th				0x40
+#define tempsen_top_tempsen_ch1_temp_th				0x44
+#define tempsen_top_tempsen_ch2_temp_th				0x48
+#define tempsen_top_tempsen_ch3_temp_th				0x4c
+#define tempsen_top_Overheat_th					0x60
+#define tempsen_top_tempsen_auto_cycle				0x64
+#define tempsen_top_tempsen_auto_prediv				0x64
+#define tempsen_top_tempsen_overheat_ctrl			0x68
+#define tempsen_top_tempsen_overheat_countdown			0x6c
+#define tempsen_top_tempsen_ch0_temp_th_cnt			0x70
+#define tempsen_top_tempsen_ch1_temp_th_cnt			0x74
+#define tempsen_top_tempsen_ch2_temp_th_cnt			0x78
+#define tempsen_top_tempsen_ch3_temp_th_cnt			0x7c
+#define tempsen_top_tempsen_test_force				0x80
+#define tempsen_top_reg_ip_version				0x0
+#define tempsen_top_reg_ip_version_OFFSET			0
+#define tempsen_top_reg_ip_version_MASK				0xffffffff
+#define tempsen_top_reg_tempsen_en				0x4
+#define tempsen_top_reg_tempsen_en_OFFSET			0
+#define tempsen_top_reg_tempsen_en_MASK				0x1
+#define tempsen_top_reg_tempsen_sel				0x4
+#define tempsen_top_reg_tempsen_sel_OFFSET			4
+#define tempsen_top_reg_tempsen_sel_MASK			0xf0
+#define tempsen_top_reg_tempsen_ovhl_cnt_to_irq			0x4
+#define tempsen_top_reg_tempsen_ovhl_cnt_to_irq_OFFSET		16
+#define tempsen_top_reg_tempsen_ovhl_cnt_to_irq_MASK		0xff0000
+#define tempsen_top_reg_tempsen_udll_cnt_to_irq			0x4
+#define tempsen_top_reg_tempsen_udll_cnt_to_irq_OFFSET		24
+#define tempsen_top_reg_tempsen_udll_cnt_to_irq_MASK		0xff000000
+#define tempsen_top_sta_tempsen_busy				0x8
+#define tempsen_top_sta_tempsen_busy_OFFSET			0
+#define tempsen_top_sta_tempsen_busy_MASK			0x1
+#define tempsen_top_reg_tempsen_bgen				0xc
+#define tempsen_top_reg_tempsen_bgen_OFFSET			0
+#define tempsen_top_reg_tempsen_bgen_MASK			0x1
+#define tempsen_top_reg_tempsen_chopen				0xc
+#define tempsen_top_reg_tempsen_chopen_OFFSET			1
+#define tempsen_top_reg_tempsen_chopen_MASK			0x2
+#define tempsen_top_reg_tempsen_choppol				0xc
+#define tempsen_top_reg_tempsen_choppol_OFFSET			2
+#define tempsen_top_reg_tempsen_choppol_MASK			0x4
+#define tempsen_top_reg_tempsen_clkpol				0xc
+#define tempsen_top_reg_tempsen_clkpol_OFFSET			3
+#define tempsen_top_reg_tempsen_clkpol_MASK			0x8
+#define tempsen_top_reg_tempsen_chopsel				0xc
+#define tempsen_top_reg_tempsen_chopsel_OFFSET			4
+#define tempsen_top_reg_tempsen_chopsel_MASK			0x30
+#define tempsen_top_reg_tempsen_accsel				0xc
+#define tempsen_top_reg_tempsen_accsel_OFFSET			6
+#define tempsen_top_reg_tempsen_accsel_MASK			0xc0
+#define tempsen_top_reg_tempsen_cyc_clkdiv			0xc
+#define tempsen_top_reg_tempsen_cyc_clkdiv_OFFSET		8
+#define tempsen_top_reg_tempsen_cyc_clkdiv_MASK			0xff00
+#define tempsen_top_reg_tempsen_tsel				0xc
+#define tempsen_top_reg_tempsen_tsel_OFFSET			16
+#define tempsen_top_reg_tempsen_tsel_MASK			0x30000
+#define tempsen_top_sta_tempsen_intr_en				0x10
+#define tempsen_top_sta_tempsen_intr_en_OFFSET			0
+#define tempsen_top_sta_tempsen_intr_en_MASK			0xffffffff
+#define tempsen_top_sta_tempsen_intr_clr			0x14
+#define tempsen_top_sta_tempsen_intr_clr_OFFSET			0
+#define tempsen_top_sta_tempsen_intr_clr_MASK			0xffffffff
+#define tempsen_top_sta_tempsen_intr_sta			0x18
+#define tempsen_top_sta_tempsen_intr_sta_OFFSET			0
+#define tempsen_top_sta_tempsen_intr_sta_MASK			0xffffffff
+#define tempsen_top_sta_tempsen_intr_raw			0x1c
+#define tempsen_top_sta_tempsen_intr_raw_OFFSET			0
+#define tempsen_top_sta_tempsen_intr_raw_MASK			0xffffffff
+#define tempsen_top_sta_tempsen_ch0_result			0x20
+#define tempsen_top_sta_tempsen_ch0_result_OFFSET		0
+#define tempsen_top_sta_tempsen_ch0_result_MASK			0x1fff
+#define tempsen_top_sta_tempsen_ch0_max_result			0x20
+#define tempsen_top_sta_tempsen_ch0_max_result_OFFSET		16
+#define tempsen_top_sta_tempsen_ch0_max_result_MASK		0x1fff0000
+#define tempsen_top_clr_tempsen_ch0_max_result			0x20
+#define tempsen_top_clr_tempsen_ch0_max_result_OFFSET		31
+#define tempsen_top_clr_tempsen_ch0_max_result_MASK		0x80000000
+#define tempsen_top_sta_tempsen_ch1_result			0x24
+#define tempsen_top_sta_tempsen_ch1_result_OFFSET		0
+#define tempsen_top_sta_tempsen_ch1_result_MASK			0x1fff
+#define tempsen_top_sta_tempsen_ch1_max_result			0x24
+#define tempsen_top_sta_tempsen_ch1_max_result_OFFSET		16
+#define tempsen_top_sta_tempsen_ch1_max_result_MASK		0x1fff0000
+#define tempsen_top_clr_tempsen_ch1_max_result			0x24
+#define tempsen_top_clr_tempsen_ch1_max_result_OFFSET		31
+#define tempsen_top_clr_tempsen_ch1_max_result_MASK		0x80000000
+#define tempsen_top_sta_tempsen_ch2_result			0x28
+#define tempsen_top_sta_tempsen_ch2_result_OFFSET		0
+#define tempsen_top_sta_tempsen_ch2_result_MASK			0x1fff
+#define tempsen_top_sta_tempsen_ch2_max_result			0x28
+#define tempsen_top_sta_tempsen_ch2_max_result_OFFSET		16
+#define tempsen_top_sta_tempsen_ch2_max_result_MASK		0x1fff0000
+#define tempsen_top_clr_tempsen_ch2_max_result			0x28
+#define tempsen_top_clr_tempsen_ch2_max_result_OFFSET		31
+#define tempsen_top_clr_tempsen_ch2_max_result_MASK		0x80000000
+#define tempsen_top_sta_tempsen_ch3_result			0x2c
+#define tempsen_top_sta_tempsen_ch3_result_OFFSET		0
+#define tempsen_top_sta_tempsen_ch3_result_MASK			0x1fff
+#define tempsen_top_sta_tempsen_ch3_max_result			0x2c
+#define tempsen_top_sta_tempsen_ch3_max_result_OFFSET		16
+#define tempsen_top_sta_tempsen_ch3_max_result_MASK		0x1fff0000
+#define tempsen_top_clr_tempsen_ch3_max_result			0x2c
+#define tempsen_top_clr_tempsen_ch3_max_result_OFFSET		31
+#define tempsen_top_clr_tempsen_ch3_max_result_MASK		0x80000000
+#define tempsen_top_reg_tempsen_ch0_hi_th			0x40
+#define tempsen_top_reg_tempsen_ch0_hi_th_OFFSET		0
+#define tempsen_top_reg_tempsen_ch0_hi_th_MASK			0x1fff
+#define tempsen_top_reg_tempsen_ch0_lo_th			0x40
+#define tempsen_top_reg_tempsen_ch0_lo_th_OFFSET		16
+#define tempsen_top_reg_tempsen_ch0_lo_th_MASK			0x1fff0000
+#define tempsen_top_reg_tempsen_ch1_hi_th			0x44
+#define tempsen_top_reg_tempsen_ch1_hi_th_OFFSET		0
+#define tempsen_top_reg_tempsen_ch1_hi_th_MASK			0x1fff
+#define tempsen_top_reg_tempsen_ch1_lo_th			0x44
+#define tempsen_top_reg_tempsen_ch1_lo_th_OFFSET		16
+#define tempsen_top_reg_tempsen_ch1_lo_th_MASK			0x1fff0000
+#define tempsen_top_reg_tempsen_ch2_hi_th			0x48
+#define tempsen_top_reg_tempsen_ch2_hi_th_OFFSET		0
+#define tempsen_top_reg_tempsen_ch2_hi_th_MASK			0x1fff
+#define tempsen_top_reg_tempsen_ch2_lo_th			0x48
+#define tempsen_top_reg_tempsen_ch2_lo_th_OFFSET		16
+#define tempsen_top_reg_tempsen_ch2_lo_th_MASK			0x1fff0000
+#define tempsen_top_reg_tempsen_ch3_hi_th			0x4c
+#define tempsen_top_reg_tempsen_ch3_hi_th_OFFSET		0
+#define tempsen_top_reg_tempsen_ch3_hi_th_MASK			0x1fff
+#define tempsen_top_reg_tempsen_ch3_lo_th			0x4c
+#define tempsen_top_reg_tempsen_ch3_lo_th_OFFSET		16
+#define tempsen_top_reg_tempsen_ch3_lo_th_MASK			0x1fff0000
+#define tempsen_top_reg_tempsen_overheat_th			0x60
+#define tempsen_top_reg_tempsen_overheat_th_OFFSET		0
+#define tempsen_top_reg_tempsen_overheat_th_MASK		0x1fff
+#define tempsen_top_reg_tempsen_auto_cycle			0x64
+#define tempsen_top_reg_tempsen_auto_cycle_OFFSET		0
+#define tempsen_top_reg_tempsen_auto_cycle_MASK			0xffffff
+#define tempsen_top_reg_tempsen_auto_prediv			0x64
+#define tempsen_top_reg_tempsen_auto_prediv_OFFSET		24
+#define tempsen_top_reg_tempsen_auto_prediv_MASK		0xff000000
+#define tempsen_top_reg_tempsen_overheat_cycle			0x68
+#define tempsen_top_reg_tempsen_overheat_cycle_OFFSET		0
+#define tempsen_top_reg_tempsen_overheat_cycle_MASK		0x3fffffff
+#define tempsen_top_reg_overheat_reset_clr			0x68
+#define tempsen_top_reg_overheat_reset_clr_OFFSET		30
+#define tempsen_top_reg_overheat_reset_clr_MASK			0x40000000
+#define tempsen_top_reg_overheat_reset_en			0x68
+#define tempsen_top_reg_overheat_reset_en_OFFSET		31
+#define tempsen_top_reg_overheat_reset_en_MASK			0x80000000
+#define tempsen_top_sta_tempsen_overheat_countdown		0x6c
+#define tempsen_top_sta_tempsen_overheat_countdown_OFFSET	0
+#define tempsen_top_sta_tempsen_overheat_countdown_MASK		0x3fffffff
+#define tempsen_top_sta_overheat_reset				0x6c
+#define tempsen_top_sta_overheat_reset_OFFSET			31
+#define tempsen_top_sta_overheat_reset_MASK			0x80000000
+#define tempsen_top_sta_ch0_over_hi_temp_th_cnt			0x70
+#define tempsen_top_sta_ch0_over_hi_temp_th_cnt_OFFSET		0
+#define tempsen_top_sta_ch0_over_hi_temp_th_cnt_MASK		0xff
+#define tempsen_top_sta_ch0_under_lo_temp_th_cnt		0x70
+#define tempsen_top_sta_ch0_under_lo_temp_th_cnt_OFFSET		8
+#define tempsen_top_sta_ch0_under_lo_temp_th_cnt_MASK		0xff00
+#define tempsen_top_reg_ch0_temp_th_cnt_clr			0x70
+#define tempsen_top_reg_ch0_temp_th_cnt_clr_OFFSET		16
+#define tempsen_top_reg_ch0_temp_th_cnt_clr_MASK		0x10000
+#define tempsen_top_sta_ch1_over_hi_temp_th_cnt			0x74
+#define tempsen_top_sta_ch1_over_hi_temp_th_cnt_OFFSET		0
+#define tempsen_top_sta_ch1_over_hi_temp_th_cnt_MASK		0xff
+#define tempsen_top_sta_ch1_under_lo_temp_th_cnt		0x74
+#define tempsen_top_sta_ch1_under_lo_temp_th_cnt_OFFSET		8
+#define tempsen_top_sta_ch1_under_lo_temp_th_cnt_MASK		0xff00
+#define tempsen_top_reg_ch1_temp_th_cnt_clr			0x74
+#define tempsen_top_reg_ch1_temp_th_cnt_clr_OFFSET		16
+#define tempsen_top_reg_ch1_temp_th_cnt_clr_MASK		0x10000
+#define tempsen_top_sta_ch2_over_hi_temp_th_cnt			0x78
+#define tempsen_top_sta_ch2_over_hi_temp_th_cnt_OFFSET		0
+#define tempsen_top_sta_ch2_over_hi_temp_th_cnt_MASK		0xff
+#define tempsen_top_sta_ch2_under_lo_temp_th_cnt		0x78
+#define tempsen_top_sta_ch2_under_lo_temp_th_cnt_OFFSET		8
+#define tempsen_top_sta_ch2_under_lo_temp_th_cnt_MASK		0xff00
+#define tempsen_top_reg_ch2_temp_th_cnt_clr			0x78
+#define tempsen_top_reg_ch2_temp_th_cnt_clr_OFFSET		16
+#define tempsen_top_reg_ch2_temp_th_cnt_clr_MASK		0x10000
+#define tempsen_top_sta_ch3_over_hi_temp_th_cnt			0x7c
+#define tempsen_top_sta_ch3_over_hi_temp_th_cnt_OFFSET		0
+#define tempsen_top_sta_ch3_over_hi_temp_th_cnt_MASK		0xff
+#define tempsen_top_sta_ch3_under_lo_temp_th_cnt		0x7c
+#define tempsen_top_sta_ch3_under_lo_temp_th_cnt_OFFSET		8
+#define tempsen_top_sta_ch3_under_lo_temp_th_cnt_MASK		0xff00
+#define tempsen_top_reg_ch3_temp_th_cnt_clr			0x7c
+#define tempsen_top_reg_ch3_temp_th_cnt_clr_OFFSET		16
+#define tempsen_top_reg_ch3_temp_th_cnt_clr_MASK		0x10000
+#define tempsen_top_reg_tempsen_force_result			0x80
+#define tempsen_top_reg_tempsen_force_result_OFFSET		0
+#define tempsen_top_reg_tempsen_force_result_MASK		0x1fff
+#define tempsen_top_reg_tempsen_force_valid			0x80
+#define tempsen_top_reg_tempsen_force_valid_OFFSET		13
+#define tempsen_top_reg_tempsen_force_valid_MASK		0x2000
+#define tempsen_top_reg_tempsen_force_busy			0x80
+#define tempsen_top_reg_tempsen_force_busy_OFFSET		14
+#define tempsen_top_reg_tempsen_force_busy_MASK			0x4000
+#define tempsen_top_reg_tempsen_force_en			0x80
+#define tempsen_top_reg_tempsen_force_en_OFFSET			15
+#define tempsen_top_reg_tempsen_force_en_MASK			0x8000
+
+#define TEMPSEN_MASK(REG_NAME) tempsen_top_##REG_NAME##_MASK
+#define TEMPSEN_OFFSET(REG_NAME) tempsen_top_##REG_NAME##_OFFSET
+#define TEMPSEN_SET(BASE_ADDR, REG_NAME, VAL) \
+	clrsetbits(BASE_ADDR + tempsen_top_##REG_NAME, \
+	TEMPSEN_MASK(REG_NAME), (VAL) << TEMPSEN_OFFSET(REG_NAME))
+#define TEMPSEN_GET(BASE_ADDR, REG_NAME) \
+	((readl(BASE_ADDR + tempsen_top_##REG_NAME) & \
+	TEMPSEN_MASK(REG_NAME)) >> TEMPSEN_OFFSET(REG_NAME))
+
+static void __maybe_unused clrsetbits(void __iomem *reg, u32 clrval, u32 setval)
+{
+	u32 regval;
+
+	regval = readl(reg);
+	regval &= ~(clrval);
+	regval |= setval;
+	writel(regval, reg);
+}
+
+struct cv1835_thermal_zone {
+	unsigned int ch;
+	void __iomem *base;
+	struct cv1835_thermal *ct;
+};
+
+struct cv1835_thermal {
+	struct device *dev;
+	void __iomem *base;
+	struct clk *clk_tempsen;
+};
+
+static void cv1835_thermal_init(struct cv1835_thermal *ct)
+{
+	void __iomem *base = ct->base;
+	u32 regval;
+
+	/* clear all interrupt status */
+	regval = TEMPSEN_GET(base, sta_tempsen_intr_raw);
+	TEMPSEN_SET(base, sta_tempsen_intr_clr, regval);
+
+	/* clear max result */
+	TEMPSEN_SET(base, clr_tempsen_ch0_max_result, 1);
+	TEMPSEN_SET(base, clr_tempsen_ch1_max_result, 1);
+
+	/* set chop period to 3:1024T */
+	TEMPSEN_SET(base, reg_tempsen_chopsel, 0x3);
+
+	/* set acc period to 2:2048T*/
+	TEMPSEN_SET(base, reg_tempsen_accsel, 0x2);
+
+	/* set tempsen clock divider to 25M/(0x31+1)= 0.5M ,T=2us */
+	TEMPSEN_SET(base, reg_tempsen_cyc_clkdiv, 0x31);
+
+	/* set reg_tempsen_auto_cycle */
+	TEMPSEN_SET(base, reg_tempsen_auto_cycle, 0x100000);
+
+	/* enable tempsen channel */
+	TEMPSEN_SET(base, reg_tempsen_sel, 0x3);
+	TEMPSEN_SET(base, reg_tempsen_en, 1);
+}
+
+static void cv1835_thermal_uninit(struct cv1835_thermal *ct)
+{
+	void __iomem *base = ct->base;
+	u32 regval;
+
+	/* disable all tempsen channel */
+	TEMPSEN_SET(base, reg_tempsen_sel, 0);
+	TEMPSEN_SET(base, reg_tempsen_en, 0);
+
+	/* clear all interrupt status */
+	regval = TEMPSEN_GET(base, sta_tempsen_intr_raw);
+	TEMPSEN_SET(base, sta_tempsen_intr_clr, regval);
+}
+
+static int calc_temp(uint32_t result)
+{
+	return ((result * 1000) * 716 / 2048 - 273000);
+
+	/* Original calculation formula */
+	// return ((result * 1000) / 2048 * 716 - 273000);
+}
+
+static int cv1835_read_temp(void *data, int *temperature)
+{
+	struct cv1835_thermal_zone *ctz = data;
+	void __iomem *base = ctz->base;
+	unsigned int ch = ctz->ch;
+	u32 result;
+
+	/* read temperature */
+	switch (ch) {
+	case 0:
+		result = TEMPSEN_GET(base, sta_tempsen_ch0_result); break;
+	case 1:
+		result = TEMPSEN_GET(base, sta_tempsen_ch1_result); break;
+	default:
+		result = 0;
+	}
+	*temperature = calc_temp(result);
+	pr_debug("ch%d temp = %d mC(0x%x)\n", ch, *temperature, result);
+
+	return 0;
+}
+
+static const struct thermal_zone_of_device_ops cv1835_thermal_ops = {
+	.get_temp = cv1835_read_temp,
+};
+
+static const struct of_device_id cv1835_thermal_of_match[] = {
+	{
+		.compatible = "cvitek,cv1835-thermal",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, cv1835_thermal_of_match);
+
+static int cv1835_thermal_probe(struct platform_device *pdev)
+{
+	struct cv1835_thermal *ct;
+	struct cv1835_thermal_zone *ctz;
+	struct resource *res;
+	struct thermal_zone_device *tz;
+	int i;
+
+	ct = devm_kzalloc(&pdev->dev, sizeof(*ct), GFP_KERNEL);
+	if (!ct)
+		return -ENOMEM;
+
+	ct->clk_tempsen = devm_clk_get(&pdev->dev, "clk_tempsen");
+	if (IS_ERR(ct->clk_tempsen)) {
+		dev_err(&pdev->dev, "failed to get clk_tempsen\n");
+		return PTR_ERR(ct->clk_tempsen);
+	}
+
+	/* enable clk_tempsen */
+	clk_prepare_enable(ct->clk_tempsen);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	ct->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(ct->base)) {
+		dev_err(&pdev->dev, "failed to map tempsen registers\n");
+		return PTR_ERR(ct->base);
+	}
+
+	ct->dev = &pdev->dev;
+
+	cv1835_thermal_init(ct);
+
+	platform_set_drvdata(pdev, ct);
+
+	for (i = 0; i < 2; i++) {
+		ctz = devm_kzalloc(&pdev->dev, sizeof(*ctz), GFP_KERNEL);
+		if (!ctz)
+			return -ENOMEM;
+
+		ctz->base = ct->base;
+		ctz->ct = ct;
+		ctz->ch = i;
+		tz = devm_thermal_zone_of_sensor_register(&pdev->dev, i, ctz,
+							  &cv1835_thermal_ops);
+		if (IS_ERR(tz)) {
+			dev_err(&pdev->dev, "failed to register thermal zone %d\n", i);
+			return PTR_ERR(tz);
+		}
+	}
+
+	return 0;
+}
+
+static int cv1835_thermal_remove(struct platform_device *pdev)
+{
+	struct cv1835_thermal *ct = platform_get_drvdata(pdev);
+
+	cv1835_thermal_uninit(ct);
+
+	clk_disable_unprepare(ct->clk_tempsen);
+
+	return 0;
+}
+
+static struct platform_driver cv1835_thermal_driver = {
+	.probe = cv1835_thermal_probe,
+	.remove = cv1835_thermal_remove,
+	.driver = {
+		.name = "cv1835-thermal",
+		.of_match_table = cv1835_thermal_of_match,
+	},
+};
+
+module_platform_driver(cv1835_thermal_driver);
+MODULE_DESCRIPTION("CV1835 thermal driver");
diff --git a/drivers/thermal/thermal_core.c b/drivers/thermal/thermal_core.c
index dd449945e1e5..df8da637e923 100644
--- a/drivers/thermal/thermal_core.c
+++ b/drivers/thermal/thermal_core.c
@@ -432,8 +432,15 @@ static void handle_thermal_trip(struct thermal_zone_device *tz, int trip)
 		    tz->temperature >= trip_temp)
 			thermal_notify_tz_trip_up(tz->id, trip);
 		if (tz->last_temperature >= trip_temp &&
-		    tz->temperature < (trip_temp - hyst))
+			tz->temperature < (trip_temp - hyst)) {
 			thermal_notify_tz_trip_down(tz->id, trip);
+			} else if (tz->last_temperature >= (trip_temp + hyst) &&
+			(tz->temperature < trip_temp + hyst) && (trip == 0) && (tz->last_temperature != tz->temperature)) {
+				thermal_notify_tz_trip_down(tz->id, trip + 1);
+			} else if (tz->last_temperature >= (trip_temp - hyst) &&
+			(tz->temperature < trip_temp - hyst) && (trip == 0) && (tz->last_temperature != tz->temperature)) {
+				thermal_notify_tz_trip_down(tz->id, trip);
+			}
 	}
 
 	if (type == THERMAL_TRIP_CRITICAL || type == THERMAL_TRIP_HOT)
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 26475b409b53..84390e9a2be0 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -125,6 +125,43 @@ source "drivers/usb/chipidea/Kconfig"
 
 source "drivers/usb/isp1760/Kconfig"
 
+config USB_CVITEK_DRD
+	tristate "Cvitek USB DRD Core Support"
+	depends on USB && HAS_DMA
+	select USB_XHCI_PLATFORM if USB_SUPPORT && USB_XHCI_HCD
+	help
+	  Say Y or M here if your system has a Dual Role SuperSpeed
+	  USB controller based on the Cvitek USB3 IP Core.
+
+	  If you choose to build this driver is a dynamically linked
+	  module, the module will be called cviusb_drd.ko.
+
+if USB_CVITEK_DRD
+
+config USB_CVITEK_MISC
+	bool "Additional miscellaneous device for ioctl"
+	depends on (USB=y || USB=USB_CVITEK_DRD)
+	help
+	  Select this if you want to send commands to driver
+	  using I/O control.
+
+	  The miscellaneous function includes the drd state
+	  configuration and gadget standby mode.
+
+endif
+
+config USB_CVITEK_GADGET
+	tristate "Cvitek device controller"
+	depends on USB_GADGET
+	help
+	  Bitmain device controller driver for CV183X.
+	  BM1880 USB device can support USB 2.0 high speed.
+
+	  Say 'Y' or 'M' here to enable device controller functionality
+	  of the Cvitek driver.
+
+comment "Platform Glue Driver Support"
+
 comment "USB port drivers"
 
 if USB
diff --git a/drivers/usb/common/Makefile b/drivers/usb/common/Makefile
index 8ac4d21ef5c8..8c50818a41f8 100644
--- a/drivers/usb/common/Makefile
+++ b/drivers/usb/common/Makefile
@@ -9,5 +9,10 @@ usb-common-$(CONFIG_TRACING)	  += debug.o
 usb-common-$(CONFIG_USB_LED_TRIG) += led.o
 
 obj-$(CONFIG_USB_CONN_GPIO)	+= usb-conn-gpio.o
+ifeq ($(CONFIG_CVITEK_USB_LEGACY),y)
+usbotg-y		:= usb-otg.o usb-otg-fsm.o
+obj-$(CONFIG_USB_OTG)	+= usbotg.o
+else
 obj-$(CONFIG_USB_OTG_FSM) += usb-otg-fsm.o
+endif
 obj-$(CONFIG_USB_ULPI_BUS)	+= ulpi.o
diff --git a/drivers/usb/common/usb-otg.c b/drivers/usb/common/usb-otg.c
new file mode 100644
index 000000000000..203f053c716f
--- /dev/null
+++ b/drivers/usb/common/usb-otg.c
@@ -0,0 +1,1257 @@
+/**
+ * drivers/usb/common/usb-otg.c - USB OTG core
+ *
+ * Copyright (C) 2015 Texas Instruments Incorporated - http://www.ti.com
+ * Author: Roger Quadros <rogerq@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/ktime.h>
+#include <linux/hrtimer.h>
+#include <linux/list.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/phy.h>	/* enum usb_otg_state */
+#include <linux/usb/gadget.h>
+#include <linux/workqueue.h>
+
+#include "usb-otg.h"
+
+#define DEBUG
+
+struct otg_gcd {
+	struct usb_gadget *gadget;
+	struct otg_gadget_ops *ops;
+};
+
+/* OTG device list */
+LIST_HEAD(otg_list);
+static DEFINE_MUTEX(otg_list_mutex);
+
+/* Hosts and Gadgets waiting for OTG controller */
+struct otg_wait_data {
+	struct device *dev;		/* OTG controller device */
+
+	struct otg_hcd primary_hcd;
+	struct otg_hcd shared_hcd;
+	struct otg_gcd gcd;
+	struct list_head list;
+};
+
+LIST_HEAD(wait_list);
+static DEFINE_MUTEX(wait_list_mutex);
+
+static int usb_otg_hcd_is_primary_hcd(struct usb_hcd *hcd)
+{
+	if (!hcd->primary_hcd)
+		return 1;
+	return hcd == hcd->primary_hcd;
+}
+
+/**
+ * Check if the OTG device is in our wait list and return
+ * otg_wait_data, else NULL.
+ *
+ * wait_list_mutex must be held.
+ */
+static struct otg_wait_data *usb_otg_get_wait(struct device *otg_dev)
+{
+	struct otg_wait_data *wait;
+
+	if (!otg_dev)
+		return NULL;
+
+	/* is there an entry for this otg_dev ?*/
+	list_for_each_entry(wait, &wait_list, list) {
+		if (wait->dev == otg_dev)
+			return wait;
+	}
+
+	return NULL;
+}
+
+/**
+ * Add the hcd to our wait list
+ */
+static int usb_otg_hcd_wait_add(struct device *otg_dev, struct usb_hcd *hcd,
+				unsigned int irqnum, unsigned long irqflags,
+				struct otg_hcd_ops *ops)
+{
+	struct otg_wait_data *wait;
+	int ret = -EINVAL;
+
+	mutex_lock(&wait_list_mutex);
+
+	wait = usb_otg_get_wait(otg_dev);
+	if (!wait) {
+		/* Not yet in wait list? allocate and add */
+		wait = kzalloc(sizeof(*wait), GFP_KERNEL);
+		if (!wait) {
+			ret = -ENOMEM;
+			goto fail;
+		}
+
+		wait->dev = otg_dev;
+		list_add_tail(&wait->list, &wait_list);
+	}
+
+	if (usb_otg_hcd_is_primary_hcd(hcd)) {
+		if (wait->primary_hcd.hcd)	/* already assigned? */
+			goto fail;
+
+		wait->primary_hcd.hcd = hcd;
+		wait->primary_hcd.irqnum = irqnum;
+		wait->primary_hcd.irqflags = irqflags;
+		wait->primary_hcd.ops = ops;
+	} else {
+		if (wait->shared_hcd.hcd)	/* already assigned? */
+			goto fail;
+
+		wait->shared_hcd.hcd = hcd;
+		wait->shared_hcd.irqnum = irqnum;
+		wait->shared_hcd.irqflags = irqflags;
+		wait->shared_hcd.ops = ops;
+	}
+
+	mutex_unlock(&wait_list_mutex);
+	return 0;
+
+fail:
+	mutex_unlock(&wait_list_mutex);
+	return ret;
+}
+
+/**
+ * Check and free wait list entry if empty
+ *
+ * wait_list_mutex must be held
+ */
+static void usb_otg_check_free_wait(struct otg_wait_data *wait)
+{
+	if (wait->primary_hcd.hcd || wait->shared_hcd.hcd || wait->gcd.gadget)
+		return;
+
+	list_del(&wait->list);
+	kfree(wait);
+}
+
+/**
+ * Remove the hcd from our wait list
+ */
+static int usb_otg_hcd_wait_remove(struct usb_hcd *hcd)
+{
+	struct otg_wait_data *wait;
+
+	mutex_lock(&wait_list_mutex);
+
+	/* is there an entry for this hcd ?*/
+	list_for_each_entry(wait, &wait_list, list) {
+		if (wait->primary_hcd.hcd == hcd) {
+			wait->primary_hcd.hcd = 0;
+			goto found;
+		} else if (wait->shared_hcd.hcd == hcd) {
+			wait->shared_hcd.hcd = 0;
+			goto found;
+		}
+	}
+
+	mutex_unlock(&wait_list_mutex);
+	return -EINVAL;
+
+found:
+	usb_otg_check_free_wait(wait);
+	mutex_unlock(&wait_list_mutex);
+
+	return 0;
+}
+
+/**
+ * Add the gadget to our wait list
+ */
+static int usb_otg_gadget_wait_add(struct device *otg_dev,
+				   struct usb_gadget *gadget,
+				   struct otg_gadget_ops *ops)
+{
+	struct otg_wait_data *wait;
+	int ret = -EINVAL;
+
+	mutex_lock(&wait_list_mutex);
+
+	wait = usb_otg_get_wait(otg_dev);
+	if (!wait) {
+		/* Not yet in wait list? allocate and add */
+		wait = kzalloc(sizeof(*wait), GFP_KERNEL);
+		if (!wait) {
+			ret = -ENOMEM;
+			goto fail;
+		}
+
+		wait->dev = otg_dev;
+		list_add_tail(&wait->list, &wait_list);
+	}
+
+	if (wait->gcd.gadget) /* already assigned? */
+		goto fail;
+
+	wait->gcd.gadget = gadget;
+	wait->gcd.ops = ops;
+	mutex_unlock(&wait_list_mutex);
+
+	return 0;
+
+fail:
+	mutex_unlock(&wait_list_mutex);
+	return ret;
+}
+
+/**
+ * Remove the gadget from our wait list
+ */
+static int usb_otg_gadget_wait_remove(struct usb_gadget *gadget)
+{
+	struct otg_wait_data *wait;
+
+	mutex_lock(&wait_list_mutex);
+
+	/* is there an entry for this gadget ?*/
+	list_for_each_entry(wait, &wait_list, list) {
+		if (wait->gcd.gadget == gadget) {
+			wait->gcd.gadget = 0;
+			goto found;
+		}
+	}
+
+	mutex_unlock(&wait_list_mutex);
+
+	return -EINVAL;
+
+found:
+	usb_otg_check_free_wait(wait);
+	mutex_unlock(&wait_list_mutex);
+
+	return 0;
+}
+
+/**
+ * Register pending host/gadget and remove entry from wait list
+ */
+static void usb_otg_flush_wait(struct device *otg_dev)
+{
+	struct otg_wait_data *wait;
+	struct otg_hcd *host;
+	struct otg_gcd *gadget;
+
+	mutex_lock(&wait_list_mutex);
+
+	wait = usb_otg_get_wait(otg_dev);
+	if (!wait)
+		goto done;
+
+	dev_dbg(otg_dev, "otg: registering pending host/gadget\n");
+	gadget = &wait->gcd;
+	if (gadget->gadget)
+		usb_otg_register_gadget(gadget->gadget, gadget->ops);
+
+	host = &wait->primary_hcd;
+	if (host->hcd)
+		usb_otg_register_hcd(host->hcd, host->irqnum, host->irqflags,
+				     host->ops);
+
+	host = &wait->shared_hcd;
+	if (host->hcd)
+		usb_otg_register_hcd(host->hcd, host->irqnum, host->irqflags,
+				     host->ops);
+
+	list_del(&wait->list);
+	kfree(wait);
+
+done:
+	mutex_unlock(&wait_list_mutex);
+}
+
+/**
+ * Check if the OTG device is in our OTG list and return
+ * usb_otg data, else NULL.
+ *
+ * otg_list_mutex must be held.
+ */
+static struct usb_otg *usb_otg_get_data(struct device *otg_dev)
+{
+	struct usb_otg *otgd;
+
+	if (!otg_dev)
+		return NULL;
+
+	list_for_each_entry(otgd, &otg_list, list) {
+		if (otgd->dev == otg_dev)
+			return otgd;
+	}
+
+	return NULL;
+}
+
+/**
+ * Get OTG device from host or gadget device.
+ *
+ * For non device tree boot, the OTG controller is assumed to be
+ * the parent of the host/gadget device.
+ * For device tree boot, the OTG controller is derived from the
+ * "otg-controller" property.
+ */
+static struct device *usb_otg_get_device(struct device *hcd_gcd_dev)
+{
+	struct device *otg_dev;
+
+	if (!hcd_gcd_dev)
+		return NULL;
+
+	// TODO: workaround for gadget, ex: g_mass_storage->parent is ucd device.
+	if (!hcd_gcd_dev->of_node)
+		hcd_gcd_dev = hcd_gcd_dev->parent;
+
+	if (hcd_gcd_dev->of_node) {
+		struct device_node *np;
+		struct platform_device *pdev;
+
+		np = of_parse_phandle(hcd_gcd_dev->of_node, "otg-controller",
+				      0);
+		if (!np)
+			goto legacy;	/* continue legacy way */
+
+		pdev = of_find_device_by_node(np);
+		of_node_put(np);
+		if (!pdev) {
+			dev_err(&pdev->dev, "couldn't get otg-controller device\n");
+			return NULL;
+		}
+
+		otg_dev = &pdev->dev;
+		return otg_dev;
+	}
+
+legacy:
+	/* otg device is parent and must be registered */
+	otg_dev = hcd_gcd_dev->parent;
+	if (!usb_otg_get_data(otg_dev))
+		return NULL;
+
+	return otg_dev;
+}
+
+/**
+ * timer callback to set timeout bit and kick FSM
+ */
+static enum hrtimer_restart set_tmout(struct hrtimer *data)
+{
+	struct otg_timer *otgtimer;
+
+	otgtimer = container_of(data, struct otg_timer, timer);
+	if (otgtimer->timeout_bit)
+		*otgtimer->timeout_bit = 1;
+
+	usb_otg_sync_inputs(&otgtimer->otgd->fsm);
+
+	return HRTIMER_NORESTART;
+}
+
+/**
+ * Initialize one OTG timer with callback, timeout and timeout bit
+ */
+static void otg_timer_init(enum otg_fsm_timer id, struct usb_otg *otgd,
+			   enum hrtimer_restart (*callback)(struct hrtimer *),
+			   unsigned long expires_ms,
+			   int *timeout_bit)
+{
+	struct otg_timer *otgtimer = &otgd->timers[id];
+	struct hrtimer *timer = &otgtimer->timer;
+
+	otgtimer->timeout = ms_to_ktime(expires_ms);
+	hrtimer_init(timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	timer->function = callback;
+
+	otgtimer->timeout_bit = timeout_bit;
+	otgtimer->otgd = otgd;
+}
+
+/**
+ * Initialize standard OTG timers
+ */
+static void usb_otg_init_timers(struct usb_otg *otgd, unsigned int *timeouts)
+{
+	struct otg_fsm *fsm = &otgd->fsm;
+	unsigned long tmouts[NUM_OTG_FSM_TIMERS];
+	int i;
+
+	/* set default timeouts */
+	tmouts[A_WAIT_VRISE] = TA_WAIT_VRISE;
+	tmouts[A_WAIT_VFALL] = TA_WAIT_VFALL;
+	tmouts[A_WAIT_BCON] = TA_WAIT_BCON;
+	tmouts[A_AIDL_BDIS] = TA_AIDL_BDIS;
+	tmouts[A_BIDL_ADIS] = TA_BIDL_ADIS;
+	tmouts[B_ASE0_BRST] = TB_ASE0_BRST;
+	tmouts[B_SE0_SRP] = TB_SE0_SRP;
+	tmouts[B_SRP_FAIL] = TB_SRP_FAIL;
+
+	/* set controller provided timeouts */
+	if (timeouts) {
+		for (i = 0; i < NUM_OTG_FSM_TIMERS; i++) {
+			if (timeouts[i])
+				tmouts[i] = timeouts[i];
+		}
+	}
+
+	otg_timer_init(A_WAIT_VRISE, otgd, set_tmout, TA_WAIT_VRISE,
+		       &fsm->a_wait_vrise_tmout);
+	otg_timer_init(A_WAIT_VFALL, otgd, set_tmout, TA_WAIT_VFALL,
+		       &fsm->a_wait_vfall_tmout);
+	otg_timer_init(A_WAIT_BCON, otgd, set_tmout, TA_WAIT_BCON,
+		       &fsm->a_wait_bcon_tmout);
+	otg_timer_init(A_AIDL_BDIS, otgd, set_tmout, TA_AIDL_BDIS,
+		       &fsm->a_aidl_bdis_tmout);
+	otg_timer_init(A_BIDL_ADIS, otgd, set_tmout, TA_BIDL_ADIS,
+		       &fsm->a_bidl_adis_tmout);
+	otg_timer_init(B_ASE0_BRST, otgd, set_tmout, TB_ASE0_BRST,
+		       &fsm->b_ase0_brst_tmout);
+
+	otg_timer_init(B_SE0_SRP, otgd, set_tmout, TB_SE0_SRP,
+		       &fsm->b_se0_srp);
+	otg_timer_init(B_SRP_FAIL, otgd, set_tmout, TB_SRP_FAIL,
+		       &fsm->b_srp_done);
+
+	/* FIXME: what about A_WAIT_ENUM? */
+}
+
+/**
+ * OTG FSM ops function to add timer
+ */
+static void usb_otg_add_timer(struct otg_fsm *fsm, enum otg_fsm_timer id)
+{
+	struct usb_otg *otgd = container_of(fsm, struct usb_otg, fsm);
+	struct otg_timer *otgtimer = &otgd->timers[id];
+	struct hrtimer *timer = &otgtimer->timer;
+
+	if (!otgd->fsm_running)
+		return;
+
+	/* if timer is already active, exit */
+	if (hrtimer_active(timer)) {
+		dev_err(otgd->dev, "otg: timer %d is already running\n", id);
+		return;
+	}
+
+	hrtimer_start(timer, otgtimer->timeout, HRTIMER_MODE_REL);
+}
+
+/**
+ * OTG FSM ops function to delete timer
+ */
+static void usb_otg_del_timer(struct otg_fsm *fsm, enum otg_fsm_timer id)
+{
+	struct usb_otg *otgd = container_of(fsm, struct usb_otg, fsm);
+	struct hrtimer *timer = &otgd->timers[id].timer;
+
+	hrtimer_cancel(timer);
+}
+
+/**
+ * Helper function to start/stop otg host. For use by otg controller.
+ */
+int usb_otg_start_host(struct otg_fsm *fsm, int on)
+{
+	struct usb_otg *otgd = container_of(fsm, struct usb_otg, fsm);
+	struct otg_hcd_ops *hcd_ops;
+
+	dev_err(otgd->dev, "otg: %s %d\n", __func__, on);
+	if (!fsm->otg->host) {
+		WARN_ONCE(1, "otg: fsm running without host\n");
+		return 0;
+	}
+
+	if (on) {
+		if (otgd->flags & OTG_FLAG_HOST_RUNNING)
+			return 0;
+
+		otgd->flags |= OTG_FLAG_HOST_RUNNING;
+
+		/* start host */
+		hcd_ops = otgd->primary_hcd.ops;
+		hcd_ops->add(otgd->primary_hcd.hcd, otgd->primary_hcd.irqnum,
+			     otgd->primary_hcd.irqflags);
+		if (otgd->shared_hcd.hcd) {
+			hcd_ops = otgd->shared_hcd.ops;
+			hcd_ops->add(otgd->shared_hcd.hcd,
+				     otgd->shared_hcd.irqnum,
+				     otgd->shared_hcd.irqflags);
+		}
+	} else {
+		if (!(otgd->flags & OTG_FLAG_HOST_RUNNING))
+			return 0;
+
+		otgd->flags &= ~OTG_FLAG_HOST_RUNNING;
+
+		/* stop host */
+		if (otgd->shared_hcd.hcd) {
+			hcd_ops = otgd->shared_hcd.ops;
+			hcd_ops->remove(otgd->shared_hcd.hcd);
+		}
+		hcd_ops = otgd->primary_hcd.ops;
+		hcd_ops->remove(otgd->primary_hcd.hcd);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_otg_start_host);
+
+/**
+ * Helper function to start/stop otg gadget. For use by otg controller.
+ */
+int usb_otg_start_gadget(struct otg_fsm *fsm, int on)
+{
+	struct usb_otg *otgd = container_of(fsm, struct usb_otg, fsm);
+	struct usb_gadget *gadget = fsm->otg->gadget;
+
+	dev_dbg(otgd->dev, "otg: %s %d\n", __func__, on);
+	if (!gadget) {
+		WARN_ONCE(1, "otg: fsm running without gadget\n");
+		return 0;
+	}
+
+	if (on) {
+		if (otgd->flags & OTG_FLAG_GADGET_RUNNING)
+			return 0;
+
+		otgd->flags |= OTG_FLAG_GADGET_RUNNING;
+		otgd->gadget_ops->start(fsm->otg->gadget);
+	} else {
+		if (!(otgd->flags & OTG_FLAG_GADGET_RUNNING))
+			return 0;
+
+		otgd->flags &= ~OTG_FLAG_GADGET_RUNNING;
+		otgd->gadget_ops->stop(fsm->otg->gadget);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_otg_start_gadget);
+
+/* Change USB protocol when there is a protocol change */
+static int drd_set_protocol(struct otg_fsm *fsm, int protocol)
+{
+	struct usb_otg *otgd = container_of(fsm, struct usb_otg, fsm);
+	int ret = 0;
+
+	if (fsm->protocol != protocol) {
+		dev_dbg(otgd->dev, "otg: changing role fsm->protocol= %d; new protocol= %d\n",
+			fsm->protocol, protocol);
+		/* stop old protocol */
+		if (fsm->protocol == PROTO_HOST)
+			ret = otg_start_host(fsm, 0);
+		else if (fsm->protocol == PROTO_GADGET)
+			ret = otg_start_gadget(fsm, 0);
+		if (ret)
+			return ret;
+
+		/* start new protocol */
+		if (protocol == PROTO_HOST)
+			ret = otg_start_host(fsm, 1);
+		else if (protocol == PROTO_GADGET)
+			ret = otg_start_gadget(fsm, 1);
+		if (ret)
+			return ret;
+
+		fsm->protocol = protocol;
+		return 0;
+	}
+
+	return 0;
+}
+
+/* Called when entering a DRD state */
+static void drd_set_state(struct otg_fsm *fsm, enum usb_otg_state new_state)
+{
+	struct usb_otg *otgd = container_of(fsm, struct usb_otg, fsm);
+
+	if (fsm->otg->state == new_state)
+		return;
+
+	fsm->state_changed = 1;
+	dev_dbg(otgd->dev, "otg: set state: %s\n",
+		usb_otg_state_string(new_state));
+	switch (new_state) {
+	case OTG_STATE_B_IDLE:
+		drd_set_protocol(fsm, PROTO_UNDEF);
+		break;
+	case OTG_STATE_B_PERIPHERAL:
+		drd_set_protocol(fsm, PROTO_GADGET);
+		break;
+	case OTG_STATE_A_HOST:
+		drd_set_protocol(fsm, PROTO_HOST);
+		break;
+	case OTG_STATE_UNDEFINED:
+	case OTG_STATE_B_SRP_INIT:
+	case OTG_STATE_B_WAIT_ACON:
+	case OTG_STATE_B_HOST:
+	case OTG_STATE_A_IDLE:
+	case OTG_STATE_A_WAIT_VRISE:
+	case OTG_STATE_A_WAIT_BCON:
+	case OTG_STATE_A_SUSPEND:
+	case OTG_STATE_A_PERIPHERAL:
+	case OTG_STATE_A_WAIT_VFALL:
+	case OTG_STATE_A_VBUS_ERR:
+	default:
+		dev_warn(otgd->dev, "%s: otg: invalid state: %s\n",
+			 __func__, usb_otg_state_string(new_state));
+		break;
+	}
+
+	fsm->otg->state = new_state;
+}
+
+/**
+ * DRD state change judgement
+ *
+ * For DRD we're only interested in some of the OTG states
+ * i.e. OTG_STATE_B_IDLE: both peripheral and host are stopped
+ *	OTG_STATE_B_PERIPHERAL: peripheral active
+ *	OTG_STATE_A_HOST: host active
+ * we're only interested in the following inputs
+ *	fsm->id, fsm->b_sess_vld
+ */
+static int drd_statemachine(struct otg_fsm *fsm)
+{
+	struct usb_otg *otgd = container_of(fsm, struct usb_otg, fsm);
+	enum usb_otg_state state;
+
+	mutex_lock(&fsm->lock);
+
+	state = fsm->otg->state;
+
+	switch (state) {
+	case OTG_STATE_UNDEFINED:
+		if (!fsm->id)
+			drd_set_state(fsm, OTG_STATE_A_HOST);
+		else if (fsm->id && fsm->b_sess_vld)
+			drd_set_state(fsm, OTG_STATE_B_PERIPHERAL);
+		else
+			drd_set_state(fsm, OTG_STATE_B_IDLE);
+		break;
+	case OTG_STATE_B_IDLE:
+		if (!fsm->id)
+			drd_set_state(fsm, OTG_STATE_A_HOST);
+		else if (fsm->b_sess_vld)
+			drd_set_state(fsm, OTG_STATE_B_PERIPHERAL);
+		break;
+	case OTG_STATE_B_PERIPHERAL:
+		if (!fsm->id)
+			drd_set_state(fsm, OTG_STATE_A_HOST);
+		else if (!fsm->b_sess_vld)
+			drd_set_state(fsm, OTG_STATE_B_IDLE);
+		break;
+	case OTG_STATE_A_HOST:
+		if (fsm->id && fsm->b_sess_vld)
+			drd_set_state(fsm, OTG_STATE_B_PERIPHERAL);
+		else if (fsm->id && !fsm->b_sess_vld)
+			drd_set_state(fsm, OTG_STATE_B_IDLE);
+		break;
+
+	/* invalid states for DRD */
+	case OTG_STATE_B_SRP_INIT:
+	case OTG_STATE_B_WAIT_ACON:
+	case OTG_STATE_B_HOST:
+	case OTG_STATE_A_IDLE:
+	case OTG_STATE_A_WAIT_VRISE:
+	case OTG_STATE_A_WAIT_BCON:
+	case OTG_STATE_A_SUSPEND:
+	case OTG_STATE_A_PERIPHERAL:
+	case OTG_STATE_A_WAIT_VFALL:
+	case OTG_STATE_A_EXIT_HNP:
+	case OTG_STATE_A_VBUS_ERR:
+		dev_err(otgd->dev, "%s: otg: invalid usb-drd state: %s\n",
+			__func__, usb_otg_state_string(state));
+		drd_set_state(fsm, OTG_STATE_UNDEFINED);
+	break;
+	}
+
+	mutex_unlock(&fsm->lock);
+	dev_dbg(otgd->dev, "%s otg: quit statemachine, changed %d\n",
+		__func__, fsm->state_changed);
+
+	return fsm->state_changed;
+}
+
+/**
+ * OTG FSM/DRD work function
+ */
+static void usb_otg_work(struct work_struct *work)
+{
+	struct usb_otg *otgd = container_of(work, struct usb_otg, work);
+
+	/* OTG state machine */
+	if (!otgd->drd_only) {
+		otg_statemachine(&otgd->fsm);
+		return;
+	}
+
+	/* DRD state machine */
+	drd_statemachine(&otgd->fsm);
+}
+
+/**
+ * usb_otg_register() - Register the OTG device to OTG core
+ * @dev: OTG controller device.
+ * @config: OTG configuration.
+ *
+ * Register the OTG controller device with the USB OTG core.
+ * The associated Host and Gadget controllers will be prevented from
+ * being started till both are available for use.
+ *
+ * For non device tree boots, the OTG controller device must be the
+ * parent node of the Host and Gadget controllers.
+ *
+ * For device tree case, the otg-controller property must be present
+ * in the Host and Gadget controller node and it must point to the
+ * same OTG controller node.
+ *
+ * Return: struct otg_fsm * if success, NULL if error.
+ */
+struct otg_fsm *usb_otg_register(struct device *dev,
+				 struct usb_otg_config *config,
+				 work_func_t usb_otg_specific_work)
+{
+	struct usb_otg *otgd;
+	struct otg_wait_data *wait;
+	int ret = 0;
+
+	if (!dev || !config || !config->fsm_ops)
+		return ERR_PTR(-EINVAL);
+
+	/* already in list? */
+	mutex_lock(&otg_list_mutex);
+	if (usb_otg_get_data(dev)) {
+		dev_err(dev, "otg: %s: device already in otg list\n",
+			__func__);
+		ret = -EINVAL;
+		goto unlock;
+	}
+
+	/* allocate and add to list */
+	otgd = kzalloc(sizeof(*otgd), GFP_KERNEL);
+	if (!otgd) {
+		ret = -ENOMEM;
+		goto unlock;
+	}
+
+	otgd->dev = dev;
+	otgd->caps = &config->otg_caps;
+	if (usb_otg_specific_work != NULL)
+		INIT_WORK(&otgd->work, usb_otg_specific_work);
+	else
+		INIT_WORK(&otgd->work, usb_otg_work);
+	otgd->wq = create_singlethread_workqueue("usb_otg");
+	if (!otgd->wq) {
+		dev_err(dev, "otg: %s: can't create workqueue\n",
+			__func__);
+		ret = -ENOMEM;
+		goto err_wq;
+	}
+
+	if (!(otgd->caps->hnp_support || otgd->caps->srp_support ||
+	      otgd->caps->adp_support))
+		otgd->drd_only = true;
+
+	/* create copy of original ops */
+	otgd->fsm_ops = *config->fsm_ops;
+
+	/* For DRD mode we don't need OTG timers */
+	if (!otgd->drd_only) {
+		usb_otg_init_timers(otgd, config->otg_timeouts);
+
+		/* FIXME: we ignore caller's timer ops */
+		otgd->fsm_ops.add_timer = usb_otg_add_timer;
+		otgd->fsm_ops.del_timer = usb_otg_del_timer;
+	}
+
+	/* set otg ops */
+	otgd->fsm.ops = &otgd->fsm_ops;
+	otgd->fsm.otg = otgd;
+
+	mutex_init(&otgd->fsm.lock);
+
+	list_add_tail(&otgd->list, &otg_list);
+	mutex_unlock(&otg_list_mutex);
+
+	/* were we in wait list? */
+	mutex_lock(&wait_list_mutex);
+	wait = usb_otg_get_wait(dev);
+	mutex_unlock(&wait_list_mutex);
+	if (wait) {
+		/* register pending host/gadget and flush from list */
+		usb_otg_flush_wait(dev);
+	}
+
+	return &otgd->fsm;
+
+err_wq:
+	kfree(otgd);
+unlock:
+	mutex_unlock(&otg_list_mutex);
+	return ERR_PTR(ret);
+}
+EXPORT_SYMBOL_GPL(usb_otg_register);
+
+/**
+ * usb_otg_unregister() - Unregister the OTG device from USB OTG core
+ * @dev: OTG controller device.
+ *
+ * Unregister OTG controller device from USB OTG core.
+ * Prevents unregistering till both the associated Host and Gadget controllers
+ * have unregistered from the OTG core.
+ *
+ * Return: 0 on success, error value otherwise.
+ */
+int usb_otg_unregister(struct device *dev)
+{
+	struct usb_otg *otgd;
+
+	mutex_lock(&otg_list_mutex);
+	otgd = usb_otg_get_data(dev);
+	if (!otgd) {
+		dev_err(dev, "otg: %s: device not in otg list\n",
+			__func__);
+		mutex_unlock(&otg_list_mutex);
+		return -EINVAL;
+	}
+
+	/* prevent unregister till both host & gadget have unregistered */
+	if (otgd->fsm.otg->host || otgd->fsm.otg->gadget) {
+		dev_err(dev, "otg: %s: host/gadget still registered\n",
+			__func__);
+		return -EBUSY;
+	}
+
+	/* OTG FSM is halted when host/gadget unregistered */
+	destroy_workqueue(otgd->wq);
+
+	/* remove from otg list */
+	list_del(&otgd->list);
+	kfree(otgd);
+	mutex_unlock(&otg_list_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_otg_unregister);
+
+/**
+ * start/kick the OTG FSM if we can
+ * fsm->lock must be held
+ */
+static void usb_otg_start_fsm(struct otg_fsm *fsm)
+{
+	struct usb_otg *otgd = container_of(fsm, struct usb_otg, fsm);
+
+	if (otgd->fsm_running)
+		goto kick_fsm;
+
+	if (!fsm->otg->host) {
+		dev_info(otgd->dev, "otg: can't start till host registers\n");
+		return;
+	}
+
+	if (!fsm->otg->gadget) {
+		dev_info(otgd->dev, "otg: can't start till gadget registers\n");
+		dev_info(otgd->dev, "TODO: install gadget!\n");
+		return;
+	}
+
+	otgd->fsm_running = true;
+kick_fsm:
+	queue_work(otgd->wq, &otgd->work);
+}
+
+/**
+ * stop the OTG FSM. Stops Host & Gadget controllers as well.
+ * fsm->lock must be held
+ */
+static void usb_otg_stop_fsm(struct otg_fsm *fsm)
+{
+	struct usb_otg *otgd = container_of(fsm, struct usb_otg, fsm);
+	int i;
+
+	if (!otgd->fsm_running)
+		return;
+
+	/* no more new events queued */
+	otgd->fsm_running = false;
+
+	/* Stop state machine / timers */
+	if (!otgd->drd_only) {
+		for (i = 0; i < ARRAY_SIZE(otgd->timers); i++) {
+			/* Ignore the uninitialized timers. */
+			if (!otgd->timers[i].otgd)
+				continue;
+			hrtimer_cancel(&otgd->timers[i].timer);
+		}
+	}
+
+	flush_workqueue(otgd->wq);
+	fsm->otg->state = OTG_STATE_UNDEFINED;
+
+	/* stop host/gadget immediately */
+	if (fsm->protocol == PROTO_HOST)
+		otg_start_host(fsm, 0);
+	else if (fsm->protocol == PROTO_GADGET)
+		otg_start_gadget(fsm, 0);
+	fsm->protocol = PROTO_UNDEF;
+}
+
+/**
+ * usb_otg_sync_inputs - Sync OTG inputs with the OTG state machine
+ * @fsm:	OTG FSM instance
+ *
+ * Used by the OTG driver to update the inputs to the OTG
+ * state machine.
+ *
+ * Can be called in IRQ context.
+ */
+void usb_otg_sync_inputs(struct otg_fsm *fsm)
+{
+	struct usb_otg *otgd = container_of(fsm, struct usb_otg, fsm);
+
+	/* Don't kick FSM till it has started */
+	if (!otgd->fsm_running)
+		return;
+
+	/* Kick FSM */
+	queue_work(otgd->wq, &otgd->work);
+}
+EXPORT_SYMBOL_GPL(usb_otg_sync_inputs);
+
+/**
+ * usb_otg_kick_fsm - Kick the OTG state machine
+ * @hcd_gcd_device:	Host/Gadget controller device
+ *
+ * Used by USB host/device stack to sync OTG related
+ * events to the OTG state machine.
+ * e.g. change in host_bus->b_hnp_enable, gadget->b_hnp_enable
+ *
+ * Returns: 0 on success, error value otherwise.
+ */
+int usb_otg_kick_fsm(struct device *hcd_gcd_device)
+{
+	struct usb_otg *otgd;
+
+	mutex_lock(&otg_list_mutex);
+	otgd = usb_otg_get_data(usb_otg_get_device(hcd_gcd_device));
+	mutex_unlock(&otg_list_mutex);
+	if (!otgd) {
+		dev_dbg(hcd_gcd_device, "otg: %s: invalid host/gadget device\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	usb_otg_sync_inputs(&otgd->fsm);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_otg_kick_fsm);
+
+/**
+ * usb_otg_register_hcd - Register Host controller to OTG core
+ * @hcd:	Host controller device
+ * @irqnum:	interrupt number
+ * @irqflags:	interrupt flags
+ * @ops:	HCD ops to add/remove the HCD
+ *
+ * This is used by the USB Host stack to register the Host controller
+ * to the OTG core. Host controller must not be started by the
+ * caller as it is left upto the OTG state machine to do so.
+ *
+ * Returns: 0 on success, error value otherwise.
+ */
+int usb_otg_register_hcd(struct usb_hcd *hcd, unsigned int irqnum,
+			 unsigned long irqflags, struct otg_hcd_ops *ops)
+{
+	struct usb_otg *otgd;
+	struct device *hcd_dev = hcd->self.controller;
+	struct device *otg_dev = usb_otg_get_device(hcd_dev);
+
+	if (!otg_dev)
+		return -EINVAL;	/* we're definitely not OTG */
+
+	/* we're otg but otg controller might not yet be registered */
+	mutex_lock(&otg_list_mutex);
+	otgd = usb_otg_get_data(otg_dev);
+	mutex_unlock(&otg_list_mutex);
+	if (!otgd) {
+		dev_dbg(hcd_dev,
+			"otg: controller not yet registered. waiting..\n");
+		/*
+		 * otg controller might register later. Put the hcd in
+		 * wait list and call us back when ready
+		 */
+		if (usb_otg_hcd_wait_add(otg_dev, hcd, irqnum, irqflags, ops)) {
+			dev_dbg(hcd_dev, "otg: failed to add to wait list\n");
+			return -EINVAL;
+		}
+
+		return 0;
+	}
+
+	/* HCD will be started by OTG fsm when needed */
+	mutex_lock(&otgd->fsm.lock);
+	if (otgd->primary_hcd.hcd) {
+		/* probably a shared HCD ? */
+		if (usb_otg_hcd_is_primary_hcd(hcd)) {
+			dev_err(otg_dev, "otg: primary host already registered\n");
+			goto err;
+		}
+
+		if (hcd->shared_hcd == otgd->primary_hcd.hcd) {
+			if (otgd->shared_hcd.hcd) {
+				dev_err(otg_dev, "otg: shared host already registered\n");
+				goto err;
+			}
+
+			otgd->shared_hcd.hcd = hcd;
+			otgd->shared_hcd.irqnum = irqnum;
+			otgd->shared_hcd.irqflags = irqflags;
+			otgd->shared_hcd.ops = ops;
+			dev_info(otg_dev, "otg: shared host %s registered\n",
+				 dev_name(hcd->self.controller));
+		} else {
+			dev_err(otg_dev, "otg: invalid shared host %s\n",
+				dev_name(hcd->self.controller));
+			goto err;
+		}
+	} else {
+		if (!usb_otg_hcd_is_primary_hcd(hcd)) {
+			dev_err(otg_dev, "otg: primary host must be registered first\n");
+			goto err;
+		}
+		otgd->primary_hcd.hcd = hcd;
+		otgd->primary_hcd.irqnum = irqnum;
+		otgd->primary_hcd.irqflags = irqflags;
+		otgd->primary_hcd.ops = ops;
+		dev_info(otg_dev, "otg: primary host %s registered\n",
+			 dev_name(hcd->self.controller));
+	}
+
+	/*
+	 * we're ready only if we have shared HCD
+	 * or we don't need shared HCD.
+	 */
+	if (otgd->shared_hcd.hcd || !otgd->primary_hcd.hcd->shared_hcd) {
+		otgd->fsm.otg->host = hcd_to_bus(hcd);
+		/* FIXME: set bus->otg_port if this is true OTG port with HNP */
+
+		/* start FSM */
+		usb_otg_start_fsm(&otgd->fsm);
+	} else {
+		dev_dbg(otg_dev, "otg: can't start till shared host registers\n");
+	}
+
+	mutex_unlock(&otgd->fsm.lock);
+
+	return 0;
+
+err:
+	mutex_unlock(&otgd->fsm.lock);
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(usb_otg_register_hcd);
+
+/**
+ * usb_otg_unregister_hcd - Unregister Host controller from OTG core
+ * @hcd:	Host controller device
+ *
+ * This is used by the USB Host stack to unregister the Host controller
+ * from the OTG core. Ensures that Host controller is not running
+ * on successful return.
+ *
+ * Returns: 0 on success, error value otherwise.
+ */
+int usb_otg_unregister_hcd(struct usb_hcd *hcd)
+{
+	struct usb_otg *otgd;
+	struct device *hcd_dev = hcd_to_bus(hcd)->controller;
+	struct device *otg_dev = usb_otg_get_device(hcd_dev);
+
+	if (!otg_dev)
+		return -EINVAL;	/* we're definitely not OTG */
+
+	mutex_lock(&otg_list_mutex);
+	otgd = usb_otg_get_data(otg_dev);
+	mutex_unlock(&otg_list_mutex);
+	if (!otgd) {
+		/* are we in wait list? */
+		if (!usb_otg_hcd_wait_remove(hcd))
+			return 0;
+
+		dev_dbg(hcd_dev, "otg: host wasn't registered with otg\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&otgd->fsm.lock);
+	if (hcd == otgd->primary_hcd.hcd) {
+		otgd->primary_hcd.hcd = NULL;
+		dev_info(otg_dev, "otg: primary host %s unregistered\n",
+			 dev_name(hcd_dev));
+	} else if (hcd == otgd->shared_hcd.hcd) {
+		otgd->shared_hcd.hcd = NULL;
+		dev_info(otg_dev, "otg: shared host %s unregistered\n",
+			 dev_name(hcd_dev));
+	} else {
+		dev_err(otg_dev, "otg: host %s wasn't registered with otg\n",
+			dev_name(hcd_dev));
+		mutex_unlock(&otgd->fsm.lock);
+		return -EINVAL;
+	}
+
+	/* stop FSM & Host */
+	usb_otg_stop_fsm(&otgd->fsm);
+	otgd->fsm.otg->host = NULL;
+
+	mutex_unlock(&otgd->fsm.lock);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_otg_unregister_hcd);
+
+/**
+ * usb_otg_register_gadget - Register Gadget controller to OTG core
+ * @gadget:	Gadget controller
+ *
+ * This is used by the USB Gadget stack to register the Gadget controller
+ * to the OTG core. Gadget controller must not be started by the
+ * caller as it is left upto the OTG state machine to do so.
+ *
+ * Gadget core must call this only when all resources required for
+ * gadget controller to run are available.
+ * i.e. gadget function driver is available.
+ *
+ * Returns: 0 on success, error value otherwise.
+ */
+int usb_otg_register_gadget(struct usb_gadget *gadget,
+			    struct otg_gadget_ops *ops)
+{
+	struct usb_otg *otgd;
+	struct device *gadget_dev = &gadget->dev;
+	struct device *otg_dev = usb_otg_get_device(gadget_dev);
+
+	if (!otg_dev)
+		return -EINVAL;	/* we're definitely not OTG */
+
+	/* we're otg but otg controller might not yet be registered */
+	mutex_lock(&otg_list_mutex);
+	otgd = usb_otg_get_data(otg_dev);
+	mutex_unlock(&otg_list_mutex);
+	if (!otgd) {
+		dev_dbg(gadget_dev,
+			"otg: controller not yet registered. waiting..\n");
+		/*
+		 * otg controller might register later. Put the gadget in
+		 * wait list and call us back when ready
+		 */
+		if (usb_otg_gadget_wait_add(otg_dev, gadget, ops)) {
+			dev_dbg(gadget_dev, "otg: failed to add to wait list\n");
+			return -EINVAL;
+		}
+
+		return 0;
+	}
+
+	mutex_lock(&otgd->fsm.lock);
+	if (otgd->fsm.otg->gadget) {
+		dev_err(otg_dev, "otg: gadget already registered with otg\n");
+		mutex_unlock(&otgd->fsm.lock);
+		return -EINVAL;
+	}
+
+	otgd->fsm.otg->gadget = gadget;
+	otgd->gadget_ops = ops;
+	dev_info(otg_dev, "otg: gadget %s registered\n",
+		 dev_name(&gadget->dev));
+
+	/* start FSM */
+	usb_otg_start_fsm(&otgd->fsm);
+	mutex_unlock(&otgd->fsm.lock);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_otg_register_gadget);
+
+/**
+ * usb_otg_unregister_gadget - Unregister Gadget controller from OTG core
+ * @gadget:	Gadget controller
+ *
+ * This is used by the USB Gadget stack to unregister the Gadget controller
+ * from the OTG core. Ensures that Gadget controller is not running
+ * on successful return.
+ *
+ * Returns: 0 on success, error value otherwise.
+ */
+int usb_otg_unregister_gadget(struct usb_gadget *gadget)
+{
+	struct usb_otg *otgd;
+	struct device *gadget_dev = &gadget->dev;
+	struct device *otg_dev = usb_otg_get_device(gadget_dev);
+
+	if (!otg_dev)
+		return -EINVAL;
+
+	mutex_lock(&otg_list_mutex);
+	otgd = usb_otg_get_data(otg_dev);
+	mutex_unlock(&otg_list_mutex);
+	if (!otgd) {
+		/* are we in wait list? */
+		if (!usb_otg_gadget_wait_remove(gadget))
+			return 0;
+
+		dev_dbg(gadget_dev, "otg: gadget wasn't registered with otg\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&otgd->fsm.lock);
+	if (otgd->fsm.otg->gadget != gadget) {
+		dev_err(otg_dev, "otg: gadget %s wasn't registered with otg\n",
+			dev_name(&gadget->dev));
+		mutex_unlock(&otgd->fsm.lock);
+		return -EINVAL;
+	}
+
+	/* Stop FSM & gadget */
+	usb_otg_stop_fsm(&otgd->fsm);
+	otgd->fsm.otg->gadget = NULL;
+	mutex_unlock(&otgd->fsm.lock);
+
+	dev_info(otg_dev, "otg: gadget %s unregistered\n",
+		 dev_name(&gadget->dev));
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_otg_unregister_gadget);
+
+/**
+ * usb_otg_fsm_to_dev - Get OTG controller device from struct otg_fsm
+ * @fsm:	otg_fsm data structure
+ *
+ * This is used by the OTG controller driver to get it's device node
+ * from any of the otg_fsm->ops.
+ */
+struct device *usb_otg_fsm_to_dev(struct otg_fsm *fsm)
+{
+	struct usb_otg *otgd = container_of(fsm, struct usb_otg, fsm);
+
+	return otgd->dev;
+}
+EXPORT_SYMBOL_GPL(usb_otg_fsm_to_dev);
diff --git a/drivers/usb/common/usb-otg.h b/drivers/usb/common/usb-otg.h
new file mode 100644
index 000000000000..c4bb61290429
--- /dev/null
+++ b/drivers/usb/common/usb-otg.h
@@ -0,0 +1,78 @@
+/**
+ * drivers/usb/common/usb-otg.h - USB OTG core local header
+ *
+ * Copyright (C) 2015 Texas Instruments Incorporated - http://www.ti.com
+ * Author: Roger Quadros <rogerq@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __DRIVERS_USB_COMMON_USB_OTG_H
+#define __DRIVERS_USB_COMMON_USB_OTG_H
+
+/*
+ *  A-DEVICE timing constants
+ */
+
+/* Wait for VBUS Rise  */
+#define TA_WAIT_VRISE        (100)
+/* a_wait_vrise: section 7.1.2
+ * a_wait_vrise_tmr: section 7.4.5.1
+ * TA_VBUS_RISE <= 100ms, section 4.4
+ * Table 4-1: Electrical Characteristics
+ * ->DC Electrical Timing
+ */
+/* Wait for VBUS Fall  */
+#define TA_WAIT_VFALL        (1000)
+/* a_wait_vfall: section 7.1.7
+ * a_wait_vfall_tmr: section: 7.4.5.2
+ */
+/* Wait for B-Connect */
+#define TA_WAIT_BCON         (10000)
+/* a_wait_bcon: section 7.1.3
+ * TA_WAIT_BCON: should be between 1100
+ * and 30000 ms, section 5.5, Table 5-1
+ */
+/* A-Idle to B-Disconnect */
+#define TA_AIDL_BDIS         (5000)
+/* a_suspend min 200 ms, section 5.2.1
+ * TA_AIDL_BDIS: section 5.5, Table 5-1
+ */
+/* B-Idle to A-Disconnect */
+#define TA_BIDL_ADIS         (500)
+/* TA_BIDL_ADIS: section 5.2.1
+ * 500ms is used for B switch to host
+ * for safe
+ */
+
+/*
+ * B-device timing constants
+ */
+
+/* Data-Line Pulse Time*/
+#define TB_DATA_PLS          (10)
+/* b_srp_init,continue 5~10ms
+ * section:5.1.3
+ */
+/* SRP Fail Time  */
+#define TB_SRP_FAIL          (6000)
+/* b_srp_init,fail time 5~6s
+ * section:5.1.6
+ */
+/* A-SE0 to B-Reset  */
+#define TB_ASE0_BRST         (155)	/* minimum 155 ms, section:5.3.1 */
+/* SE0 Time Before SRP */
+#define TB_SE0_SRP           (1000)	/* b_idle,minimum 1s, section:5.1.2 */
+/* SSEND time before SRP */
+#define TB_SSEND_SRP         (1500)	/* minimum 1.5 sec, section:5.1.2 */
+
+#define TB_SESS_VLD          (1000)
+
+#endif /* __DRIVERS_USB_COMMON_USB_OTG_H */
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 0a77717d6af2..573ba5bf69ce 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -2653,6 +2653,7 @@ static void usb_put_invalidate_rhdev(struct usb_hcd *hcd)
 	usb_put_dev(rhdev);
 }
 
+#if !defined(CONFIG_CVITEK_USB_LEGACY)
 /**
  * usb_add_hcd - finish generic HCD structure initialization and register
  * @hcd: the usb_hcd structure to initialize
@@ -2959,6 +2960,336 @@ void usb_remove_hcd(struct usb_hcd *hcd)
 }
 EXPORT_SYMBOL_GPL(usb_remove_hcd);
 
+#else
+/**
+ * usb_otg_add_hcd - finish generic HCD structure initialization and register
+ * @hcd: the usb_hcd structure to initialize
+ * @irqnum: Interrupt line to allocate
+ * @irqflags: Interrupt type flags
+ *
+ * Finish the remaining parts of generic HCD initialization: allocate the
+ * buffers of consistent memory, register the bus, request the IRQ line,
+ * and call the driver's reset() and start() routines.
+ */
+static int usb_otg_add_hcd(struct usb_hcd *hcd,
+			   unsigned int irqnum, unsigned long irqflags)
+{
+	int retval;
+	struct usb_device *rhdev;
+
+	if (!hcd->skip_phy_initialization && usb_hcd_is_primary_hcd(hcd)) {
+		hcd->phy_roothub = usb_phy_roothub_alloc(hcd->self.sysdev);
+		if (IS_ERR(hcd->phy_roothub))
+			return PTR_ERR(hcd->phy_roothub);
+
+		retval = usb_phy_roothub_init(hcd->phy_roothub);
+		if (retval)
+			return retval;
+
+		retval = usb_phy_roothub_power_on(hcd->phy_roothub);
+		if (retval)
+			goto err_usb_phy_roothub_power_on;
+	}
+
+	dev_info(hcd->self.controller, "%s\n", hcd->product_desc);
+
+	/* Keep old behaviour if authorized_default is not in [0, 1]. */
+	if (authorized_default < 0 || authorized_default > 1) {
+		if (hcd->wireless)
+			clear_bit(HCD_FLAG_DEV_AUTHORIZED, &hcd->flags);
+		else
+			set_bit(HCD_FLAG_DEV_AUTHORIZED, &hcd->flags);
+	} else {
+		if (authorized_default)
+			set_bit(HCD_FLAG_DEV_AUTHORIZED, &hcd->flags);
+		else
+			clear_bit(HCD_FLAG_DEV_AUTHORIZED, &hcd->flags);
+	}
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	/* per default all interfaces are authorized */
+	set_bit(HCD_FLAG_INTF_AUTHORIZED, &hcd->flags);
+
+	/* HC is in reset state, but accessible.  Now do the one-time init,
+	 * bottom up so that hcds can customize the root hubs before hub_wq
+	 * starts talking to them.  (Note, bus id is assigned early too.)
+	 */
+	retval = hcd_buffer_create(hcd);
+	if (retval != 0) {
+		dev_dbg(hcd->self.sysdev, "pool alloc failed\n");
+		goto err_create_buf;
+	}
+
+	retval = usb_register_bus(&hcd->self);
+	if (retval < 0)
+		goto err_register_bus;
+
+	rhdev = usb_alloc_dev(NULL, &hcd->self, 0);
+	if (rhdev == NULL) {
+		dev_err(hcd->self.sysdev, "unable to allocate root hub\n");
+		retval = -ENOMEM;
+		goto err_allocate_root_hub;
+	}
+	mutex_lock(&usb_port_peer_mutex);
+	hcd->self.root_hub = rhdev;
+	mutex_unlock(&usb_port_peer_mutex);
+
+	rhdev->rx_lanes = 1;
+	rhdev->tx_lanes = 1;
+
+	switch (hcd->speed) {
+	case HCD_USB11:
+		rhdev->speed = USB_SPEED_FULL;
+		break;
+	case HCD_USB2:
+		rhdev->speed = USB_SPEED_HIGH;
+		break;
+	case HCD_USB25:
+		rhdev->speed = USB_SPEED_WIRELESS;
+		break;
+	case HCD_USB3:
+		rhdev->speed = USB_SPEED_SUPER;
+		break;
+	case HCD_USB32:
+		rhdev->rx_lanes = 2;
+		rhdev->tx_lanes = 2;
+		/* fall through */
+	case HCD_USB31:
+		rhdev->speed = USB_SPEED_SUPER_PLUS;
+		break;
+	default:
+		retval = -EINVAL;
+		goto err_set_rh_speed;
+	}
+
+	/* wakeup flag init defaults to "everything works" for root hubs,
+	 * but drivers can override it in reset() if needed, along with
+	 * recording the overall controller's system wakeup capability.
+	 */
+	device_set_wakeup_capable(&rhdev->dev, 1);
+
+	/* HCD_FLAG_RH_RUNNING doesn't matter until the root hub is
+	 * registered.  But since the controller can die at any time,
+	 * let's initialize the flag before touching the hardware.
+	 */
+	set_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);
+
+	/* "reset" is misnamed; its role is now one-time init. the controller
+	 * should already have been reset (and boot firmware kicked off etc).
+	 */
+	if (hcd->driver->reset) {
+		retval = hcd->driver->reset(hcd);
+		if (retval < 0) {
+			dev_err(hcd->self.controller, "can't setup: %d\n",
+					retval);
+			goto err_hcd_driver_setup;
+		}
+	}
+	hcd->rh_pollable = 1;
+
+	/* NOTE: root hub and controller capabilities may not be the same */
+	if (device_can_wakeup(hcd->self.controller)
+			&& device_can_wakeup(&hcd->self.root_hub->dev))
+		dev_dbg(hcd->self.controller, "supports USB remote wakeup\n");
+
+	/* initialize tasklets */
+	init_giveback_urb_bh(&hcd->high_prio_bh);
+	init_giveback_urb_bh(&hcd->low_prio_bh);
+
+	/* enable irqs just before we start the controller,
+	 * if the BIOS provides legacy PCI irqs.
+	 */
+	if (usb_hcd_is_primary_hcd(hcd) && irqnum) {
+		retval = usb_hcd_request_irqs(hcd, irqnum, irqflags);
+		if (retval)
+			goto err_request_irq;
+	}
+
+	hcd->state = HC_STATE_RUNNING;
+	retval = hcd->driver->start(hcd);
+	if (retval < 0) {
+		dev_err(hcd->self.controller, "startup error %d\n", retval);
+		goto err_hcd_driver_start;
+	}
+
+	/* starting here, usbcore will pay attention to this root hub */
+	retval = register_root_hub(hcd);
+	if (retval != 0)
+		goto err_register_root_hub;
+
+	retval = sysfs_create_group(&rhdev->dev.kobj, &usb_bus_attr_group);
+	if (retval < 0) {
+		dev_err(hcd->self.controller, "Cannot register USB bus sysfs attributes: %d\n",
+		       retval);
+		goto error_create_attr_group;
+	}
+	if (hcd->uses_new_polling && HCD_POLL_RH(hcd))
+		usb_hcd_poll_rh_status(hcd);
+
+	return retval;
+
+error_create_attr_group:
+	clear_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);
+	if (HC_IS_RUNNING(hcd->state))
+		hcd->state = HC_STATE_QUIESCING;
+	spin_lock_irq(&hcd_root_hub_lock);
+	hcd->rh_registered = 0;
+	spin_unlock_irq(&hcd_root_hub_lock);
+
+#ifdef CONFIG_PM
+	cancel_work_sync(&hcd->wakeup_work);
+#endif
+	mutex_lock(&usb_bus_idr_lock);
+	usb_disconnect(&rhdev);		/* Sets rhdev to NULL */
+	mutex_unlock(&usb_bus_idr_lock);
+err_register_root_hub:
+	hcd->rh_pollable = 0;
+	clear_bit(HCD_FLAG_POLL_RH, &hcd->flags);
+	del_timer_sync(&hcd->rh_timer);
+	hcd->driver->stop(hcd);
+	hcd->state = HC_STATE_HALT;
+	clear_bit(HCD_FLAG_POLL_RH, &hcd->flags);
+	del_timer_sync(&hcd->rh_timer);
+err_hcd_driver_start:
+	if (usb_hcd_is_primary_hcd(hcd) && hcd->irq > 0)
+		free_irq(irqnum, hcd);
+err_request_irq:
+err_hcd_driver_setup:
+err_set_rh_speed:
+	usb_put_invalidate_rhdev(hcd);
+err_allocate_root_hub:
+	usb_deregister_bus(&hcd->self);
+err_register_bus:
+	hcd_buffer_destroy(hcd);
+err_create_buf:
+	usb_phy_roothub_power_off(hcd->phy_roothub);
+err_usb_phy_roothub_power_on:
+	usb_phy_roothub_exit(hcd->phy_roothub);
+
+	return retval;
+}
+
+/**
+ * usb_otg_remove_hcd - shutdown processing for generic HCDs
+ * @hcd: the usb_hcd structure to remove
+ * Context: !in_interrupt()
+ *
+ * Disconnects the root hub, then reverses the effects of usb_add_hcd(),
+ * invoking the HCD's stop() method.
+ */
+static void usb_otg_remove_hcd(struct usb_hcd *hcd)
+{
+	struct usb_device *rhdev = hcd->self.root_hub;
+
+	dev_info(hcd->self.controller, "remove, state %x\n", hcd->state);
+
+	usb_get_dev(rhdev);
+	sysfs_remove_group(&rhdev->dev.kobj, &usb_bus_attr_group);
+
+	clear_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);
+	if (HC_IS_RUNNING(hcd->state))
+		hcd->state = HC_STATE_QUIESCING;
+
+	dev_dbg(hcd->self.controller, "roothub graceful disconnect\n");
+	spin_lock_irq(&hcd_root_hub_lock);
+	hcd->rh_registered = 0;
+	spin_unlock_irq(&hcd_root_hub_lock);
+
+#ifdef CONFIG_PM
+	cancel_work_sync(&hcd->wakeup_work);
+#endif
+
+	mutex_lock(&usb_bus_idr_lock);
+	usb_disconnect(&rhdev);		/* Sets rhdev to NULL */
+	mutex_unlock(&usb_bus_idr_lock);
+
+	/*
+	 * tasklet_kill() isn't needed here because:
+	 * - driver's disconnect() called from usb_disconnect() should
+	 *   make sure its URBs are completed during the disconnect()
+	 *   callback
+	 *
+	 * - it is too late to run complete() here since driver may have
+	 *   been removed already now
+	 */
+
+	/* Prevent any more root-hub status calls from the timer.
+	 * The HCD might still restart the timer (if a port status change
+	 * interrupt occurs), but usb_hcd_poll_rh_status() won't invoke
+	 * the hub_status_data() callback.
+	 */
+	hcd->rh_pollable = 0;
+	clear_bit(HCD_FLAG_POLL_RH, &hcd->flags);
+	del_timer_sync(&hcd->rh_timer);
+
+	hcd->driver->stop(hcd);
+	hcd->state = HC_STATE_HALT;
+
+	/* In case the HCD restarted the timer, stop it again. */
+	clear_bit(HCD_FLAG_POLL_RH, &hcd->flags);
+	del_timer_sync(&hcd->rh_timer);
+
+	if (usb_hcd_is_primary_hcd(hcd)) {
+		if (hcd->irq > 0)
+			free_irq(hcd->irq, hcd);
+	}
+
+	usb_deregister_bus(&hcd->self);
+	hcd_buffer_destroy(hcd);
+
+	usb_phy_roothub_power_off(hcd->phy_roothub);
+	usb_phy_roothub_exit(hcd->phy_roothub);
+
+	usb_put_invalidate_rhdev(hcd);
+	hcd->flags = 0;
+}
+
+static struct otg_hcd_ops otg_hcd_intf = {
+	.add = usb_otg_add_hcd,
+	.remove = usb_otg_remove_hcd,
+};
+
+/**
+ * usb_add_hcd - finish generic HCD structure initialization and register
+ * @hcd: the usb_hcd structure to initialize
+ * @irqnum: Interrupt line to allocate
+ * @irqflags: Interrupt type flags
+ *
+ * Finish the remaining parts of generic HCD initialization: allocate the
+ * buffers of consistent memory, register the bus, request the IRQ line,
+ * and call the driver's reset() and start() routines.
+ * If it is an OTG device then it only registers the HCD with OTG core.
+ *
+ */
+int usb_add_hcd(struct usb_hcd *hcd,
+		unsigned int irqnum, unsigned long irqflags)
+{
+	/* If OTG device, OTG core takes care of adding HCD */
+	if (usb_otg_register_hcd(hcd, irqnum, irqflags, &otg_hcd_intf))
+		return usb_otg_add_hcd(hcd, irqnum, irqflags);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_add_hcd);
+
+/**
+ * usb_remove_hcd - shutdown processing for generic HCDs
+ * @hcd: the usb_hcd structure to remove
+ * Context: !in_interrupt()
+ *
+ * Disconnects the root hub, then reverses the effects of usb_add_hcd(),
+ * invoking the HCD's stop() method.
+ * If it is an OTG device then it unregisters the HCD from OTG core
+ * as well.
+ */
+void usb_remove_hcd(struct usb_hcd *hcd)
+{
+	/* If OTG device, OTG core takes care of stopping HCD */
+	if (usb_otg_unregister_hcd(hcd))
+		usb_otg_remove_hcd(hcd);
+}
+EXPORT_SYMBOL_GPL(usb_remove_hcd);
+
+#endif
 void
 usb_hcd_platform_shutdown(struct platform_device *dev)
 {
diff --git a/drivers/usb/dwc2/Kconfig b/drivers/usb/dwc2/Kconfig
index c131719367ec..16e1aa304edc 100644
--- a/drivers/usb/dwc2/Kconfig
+++ b/drivers/usb/dwc2/Kconfig
@@ -5,7 +5,6 @@ config USB_DWC2
 	depends on HAS_DMA
 	depends on USB || USB_GADGET
 	depends on HAS_IOMEM
-	select USB_ROLE_SWITCH
 	help
 	  Say Y here if your system has a Dual Role Hi-Speed USB
 	  controller based on the DesignWare HSOTG IP Core.
diff --git a/drivers/usb/dwc2/Makefile b/drivers/usb/dwc2/Makefile
index 2bcd6945df46..ca8d80fe6dbc 100644
--- a/drivers/usb/dwc2/Makefile
+++ b/drivers/usb/dwc2/Makefile
@@ -3,7 +3,10 @@ ccflags-$(CONFIG_USB_DWC2_DEBUG)	+= -DDEBUG
 ccflags-$(CONFIG_USB_DWC2_VERBOSE)	+= -DVERBOSE_DEBUG
 
 obj-$(CONFIG_USB_DWC2)			+= dwc2.o
-dwc2-y					:= core.o core_intr.o platform.o drd.o
+dwc2-y					:= core.o core_intr.o platform.o
+ifneq ($(CONFIG_USB_ROLE_SWITCH),)
+	dwc2-y				+= drd.o
+endif
 dwc2-y					+= params.o
 
 ifneq ($(filter y,$(CONFIG_USB_DWC2_HOST) $(CONFIG_USB_DWC2_DUAL_ROLE)),)
diff --git a/drivers/usb/dwc2/core.c b/drivers/usb/dwc2/core.c
index 15911ac7582b..272ae5722c86 100644
--- a/drivers/usb/dwc2/core.c
+++ b/drivers/usb/dwc2/core.c
@@ -131,54 +131,26 @@ int dwc2_restore_global_registers(struct dwc2_hsotg *hsotg)
  * dwc2_exit_partial_power_down() - Exit controller from Partial Power Down.
  *
  * @hsotg: Programming view of the DWC_otg controller
+ * @rem_wakeup: indicates whether resume is initiated by Reset.
  * @restore: Controller registers need to be restored
  */
-int dwc2_exit_partial_power_down(struct dwc2_hsotg *hsotg, bool restore)
+int dwc2_exit_partial_power_down(struct dwc2_hsotg *hsotg, int rem_wakeup,
+				 bool restore)
 {
-	u32 pcgcctl;
-	int ret = 0;
-
-	if (hsotg->params.power_down != DWC2_POWER_DOWN_PARAM_PARTIAL)
-		return -ENOTSUPP;
-
-	pcgcctl = dwc2_readl(hsotg, PCGCTL);
-	pcgcctl &= ~PCGCTL_STOPPCLK;
-	dwc2_writel(hsotg, pcgcctl, PCGCTL);
-
-	pcgcctl = dwc2_readl(hsotg, PCGCTL);
-	pcgcctl &= ~PCGCTL_PWRCLMP;
-	dwc2_writel(hsotg, pcgcctl, PCGCTL);
-
-	pcgcctl = dwc2_readl(hsotg, PCGCTL);
-	pcgcctl &= ~PCGCTL_RSTPDWNMODULE;
-	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+	struct dwc2_gregs_backup *gr;
 
-	udelay(100);
-	if (restore) {
-		ret = dwc2_restore_global_registers(hsotg);
-		if (ret) {
-			dev_err(hsotg->dev, "%s: failed to restore registers\n",
-				__func__);
-			return ret;
-		}
-		if (dwc2_is_host_mode(hsotg)) {
-			ret = dwc2_restore_host_registers(hsotg);
-			if (ret) {
-				dev_err(hsotg->dev, "%s: failed to restore host registers\n",
-					__func__);
-				return ret;
-			}
-		} else {
-			ret = dwc2_restore_device_registers(hsotg, 0);
-			if (ret) {
-				dev_err(hsotg->dev, "%s: failed to restore device registers\n",
-					__func__);
-				return ret;
-			}
-		}
-	}
+	gr = &hsotg->gr_backup;
 
-	return ret;
+	/*
+	 * Restore host or device regisers with the same mode core enterted
+	 * to partial power down by checking "GOTGCTL_CURMODE_HOST" backup
+	 * value of the "gotgctl" register.
+	 */
+	if (gr->gotgctl & GOTGCTL_CURMODE_HOST)
+		return dwc2_host_exit_partial_power_down(hsotg, rem_wakeup,
+							 restore);
+	else
+		return dwc2_gadget_exit_partial_power_down(hsotg, restore);
 }
 
 /**
@@ -188,57 +160,10 @@ int dwc2_exit_partial_power_down(struct dwc2_hsotg *hsotg, bool restore)
  */
 int dwc2_enter_partial_power_down(struct dwc2_hsotg *hsotg)
 {
-	u32 pcgcctl;
-	int ret = 0;
-
-	if (!hsotg->params.power_down)
-		return -ENOTSUPP;
-
-	/* Backup all registers */
-	ret = dwc2_backup_global_registers(hsotg);
-	if (ret) {
-		dev_err(hsotg->dev, "%s: failed to backup global registers\n",
-			__func__);
-		return ret;
-	}
-
-	if (dwc2_is_host_mode(hsotg)) {
-		ret = dwc2_backup_host_registers(hsotg);
-		if (ret) {
-			dev_err(hsotg->dev, "%s: failed to backup host registers\n",
-				__func__);
-			return ret;
-		}
-	} else {
-		ret = dwc2_backup_device_registers(hsotg);
-		if (ret) {
-			dev_err(hsotg->dev, "%s: failed to backup device registers\n",
-				__func__);
-			return ret;
-		}
-	}
-
-	/*
-	 * Clear any pending interrupts since dwc2 will not be able to
-	 * clear them after entering partial_power_down.
-	 */
-	dwc2_writel(hsotg, 0xffffffff, GINTSTS);
-
-	/* Put the controller in low power state */
-	pcgcctl = dwc2_readl(hsotg, PCGCTL);
-
-	pcgcctl |= PCGCTL_PWRCLMP;
-	dwc2_writel(hsotg, pcgcctl, PCGCTL);
-	ndelay(20);
-
-	pcgcctl |= PCGCTL_RSTPDWNMODULE;
-	dwc2_writel(hsotg, pcgcctl, PCGCTL);
-	ndelay(20);
-
-	pcgcctl |= PCGCTL_STOPPCLK;
-	dwc2_writel(hsotg, pcgcctl, PCGCTL);
-
-	return ret;
+	if (dwc2_is_host_mode(hsotg))
+		return dwc2_host_enter_partial_power_down(hsotg);
+	else
+		return dwc2_gadget_enter_partial_power_down(hsotg);
 }
 
 /**
@@ -374,6 +299,12 @@ void dwc2_hib_restore_common(struct dwc2_hsotg *hsotg, int rem_wakeup,
 			__func__);
 	} else {
 		dev_dbg(hsotg->dev, "restore done  generated here\n");
+
+		/*
+		 * To avoid restore done interrupt storm after restore is
+		 * generated clear GINTSTS_RESTOREDONE bit.
+		 */
+		dwc2_writel(hsotg, GINTSTS_RESTOREDONE, GINTSTS);
 	}
 }
 
@@ -460,9 +391,6 @@ static bool dwc2_iddig_filter_enabled(struct dwc2_hsotg *hsotg)
  */
 int dwc2_enter_hibernation(struct dwc2_hsotg *hsotg, int is_host)
 {
-	if (hsotg->params.power_down != DWC2_POWER_DOWN_PARAM_HIBERNATION)
-		return -ENOTSUPP;
-
 	if (is_host)
 		return dwc2_host_enter_hibernation(hsotg);
 	else
@@ -545,6 +473,22 @@ int dwc2_core_reset(struct dwc2_hsotg *hsotg, bool skip_wait)
 		dwc2_writel(hsotg, greset, GRSTCTL);
 	}
 
+	/*
+	 * Switching from device mode to host mode by disconnecting
+	 * device cable core enters and exits form hibernation.
+	 * However, the fifo map remains not cleared. It results
+	 * to a WARNING (WARNING: CPU: 5 PID: 0 at drivers/usb/dwc2/
+	 * gadget.c:307 dwc2_hsotg_init_fifo+0x12/0x152 [dwc2])
+	 * if in host mode we disconnect the micro a to b host
+	 * cable. Because core reset occurs.
+	 * To avoid the WARNING, fifo_map should be cleared
+	 * in dwc2_core_reset() function by taking into account configs.
+	 * fifo_map must be cleared only if driver is configured in
+	 * "CONFIG_USB_DWC2_PERIPHERAL" or "CONFIG_USB_DWC2_DUAL_ROLE"
+	 * mode.
+	 */
+	dwc2_clear_fifo_map(hsotg);
+
 	/* Wait for AHB master IDLE state */
 	if (dwc2_hsotg_wait_bit_set(hsotg, GRSTCTL, GRSTCTL_AHBIDLE, 10000)) {
 		dev_warn(hsotg->dev, "%s: HANG! AHB Idle timeout GRSTCTL GRSTCTL_AHBIDLE\n",
diff --git a/drivers/usb/dwc2/core.h b/drivers/usb/dwc2/core.h
index 03d16a08261d..9a4e77515942 100644
--- a/drivers/usb/dwc2/core.h
+++ b/drivers/usb/dwc2/core.h
@@ -428,7 +428,7 @@ enum dwc2_ep0_state {
  * @g_tx_fifo_size:	An array of TX fifo sizes in dedicated fifo
  *			mode. Each value corresponds to one EP
  *			starting from EP1 (max 15 values). Sizes are
- *			in DWORDS with possible values from from
+ *			in DWORDS with possible values from
  *			16-32768 (default: 256, 256, 256, 256, 768,
  *			768, 768, 768, 0, 0, 0, 0, 0, 0, 0).
  * @change_speed_quirk: Change speed configuration to DWC2_SPEED_PARAM_FULL
@@ -843,6 +843,37 @@ struct dwc2_hregs_backup {
 #define DWC2_LS_SCHEDULE_SLICES	(DWC2_LS_SCHEDULE_FRAMES * \
 				 DWC2_LS_PERIODIC_SLICES_PER_FRAME)
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+
+enum CHG_PORT_E {
+	CHGDET_SDP,	/* standard downstream port. */
+	CHGDET_DCP,	/* dedicated charging port. */
+	CHGDET_CDP,	/* charging downstream port. */
+	CHGDET_NUM
+};
+
+struct cvi_usb_clk {
+	int				is_on;
+	struct clk			*clk_o;
+};
+
+struct cviusb_dev {
+	void __iomem *phy_regs;
+	void __iomem *usb_pin_regs;
+	struct cvi_usb_clk	clk_axi;
+	struct cvi_usb_clk	clk_apb;
+	struct cvi_usb_clk	clk_125m;
+	struct cvi_usb_clk	clk_33k;
+	struct cvi_usb_clk	clk_12m;
+	int			vbus_pin;
+	int			vbus_pin_inverted;
+	int			pre_vbus_status;
+	int			id_override;
+	u8			dcd_dis;
+	u8			chgdet;
+};
+#endif
+
 /**
  * struct dwc2_hsotg - Holds the state of the driver, including the non-periodic
  * and periodic schedules
@@ -867,6 +898,8 @@ struct dwc2_hregs_backup {
  * @gadget_enabled:	Peripheral mode sub-driver initialization indicator.
  * @ll_hw_enabled:	Status of low-level hardware resources.
  * @hibernated:		True if core is hibernated
+ * @in_ppd:		True if core is partial power down mode.
+ * @bus_suspended:	True if bus is suspended
  * @reset_phy_on_wake:	Quirk saying that we should assert PHY reset on a
  *			remote wakeup.
  * @phy_off_for_suspend: Status of whether we turned the PHY off at suspend.
@@ -1024,7 +1057,6 @@ struct dwc2_hregs_backup {
  *			a pointer to an array of register definitions, the
  *			array size and the base address where the register bank
  *			is to be found.
- * @bus_suspended:	True if bus is suspended
  * @last_frame_num:	Number of last frame. Range from 0 to  32768
  * @frame_num_array:    Used only  if CONFIG_USB_DWC2_TRACK_MISSED_SOFS is
  *			defined, for missed SOFs tracking. Array holds that
@@ -1062,6 +1094,8 @@ struct dwc2_hsotg {
 	unsigned int gadget_enabled:1;
 	unsigned int ll_hw_enabled:1;
 	unsigned int hibernated:1;
+	unsigned int in_ppd:1;
+	bool bus_suspended;
 	unsigned int reset_phy_on_wake:1;
 	unsigned int need_phy_for_wake:1;
 	unsigned int phy_off_for_suspend:1;
@@ -1145,7 +1179,6 @@ struct dwc2_hsotg {
 	unsigned long hs_periodic_bitmap[
 		DIV_ROUND_UP(DWC2_HS_SCHEDULE_US, BITS_PER_LONG)];
 	u16 periodic_qh_count;
-	bool bus_suspended;
 	bool new_connection;
 
 	u16 last_frame_num;
@@ -1212,6 +1245,9 @@ struct dwc2_hsotg {
 	struct dwc2_hsotg_ep *eps_in[MAX_EPS_CHANNELS];
 	struct dwc2_hsotg_ep *eps_out[MAX_EPS_CHANNELS];
 #endif /* CONFIG_USB_DWC2_PERIPHERAL || CONFIG_USB_DWC2_DUAL_ROLE */
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	struct cviusb_dev cviusb;
+#endif
 };
 
 /* Normal architectures just use readl/write */
@@ -1297,13 +1333,28 @@ static inline bool dwc2_is_hs_iot(struct dwc2_hsotg *hsotg)
 	return (hsotg->hw_params.snpsid & 0xffff0000) == 0x55320000;
 }
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+/* cviusb readl/write */
+static inline u32 cviusb_readl(const void __iomem *addr)
+{
+	return readl(addr);
+}
+
+static inline void cviusb_writel(u32 value, void __iomem *addr)
+{
+	writel(value, addr);
+}
+
+#endif
+
 /*
  * The following functions support initialization of the core driver component
  * and the DWC_otg controller
  */
 int dwc2_core_reset(struct dwc2_hsotg *hsotg, bool skip_wait);
 int dwc2_enter_partial_power_down(struct dwc2_hsotg *hsotg);
-int dwc2_exit_partial_power_down(struct dwc2_hsotg *hsotg, bool restore);
+int dwc2_exit_partial_power_down(struct dwc2_hsotg *hsotg, int rem_wakeup,
+				 bool restore);
 int dwc2_enter_hibernation(struct dwc2_hsotg *hsotg, int is_host);
 int dwc2_exit_hibernation(struct dwc2_hsotg *hsotg, int rem_wakeup,
 		int reset, int is_host);
@@ -1412,11 +1463,19 @@ int dwc2_restore_device_registers(struct dwc2_hsotg *hsotg, int remote_wakeup);
 int dwc2_gadget_enter_hibernation(struct dwc2_hsotg *hsotg);
 int dwc2_gadget_exit_hibernation(struct dwc2_hsotg *hsotg,
 				 int rem_wakeup, int reset);
+int dwc2_gadget_enter_partial_power_down(struct dwc2_hsotg *hsotg);
+int dwc2_gadget_exit_partial_power_down(struct dwc2_hsotg *hsotg,
+					bool restore);
+void dwc2_gadget_enter_clock_gating(struct dwc2_hsotg *hsotg);
+void dwc2_gadget_exit_clock_gating(struct dwc2_hsotg *hsotg,
+				   int rem_wakeup);
 int dwc2_hsotg_tx_fifo_count(struct dwc2_hsotg *hsotg);
 int dwc2_hsotg_tx_fifo_total_depth(struct dwc2_hsotg *hsotg);
 int dwc2_hsotg_tx_fifo_average_depth(struct dwc2_hsotg *hsotg);
 void dwc2_gadget_init_lpm(struct dwc2_hsotg *hsotg);
 void dwc2_gadget_program_ref_clk(struct dwc2_hsotg *hsotg);
+static inline void dwc2_clear_fifo_map(struct dwc2_hsotg *hsotg)
+{ hsotg->fifo_map = 0; }
 #else
 static inline int dwc2_hsotg_remove(struct dwc2_hsotg *dwc2)
 { return 0; }
@@ -1446,6 +1505,14 @@ static inline int dwc2_gadget_enter_hibernation(struct dwc2_hsotg *hsotg)
 static inline int dwc2_gadget_exit_hibernation(struct dwc2_hsotg *hsotg,
 					       int rem_wakeup, int reset)
 { return 0; }
+static inline int dwc2_gadget_enter_partial_power_down(struct dwc2_hsotg *hsotg)
+{ return 0; }
+static inline int dwc2_gadget_exit_partial_power_down(struct dwc2_hsotg *hsotg,
+						      bool restore)
+{ return 0; }
+static inline void dwc2_gadget_enter_clock_gating(struct dwc2_hsotg *hsotg) {}
+static inline void dwc2_gadget_exit_clock_gating(struct dwc2_hsotg *hsotg,
+						 int rem_wakeup) {}
 static inline int dwc2_hsotg_tx_fifo_count(struct dwc2_hsotg *hsotg)
 { return 0; }
 static inline int dwc2_hsotg_tx_fifo_total_depth(struct dwc2_hsotg *hsotg)
@@ -1454,6 +1521,7 @@ static inline int dwc2_hsotg_tx_fifo_average_depth(struct dwc2_hsotg *hsotg)
 { return 0; }
 static inline void dwc2_gadget_init_lpm(struct dwc2_hsotg *hsotg) {}
 static inline void dwc2_gadget_program_ref_clk(struct dwc2_hsotg *hsotg) {}
+static inline void dwc2_clear_fifo_map(struct dwc2_hsotg *hsotg) {}
 #endif
 
 #if IS_ENABLED(CONFIG_USB_DWC2_HOST) || IS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)
@@ -1463,11 +1531,18 @@ void dwc2_hcd_connect(struct dwc2_hsotg *hsotg);
 void dwc2_hcd_disconnect(struct dwc2_hsotg *hsotg, bool force);
 void dwc2_hcd_start(struct dwc2_hsotg *hsotg);
 int dwc2_core_init(struct dwc2_hsotg *hsotg, bool initial_setup);
+int dwc2_port_suspend(struct dwc2_hsotg *hsotg, u16 windex);
+int dwc2_port_resume(struct dwc2_hsotg *hsotg);
 int dwc2_backup_host_registers(struct dwc2_hsotg *hsotg);
 int dwc2_restore_host_registers(struct dwc2_hsotg *hsotg);
 int dwc2_host_enter_hibernation(struct dwc2_hsotg *hsotg);
 int dwc2_host_exit_hibernation(struct dwc2_hsotg *hsotg,
 			       int rem_wakeup, int reset);
+int dwc2_host_enter_partial_power_down(struct dwc2_hsotg *hsotg);
+int dwc2_host_exit_partial_power_down(struct dwc2_hsotg *hsotg,
+				      int rem_wakeup, bool restore);
+void dwc2_host_enter_clock_gating(struct dwc2_hsotg *hsotg);
+void dwc2_host_exit_clock_gating(struct dwc2_hsotg *hsotg, int rem_wakeup);
 bool dwc2_host_can_poweroff_phy(struct dwc2_hsotg *dwc2);
 static inline void dwc2_host_schedule_phy_reset(struct dwc2_hsotg *hsotg)
 { schedule_work(&hsotg->phy_reset_work); }
@@ -1483,6 +1558,10 @@ static inline void dwc2_hcd_start(struct dwc2_hsotg *hsotg) {}
 static inline void dwc2_hcd_remove(struct dwc2_hsotg *hsotg) {}
 static inline int dwc2_core_init(struct dwc2_hsotg *hsotg, bool initial_setup)
 { return 0; }
+static inline int dwc2_port_suspend(struct dwc2_hsotg *hsotg, u16 windex)
+{ return 0; }
+static inline int dwc2_port_resume(struct dwc2_hsotg *hsotg)
+{ return 0; }
 static inline int dwc2_hcd_init(struct dwc2_hsotg *hsotg)
 { return 0; }
 static inline int dwc2_backup_host_registers(struct dwc2_hsotg *hsotg)
@@ -1494,6 +1573,14 @@ static inline int dwc2_host_enter_hibernation(struct dwc2_hsotg *hsotg)
 static inline int dwc2_host_exit_hibernation(struct dwc2_hsotg *hsotg,
 					     int rem_wakeup, int reset)
 { return 0; }
+static inline int dwc2_host_enter_partial_power_down(struct dwc2_hsotg *hsotg)
+{ return 0; }
+static inline int dwc2_host_exit_partial_power_down(struct dwc2_hsotg *hsotg,
+						    int rem_wakeup, bool restore)
+{ return 0; }
+static inline void dwc2_host_enter_clock_gating(struct dwc2_hsotg *hsotg) {}
+static inline void dwc2_host_exit_clock_gating(struct dwc2_hsotg *hsotg,
+					       int rem_wakeup) {}
 static inline bool dwc2_host_can_poweroff_phy(struct dwc2_hsotg *dwc2)
 { return false; }
 static inline void dwc2_host_schedule_phy_reset(struct dwc2_hsotg *hsotg) {}
diff --git a/drivers/usb/dwc2/core_intr.c b/drivers/usb/dwc2/core_intr.c
index e3f429f1575e..190f76b5610c 100644
--- a/drivers/usb/dwc2/core_intr.c
+++ b/drivers/usb/dwc2/core_intr.c
@@ -317,10 +317,18 @@ static void dwc2_handle_session_req_intr(struct dwc2_hsotg *hsotg)
 
 	if (dwc2_is_device_mode(hsotg)) {
 		if (hsotg->lx_state == DWC2_L2) {
-			ret = dwc2_exit_partial_power_down(hsotg, true);
-			if (ret && (ret != -ENOTSUPP))
-				dev_err(hsotg->dev,
-					"exit power_down failed\n");
+			if (hsotg->in_ppd) {
+				ret = dwc2_exit_partial_power_down(hsotg, 0,
+								   true);
+				if (ret)
+					dev_err(hsotg->dev,
+						"exit power_down failed\n");
+			}
+
+			/* Exit gadget mode clock gating. */
+			if (hsotg->params.power_down ==
+			    DWC2_POWER_DOWN_PARAM_NONE && hsotg->bus_suspended)
+				dwc2_gadget_exit_clock_gating(hsotg, 0);
 		}
 
 		/*
@@ -415,32 +423,40 @@ static void dwc2_handle_wakeup_detected_intr(struct dwc2_hsotg *hsotg)
 		dev_dbg(hsotg->dev, "DSTS=0x%0x\n",
 			dwc2_readl(hsotg, DSTS));
 		if (hsotg->lx_state == DWC2_L2) {
-			u32 dctl = dwc2_readl(hsotg, DCTL);
-
-			/* Clear Remote Wakeup Signaling */
-			dctl &= ~DCTL_RMTWKUPSIG;
-			dwc2_writel(hsotg, dctl, DCTL);
-			ret = dwc2_exit_partial_power_down(hsotg, true);
-			if (ret && (ret != -ENOTSUPP))
-				dev_err(hsotg->dev, "exit power_down failed\n");
+			if (hsotg->in_ppd) {
+				u32 dctl = dwc2_readl(hsotg, DCTL);
+				/* Clear Remote Wakeup Signaling */
+				dctl &= ~DCTL_RMTWKUPSIG;
+				dwc2_writel(hsotg, dctl, DCTL);
+				ret = dwc2_exit_partial_power_down(hsotg, 1,
+								   true);
+				if (ret)
+					dev_err(hsotg->dev,
+						"exit partial_power_down failed\n");
+				call_gadget(hsotg, resume);
+			}
 
-			/* Change to L0 state */
-			hsotg->lx_state = DWC2_L0;
-			call_gadget(hsotg, resume);
+			/* Exit gadget mode clock gating. */
+			if (hsotg->params.power_down ==
+			    DWC2_POWER_DOWN_PARAM_NONE && hsotg->bus_suspended)
+				dwc2_gadget_exit_clock_gating(hsotg, 0);
 		} else {
 			/* Change to L0 state */
 			hsotg->lx_state = DWC2_L0;
 		}
 	} else {
-		if (hsotg->params.power_down)
-			return;
-
-		if (hsotg->lx_state != DWC2_L1) {
-			u32 pcgcctl = dwc2_readl(hsotg, PCGCTL);
+		if (hsotg->lx_state == DWC2_L2) {
+			if (hsotg->in_ppd) {
+				ret = dwc2_exit_partial_power_down(hsotg, 1,
+								   true);
+				if (ret)
+					dev_err(hsotg->dev,
+						"exit partial_power_down failed\n");
+			}
 
-			/* Restart the Phy Clock */
-			pcgcctl &= ~PCGCTL_STOPPCLK;
-			dwc2_writel(hsotg, pcgcctl, PCGCTL);
+			if (hsotg->params.power_down ==
+			    DWC2_POWER_DOWN_PARAM_NONE && hsotg->bus_suspended)
+				dwc2_host_exit_clock_gating(hsotg, 1);
 
 			/*
 			 * If we've got this quirk then the PHY is stuck upon
@@ -516,31 +532,34 @@ static void dwc2_handle_usb_suspend_intr(struct dwc2_hsotg *hsotg)
 			return;
 		}
 		if (dsts & DSTS_SUSPSTS) {
-			if (hsotg->hw_params.power_optimized) {
+			switch (hsotg->params.power_down) {
+			case DWC2_POWER_DOWN_PARAM_PARTIAL:
 				ret = dwc2_enter_partial_power_down(hsotg);
-				if (ret) {
-					if (ret != -ENOTSUPP)
-						dev_err(hsotg->dev,
-							"%s: enter partial_power_down failed\n",
-							__func__);
-					goto skip_power_saving;
-				}
+				if (ret)
+					dev_err(hsotg->dev,
+						"enter partial_power_down failed\n");
 
 				udelay(100);
 
 				/* Ask phy to be suspended */
 				if (!IS_ERR_OR_NULL(hsotg->uphy))
 					usb_phy_set_suspend(hsotg->uphy, true);
-			}
-
-			if (hsotg->hw_params.hibernation) {
+				break;
+			case DWC2_POWER_DOWN_PARAM_HIBERNATION:
 				ret = dwc2_enter_hibernation(hsotg, 0);
-				if (ret && ret != -ENOTSUPP)
+				if (ret)
 					dev_err(hsotg->dev,
-						"%s: enter hibernation failed\n",
-						__func__);
+						"enter hibernation failed\n");
+				break;
+			case DWC2_POWER_DOWN_PARAM_NONE:
+				/*
+				 * If neither hibernation nor partial power down are supported,
+				 * clock gating is used to save power.
+				 */
+				dwc2_gadget_enter_clock_gating(hsotg);
+				break;
 			}
-skip_power_saving:
+
 			/*
 			 * Change to L2 (suspend) state before releasing
 			 * spinlock
@@ -735,10 +754,11 @@ static inline void dwc_handle_gpwrdn_disc_det(struct dwc2_hsotg *hsotg,
  * The GPWRDN interrupts are those that occur in both Host and
  * Device mode while core is in hibernated state.
  */
-static void dwc2_handle_gpwrdn_intr(struct dwc2_hsotg *hsotg)
+static int dwc2_handle_gpwrdn_intr(struct dwc2_hsotg *hsotg)
 {
 	u32 gpwrdn;
 	int linestate;
+	int ret = 0;
 
 	gpwrdn = dwc2_readl(hsotg, GPWRDN);
 	/* clear all interrupt */
@@ -762,10 +782,16 @@ static void dwc2_handle_gpwrdn_intr(struct dwc2_hsotg *hsotg)
 		if (hsotg->hw_params.hibernation &&
 		    hsotg->hibernated) {
 			if (gpwrdn & GPWRDN_IDSTS) {
-				dwc2_exit_hibernation(hsotg, 0, 0, 0);
+				ret = dwc2_exit_hibernation(hsotg, 0, 0, 0);
+				if (ret)
+					dev_err(hsotg->dev,
+						"exit hibernation failed.\n");
 				call_gadget(hsotg, resume);
 			} else {
-				dwc2_exit_hibernation(hsotg, 1, 0, 1);
+				ret = dwc2_exit_hibernation(hsotg, 1, 0, 1);
+				if (ret)
+					dev_err(hsotg->dev,
+						"exit hibernation failed.\n");
 			}
 		}
 	} else if ((gpwrdn & GPWRDN_RST_DET) &&
@@ -784,6 +810,8 @@ static void dwc2_handle_gpwrdn_intr(struct dwc2_hsotg *hsotg)
 		 */
 		dwc_handle_gpwrdn_disc_det(hsotg, gpwrdn);
 	}
+
+	return ret;
 }
 
 /*
diff --git a/drivers/usb/dwc2/debugfs.c b/drivers/usb/dwc2/debugfs.c
index aaafd463d72a..f13eed4231e1 100644
--- a/drivers/usb/dwc2/debugfs.c
+++ b/drivers/usb/dwc2/debugfs.c
@@ -691,6 +691,8 @@ static int params_show(struct seq_file *seq, void *v)
 	print_param(seq, p, ulpi_fs_ls);
 	print_param(seq, p, host_support_fs_ls_low_power);
 	print_param(seq, p, host_ls_low_power_phy_clk);
+	print_param(seq, p, activate_stm_fs_transceiver);
+	print_param(seq, p, activate_stm_id_vb_detection);
 	print_param(seq, p, ts_dline);
 	print_param(seq, p, reload_ctl);
 	print_param_hex(seq, p, ahbcfg);
diff --git a/drivers/usb/dwc2/gadget.c b/drivers/usb/dwc2/gadget.c
index da0df69cc234..ffd0cf69e5b0 100644
--- a/drivers/usb/dwc2/gadget.c
+++ b/drivers/usb/dwc2/gadget.c
@@ -316,7 +316,12 @@ static void dwc2_hsotg_init_fifo(struct dwc2_hsotg *hsotg)
 	u32 *txfsz = hsotg->params.g_tx_fifo_size;
 
 	/* Reset fifo map if not correctly cleared during previous session */
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	dev_dbg(hsotg->dev,
+		"%s: fifo is not cleared correctly\n", __func__);
+#else
 	WARN_ON(hsotg->fifo_map);
+#endif
 	hsotg->fifo_map = 0;
 
 	/* set RX/NPTX FIFO sizes */
@@ -435,6 +440,9 @@ static void dwc2_hsotg_unmap_dma(struct dwc2_hsotg *hsotg,
 	struct usb_request *req = &hs_req->req;
 
 	usb_gadget_unmap_request(&hsotg->gadget, req, hs_ep->map_dir);
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	req->dma = 0;
+#endif
 }
 
 /*
@@ -1267,6 +1275,10 @@ static int dwc2_hsotg_map_dma(struct dwc2_hsotg *hsotg,
 {
 	int ret;
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	if (req->dma)
+		return 0;
+#endif
 	hs_ep->map_dir = hs_ep->dir_in;
 	ret = usb_gadget_map_request(&hsotg->gadget, req, hs_ep->dir_in);
 	if (ret)
@@ -2055,7 +2067,15 @@ static void dwc2_hsotg_enqueue_setup(struct dwc2_hsotg *hsotg)
 
 	ret = dwc2_hsotg_ep_queue(&hsotg->eps_out[0]->ep, req, GFP_ATOMIC);
 	if (ret < 0) {
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+		/* Not to show this message due to flow necessary.
+		 * We may switch to device mode without cable connected.
+		 */
+		if (ret != -EAGAIN)
+			dev_err(hsotg->dev, "%s: failed queue (%d)\n", __func__, ret);
+#else
 		dev_err(hsotg->dev, "%s: failed queue (%d)\n", __func__, ret);
+#endif
 		/*
 		 * Don't think there's much we can do other than watch the
 		 * driver fail.
@@ -3414,7 +3434,7 @@ void dwc2_hsotg_core_init_disconnected(struct dwc2_hsotg *hsotg,
 
 	/* remove the HNP/SRP and set the PHY */
 	usbcfg &= ~(GUSBCFG_SRPCAP | GUSBCFG_HNPCAP);
-        dwc2_writel(hsotg, usbcfg, GUSBCFG);
+	dwc2_writel(hsotg, usbcfg, GUSBCFG);
 
 	dwc2_phy_init(hsotg, true);
 
@@ -3724,10 +3744,10 @@ static irqreturn_t dwc2_hsotg_irq(int irq, void *pw)
 		dwc2_writel(hsotg, GINTSTS_RESETDET, GINTSTS);
 
 		/* This event must be used only if controller is suspended */
-		if (hsotg->lx_state == DWC2_L2) {
-			dwc2_exit_partial_power_down(hsotg, true);
-			hsotg->lx_state = DWC2_L0;
-		}
+		if (hsotg->in_ppd && hsotg->lx_state == DWC2_L2)
+			dwc2_exit_partial_power_down(hsotg, 0, true);
+
+		hsotg->lx_state = DWC2_L0;
 	}
 
 	if (gintsts & (GINTSTS_USBRST | GINTSTS_RESETDET)) {
@@ -4671,11 +4691,15 @@ static int dwc2_hsotg_vbus_session(struct usb_gadget *gadget, int is_active)
 	spin_lock_irqsave(&hsotg->lock, flags);
 
 	/*
-	 * If controller is hibernated, it must exit from power_down
-	 * before being initialized / de-initialized
+	 * If controller is in partial power down state, it must exit from
+	 * that state before being initialized / de-initialized
 	 */
-	if (hsotg->lx_state == DWC2_L2)
-		dwc2_exit_partial_power_down(hsotg, false);
+	if (hsotg->lx_state == DWC2_L2 && hsotg->in_ppd)
+		/*
+		 * No need to check the return value as
+		 * registers are not being restored.
+		 */
+		dwc2_exit_partial_power_down(hsotg, 0, false);
 
 	if (is_active) {
 		hsotg->op_state = OTG_STATE_B_PERIPHERAL;
@@ -4934,6 +4958,10 @@ int dwc2_gadget_init(struct dwc2_hsotg *hsotg)
 	else if (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL)
 		hsotg->op_state = OTG_STATE_B_PERIPHERAL;
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	/* Not support OTG protocol */
+	hsotg->gadget.is_otg = 0;
+#endif
 	ret = dwc2_hsotg_hw_cfg(hsotg);
 	if (ret) {
 		dev_err(hsotg->dev, "Hardware configuration failed: %d\n", ret);
@@ -5357,6 +5385,10 @@ int dwc2_gadget_exit_hibernation(struct dwc2_hsotg *hsotg,
 	dwc2_writel(hsotg, dr->dcfg, DCFG);
 	dwc2_writel(hsotg, dr->dctl, DCTL);
 
+	/* On USB Reset, reset device address to zero */
+	if (reset)
+		dwc2_clear_bit(hsotg, DCFG, DCFG_DEVADDR_MASK);
+
 	/* De-assert Wakeup Logic */
 	gpwrdn = dwc2_readl(hsotg, GPWRDN);
 	gpwrdn &= ~GPWRDN_PMUACTV;
@@ -5407,3 +5439,205 @@ int dwc2_gadget_exit_hibernation(struct dwc2_hsotg *hsotg,
 
 	return ret;
 }
+
+/**
+ * dwc2_gadget_enter_partial_power_down() - Put controller in partial
+ * power down.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ *
+ * Return: non-zero if failed to enter device partial power down.
+ *
+ * This function is for entering device mode partial power down.
+ */
+int dwc2_gadget_enter_partial_power_down(struct dwc2_hsotg *hsotg)
+{
+	u32 pcgcctl;
+	int ret = 0;
+
+	dev_dbg(hsotg->dev, "Entering device partial power down started.\n");
+
+	/* Backup all registers */
+	ret = dwc2_backup_global_registers(hsotg);
+	if (ret) {
+		dev_err(hsotg->dev, "%s: failed to backup global registers\n",
+			__func__);
+		return ret;
+	}
+
+	ret = dwc2_backup_device_registers(hsotg);
+	if (ret) {
+		dev_err(hsotg->dev, "%s: failed to backup device registers\n",
+			__func__);
+		return ret;
+	}
+
+	/*
+	 * Clear any pending interrupts since dwc2 will not be able to
+	 * clear them after entering partial_power_down.
+	 */
+	dwc2_writel(hsotg, 0xffffffff, GINTSTS);
+
+	/* Put the controller in low power state */
+	pcgcctl = dwc2_readl(hsotg, PCGCTL);
+
+	pcgcctl |= PCGCTL_PWRCLMP;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+	udelay(5);
+
+	pcgcctl |= PCGCTL_RSTPDWNMODULE;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+	udelay(5);
+
+	pcgcctl |= PCGCTL_STOPPCLK;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+
+	/* Set in_ppd flag to 1 as here core enters suspend. */
+	hsotg->in_ppd = 1;
+	hsotg->lx_state = DWC2_L2;
+
+	dev_dbg(hsotg->dev, "Entering device partial power down completed.\n");
+
+	return ret;
+}
+
+/*
+ * dwc2_gadget_exit_partial_power_down() - Exit controller from device partial
+ * power down.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ * @restore: indicates whether need to restore the registers or not.
+ *
+ * Return: non-zero if failed to exit device partial power down.
+ *
+ * This function is for exiting from device mode partial power down.
+ */
+int dwc2_gadget_exit_partial_power_down(struct dwc2_hsotg *hsotg,
+					bool restore)
+{
+	u32 pcgcctl;
+	u32 dctl;
+	struct dwc2_dregs_backup *dr;
+	int ret = 0;
+
+	dr = &hsotg->dr_backup;
+
+	dev_dbg(hsotg->dev, "Exiting device partial Power Down started.\n");
+
+	pcgcctl = dwc2_readl(hsotg, PCGCTL);
+	pcgcctl &= ~PCGCTL_STOPPCLK;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+
+	pcgcctl = dwc2_readl(hsotg, PCGCTL);
+	pcgcctl &= ~PCGCTL_PWRCLMP;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+
+	pcgcctl = dwc2_readl(hsotg, PCGCTL);
+	pcgcctl &= ~PCGCTL_RSTPDWNMODULE;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+
+	udelay(100);
+	if (restore) {
+		ret = dwc2_restore_global_registers(hsotg);
+		if (ret) {
+			dev_err(hsotg->dev, "%s: failed to restore registers\n",
+				__func__);
+			return ret;
+		}
+		/* Restore DCFG */
+		dwc2_writel(hsotg, dr->dcfg, DCFG);
+
+		ret = dwc2_restore_device_registers(hsotg, 0);
+		if (ret) {
+			dev_err(hsotg->dev, "%s: failed to restore device registers\n",
+				__func__);
+			return ret;
+		}
+	}
+
+	/* Set the Power-On Programming done bit */
+	dctl = dwc2_readl(hsotg, DCTL);
+	dctl |= DCTL_PWRONPRGDONE;
+	dwc2_writel(hsotg, dctl, DCTL);
+
+	/* Set in_ppd flag to 0 as here core exits from suspend. */
+	hsotg->in_ppd = 0;
+	hsotg->lx_state = DWC2_L0;
+
+	dev_dbg(hsotg->dev, "Exiting device partial Power Down completed.\n");
+	return ret;
+}
+
+/**
+ * dwc2_gadget_enter_clock_gating() - Put controller in clock gating.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ *
+ * Return: non-zero if failed to enter device partial power down.
+ *
+ * This function is for entering device mode clock gating.
+ */
+void dwc2_gadget_enter_clock_gating(struct dwc2_hsotg *hsotg)
+{
+	u32 pcgctl;
+
+	dev_dbg(hsotg->dev, "Entering device clock gating.\n");
+
+	/* Set the Phy Clock bit as suspend is received. */
+	pcgctl = dwc2_readl(hsotg, PCGCTL);
+	pcgctl |= PCGCTL_STOPPCLK;
+	dwc2_writel(hsotg, pcgctl, PCGCTL);
+	udelay(5);
+#if !IS_ENABLED(CONFIG_ARCH_CVITEK)
+	/* Set the Gate hclk as suspend is received. */
+	pcgctl = dwc2_readl(hsotg, PCGCTL);
+	pcgctl |= PCGCTL_GATEHCLK;
+	dwc2_writel(hsotg, pcgctl, PCGCTL);
+	udelay(5);
+#endif
+
+	hsotg->lx_state = DWC2_L2;
+	hsotg->bus_suspended = true;
+}
+
+/*
+ * dwc2_gadget_exit_clock_gating() - Exit controller from device clock gating.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ * @rem_wakeup: indicates whether remote wake up is enabled.
+ *
+ * This function is for exiting from device mode clock gating.
+ */
+void dwc2_gadget_exit_clock_gating(struct dwc2_hsotg *hsotg, int rem_wakeup)
+{
+	u32 pcgctl;
+	u32 dctl;
+
+	dev_dbg(hsotg->dev, "Exiting device clock gating.\n");
+
+#if !IS_ENABLED(CONFIG_ARCH_CVITEK)
+	/* Clear the Gate hclk. */
+	pcgctl = dwc2_readl(hsotg, PCGCTL);
+	pcgctl &= ~PCGCTL_GATEHCLK;
+	dwc2_writel(hsotg, pcgctl, PCGCTL);
+	udelay(5);
+#endif
+
+	/* Phy Clock bit. */
+	pcgctl = dwc2_readl(hsotg, PCGCTL);
+	pcgctl &= ~PCGCTL_STOPPCLK;
+	dwc2_writel(hsotg, pcgctl, PCGCTL);
+	udelay(5);
+
+	if (rem_wakeup) {
+		/* Set Remote Wakeup Signaling */
+		dctl = dwc2_readl(hsotg, DCTL);
+		dctl |= DCTL_RMTWKUPSIG;
+		dwc2_writel(hsotg, dctl, DCTL);
+	}
+
+	/* Change to L0 state */
+	call_gadget(hsotg, resume);
+	hsotg->lx_state = DWC2_L0;
+	hsotg->bus_suspended = false;
+}
diff --git a/drivers/usb/dwc2/hcd.c b/drivers/usb/dwc2/hcd.c
index 9279d3d3698c..8990f4c4b52b 100644
--- a/drivers/usb/dwc2/hcd.c
+++ b/drivers/usb/dwc2/hcd.c
@@ -56,8 +56,6 @@
 #include "core.h"
 #include "hcd.h"
 
-static void dwc2_port_resume(struct dwc2_hsotg *hsotg);
-
 /*
  * =========================================================================
  *  Host Core Layer Functions
@@ -3208,6 +3206,15 @@ static void dwc2_conn_id_status_change(struct work_struct *work)
 		if (count > 250)
 			dev_err(hsotg->dev,
 				"Connection id status change timed out\n");
+
+		/*
+		 * Exit Partial Power Down without restoring registers.
+		 * No need to check the return value as registers
+		 * are not being restored.
+		 */
+		if (hsotg->in_ppd && hsotg->lx_state == DWC2_L2)
+			dwc2_exit_partial_power_down(hsotg, 0, false);
+
 		hsotg->op_state = OTG_STATE_B_PERIPHERAL;
 		dwc2_core_init(hsotg, false);
 		dwc2_enable_global_interrupts(hsotg);
@@ -3277,13 +3284,23 @@ static int dwc2_host_is_b_hnp_enabled(struct dwc2_hsotg *hsotg)
 	return hcd->self.b_hnp_enable;
 }
 
-/* Must NOT be called with interrupt disabled or spinlock held */
-static void dwc2_port_suspend(struct dwc2_hsotg *hsotg, u16 windex)
+/**
+ * dwc2_port_suspend() - Put controller in suspend mode for host.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ * @windex: The control request wIndex field
+ *
+ * Return: non-zero if failed to enter suspend mode for host.
+ *
+ * This function is for entering Host mode suspend.
+ * Must NOT be called with interrupt disabled or spinlock held.
+ */
+int dwc2_port_suspend(struct dwc2_hsotg *hsotg, u16 windex)
 {
 	unsigned long flags;
-	u32 hprt0;
 	u32 pcgctl;
 	u32 gotgctl;
+	int ret = 0;
 
 	dev_dbg(hsotg->dev, "%s()\n", __func__);
 
@@ -3296,22 +3313,33 @@ static void dwc2_port_suspend(struct dwc2_hsotg *hsotg, u16 windex)
 		hsotg->op_state = OTG_STATE_A_SUSPEND;
 	}
 
-	hprt0 = dwc2_read_hprt0(hsotg);
-	hprt0 |= HPRT0_SUSP;
-	dwc2_writel(hsotg, hprt0, HPRT0);
-
-	hsotg->bus_suspended = true;
-
-	/*
-	 * If power_down is supported, Phy clock will be suspended
-	 * after registers are backuped.
-	 */
-	if (!hsotg->params.power_down) {
-		/* Suspend the Phy Clock */
-		pcgctl = dwc2_readl(hsotg, PCGCTL);
-		pcgctl |= PCGCTL_STOPPCLK;
-		dwc2_writel(hsotg, pcgctl, PCGCTL);
-		udelay(10);
+	switch (hsotg->params.power_down) {
+	case DWC2_POWER_DOWN_PARAM_PARTIAL:
+		ret = dwc2_enter_partial_power_down(hsotg);
+		if (ret)
+			dev_err(hsotg->dev,
+				"enter partial_power_down failed.\n");
+		break;
+	case DWC2_POWER_DOWN_PARAM_HIBERNATION:
+		/*
+		 * Perform spin unlock and lock because in
+		 * "dwc2_host_enter_hibernation()" function there is a spinlock
+		 * logic which prevents servicing of any IRQ during entering
+		 * hibernation.
+		 */
+		spin_unlock_irqrestore(&hsotg->lock, flags);
+		ret = dwc2_enter_hibernation(hsotg, 1);
+		if (ret)
+			dev_err(hsotg->dev, "enter hibernation failed.\n");
+		spin_lock_irqsave(&hsotg->lock, flags);
+		break;
+	case DWC2_POWER_DOWN_PARAM_NONE:
+		/*
+		 * If not hibernation nor partial power down are supported,
+		 * clock gating is used to save power.
+		 */
+		dwc2_host_enter_clock_gating(hsotg);
+		break;
 	}
 
 	/* For HNP the bus must be suspended for at least 200ms */
@@ -3326,44 +3354,54 @@ static void dwc2_port_suspend(struct dwc2_hsotg *hsotg, u16 windex)
 	} else {
 		spin_unlock_irqrestore(&hsotg->lock, flags);
 	}
+
+	return ret;
 }
 
-/* Must NOT be called with interrupt disabled or spinlock held */
-static void dwc2_port_resume(struct dwc2_hsotg *hsotg)
+/**
+ * dwc2_port_resume() - Exit controller from suspend mode for host.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ *
+ * Return: non-zero if failed to exit suspend mode for host.
+ *
+ * This function is for exiting Host mode suspend.
+ * Must NOT be called with interrupt disabled or spinlock held.
+ */
+int dwc2_port_resume(struct dwc2_hsotg *hsotg)
 {
 	unsigned long flags;
-	u32 hprt0;
-	u32 pcgctl;
+	int ret = 0;
 
 	spin_lock_irqsave(&hsotg->lock, flags);
 
-	/*
-	 * If power_down is supported, Phy clock is already resumed
-	 * after registers restore.
-	 */
-	if (!hsotg->params.power_down) {
-		pcgctl = dwc2_readl(hsotg, PCGCTL);
-		pcgctl &= ~PCGCTL_STOPPCLK;
-		dwc2_writel(hsotg, pcgctl, PCGCTL);
+	switch (hsotg->params.power_down) {
+	case DWC2_POWER_DOWN_PARAM_PARTIAL:
+		ret = dwc2_exit_partial_power_down(hsotg, 0, true);
+		if (ret)
+			dev_err(hsotg->dev,
+				"exit partial_power_down failed.\n");
+		break;
+	case DWC2_POWER_DOWN_PARAM_HIBERNATION:
+		/* Exit host hibernation. */
+		ret = dwc2_exit_hibernation(hsotg, 0, 0, 1);
+		if (ret)
+			dev_err(hsotg->dev, "exit hibernation failed.\n");
+		break;
+	case DWC2_POWER_DOWN_PARAM_NONE:
+		/*
+		 * If not hibernation nor partial power down are supported,
+		 * port resume is done using the clock gating programming flow.
+		 */
 		spin_unlock_irqrestore(&hsotg->lock, flags);
-		msleep(20);
+		dwc2_host_exit_clock_gating(hsotg, 0);
 		spin_lock_irqsave(&hsotg->lock, flags);
+		break;
 	}
 
-	hprt0 = dwc2_read_hprt0(hsotg);
-	hprt0 |= HPRT0_RES;
-	hprt0 &= ~HPRT0_SUSP;
-	dwc2_writel(hsotg, hprt0, HPRT0);
 	spin_unlock_irqrestore(&hsotg->lock, flags);
 
-	msleep(USB_RESUME_TIMEOUT);
-
-	spin_lock_irqsave(&hsotg->lock, flags);
-	hprt0 = dwc2_read_hprt0(hsotg);
-	hprt0 &= ~(HPRT0_RES | HPRT0_SUSP);
-	dwc2_writel(hsotg, hprt0, HPRT0);
-	hsotg->bus_suspended = false;
-	spin_unlock_irqrestore(&hsotg->lock, flags);
+	return ret;
 }
 
 /* Handles hub class-specific requests */
@@ -3413,12 +3451,8 @@ static int dwc2_hcd_hub_control(struct dwc2_hsotg *hsotg, u16 typereq,
 			dev_dbg(hsotg->dev,
 				"ClearPortFeature USB_PORT_FEAT_SUSPEND\n");
 
-			if (hsotg->bus_suspended) {
-				if (hsotg->hibernated)
-					dwc2_exit_hibernation(hsotg, 0, 0, 1);
-				else
-					dwc2_port_resume(hsotg);
-			}
+			if (hsotg->bus_suspended)
+				retval = dwc2_port_resume(hsotg);
 			break;
 
 		case USB_PORT_FEAT_POWER:
@@ -3629,10 +3663,8 @@ static int dwc2_hcd_hub_control(struct dwc2_hsotg *hsotg, u16 typereq,
 				"SetPortFeature - USB_PORT_FEAT_SUSPEND\n");
 			if (windex != hsotg->otg_port)
 				goto error;
-			if (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_HIBERNATION)
-				dwc2_enter_hibernation(hsotg, 1);
-			else
-				dwc2_port_suspend(hsotg, windex);
+			if (!hsotg->bus_suspended)
+				retval = dwc2_port_suspend(hsotg, windex);
 			break;
 
 		case USB_PORT_FEAT_POWER:
@@ -3647,12 +3679,30 @@ static int dwc2_hcd_hub_control(struct dwc2_hsotg *hsotg, u16 typereq,
 			break;
 
 		case USB_PORT_FEAT_RESET:
-			if (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_HIBERNATION &&
-			    hsotg->hibernated)
-				dwc2_exit_hibernation(hsotg, 0, 1, 1);
-			hprt0 = dwc2_read_hprt0(hsotg);
 			dev_dbg(hsotg->dev,
 				"SetPortFeature - USB_PORT_FEAT_RESET\n");
+
+			hprt0 = dwc2_read_hprt0(hsotg);
+
+			if (hsotg->hibernated) {
+				retval = dwc2_exit_hibernation(hsotg, 0, 1, 1);
+				if (retval)
+					dev_err(hsotg->dev,
+						"exit hibernation failed\n");
+			}
+
+			if (hsotg->in_ppd) {
+				retval = dwc2_exit_partial_power_down(hsotg, 1,
+								      true);
+				if (retval)
+					dev_err(hsotg->dev,
+						"exit partial_power_down failed\n");
+			}
+
+			if (hsotg->params.power_down ==
+			    DWC2_POWER_DOWN_PARAM_NONE && hsotg->bus_suspended)
+				dwc2_host_exit_clock_gating(hsotg, 0);
+
 			pcgctl = dwc2_readl(hsotg, PCGCTL);
 			pcgctl &= ~(PCGCTL_ENBL_SLEEP_GATING | PCGCTL_STOPPCLK);
 			dwc2_writel(hsotg, pcgctl, PCGCTL);
@@ -4305,8 +4355,8 @@ static int _dwc2_hcd_suspend(struct usb_hcd *hcd)
 	struct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);
 	unsigned long flags;
 	int ret = 0;
-	u32 hprt0;
-	u32 pcgctl;
+
+	dev_dbg(hsotg->dev, "DWC OTG HCD SUSPEND\n");
 
 	spin_lock_irqsave(&hsotg->lock, flags);
 
@@ -4323,46 +4373,51 @@ static int _dwc2_hcd_suspend(struct usb_hcd *hcd)
 		goto unlock;
 
 	if (hsotg->params.power_down != DWC2_POWER_DOWN_PARAM_PARTIAL ||
-	    hsotg->flags.b.port_connect_status == 0)
+	    hsotg->flags.b.port_connect_status == 0 || hsotg->bus_suspended)
 		goto skip_power_saving;
 
-	/*
-	 * Drive USB suspend and disable port Power
-	 * if usb bus is not suspended.
-	 */
-	if (!hsotg->bus_suspended) {
-		hprt0 = dwc2_read_hprt0(hsotg);
-		if (hprt0 & HPRT0_CONNSTS) {
-			hprt0 |= HPRT0_SUSP;
-			if (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_PARTIAL)
-				hprt0 &= ~HPRT0_PWR;
-			dwc2_writel(hsotg, hprt0, HPRT0);
-		}
-		if (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_PARTIAL) {
-			spin_unlock_irqrestore(&hsotg->lock, flags);
-			dwc2_vbus_supply_exit(hsotg);
-			spin_lock_irqsave(&hsotg->lock, flags);
-		} else {
-			pcgctl = readl(hsotg->regs + PCGCTL);
-			pcgctl |= PCGCTL_STOPPCLK;
-			writel(pcgctl, hsotg->regs + PCGCTL);
-		}
-	}
+	if (hsotg->flags.b.port_connect_status == 0)
+		goto skip_power_saving;
 
-	if (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_PARTIAL) {
+	switch (hsotg->params.power_down) {
+	case DWC2_POWER_DOWN_PARAM_PARTIAL:
 		/* Enter partial_power_down */
 		ret = dwc2_enter_partial_power_down(hsotg);
-		if (ret) {
-			if (ret != -ENOTSUPP)
-				dev_err(hsotg->dev,
-					"enter partial_power_down failed\n");
-			goto skip_power_saving;
-		}
+		if (ret)
+			dev_err(hsotg->dev,
+				"enter partial_power_down failed\n");
+		/* After entering suspend, hardware is not accessible */
+		clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+		break;
+	case DWC2_POWER_DOWN_PARAM_HIBERNATION:
+		/* Enter hibernation */
+		spin_unlock_irqrestore(&hsotg->lock, flags);
+		ret = dwc2_enter_hibernation(hsotg, 1);
+		if (ret)
+			dev_err(hsotg->dev, "enter hibernation failed\n");
+		spin_lock_irqsave(&hsotg->lock, flags);
+
+		/* After entering suspend, hardware is not accessible */
+		clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+		break;
+	case DWC2_POWER_DOWN_PARAM_NONE:
+		/*
+		 * If not hibernation nor partial power down are supported,
+		 * clock gating is used to save power.
+		 */
+		dwc2_host_enter_clock_gating(hsotg);
 
-		/* After entering partial_power_down, hardware is no more accessible */
+		/* After entering suspend, hardware is not accessible */
 		clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+		break;
+	default:
+		goto skip_power_saving;
 	}
 
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+	dwc2_vbus_supply_exit(hsotg);
+	spin_lock_irqsave(&hsotg->lock, flags);
+
 	/* Ask phy to be suspended */
 	if (!IS_ERR_OR_NULL(hsotg->uphy)) {
 		spin_unlock_irqrestore(&hsotg->lock, flags);
@@ -4382,9 +4437,11 @@ static int _dwc2_hcd_resume(struct usb_hcd *hcd)
 {
 	struct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);
 	unsigned long flags;
-	u32 pcgctl;
+	u32 hprt0;
 	int ret = 0;
 
+	dev_dbg(hsotg->dev, "DWC OTG HCD RESUME\n");
+
 	spin_lock_irqsave(&hsotg->lock, flags);
 
 	if (dwc2_is_device_mode(hsotg))
@@ -4393,68 +4450,102 @@ static int _dwc2_hcd_resume(struct usb_hcd *hcd)
 	if (hsotg->lx_state != DWC2_L2)
 		goto unlock;
 
-	if (hsotg->params.power_down > DWC2_POWER_DOWN_PARAM_PARTIAL) {
+	hprt0 = dwc2_read_hprt0(hsotg);
+
+	/*
+	 * Added port connection status checking which prevents exiting from
+	 * Partial Power Down mode from _dwc2_hcd_resume() if not in Partial
+	 * Power Down mode.
+	 */
+	if (hprt0 & HPRT0_CONNSTS) {
 		hsotg->lx_state = DWC2_L0;
 		goto unlock;
 	}
 
-	/*
-	 * Enable power if not already done.
-	 * This must not be spinlocked since duration
-	 * of this call is unknown.
-	 */
-	if (!IS_ERR_OR_NULL(hsotg->uphy)) {
+	switch (hsotg->params.power_down) {
+	case DWC2_POWER_DOWN_PARAM_PARTIAL:
+		ret = dwc2_exit_partial_power_down(hsotg, 0, true);
+		if (ret)
+			dev_err(hsotg->dev,
+				"exit partial_power_down failed\n");
+		/*
+		 * Set HW accessible bit before powering on the controller
+		 * since an interrupt may rise.
+		 */
+		set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+		break;
+	case DWC2_POWER_DOWN_PARAM_HIBERNATION:
+		ret = dwc2_exit_hibernation(hsotg, 0, 0, 1);
+		if (ret)
+			dev_err(hsotg->dev, "exit hibernation failed.\n");
+
+		/*
+		 * Set HW accessible bit before powering on the controller
+		 * since an interrupt may rise.
+		 */
+		set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+		break;
+	case DWC2_POWER_DOWN_PARAM_NONE:
+		/*
+		 * If not hibernation nor partial power down are supported,
+		 * port resume is done using the clock gating programming flow.
+		 */
 		spin_unlock_irqrestore(&hsotg->lock, flags);
-		usb_phy_set_suspend(hsotg->uphy, false);
+		dwc2_host_exit_clock_gating(hsotg, 0);
+
+		/*
+		 * Initialize the Core for Host mode, as after system resume
+		 * the global interrupts are disabled.
+		 */
+		dwc2_core_init(hsotg, false);
+		dwc2_enable_global_interrupts(hsotg);
+		dwc2_hcd_reinit(hsotg);
 		spin_lock_irqsave(&hsotg->lock, flags);
-	}
 
-	if (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_PARTIAL) {
 		/*
 		 * Set HW accessible bit before powering on the controller
 		 * since an interrupt may rise.
 		 */
 		set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+		break;
+	default:
+		hsotg->lx_state = DWC2_L0;
+		goto unlock;
+	}
 
+	/* Change Root port status, as port status change occurred after resume.*/
+	hsotg->flags.b.port_suspend_change = 1;
 
-		/* Exit partial_power_down */
-		ret = dwc2_exit_partial_power_down(hsotg, true);
-		if (ret && (ret != -ENOTSUPP))
-			dev_err(hsotg->dev, "exit partial_power_down failed\n");
-	} else {
-		pcgctl = readl(hsotg->regs + PCGCTL);
-		pcgctl &= ~PCGCTL_STOPPCLK;
-		writel(pcgctl, hsotg->regs + PCGCTL);
+	/*
+	 * Enable power if not already done.
+	 * This must not be spinlocked since duration
+	 * of this call is unknown.
+	 */
+	if (!IS_ERR_OR_NULL(hsotg->uphy)) {
+		spin_unlock_irqrestore(&hsotg->lock, flags);
+		usb_phy_set_suspend(hsotg->uphy, false);
+		spin_lock_irqsave(&hsotg->lock, flags);
 	}
 
-	hsotg->lx_state = DWC2_L0;
-
+	/* Enable external vbus supply after resuming the port. */
 	spin_unlock_irqrestore(&hsotg->lock, flags);
+	dwc2_vbus_supply_init(hsotg);
 
-	if (hsotg->bus_suspended) {
-		spin_lock_irqsave(&hsotg->lock, flags);
-		hsotg->flags.b.port_suspend_change = 1;
-		spin_unlock_irqrestore(&hsotg->lock, flags);
-		dwc2_port_resume(hsotg);
-	} else {
-		if (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_PARTIAL) {
-			dwc2_vbus_supply_init(hsotg);
-
-			/* Wait for controller to correctly update D+/D- level */
-			usleep_range(3000, 5000);
-		}
+	/* Wait for controller to correctly update D+/D- level */
+	usleep_range(3000, 5000);
+	spin_lock_irqsave(&hsotg->lock, flags);
 
-		/*
-		 * Clear Port Enable and Port Status changes.
-		 * Enable Port Power.
-		 */
-		dwc2_writel(hsotg, HPRT0_PWR | HPRT0_CONNDET |
-				HPRT0_ENACHG, HPRT0);
-		/* Wait for controller to detect Port Connect */
-		usleep_range(5000, 7000);
-	}
+	/*
+	 * Clear Port Enable and Port Status changes.
+	 * Enable Port Power.
+	 */
+	dwc2_writel(hsotg, HPRT0_PWR | HPRT0_CONNDET |
+			HPRT0_ENACHG, HPRT0);
 
-	return ret;
+	/* Wait for controller to detect Port Connect */
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+	usleep_range(5000, 7000);
+	spin_lock_irqsave(&hsotg->lock, flags);
 unlock:
 	spin_unlock_irqrestore(&hsotg->lock, flags);
 
@@ -4565,12 +4656,41 @@ static int _dwc2_hcd_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,
 	struct dwc2_qh *qh;
 	bool qh_allocated = false;
 	struct dwc2_qtd *qtd;
+	struct dwc2_gregs_backup *gr;
+
+	gr = &hsotg->gr_backup;
 
 	if (dbg_urb(urb)) {
 		dev_vdbg(hsotg->dev, "DWC OTG HCD URB Enqueue\n");
 		dwc2_dump_urb_info(hcd, urb, "urb_enqueue");
 	}
 
+	if (hsotg->hibernated) {
+		if (gr->gotgctl & GOTGCTL_CURMODE_HOST)
+			retval = dwc2_exit_hibernation(hsotg, 0, 0, 1);
+		else
+			retval = dwc2_exit_hibernation(hsotg, 0, 0, 0);
+
+		if (retval)
+			dev_err(hsotg->dev,
+				"exit hibernation failed.\n");
+	}
+
+	if (hsotg->in_ppd) {
+		retval = dwc2_exit_partial_power_down(hsotg, 0, true);
+		if (retval)
+			dev_err(hsotg->dev,
+				"exit partial_power_down failed\n");
+	}
+
+	if (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_NONE &&
+	    hsotg->bus_suspended) {
+		if (dwc2_is_device_mode(hsotg))
+			dwc2_gadget_exit_clock_gating(hsotg, 0);
+		else
+			dwc2_host_exit_clock_gating(hsotg, 0);
+	}
+
 	if (!ep)
 		return -EINVAL;
 
@@ -5619,3 +5739,249 @@ bool dwc2_host_can_poweroff_phy(struct dwc2_hsotg *dwc2)
 	/* No reason to keep the PHY powered, so allow poweroff */
 	return true;
 }
+
+/**
+ * dwc2_host_enter_partial_power_down() - Put controller in partial
+ * power down.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ *
+ * Return: non-zero if failed to enter host partial power down.
+ *
+ * This function is for entering Host mode partial power down.
+ */
+int dwc2_host_enter_partial_power_down(struct dwc2_hsotg *hsotg)
+{
+	u32 pcgcctl;
+	u32 hprt0;
+	int ret = 0;
+
+	dev_dbg(hsotg->dev, "Entering host partial power down started.\n");
+
+	/* Put this port in suspend mode. */
+	hprt0 = dwc2_read_hprt0(hsotg);
+	hprt0 |= HPRT0_SUSP;
+	dwc2_writel(hsotg, hprt0, HPRT0);
+	udelay(5);
+
+	/* Wait for the HPRT0.PrtSusp register field to be set */
+	if (dwc2_hsotg_wait_bit_set(hsotg, HPRT0, HPRT0_SUSP, 3000))
+		dev_warn(hsotg->dev, "Suspend wasn't generated\n");
+
+	/* Backup all registers */
+	ret = dwc2_backup_global_registers(hsotg);
+	if (ret) {
+		dev_err(hsotg->dev, "%s: failed to backup global registers\n",
+			__func__);
+		return ret;
+	}
+
+	ret = dwc2_backup_host_registers(hsotg);
+	if (ret) {
+		dev_err(hsotg->dev, "%s: failed to backup host registers\n",
+			__func__);
+		return ret;
+	}
+
+	/*
+	 * Clear any pending interrupts since dwc2 will not be able to
+	 * clear them after entering partial_power_down.
+	 */
+	dwc2_writel(hsotg, 0xffffffff, GINTSTS);
+
+	/* Put the controller in low power state */
+	pcgcctl = dwc2_readl(hsotg, PCGCTL);
+
+	pcgcctl |= PCGCTL_PWRCLMP;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+	udelay(5);
+
+	pcgcctl |= PCGCTL_RSTPDWNMODULE;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+	udelay(5);
+
+	pcgcctl |= PCGCTL_STOPPCLK;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+
+	/* Set in_ppd flag to 1 as here core enters suspend. */
+	hsotg->in_ppd = 1;
+	hsotg->lx_state = DWC2_L2;
+	hsotg->bus_suspended = true;
+
+	dev_dbg(hsotg->dev, "Entering host partial power down completed.\n");
+
+	return ret;
+}
+
+/*
+ * dwc2_host_exit_partial_power_down() - Exit controller from host partial
+ * power down.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ * @rem_wakeup: indicates whether resume is initiated by Reset.
+ * @restore: indicates whether need to restore the registers or not.
+ *
+ * Return: non-zero if failed to exit host partial power down.
+ *
+ * This function is for exiting from Host mode partial power down.
+ */
+int dwc2_host_exit_partial_power_down(struct dwc2_hsotg *hsotg,
+				      int rem_wakeup, bool restore)
+{
+	u32 pcgcctl;
+	int ret = 0;
+	u32 hprt0;
+
+	dev_dbg(hsotg->dev, "Exiting host partial power down started.\n");
+
+	pcgcctl = dwc2_readl(hsotg, PCGCTL);
+	pcgcctl &= ~PCGCTL_STOPPCLK;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+	udelay(5);
+
+	pcgcctl = dwc2_readl(hsotg, PCGCTL);
+	pcgcctl &= ~PCGCTL_PWRCLMP;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+	udelay(5);
+
+	pcgcctl = dwc2_readl(hsotg, PCGCTL);
+	pcgcctl &= ~PCGCTL_RSTPDWNMODULE;
+	dwc2_writel(hsotg, pcgcctl, PCGCTL);
+
+	udelay(100);
+	if (restore) {
+		ret = dwc2_restore_global_registers(hsotg);
+		if (ret) {
+			dev_err(hsotg->dev, "%s: failed to restore registers\n",
+				__func__);
+			return ret;
+		}
+
+		ret = dwc2_restore_host_registers(hsotg);
+		if (ret) {
+			dev_err(hsotg->dev, "%s: failed to restore host registers\n",
+				__func__);
+			return ret;
+		}
+	}
+
+	/* Drive resume signaling and exit suspend mode on the port. */
+	hprt0 = dwc2_read_hprt0(hsotg);
+	hprt0 |= HPRT0_RES;
+	hprt0 &= ~HPRT0_SUSP;
+	dwc2_writel(hsotg, hprt0, HPRT0);
+	udelay(5);
+
+	if (!rem_wakeup) {
+		/* Stop driveing resume signaling on the port. */
+		hprt0 = dwc2_read_hprt0(hsotg);
+		hprt0 &= ~HPRT0_RES;
+		dwc2_writel(hsotg, hprt0, HPRT0);
+
+		hsotg->bus_suspended = false;
+	} else {
+		/* Turn on the port power bit. */
+		hprt0 = dwc2_read_hprt0(hsotg);
+		hprt0 |= HPRT0_PWR;
+		dwc2_writel(hsotg, hprt0, HPRT0);
+
+		/* Connect hcd. */
+		dwc2_hcd_connect(hsotg);
+
+		mod_timer(&hsotg->wkp_timer,
+			  jiffies + msecs_to_jiffies(71));
+	}
+
+	/* Set lx_state to and in_ppd to 0 as here core exits from suspend. */
+	hsotg->in_ppd = 0;
+	hsotg->lx_state = DWC2_L0;
+
+	dev_dbg(hsotg->dev, "Exiting host partial power down completed.\n");
+	return ret;
+}
+
+/**
+ * dwc2_host_enter_clock_gating() - Put controller in clock gating.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ *
+ * This function is for entering Host mode clock gating.
+ */
+void dwc2_host_enter_clock_gating(struct dwc2_hsotg *hsotg)
+{
+	u32 hprt0;
+	u32 pcgctl;
+
+	dev_dbg(hsotg->dev, "Entering host clock gating.\n");
+
+	/* Put this port in suspend mode. */
+	hprt0 = dwc2_read_hprt0(hsotg);
+	hprt0 |= HPRT0_SUSP;
+	dwc2_writel(hsotg, hprt0, HPRT0);
+
+	/* Set the Phy Clock bit as suspend is received. */
+	pcgctl = dwc2_readl(hsotg, PCGCTL);
+	pcgctl |= PCGCTL_STOPPCLK;
+	dwc2_writel(hsotg, pcgctl, PCGCTL);
+	udelay(5);
+
+	/* Set the Gate hclk as suspend is received. */
+	pcgctl = dwc2_readl(hsotg, PCGCTL);
+	pcgctl |= PCGCTL_GATEHCLK;
+	dwc2_writel(hsotg, pcgctl, PCGCTL);
+	udelay(5);
+
+	hsotg->bus_suspended = true;
+	hsotg->lx_state = DWC2_L2;
+}
+
+/**
+ * dwc2_host_exit_clock_gating() - Exit controller from clock gating.
+ *
+ * @hsotg: Programming view of the DWC_otg controller
+ * @rem_wakeup: indicates whether resume is initiated by remote wakeup
+ *
+ * This function is for exiting Host mode clock gating.
+ */
+void dwc2_host_exit_clock_gating(struct dwc2_hsotg *hsotg, int rem_wakeup)
+{
+	u32 hprt0;
+	u32 pcgctl;
+
+	dev_dbg(hsotg->dev, "Exiting host clock gating.\n");
+
+	/* Clear the Gate hclk. */
+	pcgctl = dwc2_readl(hsotg, PCGCTL);
+	pcgctl &= ~PCGCTL_GATEHCLK;
+	dwc2_writel(hsotg, pcgctl, PCGCTL);
+	udelay(5);
+
+	/* Phy Clock bit. */
+	pcgctl = dwc2_readl(hsotg, PCGCTL);
+	pcgctl &= ~PCGCTL_STOPPCLK;
+	dwc2_writel(hsotg, pcgctl, PCGCTL);
+	udelay(5);
+
+	/* Drive resume signaling and exit suspend mode on the port. */
+	hprt0 = dwc2_read_hprt0(hsotg);
+	hprt0 |= HPRT0_RES;
+	hprt0 &= ~HPRT0_SUSP;
+	dwc2_writel(hsotg, hprt0, HPRT0);
+	udelay(5);
+
+	if (!rem_wakeup) {
+		/* In case of port resume need to wait for 40 ms */
+		msleep(USB_RESUME_TIMEOUT);
+
+		/* Stop driveing resume signaling on the port. */
+		hprt0 = dwc2_read_hprt0(hsotg);
+		hprt0 &= ~HPRT0_RES;
+		dwc2_writel(hsotg, hprt0, HPRT0);
+
+		hsotg->bus_suspended = false;
+		hsotg->lx_state = DWC2_L0;
+	} else {
+		mod_timer(&hsotg->wkp_timer,
+			  jiffies + msecs_to_jiffies(71));
+	}
+}
diff --git a/drivers/usb/dwc2/hcd_intr.c b/drivers/usb/dwc2/hcd_intr.c
index d5f4ec1b73b1..4776f34a8273 100644
--- a/drivers/usb/dwc2/hcd_intr.c
+++ b/drivers/usb/dwc2/hcd_intr.c
@@ -1958,6 +1958,23 @@ static void dwc2_hc_chhltd_intr_dma(struct dwc2_hsotg *hsotg,
 				dwc2_halt_channel(hsotg, chan, qtd,
 					DWC2_HC_XFER_PERIODIC_INCOMPLETE);
 			} else {
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+				dev_info(hsotg->dev,
+					"%s: Channel %d - ChHltd set, but reason is unknown, ignore it\n",
+					__func__, chnum);
+				dev_info(hsotg->dev,
+					"hcint 0x%08x, intsts 0x%08x\n",
+					chan->hcint,
+					dwc2_readl(hsotg, GINTSTS));
+				/* Unknown halt reason.
+				 * From the catc, the device returns an incomplete transaction
+				 * but recovers by the USB bus level error handling (resend).
+				 * Make it a successful transaction anyway and let the function
+				 * driver check the content.
+				 */
+				dwc2_hc_xfercomp_intr(hsotg, chan, chnum, qtd);
+			}
+#else
 				dev_err(hsotg->dev,
 					"%s: Channel %d - ChHltd set, but reason is unknown\n",
 					__func__, chnum);
@@ -1966,13 +1983,15 @@ static void dwc2_hc_chhltd_intr_dma(struct dwc2_hsotg *hsotg,
 					chan->hcint,
 					dwc2_readl(hsotg, GINTSTS));
 				goto error;
-			}
+#endif
 		}
 	} else {
 		dev_info(hsotg->dev,
 			 "NYET/NAK/ACK/other in non-error case, 0x%08x\n",
 			 chan->hcint);
+#if !IS_ENABLED(CONFIG_ARCH_CVITEK)
 error:
+#endif
 		/* Failthrough: use 3-strikes rule */
 		qtd->error_count++;
 		dwc2_update_urb_state_abn(hsotg, chan, chnum, qtd->urb,
diff --git a/drivers/usb/dwc2/hw.h b/drivers/usb/dwc2/hw.h
index c3d6dde2aca4..6b16fbf98bc6 100644
--- a/drivers/usb/dwc2/hw.h
+++ b/drivers/usb/dwc2/hw.h
@@ -44,6 +44,7 @@
 #define GOTGCTL_CHIRPEN			BIT(27)
 #define GOTGCTL_MULT_VALID_BC_MASK	(0x1f << 22)
 #define GOTGCTL_MULT_VALID_BC_SHIFT	22
+#define GOTGCTL_CURMODE_HOST		BIT(21)
 #define GOTGCTL_OTGVER			BIT(20)
 #define GOTGCTL_BSESVLD			BIT(19)
 #define GOTGCTL_ASESVLD			BIT(18)
diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 267543c3dc38..b963f0836197 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -163,34 +163,31 @@ static void dwc2_set_stm32f7_hsotg_params(struct dwc2_hsotg *hsotg)
 	p->host_perio_tx_fifo_size = 256;
 }
 
-static void dwc2_set_stm32mp15_fsotg_params(struct dwc2_hsotg *hsotg)
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+static void dwc2_set_cv182x_params(struct dwc2_hsotg *hsotg)
 {
 	struct dwc2_core_params *p = &hsotg->params;
 
 	p->otg_cap = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
-	p->speed = DWC2_SPEED_PARAM_FULL;
-	p->host_rx_fifo_size = 128;
-	p->host_nperio_tx_fifo_size = 96;
-	p->host_perio_tx_fifo_size = 96;
-	p->max_packet_count = 256;
-	p->phy_type = DWC2_PHY_TYPE_PARAM_FS;
-	p->i2c_enable = false;
-	p->activate_stm_fs_transceiver = true;
-	p->activate_stm_id_vb_detection = true;
-	p->power_down = DWC2_POWER_DOWN_PARAM_NONE;
-}
-
-static void dwc2_set_stm32mp15_hsotg_params(struct dwc2_hsotg *hsotg)
-{
-	struct dwc2_core_params *p = &hsotg->params;
-
-	p->otg_cap = DWC2_CAP_PARAM_NO_HNP_SRP_CAPABLE;
-	p->activate_stm_id_vb_detection = !device_property_read_bool(hsotg->dev, "usb-role-switch");
-	p->host_rx_fifo_size = 440;
-	p->host_nperio_tx_fifo_size = 256;
-	p->host_perio_tx_fifo_size = 256;
+	p->speed = DWC2_SPEED_PARAM_HIGH;
+	p->phy_type = DWC2_PHY_TYPE_PARAM_UTMI;
+	p->ahbcfg = GAHBCFG_HBSTLEN_INCR16 << GAHBCFG_HBSTLEN_SHIFT;
+	p->phy_utmi_width = 16;
+	p->g_dma = 1;
+	p->g_dma_desc = 1;
+	p->lpm = false;
+	p->lpm_clock_gating = false;
+	p->besl = false;
+	p->hird_threshold_en = false;
+	p->max_packet_count = (1 << 10) - 1;
+	p->max_transfer_size = (1 << 19) - 1;
+	p->reload_ctl = 0;
+	p->enable_dynamic_fifo = true;
+	p->en_multiple_tx_fifo = true;
+	/* [TODO] shall we power down this ?*/
 	p->power_down = DWC2_POWER_DOWN_PARAM_NONE;
 }
+#endif
 
 const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "brcm,bcm2835-usb", .data = dwc2_set_bcm_params },
@@ -216,10 +213,10 @@ const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "st,stm32f4x9-hsotg" },
 	{ .compatible = "st,stm32f7-hsotg",
 	  .data = dwc2_set_stm32f7_hsotg_params },
-	{ .compatible = "st,stm32mp15-fsotg",
-	  .data = dwc2_set_stm32mp15_fsotg_params },
-	{ .compatible = "st,stm32mp15-hsotg",
-	  .data = dwc2_set_stm32mp15_hsotg_params },
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	{ .compatible = "cvitek,cv182x-usb",
+	  .data = dwc2_set_cv182x_params },
+#endif
 	{},
 };
 MODULE_DEVICE_TABLE(of, dwc2_of_match_table);
@@ -858,10 +855,12 @@ int dwc2_get_hwparams(struct dwc2_hsotg *hsotg)
 	return 0;
 }
 
+typedef void (*set_params_cb)(struct dwc2_hsotg *data);
+
 int dwc2_init_params(struct dwc2_hsotg *hsotg)
 {
 	const struct of_device_id *match;
-	void (*set_params)(struct dwc2_hsotg *data);
+	set_params_cb set_params;
 
 	dwc2_set_default_params(hsotg);
 	dwc2_get_device_properties(hsotg);
diff --git a/drivers/usb/dwc2/pci.c b/drivers/usb/dwc2/pci.c
index 7afc10872f1f..0000151e3ca9 100644
--- a/drivers/usb/dwc2/pci.c
+++ b/drivers/usb/dwc2/pci.c
@@ -63,20 +63,6 @@ struct dwc2_pci_glue {
 	struct platform_device *phy;
 };
 
-static int dwc2_pci_quirks(struct pci_dev *pdev, struct platform_device *dwc2)
-{
-	if (pdev->vendor == PCI_VENDOR_ID_SYNOPSYS &&
-	    pdev->device == PCI_PRODUCT_ID_HAPS_HSOTG) {
-		struct property_entry properties[] = {
-			{ },
-		};
-
-		return platform_device_add_properties(dwc2, properties);
-	}
-
-	return 0;
-}
-
 /**
  * dwc2_pci_probe() - Provides the cleanup entry points for the DWC_otg PCI
  * driver
@@ -143,10 +129,6 @@ static int dwc2_pci_probe(struct pci_dev *pci,
 
 	dwc2->dev.parent = dev;
 
-	ret = dwc2_pci_quirks(pci, dwc2);
-	if (ret)
-		goto err;
-
 	glue = devm_kzalloc(dev, sizeof(*glue), GFP_KERNEL);
 	if (!glue) {
 		ret = -ENOMEM;
diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index 9d0dd09a2015..d012f2731d14 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -47,6 +47,7 @@
 #include <linux/phy/phy.h>
 #include <linux/platform_data/s3c-hsotg.h>
 #include <linux/reset.h>
+#include <linux/of_gpio.h>
 
 #include <linux/usb/of.h>
 
@@ -54,6 +55,15 @@
 #include "hcd.h"
 #include "debug.h"
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+#include <linux/ctype.h>
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+#endif
+#endif
+
 static const char dwc2_driver_name[] = "dwc2";
 
 /*
@@ -121,10 +131,28 @@ static int dwc2_get_dr_mode(struct dwc2_hsotg *hsotg)
 	return 0;
 }
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+static void dwc2_set_hw_id(struct dwc2_hsotg *hsotg, int is_dev)
+{
+	if (is_dev) {
+		/* device */
+		iowrite32((ioread32((void *)hsotg->cviusb.usb_pin_regs) & ~0x0000C0) | 0xC0,
+				(void *)hsotg->cviusb.usb_pin_regs);
+	} else {
+		/* host */
+		iowrite32((ioread32((void *)hsotg->cviusb.usb_pin_regs) & ~0x0000C0) | 0x40,
+				(void *)hsotg->cviusb.usb_pin_regs);
+	}
+}
+#endif
+
 static int __dwc2_lowlevel_hw_enable(struct dwc2_hsotg *hsotg)
 {
 	struct platform_device *pdev = to_platform_device(hsotg->dev);
 	int ret;
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	struct cviusb_dev *cviusb = &hsotg->cviusb;
+#endif
 
 	ret = regulator_bulk_enable(ARRAY_SIZE(hsotg->supplies),
 				    hsotg->supplies);
@@ -137,6 +165,37 @@ static int __dwc2_lowlevel_hw_enable(struct dwc2_hsotg *hsotg)
 			return ret;
 	}
 
+	/* Enable the clock here for init/resume process. */
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	if (!IS_ERR(cviusb->clk_axi.clk_o)) {
+		clk_prepare_enable(cviusb->clk_axi.clk_o);
+		cviusb->clk_axi.is_on = 1;
+		dev_info(hsotg->dev, "axi clk installed\n");
+	}
+	if (!IS_ERR(cviusb->clk_apb.clk_o)) {
+		clk_prepare_enable(cviusb->clk_apb.clk_o);
+		cviusb->clk_apb.is_on = 1;
+		dev_info(hsotg->dev, "apb clk installed\n");
+	}
+	if (!IS_ERR(cviusb->clk_125m.clk_o)) {
+		clk_prepare_enable(cviusb->clk_125m.clk_o);
+		cviusb->clk_125m.is_on = 1;
+		dev_info(hsotg->dev, "125m clk installed\n");
+	}
+	if (!IS_ERR(cviusb->clk_33k.clk_o)) {
+		clk_prepare_enable(cviusb->clk_33k.clk_o);
+		cviusb->clk_33k.is_on = 1;
+		dev_info(hsotg->dev, "33k clk installed\n");
+	}
+	if (!IS_ERR(cviusb->clk_12m.clk_o)) {
+		clk_prepare_enable(cviusb->clk_12m.clk_o);
+		cviusb->clk_12m.is_on = 1;
+		dev_info(hsotg->dev, "12m clk installed\n");
+	}
+
+	dwc2_set_hw_id(hsotg, hsotg->cviusb.id_override);
+#endif
+
 	if (hsotg->uphy) {
 		ret = usb_phy_init(hsotg->uphy);
 	} else if (hsotg->plat && hsotg->plat->phy_init) {
@@ -268,13 +327,14 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 
 	hsotg->plat = dev_get_platdata(hsotg->dev);
 
+#if !IS_ENABLED(CONFIG_ARCH_CVITEK)
 	/* Clock */
 	hsotg->clk = devm_clk_get_optional(hsotg->dev, "otg");
 	if (IS_ERR(hsotg->clk)) {
 		dev_err(hsotg->dev, "cannot get otg clock\n");
 		return PTR_ERR(hsotg->clk);
 	}
-
+#endif
 	/* Regulators */
 	for (i = 0; i < ARRAY_SIZE(hsotg->supplies); i++)
 		hsotg->supplies[i].supply = dwc2_hsotg_supply_names[i];
@@ -290,6 +350,401 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 	return 0;
 }
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+
+#if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || \
+	IS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)
+
+#define PHY_REG(x)	(x)
+
+#define REG014				PHY_REG(0x014)
+#define REG014_UTMI_RESET		(1 << 8)
+#define REG014_DMPULLDOWN		(1 << 7)
+#define REG014_DPPULLDOWN		(1 << 6)
+#define REG014_TERMSEL			(1 << 5)
+#define REG014_XCVRSEL_MASK		(0x3 << 3)
+#define REG014_XCVRSEL_SHIFT		3
+#define REG014_OPMODE_MASK		(0x3 << 1)
+#define REG014_OPMODE_SHIFT		1
+#define REG014_UTMI_OVERRIDE		(1 << 0)
+
+#define REG020				PHY_REG(0x020)
+#define REG020_DP_DET			(1 << 17)
+#define REG020_CHG_DET			(1 << 16)
+#define REG020_VDM_SRC_EN		(1 << 5)
+#define REG020_VDP_SRC_EN		(1 << 4)
+#define REG020_DM_CMP_EN		(1 << 3)
+#define REG020_DP_CMP_EN		(1 << 2)
+#define REG020_DCD_EN			(1 << 1)
+#define REG020_BC_EN			(1 << 0)
+
+#ifdef CONFIG_PROC_FS
+
+#define CVIUSB_ROLE_PROC_NAME "cviusb/otg_role"
+#define CVIUSB_CHGDET_PROC_NAME "cviusb/chg_det"
+
+static struct proc_dir_entry *cviusb_proc_dir;
+static struct proc_dir_entry *cviusb_role_proc_entry;
+static struct proc_dir_entry *cviusb_chgdet_proc_entry;
+
+static u8 *sel_role[] = {
+	"host",
+	"device",
+};
+
+static int proc_role_show(struct seq_file *m, void *v)
+{
+	struct dwc2_hsotg *hsotg = (struct dwc2_hsotg *)m->private;
+
+	seq_printf(m, "%s\n", sel_role[hsotg->cviusb.id_override]);
+
+	return 0;
+}
+
+static int sel_role_hdler(struct dwc2_hsotg *hsotg, char const *input)
+{
+	u32 num;
+	u8 str[80] = {0};
+	u8 t = 0;
+	u8 i, n;
+	u8 *p;
+
+	num = sscanf(input, "%s", str);
+	if (num > 1) {
+		return -EINVAL;
+	}
+
+	/* convert to lower case for following type compare */
+	p = str;
+	for (; *p; ++p)
+		*p = tolower(*p);
+	n = ARRAY_SIZE(sel_role);
+	for (i = 0; i < n; i++) {
+		if (!strcmp(str, sel_role[i])) {
+			t = i;
+			break;
+		}
+	}
+	if (i == n)
+		return -EINVAL;
+
+	hsotg->cviusb.id_override = t;
+	dwc2_set_hw_id(hsotg, t);
+
+	return 0;
+}
+
+static ssize_t role_proc_write(struct file *file, const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char procdata[32] = {'\0'};
+	struct dwc2_hsotg *hsotg = PDE_DATA(file_inode(file));
+
+	if (user_buf == NULL || count >= sizeof(procdata)) {
+		dev_err(hsotg->dev, "Invalid input value\n");
+		return -EINVAL;
+	}
+
+	if (copy_from_user(procdata, user_buf, count)) {
+		dev_err(hsotg->dev, "copy_from_user fail\n");
+		return -EFAULT;
+	}
+
+	sel_role_hdler(hsotg, procdata);
+
+	return count;
+}
+
+static int proc_role_open(struct inode *inode, struct file *file)
+{
+	struct dwc2_hsotg *hsotg = PDE_DATA(inode);
+
+	return single_open(file, proc_role_show, hsotg);
+}
+
+static const struct proc_ops role_proc_ops = {
+	.proc_open		= proc_role_open,
+	.proc_read		= seq_read,
+	.proc_write		= role_proc_write,
+	.proc_lseek		= seq_lseek,
+	.proc_release	= single_release,
+};
+
+#define TDCD_TIMEOUT_MAX	900	//ms
+#define TDCD_TIMEOUT_MIN	300	//ms
+#define TDCD_DBNC		10	//ms
+#define TVDMSRC_EN		20	//ms
+#define TVDPSRC_ON		40	//ms
+#define TVDMSRC_ON		40	//ms
+
+static u8 *dcd_en[] = {
+	"dcd_off",
+	"dcd_on",
+};
+
+static u8 *chg_port[CHGDET_NUM] = {
+	"sdp",
+	"dcp",
+	"cdp",
+};
+
+static void utmi_chgdet_prepare(struct dwc2_hsotg *hsotg)
+{
+	struct cviusb_dev *cviusb = &hsotg->cviusb;
+
+	cviusb_writel(REG014_UTMI_OVERRIDE |
+			(REG014_OPMODE_MASK & (0x1 << REG014_OPMODE_SHIFT)) |
+			(REG014_XCVRSEL_MASK & (0x1 << REG014_XCVRSEL_SHIFT)),
+			cviusb->phy_regs + REG014);
+}
+
+static void utmi_reset(struct dwc2_hsotg *hsotg)
+{
+	struct cviusb_dev *cviusb = &hsotg->cviusb;
+
+	cviusb_writel(0, cviusb->phy_regs + REG014);
+}
+
+static void dcd_det(struct dwc2_hsotg *hsotg)
+{
+	struct cviusb_dev *cviusb = &hsotg->cviusb;
+	int cnt = 0;
+	u32 dbnc = 0;
+
+	/* 1. utmi prepare */
+	utmi_chgdet_prepare(hsotg);
+	/* 2. Enable bc and dcd*/
+	cviusb_writel(REG020_BC_EN | REG020_DCD_EN, cviusb->phy_regs + REG020);
+	/* 3. DCD det in 900ms */
+	while (cnt++ < TDCD_TIMEOUT_MAX) {
+		if (!(dwc2_readl(hsotg, DSTS) & BIT(22)))
+			dbnc += 1;
+		else
+			dbnc = 0;
+		if (dbnc >= TDCD_DBNC)
+			break;
+		usleep_range(1000, 1010);
+	}
+	/* 4. Disable bc dcd. */
+	cviusb_writel(0, cviusb->phy_regs + REG020);
+	/* 5. utmi reset */
+	utmi_reset(hsotg);
+	usleep_range(1000, 1010);
+}
+
+static int chg_det(struct dwc2_hsotg *hsotg)
+{
+	struct cviusb_dev *cviusb = &hsotg->cviusb;
+	int cnt = 0;
+	int det = 0;
+	u32 reg;
+
+	/* 1. Enable bc */
+	cviusb_writel(REG020_BC_EN | REG020_VDP_SRC_EN | REG020_DM_CMP_EN,
+			cviusb->phy_regs + REG020);
+	/* need 2ms delay to avoid the unstable value on DM CMP. */
+	usleep_range(2000, 2010);
+	/* 2. Dm det in 40ms */
+	while (cnt++ < TVDPSRC_ON) {
+		reg = cviusb_readl(cviusb->phy_regs + REG020);
+		if (reg & REG020_CHG_DET)
+			det = 1;
+		if (!det && cnt > TVDMSRC_EN)
+			break;
+		usleep_range(1000, 1010);
+	}
+	/* 3. Disable bc. */
+	cviusb_writel(0, cviusb->phy_regs + REG020);
+
+	return det;
+}
+
+static int cdp_det(struct dwc2_hsotg *hsotg)
+{
+	struct cviusb_dev *cviusb = &hsotg->cviusb;
+	int cnt = 0;
+	int det = 0;
+
+	/* 1. Enable bc */
+	cviusb_writel(REG020_BC_EN | REG020_VDM_SRC_EN | REG020_DP_CMP_EN,
+			cviusb->phy_regs + REG020);
+	usleep_range(1000, 1010);
+	/* 2. Dp det in 40ms */
+	while (cnt++ < TVDMSRC_ON) {
+		if ((cviusb_readl(cviusb->phy_regs + REG020) & REG020_DP_DET))
+			det = 1;
+		/* 5ms for 2nd detection. */
+		if (!det && cnt > 5)
+			break;
+		usleep_range(1000, 1010);
+	}
+	/* 3. Disable bc. */
+	cviusb_writel(0, cviusb->phy_regs + REG020);
+
+	return !det;
+}
+
+static int proc_chgdet_show(struct seq_file *m, void *v)
+{
+	struct dwc2_hsotg *hsotg = (struct dwc2_hsotg *)m->private;
+	struct cviusb_dev *cviusb = &hsotg->cviusb;
+	u32 reg;
+
+	if (!hsotg->cviusb.id_override)
+		return -EPERM;
+
+	/* Disconnect the data line. */
+	reg = dwc2_readl(hsotg, DCTL) | DCTL_SFTDISCON;
+	dwc2_writel(hsotg, reg, DCTL);
+
+	/* Run dcd detection or wait TDCD_TIMEOUT_MIN. */
+	if (cviusb->dcd_dis)
+		msleep(TDCD_TIMEOUT_MIN);
+	else
+		dcd_det(hsotg);
+	/* Run chgdet */
+	if (chg_det(hsotg)) {
+		usleep_range(1000, 1010);
+		if (cdp_det(hsotg))
+			cviusb->chgdet = CHGDET_CDP;
+		else
+			cviusb->chgdet = CHGDET_DCP;
+	} else
+		cviusb->chgdet = CHGDET_SDP;
+
+	/* Run dcpdet */
+	seq_printf(m, "%s\n", chg_port[hsotg->cviusb.chgdet]);
+
+	return 0;
+}
+
+static int dcd_en_hdler(struct dwc2_hsotg *hsotg, char const *input)
+{
+	u32 num;
+	u8 str[80] = {0};
+	u8 t = 0;
+	u8 i, n;
+	u8 *p;
+
+	num = sscanf(input, "%s", str);
+	if (num > 1) {
+		return -EINVAL;
+	}
+
+	/* convert to lower case for following type compare */
+	p = str;
+	for (; *p; ++p)
+		*p = tolower(*p);
+	n = ARRAY_SIZE(dcd_en);
+	for (i = 0; i < n; i++) {
+		if (!strcmp(str, dcd_en[i])) {
+			t = i;
+			break;
+		}
+	}
+	if (i == n)
+		return -EINVAL;
+
+	switch (t) {
+	case 0:
+		/* dcd off */
+		hsotg->cviusb.dcd_dis = 1;
+		break;
+	case 1:
+		/* dcd on */
+		hsotg->cviusb.dcd_dis = 0;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static ssize_t chgdet_proc_write(struct file *file, const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char procdata[32] = {'\0'};
+	struct dwc2_hsotg *hsotg = PDE_DATA(file_inode(file));
+
+	if (user_buf == NULL || count >= sizeof(procdata)) {
+		dev_err(hsotg->dev, "Invalid input value\n");
+		return -EINVAL;
+	}
+
+	if (copy_from_user(procdata, user_buf, count)) {
+		dev_err(hsotg->dev, "copy_from_user fail\n");
+		return -EFAULT;
+	}
+
+	dcd_en_hdler(hsotg, procdata);
+
+	return count;
+}
+
+static int proc_chgdet_open(struct inode *inode, struct file *file)
+{
+	struct dwc2_hsotg *hsotg = PDE_DATA(inode);
+
+	return single_open(file, proc_chgdet_show, hsotg);
+}
+
+static const struct proc_ops chgdet_proc_ops = {
+	.proc_open		= proc_chgdet_open,
+	.proc_read		= seq_read,
+	.proc_write		= chgdet_proc_write,
+	.proc_lseek		= seq_lseek,
+	.proc_release	= single_release,
+};
+
+#endif
+
+static int vbus_is_present(struct cviusb_dev *cviusb)
+{
+	if (gpio_is_valid(cviusb->vbus_pin))
+		return gpio_get_value(cviusb->vbus_pin) ^
+			cviusb->vbus_pin_inverted;
+
+	/* No Vbus detection: Assume always present */
+	return 1;
+}
+
+static irqreturn_t vbus_irq_handler(int irq, void *devid)
+{
+	struct cviusb_dev *cviusb = devid;
+	struct dwc2_hsotg *hsotg = container_of(cviusb, struct dwc2_hsotg, cviusb);
+	int vbus;
+
+	/* do nothing if we are an A-device (vbus provider). */
+	if (hsotg->op_state != OTG_STATE_B_PERIPHERAL)
+		return IRQ_HANDLED;
+	vbus = vbus_is_present(cviusb);
+	dev_dbg(hsotg->dev, "vbus int = %d\n", vbus);
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t vbus_irq_thread(int irq, void *devid)
+{
+	struct cviusb_dev *cviusb = devid;
+	struct dwc2_hsotg *hsotg = container_of(cviusb, struct dwc2_hsotg, cviusb);
+	struct usb_gadget *gadget = &hsotg->gadget;
+	int vbus;
+
+	if (!gadget->udc)
+		return IRQ_HANDLED;
+
+	/* debounce */
+	udelay(10);
+	vbus = vbus_is_present(cviusb);
+	if (cviusb->pre_vbus_status != vbus) {
+		dev_dbg(hsotg->dev, "vbus thread = %d\n", vbus);
+		usb_udc_vbus_handler(gadget, (vbus != 0));
+		cviusb->pre_vbus_status = vbus;
+	}
+	return IRQ_HANDLED;
+}
+#endif	/* CONFIG_USB_DWC2_PERIPHERAL || CONFIG_USB_DWC2_DUAL_ROLE */
+
+#endif	/* CONFIG_ARCH_CVITEK */
+
 /**
  * dwc2_driver_remove() - Called when the DWC_otg core is unregistered with the
  * DWC_otg driver
@@ -304,6 +759,46 @@ static int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)
 static int dwc2_driver_remove(struct platform_device *dev)
 {
 	struct dwc2_hsotg *hsotg = platform_get_drvdata(dev);
+	struct dwc2_gregs_backup *gr;
+	int ret = 0;
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	struct cviusb_dev *cviusb = &hsotg->cviusb;
+
+	devm_free_irq(&dev->dev,
+		      gpio_to_irq(hsotg->cviusb.vbus_pin),
+		      (void *)&hsotg->cviusb);
+#endif
+
+	gr = &hsotg->gr_backup;
+
+	/* Exit Hibernation when driver is removed. */
+	if (hsotg->hibernated) {
+		if (gr->gotgctl & GOTGCTL_CURMODE_HOST)
+			ret = dwc2_exit_hibernation(hsotg, 0, 0, 1);
+		else
+			ret = dwc2_exit_hibernation(hsotg, 0, 0, 0);
+
+		if (ret)
+			dev_err(hsotg->dev,
+				"exit hibernation failed.\n");
+	}
+
+	/* Exit Partial Power Down when driver is removed. */
+	if (hsotg->in_ppd) {
+		ret = dwc2_exit_partial_power_down(hsotg, 0, true);
+		if (ret)
+			dev_err(hsotg->dev,
+				"exit partial_power_down failed\n");
+	}
+
+	/* Exit clock gating when driver is removed. */
+	if (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_NONE &&
+	    hsotg->bus_suspended) {
+		if (dwc2_is_device_mode(hsotg))
+			dwc2_gadget_exit_clock_gating(hsotg, 0);
+		else
+			dwc2_host_exit_clock_gating(hsotg, 0);
+	}
 
 	dwc2_debugfs_exit(hsotg);
 	if (hsotg->hcd_enabled)
@@ -311,7 +806,9 @@ static int dwc2_driver_remove(struct platform_device *dev)
 	if (hsotg->gadget_enabled)
 		dwc2_hsotg_remove(hsotg);
 
+#if IS_ENABLED(CONFIG_USB_ROLE_SWITCH)
 	dwc2_drd_exit(hsotg);
+#endif
 
 	if (hsotg->params.activate_stm_id_vb_detection)
 		regulator_disable(hsotg->usb33d);
@@ -322,7 +819,50 @@ static int dwc2_driver_remove(struct platform_device *dev)
 	reset_control_assert(hsotg->reset);
 	reset_control_assert(hsotg->reset_ecc);
 
-	return 0;
+	/* Disable the clock here for remove process. */
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	if (cviusb->clk_axi.clk_o) {
+		clk_disable_unprepare(cviusb->clk_axi.clk_o);
+		dev_info(hsotg->dev, "axi clk disable\n");
+		cviusb->clk_axi.is_on = 0;
+	}
+	if (cviusb->clk_apb.clk_o) {
+		clk_disable_unprepare(cviusb->clk_apb.clk_o);
+		dev_info(hsotg->dev, "apb clk disable\n");
+		cviusb->clk_apb.is_on = 0;
+	}
+	if (cviusb->clk_125m.clk_o) {
+		clk_disable_unprepare(cviusb->clk_125m.clk_o);
+		dev_info(hsotg->dev, "125m clk disable\n");
+		cviusb->clk_125m.is_on = 0;
+	}
+	if (cviusb->clk_33k.clk_o) {
+		clk_disable_unprepare(cviusb->clk_33k.clk_o);
+		dev_info(hsotg->dev, "33k clk disable\n");
+		cviusb->clk_33k.is_on = 0;
+	}
+	if (cviusb->clk_12m.clk_o) {
+		clk_disable_unprepare(cviusb->clk_12m.clk_o);
+		dev_info(hsotg->dev, "12m clk disable\n");
+		cviusb->clk_12m.is_on = 0;
+	}
+
+#if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || \
+	IS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)
+
+#ifdef CONFIG_PROC_FS
+	proc_remove(cviusb_chgdet_proc_entry);
+	proc_remove(cviusb_role_proc_entry);
+	proc_remove(cviusb_proc_dir);
+	cviusb_proc_dir = NULL;
+	cviusb_role_proc_entry = NULL;
+#endif	/* CONFIG_PROC_FS */
+
+#endif	/* CONFIG_USB_DWC2_PERIPHERAL || CONFIG_USB_DWC2_DUAL_ROLE */
+
+#endif
+
+	return ret;
 }
 
 /**
@@ -410,6 +950,10 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	struct dwc2_hsotg *hsotg;
 	struct resource *res;
 	int retval;
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	struct cviusb_dev *cviusb;
+	enum of_gpio_flags	flags;
+#endif
 
 	hsotg = devm_kzalloc(&dev->dev, sizeof(*hsotg), GFP_KERNEL);
 	if (!hsotg)
@@ -434,7 +978,40 @@ static int dwc2_driver_probe(struct platform_device *dev)
 
 	dev_dbg(&dev->dev, "mapped PA %08lx to VA %p\n",
 		(unsigned long)res->start, hsotg->regs);
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	cviusb = &hsotg->cviusb;
+	cviusb->usb_pin_regs = ioremap(0x03000048, 0x4);
+	/* init as host mode */
+	hsotg->cviusb.id_override = 0;
+	res = platform_get_resource(dev, IORESOURCE_MEM, 1);
+	cviusb->phy_regs = devm_ioremap_resource(&dev->dev, res);
+	if (IS_ERR(cviusb->phy_regs))
+		return PTR_ERR(cviusb->phy_regs);
+
+	dev_dbg(&dev->dev, "mapped PA %08lx to VA %p\n",
+		(unsigned long)res->start, cviusb->phy_regs);
 
+	cviusb->clk_axi.clk_o = devm_clk_get(&dev->dev, "clk_axi");
+	if (IS_ERR(cviusb->clk_axi.clk_o)) {
+		dev_warn(&dev->dev, "Clock axi not found\n");
+	}
+	cviusb->clk_apb.clk_o = devm_clk_get(&dev->dev, "clk_apb");
+	if (IS_ERR(cviusb->clk_apb.clk_o)) {
+		dev_warn(&dev->dev, "Clock apb not found\n");
+	}
+	cviusb->clk_125m.clk_o = devm_clk_get(&dev->dev, "clk_125m");
+	if (IS_ERR(cviusb->clk_125m.clk_o)) {
+		dev_warn(&dev->dev, "Clock 125m not found\n");
+	}
+	cviusb->clk_33k.clk_o = devm_clk_get(&dev->dev, "clk_33k");
+	if (IS_ERR(cviusb->clk_33k.clk_o)) {
+		dev_warn(&dev->dev, "Clock 33k not found\n");
+	}
+	cviusb->clk_12m.clk_o = devm_clk_get(&dev->dev, "clk_12m");
+	if (IS_ERR(cviusb->clk_12m.clk_o)) {
+		dev_warn(&dev->dev, "Clock 12m not found\n");
+	}
+#endif
 	retval = dwc2_lowlevel_hw_init(hsotg);
 	if (retval)
 		return retval;
@@ -465,6 +1042,10 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	if (retval)
 		return retval;
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	/* Not to eanble the GINtMSK till all isr are ready. */
+	dwc2_writel(hsotg, 0, GINTMSK);
+#endif
 	hsotg->needs_byte_swap = dwc2_check_core_endianness(hsotg);
 
 	retval = dwc2_get_dr_mode(hsotg);
@@ -535,12 +1116,14 @@ static int dwc2_driver_probe(struct platform_device *dev)
 		usleep_range(5000, 7000);
 	}
 
+#if IS_ENABLED(CONFIG_USB_ROLE_SWITCH)
 	retval = dwc2_drd_init(hsotg);
 	if (retval) {
 		if (retval != -EPROBE_DEFER)
 			dev_err(hsotg->dev, "failed to initialize dual-role\n");
 		goto error_init;
 	}
+#endif
 
 	if (hsotg->dr_mode != USB_DR_MODE_HOST) {
 		retval = dwc2_gadget_init(hsotg);
@@ -597,6 +1180,62 @@ static int dwc2_driver_probe(struct platform_device *dev)
 		}
 	}
 #endif /* CONFIG_USB_DWC2_PERIPHERAL || CONFIG_USB_DWC2_DUAL_ROLE */
+
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+
+#if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || \
+	IS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)
+
+	hsotg->cviusb.vbus_pin = of_get_named_gpio_flags(dev->dev.of_node,
+				"vbus-gpio", 0, &flags);
+	hsotg->cviusb.vbus_pin_inverted = (flags & OF_GPIO_ACTIVE_LOW) ? 1 : 0;
+	dev_dbg(hsotg->dev, "vbus_pin = %d, flags = %d\n",
+			hsotg->cviusb.vbus_pin, hsotg->cviusb.vbus_pin_inverted);
+	if (gpio_is_valid(hsotg->cviusb.vbus_pin)) {
+		if (!devm_gpio_request(&dev->dev,
+			hsotg->cviusb.vbus_pin, "cviusb-otg")) {
+			irq_set_status_flags(gpio_to_irq(hsotg->cviusb.vbus_pin),
+					IRQ_NOAUTOEN);
+			retval = devm_request_threaded_irq(&dev->dev,
+					gpio_to_irq(hsotg->cviusb.vbus_pin),
+					vbus_irq_handler,
+					vbus_irq_thread,
+					IRQF_TRIGGER_RISING |
+					IRQF_TRIGGER_FALLING,
+					"cviusb-otg", (void *)&hsotg->cviusb);
+			if (retval) {
+				hsotg->cviusb.vbus_pin = -ENODEV;
+				dev_err(hsotg->dev,
+					"failed to request vbus irq\n");
+			} else {
+				hsotg->cviusb.pre_vbus_status = vbus_is_present(&hsotg->cviusb);
+				enable_irq(gpio_to_irq(hsotg->cviusb.vbus_pin));
+				dev_dbg(hsotg->dev,
+					"enable vbus irq, vbus status = %d\n",
+					hsotg->cviusb.pre_vbus_status);
+			}
+		} else {
+			/* gpio_request fail so use -EINVAL for gpio_is_valid */
+			hsotg->cviusb.vbus_pin = -EINVAL;
+			dev_err(hsotg->dev, "request gpio fail!\n");
+		}
+	}
+
+#ifdef CONFIG_PROC_FS
+	cviusb_proc_dir = proc_mkdir("cviusb", NULL);
+	cviusb_role_proc_entry = proc_create_data(CVIUSB_ROLE_PROC_NAME, 0644, NULL,
+					  &role_proc_ops, hsotg);
+	if (!cviusb_role_proc_entry)
+		dev_err(&dev->dev, "cviusb: can't role procfs.\n");
+	cviusb_chgdet_proc_entry = proc_create_data(CVIUSB_CHGDET_PROC_NAME, 0644, NULL,
+					  &chgdet_proc_ops, hsotg);
+	if (!cviusb_chgdet_proc_entry)
+		dev_err(&dev->dev, "cviusb: can't chgdet procfs.\n");
+#endif	/* CONFIG_PROC_FS */
+
+#endif	/* CONFIG_USB_DWC2_PERIPHERAL || CONFIG_USB_DWC2_DUAL_ROLE */
+
+#endif	/* CONFIG_ARCH_CVITEK */
 	return 0;
 
 #if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || \
@@ -606,8 +1245,11 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	if (hsotg->hcd_enabled)
 		dwc2_hcd_remove(hsotg);
 #endif
+
 error_drd:
+#if IS_ENABLED(CONFIG_USB_ROLE_SWITCH)
 	dwc2_drd_exit(hsotg);
+#endif
 
 error_init:
 	if (hsotg->params.activate_stm_id_vb_detection)
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 2d152571a7de..4fbff3c5153e 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -457,6 +457,17 @@ config USB_CONFIGFS_F_UVC
 	  device. It provides a userspace API to process UVC control requests
 	  and stream video data to the host.
 
+config USB_UVCG_SG_TRANSFER
+	bool "USB UVCG SG Support"
+	depends on USB_CONFIGFS_F_UVC
+	depends on VIDEO_V4L2
+	depends on VIDEO_DEV
+	default n
+	help
+	  Enable the scatter-gather method for isochronous transfer in UVC.
+	  The USB device controller shall be able to queue multiple u-frame
+	  data by dma desriptors.
+
 config USB_CONFIGFS_F_PRINTER
 	bool "Printer function"
 	select USB_F_PRINTER
diff --git a/drivers/usb/gadget/function/f_uac1.c b/drivers/usb/gadget/function/f_uac1.c
index e65f474ad7b3..060c303aec17 100644
--- a/drivers/usb/gadget/function/f_uac1.c
+++ b/drivers/usb/gadget/function/f_uac1.c
@@ -56,6 +56,19 @@ static inline struct f_uac1_opts *g_audio_to_uac1_opts(struct g_audio *audio)
 /* Number of streaming interfaces */
 #define F_AUDIO_NUM_INTERFACES		2
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+static struct usb_interface_assoc_descriptor iad_desc = {
+	.bLength = sizeof(iad_desc),
+	.bDescriptorType = USB_DT_INTERFACE_ASSOCIATION,
+
+	.bFirstInterface = 0,
+	.bInterfaceCount = 3,
+	.bFunctionClass = USB_CLASS_AUDIO,
+	.bFunctionSubClass = USB_SUBCLASS_AUDIOSTREAMING,
+	.bFunctionProtocol = UAC_VERSION_1,
+};
+#endif
+
 /* B.3.1  Standard AC Interface Descriptor */
 static struct usb_interface_descriptor ac_interface_desc = {
 	.bLength =		USB_DT_INTERFACE_SIZE,
@@ -255,6 +268,9 @@ static struct uac_iso_endpoint_descriptor as_iso_in_desc = {
 };
 
 static struct usb_descriptor_header *f_audio_desc[] = {
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	(struct usb_descriptor_header *) &iad_desc,
+#endif
 	(struct usb_descriptor_header *)&ac_interface_desc,
 	(struct usb_descriptor_header *)&ac_header_desc,
 
@@ -567,6 +583,9 @@ static int f_audio_bind(struct usb_configuration *c, struct usb_function *f)
 	us = usb_gstrings_attach(cdev, uac1_strings, ARRAY_SIZE(strings_uac1));
 	if (IS_ERR(us))
 		return PTR_ERR(us);
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	iad_desc.iFunction = us[STR_AC_IF].id;
+#endif
 	ac_interface_desc.iInterface = us[STR_AC_IF].id;
 	usb_out_it_desc.iTerminal = us[STR_USB_OUT_IT].id;
 	usb_out_it_desc.iChannelNames = us[STR_USB_OUT_IT_CH_NAMES].id;
@@ -603,6 +622,9 @@ static int f_audio_bind(struct usb_configuration *c, struct usb_function *f)
 	status = usb_interface_id(c, f);
 	if (status < 0)
 		goto fail;
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	iad_desc.bFirstInterface = status;
+#endif
 	ac_interface_desc.bInterfaceNumber = status;
 	uac1->ac_intf = status;
 	uac1->ac_alt = 0;
diff --git a/drivers/usb/gadget/function/u_audio.c b/drivers/usb/gadget/function/u_audio.c
index 6c8b8f5b7e0f..6ffb5ac6cc3c 100644
--- a/drivers/usb/gadget/function/u_audio.c
+++ b/drivers/usb/gadget/function/u_audio.c
@@ -23,6 +23,49 @@
 #define PRD_SIZE_MAX	PAGE_SIZE
 #define MIN_PERIODS	4
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK) && defined(UAC1_DBG)
+
+#define dprintk(fmt, arg...)	pr_debug(KERN_DEBUG "%s: " fmt, __func__, ## arg)
+
+#define UAC_DBG_NUM	40
+struct uac_dbg_s {
+	struct timeval	time;
+	struct usb_request req;
+};
+
+static struct uac_dbg_s uac_dbg[UAC_DBG_NUM];
+static int uac_dbg_idx = UAC_DBG_NUM;
+module_param(uac_dbg_idx, int, 0644);
+
+static void uac_dbg_log(struct usb_request *req)
+{
+	struct timeval tv;
+	struct uac_dbg_s *dbg;
+
+	if (uac_dbg_idx >= UAC_DBG_NUM)
+		return;
+
+	do_gettimeofday(&tv);
+	dbg = &uac_dbg[uac_dbg_idx];
+	memcpy(&dbg->req, req, sizeof(struct usb_request));
+	dbg->time.tv_sec = tv.tv_sec;
+	dbg->time.tv_usec = tv.tv_usec;
+	uac_dbg_idx++;
+
+	if (uac_dbg_idx == UAC_DBG_NUM) {
+		int i;
+		u64 time_0;
+
+		for (i = 0; i < uac_dbg_idx; i++) {
+			//time_0 = (uac_dbg[i].time.tv_sec * STOUS) + uac_dbg[i].time.tv_usec;
+			time_0 = uac_dbg[i].time.tv_usec;
+			dprintk("[%d - %llu] status = %d, length = %d\n", i,
+					time_0, uac_dbg[i].req.status, uac_dbg[i].req.actual);
+		}
+	}
+}
+#endif
+
 struct uac_req {
 	struct uac_rtd_params *pp; /* parent param */
 	struct usb_request *req;
@@ -97,6 +140,9 @@ static void u_audio_iso_complete(struct usb_ep *ep, struct usb_request *req)
 	if (req->status == -ESHUTDOWN)
 		return;
 
+#if IS_ENABLED(CONFIG_ARCH_CVITEK) && defined(UAC1_DBG)
+	uac_dbg_log(req);
+#endif
 	/*
 	 * We can't really do much about bad xfers.
 	 * Afterall, the ISOCH xfers could fail legitimately.
@@ -370,6 +416,9 @@ int u_audio_start_capture(struct g_audio *audio_dev)
 
 	ep = audio_dev->out_ep;
 	prm = &uac->c_prm;
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	usb_ep_disable(ep);
+#endif
 	config_ep_by_speed(gadget, &audio_dev->func, ep);
 	req_len = ep->maxpacket;
 
@@ -423,6 +472,9 @@ int u_audio_start_playback(struct g_audio *audio_dev)
 
 	ep = audio_dev->in_ep;
 	prm = &uac->p_prm;
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	usb_ep_disable(ep);
+#endif
 	config_ep_by_speed(gadget, &audio_dev->func, ep);
 
 	ep_desc = ep->desc;
diff --git a/drivers/usb/gadget/function/u_uac1.h b/drivers/usb/gadget/function/u_uac1.h
index 39c0e29e1b46..723a6ee34157 100644
--- a/drivers/usb/gadget/function/u_uac1.h
+++ b/drivers/usb/gadget/function/u_uac1.h
@@ -10,15 +10,19 @@
 
 #include <linux/usb/composite.h>
 
-#define UAC1_OUT_EP_MAX_PACKET_SIZE	200
 #define UAC1_DEF_CCHMASK	0x3
 #define UAC1_DEF_CSRATE		48000
 #define UAC1_DEF_CSSIZE		2
 #define UAC1_DEF_PCHMASK	0x3
 #define UAC1_DEF_PSRATE		48000
 #define UAC1_DEF_PSSIZE		2
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+#define UAC1_OUT_EP_MAX_PACKET_SIZE	256
+#define UAC1_DEF_REQ_NUM	3
+#else
+#define UAC1_OUT_EP_MAX_PACKET_SIZE	200
 #define UAC1_DEF_REQ_NUM	2
-
+#endif
 
 struct f_uac1_opts {
 	struct usb_function_instance	func_inst;
diff --git a/drivers/usb/gadget/function/uvc_configfs.c b/drivers/usb/gadget/function/uvc_configfs.c
index 2db01170d096..19e720896a14 100644
--- a/drivers/usb/gadget/function/uvc_configfs.c
+++ b/drivers/usb/gadget/function/uvc_configfs.c
@@ -824,11 +824,13 @@ static const struct uvcg_config_group_type uvcg_control_grp_type = {
 static const char * const uvcg_format_names[] = {
 	"uncompressed",
 	"mjpeg",
+	"framebased",
 };
 
 enum uvcg_format_type {
 	UVCG_UNCOMPRESSED = 0,
 	UVCG_MJPEG,
+	UVCG_FRAMEBASED,
 };
 
 struct uvcg_format {
@@ -1134,9 +1136,15 @@ struct uvcg_frame {
 		u16	w_height;
 		u32	dw_min_bit_rate;
 		u32	dw_max_bit_rate;
+		/*
+		 * dw_max_video_frame_buffer_size is only for uncompressed and
+		 * mjpeg format
+		 */
 		u32	dw_max_video_frame_buffer_size;
 		u32	dw_default_frame_interval;
 		u8	b_frame_interval_type;
+		/* dw_bytes_perline is only for framebased format */
+		u32	dw_bytes_perline;
 	} __attribute__((packed)) frame;
 	u32 *dw_frame_interval;
 };
@@ -1247,7 +1255,7 @@ UVCG_FRAME_ATTR(dw_min_bit_rate, dwMinBitRate, 32);
 UVCG_FRAME_ATTR(dw_max_bit_rate, dwMaxBitRate, 32);
 UVCG_FRAME_ATTR(dw_max_video_frame_buffer_size, dwMaxVideoFrameBufferSize, 32);
 UVCG_FRAME_ATTR(dw_default_frame_interval, dwDefaultFrameInterval, 32);
-
+UVCG_FRAME_ATTR(dw_bytes_perline, dwBytesPerLine, 32);
 #undef UVCG_FRAME_ATTR
 
 static ssize_t uvcg_frame_dw_frame_interval_show(struct config_item *item,
@@ -1381,7 +1389,7 @@ static ssize_t uvcg_frame_dw_frame_interval_store(struct config_item *item,
 
 UVC_ATTR(uvcg_frame_, dw_frame_interval, dwFrameInterval);
 
-static struct configfs_attribute *uvcg_frame_attrs[] = {
+static struct configfs_attribute *uvcg_frame_attrs1[] = {
 	&uvcg_frame_attr_b_frame_index,
 	&uvcg_frame_attr_bm_capabilities,
 	&uvcg_frame_attr_w_width,
@@ -1394,9 +1402,28 @@ static struct configfs_attribute *uvcg_frame_attrs[] = {
 	NULL,
 };
 
-static const struct config_item_type uvcg_frame_type = {
+static struct configfs_attribute *uvcg_frame_attrs2[] = {
+	&uvcg_frame_attr_b_frame_index,
+	&uvcg_frame_attr_bm_capabilities,
+	&uvcg_frame_attr_w_width,
+	&uvcg_frame_attr_w_height,
+	&uvcg_frame_attr_dw_min_bit_rate,
+	&uvcg_frame_attr_dw_max_bit_rate,
+	&uvcg_frame_attr_dw_default_frame_interval,
+	&uvcg_frame_attr_dw_frame_interval,
+	&uvcg_frame_attr_dw_bytes_perline,
+	NULL,
+};
+
+static const struct config_item_type uvcg_frame_type1 = {
 	.ct_item_ops	= &uvcg_config_item_ops,
-	.ct_attrs	= uvcg_frame_attrs,
+	.ct_attrs	= uvcg_frame_attrs1,
+	.ct_owner	= THIS_MODULE,
+};
+
+static const struct config_item_type uvcg_frame_type2 = {
+	.ct_item_ops	= &uvcg_config_item_ops,
+	.ct_attrs	= uvcg_frame_attrs2,
 	.ct_owner	= THIS_MODULE,
 };
 
@@ -1420,6 +1447,7 @@ static struct config_item *uvcg_frame_make(struct config_group *group,
 	h->frame.dw_max_bit_rate		= 55296000;
 	h->frame.dw_max_video_frame_buffer_size	= 460800;
 	h->frame.dw_default_frame_interval	= 666666;
+	h->frame.dw_bytes_perline = 0;
 
 	opts_item = group->cg_item.ci_parent->ci_parent->ci_parent;
 	opts = to_f_uvc_opts(opts_item);
@@ -1432,6 +1460,9 @@ static struct config_item *uvcg_frame_make(struct config_group *group,
 	} else if (fmt->type == UVCG_MJPEG) {
 		h->frame.b_descriptor_subtype = UVC_VS_FRAME_MJPEG;
 		h->fmt_type = UVCG_MJPEG;
+	} else if (fmt->type == UVCG_FRAMEBASED) {
+		h->frame.b_descriptor_subtype = UVC_VS_FRAME_FRAME_BASED;
+		h->fmt_type = UVCG_FRAMEBASED;
 	} else {
 		mutex_unlock(&opts->lock);
 		kfree(h);
@@ -1440,7 +1471,10 @@ static struct config_item *uvcg_frame_make(struct config_group *group,
 	++fmt->num_frames;
 	mutex_unlock(&opts->lock);
 
-	config_item_init_type_name(&h->item, name, &uvcg_frame_type);
+	if (fmt->type == UVCG_FRAMEBASED)
+		config_item_init_type_name(&h->item, name, &uvcg_frame_type2);
+	else
+		config_item_init_type_name(&h->item, name, &uvcg_frame_type1);
 
 	return &h->item;
 }
@@ -1470,7 +1504,8 @@ static void uvcg_format_set_indices(struct config_group *fmt)
 	list_for_each_entry(ci, &fmt->cg_children, ci_entry) {
 		struct uvcg_frame *frm;
 
-		if (ci->ci_type != &uvcg_frame_type)
+		if (ci->ci_type != &uvcg_frame_type1 &&
+		    ci->ci_type != &uvcg_frame_type2)
 			continue;
 
 		frm = to_uvcg_frame(ci);
@@ -1913,6 +1948,260 @@ static const struct uvcg_config_group_type uvcg_mjpeg_grp_type = {
 	.name = "mjpeg",
 };
 
+ /* -----------------------------------------------------------------------------
+ * streaming/framebased/<NAME>
+ */
+
+struct uvcg_framebased {
+	struct uvcg_format		fmt;
+	struct uvc_format_framebased	desc;
+};
+
+static struct uvcg_framebased *to_uvcg_framebased(struct config_item *item)
+{
+	return container_of(
+		container_of(to_config_group(item), struct uvcg_format, group),
+		struct uvcg_framebased, fmt);
+}
+
+static struct configfs_group_operations uvcg_framebased_group_ops = {
+	.make_item		= uvcg_frame_make,
+	.drop_item		= uvcg_frame_drop,
+};
+
+#define UVCG_FRAMEBASED_ATTR_RO(cname, aname, bits)			\
+static ssize_t uvcg_framebased_##cname##_show(struct config_item *item,\
+					char *page)			\
+{									\
+	struct uvcg_framebased *u = to_uvcg_framebased(item);		\
+	struct f_uvc_opts *opts;					\
+	struct config_item *opts_item;					\
+	struct mutex *su_mutex = &u->fmt.group.cg_subsys->su_mutex;	\
+	int result;							\
+									\
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */	\
+									\
+	opts_item = u->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;\
+	opts = to_f_uvc_opts(opts_item);				\
+									\
+	mutex_lock(&opts->lock);					\
+	result = sprintf(page, "%u\n", le##bits##_to_cpu(u->desc.aname));\
+	mutex_unlock(&opts->lock);					\
+									\
+	mutex_unlock(su_mutex);						\
+	return result;							\
+}									\
+									\
+UVC_ATTR_RO(uvcg_framebased_, cname, aname)
+
+#define UVCG_FRAMEBASED_ATTR(cname, aname, bits)			\
+static ssize_t uvcg_framebased_##cname##_show(struct config_item *item,\
+				char *page)\
+{									\
+	struct uvcg_framebased *u = to_uvcg_framebased(item);		\
+	struct f_uvc_opts *opts;					\
+	struct config_item *opts_item;					\
+	struct mutex *su_mutex = &u->fmt.group.cg_subsys->su_mutex;	\
+	int result;							\
+									\
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */	\
+									\
+	opts_item = u->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;\
+	opts = to_f_uvc_opts(opts_item);				\
+									\
+	mutex_lock(&opts->lock);					\
+	result = sprintf(page, "%u\n", le##bits##_to_cpu(u->desc.aname));\
+	mutex_unlock(&opts->lock);					\
+									\
+	mutex_unlock(su_mutex);						\
+	return result;							\
+}									\
+									\
+static ssize_t								\
+uvcg_framebased_##cname##_store(struct config_item *item,		\
+			   const char *page, size_t len)		\
+{									\
+	struct uvcg_framebased *u = to_uvcg_framebased(item);		\
+	struct f_uvc_opts *opts;					\
+	struct config_item *opts_item;					\
+	struct mutex *su_mutex = &u->fmt.group.cg_subsys->su_mutex;	\
+	int ret;							\
+	u8 num;								\
+									\
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */	\
+									\
+	opts_item = u->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;\
+	opts = to_f_uvc_opts(opts_item);				\
+									\
+	mutex_lock(&opts->lock);					\
+	if (u->fmt.linked || opts->refcnt) {				\
+		ret = -EBUSY;						\
+		goto end;						\
+	}								\
+									\
+	ret = kstrtou8(page, 0, &num);					\
+	if (ret)							\
+		goto end;						\
+									\
+	if (num > 255) {						\
+		ret = -EINVAL;						\
+		goto end;						\
+	}								\
+	u->desc.aname = num;						\
+	ret = len;							\
+end:									\
+	mutex_unlock(&opts->lock);					\
+	mutex_unlock(su_mutex);						\
+	return ret;							\
+}									\
+									\
+UVC_ATTR(uvcg_framebased_, cname, aname)
+
+UVCG_FRAMEBASED_ATTR_RO(b_format_index, bFormatIndex, 8);
+UVCG_FRAMEBASED_ATTR_RO(b_bits_per_pixel, bBitsPerPixel, 8);
+UVCG_FRAMEBASED_ATTR(b_default_frame_index, bDefaultFrameIndex, 8);
+UVCG_FRAMEBASED_ATTR_RO(b_aspect_ratio_x, bAspectRatioX, 8);
+UVCG_FRAMEBASED_ATTR_RO(b_aspect_ratio_y, bAspectRatioY, 8);
+UVCG_FRAMEBASED_ATTR_RO(bm_interface_flags, bmInterfaceFlags, 8);
+
+#undef UVCG_FRAMEBASED_ATTR
+#undef UVCG_FRAMEBASED_ATTR_RO
+
+static ssize_t uvcg_framebased_guid_format_show(struct config_item *item,
+							char *page)
+{
+	struct uvcg_framebased *ch = to_uvcg_framebased(item);
+	struct f_uvc_opts *opts;
+	struct config_item *opts_item;
+	struct mutex *su_mutex = &ch->fmt.group.cg_subsys->su_mutex;
+
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */
+
+	opts_item = ch->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;
+	opts = to_f_uvc_opts(opts_item);
+
+	mutex_lock(&opts->lock);
+	memcpy(page, ch->desc.guidFormat, sizeof(ch->desc.guidFormat));
+	mutex_unlock(&opts->lock);
+
+	mutex_unlock(su_mutex);
+
+	return sizeof(ch->desc.guidFormat);
+}
+
+static ssize_t uvcg_framebased_guid_format_store(struct config_item *item,
+						   const char *page, size_t len)
+{
+	struct uvcg_framebased *ch = to_uvcg_framebased(item);
+	struct f_uvc_opts *opts;
+	struct config_item *opts_item;
+	struct mutex *su_mutex = &ch->fmt.group.cg_subsys->su_mutex;
+	int ret;
+
+	mutex_lock(su_mutex); /* for navigating configfs hierarchy */
+
+	opts_item = ch->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;
+	opts = to_f_uvc_opts(opts_item);
+
+	mutex_lock(&opts->lock);
+	if (ch->fmt.linked || opts->refcnt) {
+		ret = -EBUSY;
+		goto end;
+	}
+
+	memcpy(ch->desc.guidFormat, page,
+	       min(sizeof(ch->desc.guidFormat), len));
+	ret = sizeof(ch->desc.guidFormat);
+
+end:
+	mutex_unlock(&opts->lock);
+	mutex_unlock(su_mutex);
+	return ret;
+}
+
+UVC_ATTR(uvcg_framebased_, guid_format, guidFormat);
+
+static inline ssize_t
+uvcg_framebased_bma_controls_show(struct config_item *item, char *page)
+{
+	struct uvcg_framebased *u = to_uvcg_framebased(item);
+
+	return uvcg_format_bma_controls_show(&u->fmt, page);
+}
+
+static inline ssize_t
+uvcg_framebased_bma_controls_store(struct config_item *item,
+				     const char *page, size_t len)
+{
+	struct uvcg_framebased *u = to_uvcg_framebased(item);
+
+	return uvcg_format_bma_controls_store(&u->fmt, page, len);
+}
+
+UVC_ATTR(uvcg_framebased_, bma_controls, bmaControls);
+
+static struct configfs_attribute *uvcg_framebased_attrs[] = {
+	&uvcg_framebased_attr_b_format_index,
+	&uvcg_framebased_attr_b_default_frame_index,
+	&uvcg_framebased_attr_b_bits_per_pixel,
+	&uvcg_framebased_attr_b_aspect_ratio_x,
+	&uvcg_framebased_attr_b_aspect_ratio_y,
+	&uvcg_framebased_attr_bm_interface_flags,
+	&uvcg_framebased_attr_bma_controls,
+	&uvcg_framebased_attr_guid_format,
+	NULL,
+};
+
+static const struct config_item_type uvcg_framebased_type = {
+	.ct_item_ops	= &uvcg_config_item_ops,
+	.ct_group_ops	= &uvcg_framebased_group_ops,
+	.ct_attrs	= uvcg_framebased_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static struct config_group *uvcg_framebased_make(struct config_group *group,
+						   const char *name)
+{
+	static char guid[] = { /*Declear frame frame based as H264*/
+		'H',  '2',  '6',  '4', 0x00, 0x00, 0x10, 0x00,
+		0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
+	};
+	struct uvcg_framebased *f;
+
+	f = kzalloc(sizeof(*f), GFP_KERNEL);
+	if (!f)
+		return ERR_PTR(-ENOMEM);
+
+	f->desc.bLength			= UVC_DT_FORMAT_FRAMEBASED_SIZE;
+	f->desc.bDescriptorType		= USB_DT_CS_INTERFACE;
+	f->desc.bDescriptorSubType	= UVC_VS_FORMAT_FRAME_BASED;
+	memcpy(f->desc.guidFormat, guid, sizeof(guid));
+	f->desc.bBitsPerPixel		= 0;
+	f->desc.bDefaultFrameIndex	= 1;
+	f->desc.bAspectRatioX		= 0;
+	f->desc.bAspectRatioY		= 0;
+	f->desc.bmInterfaceFlags	= 0;
+	f->desc.bCopyProtect		= 0;
+
+	f->fmt.type = UVCG_FRAMEBASED;
+	config_group_init_type_name(&f->fmt.group, name,
+				    &uvcg_framebased_type);
+
+	return &f->fmt.group;
+}
+
+static struct configfs_group_operations uvcg_framebased_grp_ops = {
+	.make_group		= uvcg_framebased_make,
+};
+static const struct uvcg_config_group_type uvcg_framebased_grp_type = {
+	.type = {
+		.ct_item_ops	= &uvcg_config_item_ops,
+		.ct_group_ops	= &uvcg_framebased_grp_ops,
+		.ct_owner	= THIS_MODULE,
+	},
+	.name = "framebased",
+};
+
 /* -----------------------------------------------------------------------------
  * streaming/color_matching/default
  */
@@ -2106,6 +2395,10 @@ static int __uvcg_cnt_strm(void *priv1, void *priv2, void *priv3, int n,
 				container_of(fmt, struct uvcg_mjpeg, fmt);
 
 			*size += sizeof(m->desc);
+		} else if (fmt->type == UVCG_FRAMEBASED) {
+			struct uvcg_framebased *f =
+				container_of(fmt, struct uvcg_framebased, fmt);
+			*size += sizeof(f->desc);
 		} else {
 			return -EINVAL;
 		}
@@ -2116,6 +2409,11 @@ static int __uvcg_cnt_strm(void *priv1, void *priv2, void *priv3, int n,
 		int sz = sizeof(frm->dw_frame_interval);
 
 		*size += sizeof(frm->frame);
+		/*
+		 * framebased has duplicate member with uncompressed and
+		 * mjpeg, so minus it
+		 */
+		*size -= sizeof(u32);
 		*size += frm->frame.b_frame_interval_type * sz;
 	}
 	break;
@@ -2126,6 +2424,27 @@ static int __uvcg_cnt_strm(void *priv1, void *priv2, void *priv3, int n,
 	return 0;
 }
 
+static int __uvcg_copy_framebased_desc(void *dest, struct uvcg_frame *frm,
+				       int sz)
+{
+	struct uvc_frame_framebased *desc = dest;
+
+	desc->bLength = frm->frame.b_length;
+	desc->bDescriptorType = frm->frame.b_descriptor_type;
+	desc->bDescriptorSubType = frm->frame.b_descriptor_subtype;
+	desc->bFrameIndex = frm->frame.b_frame_index;
+	desc->bmCapabilities = frm->frame.bm_capabilities;
+	desc->wWidth = frm->frame.w_width;
+	desc->wHeight = frm->frame.w_height;
+	desc->dwMinBitRate = frm->frame.dw_min_bit_rate;
+	desc->dwMaxBitRate = frm->frame.dw_max_bit_rate;
+	desc->dwDefaultFrameInterval = frm->frame.dw_default_frame_interval;
+	desc->bFrameIntervalType = frm->frame.b_frame_interval_type;
+	desc->dwBytesPerLine = frm->frame.dw_bytes_perline;
+
+	return 0;
+}
+
 /*
  * Fill an array of streaming descriptors.
  *
@@ -2180,6 +2499,15 @@ static int __uvcg_fill_strm(void *priv1, void *priv2, void *priv3, int n,
 			m->desc.bNumFrameDescriptors = fmt->num_frames;
 			memcpy(*dest, &m->desc, sizeof(m->desc));
 			*dest += sizeof(m->desc);
+		} else if (fmt->type == UVCG_FRAMEBASED) {
+			struct uvcg_framebased *f =
+				container_of(fmt, struct uvcg_framebased,
+					     fmt);
+
+			f->desc.bFormatIndex = n + 1;
+			f->desc.bNumFrameDescriptors = fmt->num_frames;
+			memcpy(*dest, &f->desc, sizeof(f->desc));
+			*dest += sizeof(f->desc);
 		} else {
 			return -EINVAL;
 		}
@@ -2189,8 +2517,11 @@ static int __uvcg_fill_strm(void *priv1, void *priv2, void *priv3, int n,
 		struct uvcg_frame *frm = priv1;
 		struct uvc_descriptor_header *h = *dest;
 
-		sz = sizeof(frm->frame);
-		memcpy(*dest, &frm->frame, sz);
+		sz = sizeof(frm->frame) - 4;
+		if (frm->fmt_type != UVCG_FRAMEBASED)
+			memcpy(*dest, &frm->frame, sz);
+		else
+			__uvcg_copy_framebased_desc(*dest, frm, sz);
 		*dest += sz;
 		sz = frm->frame.b_frame_interval_type *
 			sizeof(*frm->dw_frame_interval);
@@ -2202,6 +2533,9 @@ static int __uvcg_fill_strm(void *priv1, void *priv2, void *priv3, int n,
 		else if (frm->fmt_type == UVCG_MJPEG)
 			h->bLength = UVC_DT_FRAME_MJPEG_SIZE(
 				frm->frame.b_frame_interval_type);
+		else if (frm->fmt_type == UVCG_FRAMEBASED)
+			h->bLength = UVC_DT_FRAME_FRAMEBASED_SIZE(
+				 frm->frame.b_frame_interval_type);
 	}
 	break;
 	}
@@ -2414,6 +2748,7 @@ static const struct uvcg_config_group_type uvcg_streaming_grp_type = {
 		&uvcg_streaming_header_grp_type,
 		&uvcg_uncompressed_grp_type,
 		&uvcg_mjpeg_grp_type,
+		&uvcg_framebased_grp_type,
 		&uvcg_color_matching_grp_type,
 		&uvcg_streaming_class_grp_type,
 		NULL,
diff --git a/drivers/usb/gadget/function/uvc_v4l2.c b/drivers/usb/gadget/function/uvc_v4l2.c
index 65abd55ce234..89a4329e94fe 100644
--- a/drivers/usb/gadget/function/uvc_v4l2.c
+++ b/drivers/usb/gadget/function/uvc_v4l2.c
@@ -58,6 +58,9 @@ struct uvc_format {
 static struct uvc_format uvc_formats[] = {
 	{ 16, V4L2_PIX_FMT_YUYV  },
 	{ 0,  V4L2_PIX_FMT_MJPEG },
+#if IS_ENABLED(CONFIG_ARCH_CVITEK)
+	{ 0,  V4L2_PIX_FMT_H264 },
+#endif
 };
 
 static int
diff --git a/drivers/usb/gadget/function/uvc_video.c b/drivers/usb/gadget/function/uvc_video.c
index 5ce548c2359d..4384d5058a29 100644
--- a/drivers/usb/gadget/function/uvc_video.c
+++ b/drivers/usb/gadget/function/uvc_video.c
@@ -12,13 +12,16 @@
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 #include <linux/usb/video.h>
-
+#if IS_ENABLED(CONFIG_USB_UVCG_SG_TRANSFER)
+#include <linux/scatterlist.h>
+#endif
 #include <media/v4l2-dev.h>
 
 #include "uvc.h"
 #include "uvc_queue.h"
 #include "uvc_video.h"
 
+#define UVCG_MAX_SG_NUM		64	// 8ms in 125us interval.
 /* --------------------------------------------------------------------------
  * Video codecs
  */
@@ -94,6 +97,7 @@ uvc_video_encode_bulk(struct usb_request *req, struct uvc_video *video,
 		video->payload_size = 0;
 }
 
+#if !IS_ENABLED(CONFIG_USB_UVCG_SG_TRANSFER)
 static void
 uvc_video_encode_isoc(struct usb_request *req, struct uvc_video *video,
 		struct uvc_buffer *buf)
@@ -120,7 +124,44 @@ uvc_video_encode_isoc(struct usb_request *req, struct uvc_video *video,
 		video->fid ^= UVC_STREAM_FID;
 	}
 }
+#else
+static void
+uvc_video_encode_isoc(struct usb_request *req, struct uvc_video *video,
+		struct uvc_buffer *buf)
+{
+	int i;
+	struct scatterlist *sg;
 
+	req->length = 0;
+
+	for_each_sg(req->sg, sg, UVCG_MAX_SG_NUM, i) {
+		void *mem = sg_virt(sg);
+		int len = video->req_size;
+		int ret;
+
+		/* Add the header. */
+		ret = uvc_video_encode_header(video, buf, mem, len);
+		mem += ret;
+		len -= ret;
+		/* Process video data. */
+		ret = uvc_video_encode_data(video, buf, mem, len);
+		len -= ret;
+
+		sg->length = video->req_size - len;
+		req->length += sg->length;
+
+		if (buf->bytesused == video->queue.buf_used) {
+			video->queue.buf_used = 0;
+			buf->state = UVC_BUF_STATE_DONE;
+			uvcg_queue_next_buffer(&video->queue, buf);
+			video->fid ^= UVC_STREAM_FID;
+			i++;
+			break;
+		}
+	}
+	req->num_sgs = i;
+}
+#endif
 /* --------------------------------------------------------------------------
  * Request handling
  */
@@ -199,6 +240,9 @@ uvc_video_alloc_requests(struct uvc_video *video)
 {
 	unsigned int req_size;
 	unsigned int i;
+#if IS_ENABLED(CONFIG_USB_UVCG_SG_TRANSFER)
+	unsigned int j;
+#endif
 	int ret = -ENOMEM;
 
 	BUG_ON(video->req_size);
@@ -206,7 +250,7 @@ uvc_video_alloc_requests(struct uvc_video *video)
 	req_size = video->ep->maxpacket
 		 * max_t(unsigned int, video->ep->maxburst, 1)
 		 * (video->ep->mult);
-
+#if !IS_ENABLED(CONFIG_USB_UVCG_SG_TRANSFER)
 	for (i = 0; i < UVC_NUM_REQUESTS; ++i) {
 		video->req_buffer[i] = kmalloc(req_size, GFP_KERNEL);
 		if (video->req_buffer[i] == NULL)
@@ -225,6 +269,32 @@ uvc_video_alloc_requests(struct uvc_video *video)
 	}
 
 	video->req_size = req_size;
+#else
+	req_size = ALIGN(req_size, 32);
+	for (i = 0; i < UVC_NUM_REQUESTS; ++i) {
+		video->req_buffer[i] = kmalloc(req_size * UVCG_MAX_SG_NUM, GFP_KERNEL);
+		if (video->req_buffer[i] == NULL)
+			goto error;
+
+		video->req[i] = usb_ep_alloc_request(video->ep, GFP_KERNEL);
+		if (video->req[i] == NULL)
+			goto error;
+		video->req[i]->sg = kmalloc(sizeof(struct scatterlist) * UVCG_MAX_SG_NUM, GFP_KERNEL);
+		if (video->req[i]->sg == NULL)
+			goto error;
+		sg_init_table(video->req[i]->sg, UVCG_MAX_SG_NUM);
+		video->req[i]->buf = video->req_buffer[i];
+		for (j = 0; j < UVCG_MAX_SG_NUM; j++)
+			sg_set_buf(&video->req[i]->sg[j], video->req[i]->buf + req_size * j, 0);
+		video->req[i]->num_sgs = 0;
+		video->req[i]->length = 0;
+		video->req[i]->complete = uvc_video_complete;
+		video->req[i]->context = video;
+		list_add_tail(&video->req[i]->list, &video->req_free);
+	}
+
+	video->req_size = req_size;
+#endif
 
 	return 0;
 
@@ -278,6 +348,11 @@ static void uvcg_video_pump(struct work_struct *work)
 
 		video->encode(req, video, buf);
 
+		if (!video->ep->enabled) {
+			spin_unlock_irqrestore(&queue->irqlock, flags);
+			uvcg_queue_cancel(queue, 0);
+			break;
+		}
 		/* Queue the USB request */
 		ret = uvcg_video_ep_queue(video, req);
 		spin_unlock_irqrestore(&queue->irqlock, flags);
diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 14d9d1ee16fc..2db5a00856fd 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -18,6 +18,9 @@
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 #include <linux/usb.h>
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+#include <linux/usb/otg.h>
+#endif
 
 #include "trace.h"
 
@@ -29,6 +32,7 @@
  * @list: for use by the udc class driver
  * @vbus: for udcs who care about vbus status, this value is real vbus status;
  * for udcs who do not care about vbus status, this value is always true
+ * @is_otg - we're registered with OTG core and it takes care of UDC start/stop
  *
  * This represents the internal data structure which is used by the UDC-class
  * to hold information about udc driver and gadget together.
@@ -39,6 +43,9 @@ struct usb_udc {
 	struct device			dev;
 	struct list_head		list;
 	bool				vbus;
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+	bool				is_otg;
+#endif
 };
 
 static struct class *udc_class;
@@ -1144,6 +1151,78 @@ static inline void usb_gadget_udc_set_speed(struct usb_udc *udc,
 	}
 }
 
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+/**
+ * usb_gadget_start - start the usb gadget controller and connect to bus
+ * @gadget: the gadget device to start
+ *
+ * This is external API for use by OTG core.
+ *
+ * Start the usb device controller and connect to bus (enable pull).
+ */
+static int usb_gadget_start(struct usb_gadget *gadget)
+{
+	int ret;
+	struct usb_udc *udc = NULL;
+
+	dev_dbg(&gadget->dev, "%s\n", __func__);
+	mutex_lock(&udc_lock);
+	list_for_each_entry(udc, &udc_list, list)
+		if (udc->gadget == gadget)
+			goto found;
+
+	dev_err(gadget->dev.parent, "%s: gadget not registered.\n",
+		__func__);
+	mutex_unlock(&udc_lock);
+	return -EINVAL;
+
+found:
+	ret = usb_gadget_udc_start(udc);
+	if (ret)
+		dev_err(&udc->dev, "USB Device Controller didn't start: %d\n",
+			ret);
+	else
+		usb_udc_connect_control(udc);
+
+	mutex_unlock(&udc_lock);
+
+	return ret;
+}
+
+/**
+ * usb_gadget_stop - disconnect from bus and stop the usb gadget
+ * @gadget: The gadget device we want to stop
+ *
+ * This is external API for use by OTG core.
+ *
+ * Disconnect from the bus (disable pull) and stop the
+ * gadget controller.
+ */
+static int usb_gadget_stop(struct usb_gadget *gadget)
+{
+	struct usb_udc *udc = NULL;
+
+	dev_dbg(&gadget->dev, "%s\n", __func__);
+	mutex_lock(&udc_lock);
+	list_for_each_entry(udc, &udc_list, list)
+		if (udc->gadget == gadget)
+			goto found;
+
+	dev_err(gadget->dev.parent, "%s: gadget not registered.\n",
+		__func__);
+	mutex_unlock(&udc_lock);
+	return -EINVAL;
+
+found:
+	usb_gadget_disconnect(udc->gadget);
+	udc->driver->disconnect(udc->gadget);
+	usb_gadget_udc_stop(udc);
+	mutex_unlock(&udc_lock);
+
+	return 0;
+}
+#endif
+
 /**
  * usb_udc_release - release the usb_udc struct
  * @dev: the dev member within usb_udc
@@ -1355,11 +1434,26 @@ static void usb_gadget_remove_driver(struct usb_udc *udc)
 
 	kobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);
 
+#if !defined(CONFIG_CVITEK_USB_LEGACY)
 	usb_gadget_disconnect(udc->gadget);
 	if (udc->gadget->irq)
 		synchronize_irq(udc->gadget->irq);
 	udc->driver->unbind(udc->gadget);
 	usb_gadget_udc_stop(udc);
+#else
+	/* If OTG, the otg core ensures UDC is stopped on unregister */
+	if (udc->is_otg) {
+		mutex_unlock(&udc_lock);
+		usb_otg_unregister_gadget(udc->gadget);
+		mutex_lock(&udc_lock);
+		udc->driver->unbind(udc->gadget);
+	} else {
+		usb_gadget_disconnect(udc->gadget);
+		udc->driver->disconnect(udc->gadget);
+		udc->driver->unbind(udc->gadget);
+		usb_gadget_udc_stop(udc);
+	}
+#endif
 
 	udc->driver = NULL;
 	udc->gadget->dev.driver = NULL;
@@ -1415,6 +1509,13 @@ EXPORT_SYMBOL_GPL(usb_del_gadget_udc);
 
 /* ------------------------------------------------------------------------- */
 
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+struct otg_gadget_ops otg_gadget_intf = {
+	.start = usb_gadget_start,
+	.stop = usb_gadget_stop,
+};
+#endif
+
 static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *driver)
 {
 	int ret;
@@ -1430,6 +1531,7 @@ static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *dri
 	ret = driver->bind(udc->gadget, driver);
 	if (ret)
 		goto err1;
+#if !defined(CONFIG_CVITEK_USB_LEGACY)
 	ret = usb_gadget_udc_start(udc);
 	if (ret) {
 		driver->unbind(udc->gadget);
@@ -1437,6 +1539,20 @@ static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *dri
 	}
 	usb_udc_connect_control(udc);
 
+#else
+	/* If OTG, the otg core starts the UDC when needed */
+	mutex_unlock(&udc_lock);
+	udc->is_otg = !usb_otg_register_gadget(udc->gadget, &otg_gadget_intf);
+	mutex_lock(&udc_lock);
+	if (!udc->is_otg) {
+		ret = usb_gadget_udc_start(udc);
+		if (ret) {
+			driver->unbind(udc->gadget);
+			goto err1;
+		}
+		usb_udc_connect_control(udc);
+	}
+#endif
 	kobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);
 	return 0;
 err1:
@@ -1557,6 +1673,13 @@ static ssize_t soft_connect_store(struct device *dev,
 		goto out;
 	}
 
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+	/* In OTG mode we don't support softconnect, but b_bus_req */
+	if (udc->is_otg) {
+		dev_err(dev, "soft-connect not supported in OTG mode\n");
+		return -EOPNOTSUPP;
+	}
+#endif
 	if (sysfs_streq(buf, "connect")) {
 		usb_gadget_udc_start(udc);
 		usb_gadget_connect(udc->gadget);
diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c
index 972a44b2a7f1..f4236328fe32 100644
--- a/drivers/usb/host/xhci-plat.c
+++ b/drivers/usb/host/xhci-plat.c
@@ -94,6 +94,10 @@ static void xhci_plat_quirks(struct device *dev, struct xhci_hcd *xhci)
 	 * dev struct in order to setup MSI
 	 */
 	xhci->quirks |= XHCI_PLAT | priv->quirks;
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+	/* Use the SW bandwidth calculation. */
+	xhci->quirks |= XHCI_SW_BW_CHECKING;
+#endif
 }
 
 /* called during probe() after chip reset completes */
@@ -115,7 +119,32 @@ static int xhci_plat_start(struct usb_hcd *hcd)
 	return xhci_run(hcd);
 }
 
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+static int cvi_core_init_mode(struct platform_device *pdev)
+{
+	/* Bypass the bandwidth report. */
+	iowrite32((ioread32(ioremap(0x040D8098, 0x4)) | (1 << 17) | (1 << 18)),
+		ioremap(0x040D8098, 0x4));
+	return 0;
+}
+#endif
+
 #ifdef CONFIG_OF
+
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+int xhci_cvitek_init_quirk(struct usb_hcd *hcd)
+{
+
+	if (usb_hcd_is_primary_hcd(hcd))
+		cvi_core_init_mode(to_platform_device(hcd->self.controller));
+	return 0;
+}
+
+static const struct xhci_plat_priv xhci_plat_cvitek = {
+	.init_quirk = xhci_cvitek_init_quirk,
+};
+#endif
+
 static const struct xhci_plat_priv xhci_plat_marvell_armada = {
 	.init_quirk = xhci_mvebu_mbus_init_quirk,
 };
@@ -143,6 +172,11 @@ static const struct of_device_id usb_xhci_of_match[] = {
 	}, {
 		.compatible = "xhci-platform",
 	}, {
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+		.compatible = "cvitek,xhci-platform",
+		.data = &xhci_plat_cvitek,
+	}, {
+#endif
 		.compatible = "marvell,armada-375-xhci",
 		.data = &xhci_plat_marvell_armada,
 	}, {
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index b069fe3f8ab0..f17df2009206 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -5329,6 +5329,11 @@ int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks)
 	if (xhci->quirks & XHCI_NO_64BIT_SUPPORT)
 		xhci->hcc_params &= ~BIT(0);
 
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+	/* force set 64BIT_SUPPORT */
+	xhci->hcc_params |= BIT(0);
+#endif
+
 	/* Set dma_mask and coherent_dma_mask to 64-bits,
 	 * if xHC supports 64-bit addressing */
 	if (HCC_64BIT_ADDR(xhci->hcc_params) &&
diff --git a/drivers/usb/roles/Kconfig b/drivers/usb/roles/Kconfig
index f8b31aa67526..61434aa3588a 100644
--- a/drivers/usb/roles/Kconfig
+++ b/drivers/usb/roles/Kconfig
@@ -2,6 +2,7 @@
 
 config USB_ROLE_SWITCH
 	tristate "USB Role Switch Support"
+	depends on USB_DWC2_DUAL_ROLE
 	help
 	  USB Role Switch is a device that can select the USB role - host or
 	  device - for a USB port (connector). In most cases dual-role capable
diff --git a/drivers/video/fbdev/Kconfig b/drivers/video/fbdev/Kconfig
index dd5958463097..f42663d53f29 100644
--- a/drivers/video/fbdev/Kconfig
+++ b/drivers/video/fbdev/Kconfig
@@ -2238,3 +2238,4 @@ config FB_SM712
 source "drivers/video/fbdev/omap/Kconfig"
 source "drivers/video/fbdev/omap2/Kconfig"
 source "drivers/video/fbdev/mmp/Kconfig"
+source "drivers/video/fbdev/cvitek/Kconfig"
diff --git a/drivers/video/fbdev/Makefile b/drivers/video/fbdev/Makefile
index 477b9624b703..a34d55ff96f1 100644
--- a/drivers/video/fbdev/Makefile
+++ b/drivers/video/fbdev/Makefile
@@ -128,7 +128,7 @@ obj-$(CONFIG_FB_OF)               += offb.o
 obj-$(CONFIG_FB_MX3)		  += mx3fb.o
 obj-$(CONFIG_FB_DA8XX)		  += da8xx-fb.o
 obj-$(CONFIG_FB_SSD1307)	  += ssd1307fb.o
-obj-$(CONFIG_FB_SIMPLE)           += simplefb.o
+obj-$(CONFIG_FB_SIMPLE)           += simplefb.o dc8000-fb.o
 
 # the test framebuffer is last
 obj-$(CONFIG_FB_VIRTUAL)          += vfb.o
diff --git a/drivers/video/fbdev/core/fbmem.c b/drivers/video/fbdev/core/fbmem.c
index 1704deaf4152..9fca19ccab4e 100644
--- a/drivers/video/fbdev/core/fbmem.c
+++ b/drivers/video/fbdev/core/fbmem.c
@@ -1233,36 +1233,30 @@ struct fb_cmap32 {
 static int fb_getput_cmap(struct fb_info *info, unsigned int cmd,
 			  unsigned long arg)
 {
-	struct fb_cmap_user __user *cmap;
-	struct fb_cmap32 __user *cmap32;
-	__u32 data;
-	int err;
-
-	cmap = compat_alloc_user_space(sizeof(*cmap));
-	cmap32 = compat_ptr(arg);
+	struct fb_cmap32 cmap32;
+	struct fb_cmap cmap_from;
+	struct fb_cmap_user cmap;
 
-	if (copy_in_user(&cmap->start, &cmap32->start, 2 * sizeof(__u32)))
+	if (copy_from_user(&cmap32, compat_ptr(arg), sizeof(cmap32)))
 		return -EFAULT;
 
-	if (get_user(data, &cmap32->red) ||
-	    put_user(compat_ptr(data), &cmap->red) ||
-	    get_user(data, &cmap32->green) ||
-	    put_user(compat_ptr(data), &cmap->green) ||
-	    get_user(data, &cmap32->blue) ||
-	    put_user(compat_ptr(data), &cmap->blue) ||
-	    get_user(data, &cmap32->transp) ||
-	    put_user(compat_ptr(data), &cmap->transp))
-		return -EFAULT;
+	cmap = (struct fb_cmap_user) {
+		.start	= cmap32.start,
+		.len	= cmap32.len,
+		.red	= compat_ptr(cmap32.red),
+		.green	= compat_ptr(cmap32.green),
+		.blue	= compat_ptr(cmap32.blue),
+		.transp	= compat_ptr(cmap32.transp),
+	};
 
-	err = do_fb_ioctl(info, cmd, (unsigned long) cmap);
+	if (cmd == FBIOPUTCMAP)
+		return fb_set_user_cmap(&cmap, info);
 
-	if (!err) {
-		if (copy_in_user(&cmap32->start,
-				 &cmap->start,
-				 2 * sizeof(__u32)))
-			err = -EFAULT;
-	}
-	return err;
+	lock_fb_info(info);
+	cmap_from = info->cmap;
+	unlock_fb_info(info);
+
+	return fb_cmap_to_user(&cmap_from, &cmap);
 }
 
 static int do_fscreeninfo_to_user(struct fb_fix_screeninfo *fix,
diff --git a/drivers/video/fbdev/cvitek/Kconfig b/drivers/video/fbdev/cvitek/Kconfig
new file mode 100644
index 000000000000..6ff7df82d21e
--- /dev/null
+++ b/drivers/video/fbdev/cvitek/Kconfig
@@ -0,0 +1,13 @@
+config FB_CVITEK
+	tristate "Cvitek framebuffer support"
+	depends on FB
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  Framebuffer support for the CVITEK SoC.
+
+	  This driver is also available as a module ( = code which can be
+	  inserted and removed from the running kernel whenever you want). The
+	  module will be called cvifb. If you want to compile it as a module,
+	  say M here and read <file:Documentation/kbuild/modules.txt>.
diff --git a/drivers/video/fbdev/dc8000-fb.c b/drivers/video/fbdev/dc8000-fb.c
new file mode 100644
index 000000000000..ea674b5313b5
--- /dev/null
+++ b/drivers/video/fbdev/dc8000-fb.c
@@ -0,0 +1,1696 @@
+#include <linux/fb.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+#include <linux/serial_core.h>
+#include <linux/ioport.h>
+#include <linux/wait.h>
+
+/* DC8000 hw reg*/
+#define FRAMEBUFFER_CONFIG                                          0x1518
+#define FRAMEBUFFER_ADDRESS                                         0x1400
+#define FRAMEBUFFER_STRIDE                                          0x1408
+#define HDISPLAY                                                    0x1430
+#define HSYNC                                                       0x1438
+#define VDISPLAY                                                    0x1440
+#define VSYNC                                                       0x1448
+#define PANEL_CONFIG                                                0x1418
+#define DPI_CONFIG                                                  0x14B8
+#define CURSOR_ADDRESS                                              0x146C
+#define CURSOR_CONFIG                                               0x1468
+#define CURSOR_LOCATION                                             0x1470
+#define CURSOR_BACKGROUND                                           0x1474
+#define CURSOR_FOREGROUND                                           0x1478
+#define FRAMEBUFFER_UPLANAR_ADDRESS                                 0x1530
+#define FRAMEBUFFER_VPLANAR_ADDRESS                                 0x1538
+#define FRAMEBUFFER_USTRIDE                                         0x1800
+#define FRAMEBUFFER_VSTRIDE                                         0x1808
+#define INDEXCOLOR_TABLEINDEX                                       0x1818
+#define INDEXCOLOR_TABLEDATA                                        0x1820
+#define FRAMEBUFFER_SIZE                                            0x1810
+#define FRAMEBUFFER_SCALEFACTORX                                    0x1828
+#define FRAMEBUFFER_SCALEFACTORY                                    0x1830
+#define FRAMEBUFFER_SCALEFCONFIG                                    0x1520
+#define HORIFILTER_KERNELINDEX                                      0x1838
+#define HORIFILTER_KERNEL                                           0x1A00
+#define VERTIFILTER_KERNELINDEX                                     0x1A08
+#define VERTIFILTER_KERNEL                                          0x1A10
+#define FRAMEBUFFER_INITIALOFFSET                                   0x1A20
+#define FRAMEBUFFER_COLORKEY                                        0x1508
+#define FRAMEBUFFER_COLORHIGHKEY                                    0x1510
+#define FRAMEBUFFER_BGCOLOR                                         0x1528
+#define FRAMEBUFFER_CLEARVALUE                                      0x1A18
+#define DISPLAY_INTRENABLE                                          0x1480
+#define INT_STATE                                                   0x147C
+#define PANEL_DEST_ADDRESS                                          0x14F0
+#define MEM_DEST_ADDRESS                                            0x14E8
+#define DEST_CONFIG                                                 0x14F8
+#define DEST_STRIDE                                                 0x1500
+#define DBI_CONFIG                                                  0x1488
+#define AQHICLOCKCONTROL                                            0x0000
+#define OVERLAY_CONFIG                                              0x1540
+#define OVERLAY_STRIDE                                              0x1600
+#define OVERLAY_USTRIDE                                             0x18C0
+#define OVERLAY_VSTRIDE                                             0x1900
+#define OVERLAY_TL                                                  0x1640
+#define OVERLAY_BR                                                  0x1680
+#define OVERLAY_ALPHA_BLEND_CONFIG                                  0x1580
+#define OVERLAY_SRC_GLOBAL_COLOR                                    0x16C0
+#define OVERLAY_DST_GLOBAL_COLOR                                    0x1700
+#define OVERLAY_CLEAR_VALUE                                         0x1940
+#define OVERLAY_SIZE                                                0x17C0
+#define OVERLAY_COLOR_KEY                                           0x1740
+#define OVERLAY_COLOR_KEY_HIGH                                      0x1780
+#define OVERLAY_ADDRESS                                             0x15C0
+#define OVERLAY_UPLANAR_ADDRESS                                     0x1840
+#define OVERLAY_VPLANAR_ADDRESS                                     0x1880
+#define OVERLAY_SCALE_CONFIG                                        0x1C00
+#define OVERLAY_SCALE_FACTOR_X                                      0x1A40
+#define OVERLAY_SCALE_FACTOR_Y                                      0x1A80
+#define OVERLAY_HORI_FILTER_KERNEL_INDEX                            0x1AC0
+#define OVERLAY_HORI_FILTER_KERNEL                                  0x1B00
+#define OVERLAY_VERTI_FILTER_KERNEL_INDEX                           0x1B40
+#define OVERLAY_VERTI_FILTER_KERNEL                                 0x1B80
+#define OVERLAY_INITIAL_OFFSET                                      0x1BC0
+#define GAMMA_EX_INDEX                                              0x1CF0
+#define GAMMA_EX_DATA                                               0x1CF8
+#define GAMMA_EX_ONE_DATA                                           0x1D80
+#define GAMMA_INDEX                                                 0x1458
+#define GAMMA_DATA                                                  0x1460
+#define DISPLAY_DITHER_TABLE_LOW                                    0x1420
+#define DISPLAY_DITHER_TABLE_HIGH                                   0x1428
+#define DISPLAY_DITHER_CONFIG                                       0x1410
+
+/* ultrafb.h */
+#define ULTRAFBIO_CURSOR 0x46A0
+#define ULTRAFBIO_BLENDING_MODE 0x46A4
+#define ULTRAFBIO_GLOBAL_MODE_VALUE 0x46A5
+#define ULTRAFBIO_BUFFER_SIZE 0x46A7
+#define ULTRAFBIO_OVERLAY_RECT 0x46A8
+#define ULTRAFBIO_SCALE_FILTER_TAP 0x46A9
+#define ULTRAFBIO_SYNC_TABLE 0x46AA
+#define ULTRAFBIO_GAMMA 0x46BD
+#define ULTRAFBIO_DITHER 0x46BE
+#define ULTRAFBIO_ROTATION 0x46BF
+#define ULTRAFBIO_TILEMODE 0x46C1
+#define ULTRAFBIO_COLORKEY 0x46C2
+
+#define CURSOR_SIZE 32
+#define GAMMA_INDEX_MAX 256
+
+typedef struct _dc_frame_info {
+	unsigned int width;
+	unsigned int height;
+	unsigned int stride;
+}
+dc_frame_info;
+
+typedef struct _dc_overlay_rect {
+	unsigned int tlx;
+	unsigned int tly;
+	unsigned int brx;
+	unsigned int bry;
+}
+dc_overlay_rect;
+
+typedef enum _dc_alpha_blending_mode {
+	DC_BLEND_MODE_CLEAR = 0x0,
+	DC_BLEND_MODE_SRC,
+	DC_BLEND_MODE_DST,
+	DC_BLEND_MODE_SRC_OVER,
+	DC_BLEND_MODE_DST_OVER,
+	DC_BLEND_MODE_SRC_IN,
+	DC_BLEND_MODE_DST_IN,
+	DC_BLEND_MODE_SRC_OUT,
+}
+dc_alpha_blending_mode;
+
+typedef enum _dc_rot_angle {
+	DC_ROT_ANGLE_ROT0 = 0x0,
+	DC_ROT_ANGLE_FLIP_X,
+	DC_ROT_ANGLE_FLIP_Y,
+	DC_ROT_ANGLE_FLIP_XY,
+	DC_ROT_ANGLE_ROT90,
+	DC_ROT_ANGLE_ROT180,
+	DC_ROT_ANGLE_ROT270,
+}
+dc_rot_angle;
+
+typedef enum _dc_tile_mode {
+	DC_TILE_MODE_LINEAR = 0x0,
+	DC_TILE_MODE_TILED4X4,
+	DC_TILE_MODE_SUPER_TILED_XMAJOR,
+	DC_TILE_MODE_SUPER_TILED_YMAJOR,
+	DC_TILE_MODE_TILE_MODE8X8,
+	DC_TILE_MODE_TILE_MODE8X4,
+	DC_TILE_MODE_SUPER_TILED_XMAJOR8X4,
+	DC_TILE_MODE_SUPER_TILED_YMAJOR4X8,
+	DC_TILE_MODE_TILE_Y,
+}
+dc_tile_mode;
+
+typedef struct _dc_global_alpha {
+	unsigned int global_alpha_mode;
+	unsigned int global_alpha_value;
+}
+dc_global_alpha;
+
+typedef struct _dc_filter_tap {
+	unsigned int vertical_filter_tap;
+	unsigned int horizontal_filter_tap;
+}
+dc_filter_tap;
+
+typedef struct _dc_sync_table {
+	unsigned int horkernel[128];
+	unsigned int verkernel[128];
+}
+dc_sync_table;
+
+typedef struct _dc_gamma_table {
+	bool gamma_enable;
+	unsigned int gamma[GAMMA_INDEX_MAX][3];
+}
+dc_gamma_table;
+
+typedef struct _dc_color_key {
+	unsigned char enable;
+	unsigned int colorkey_low;
+	unsigned int colorkey_high;
+	/* background color only available for video, not available for overlay*/
+	unsigned int bg_color;
+}
+dc_color_key;
+
+#define DEBUG 0
+
+// #define DEFAULT_DC_ROT_ANGLE	DC_ROT_ANGLE_ROT0;
+#define DEFAULT_DC_ROT_ANGLE	DC_ROT_ANGLE_ROT180;	// for ICE EVB C910 board HW
+
+#define DEFAULT_WIDTH           720
+#define DEFAULT_HEIGHT          1280
+#define DEFAULT_FB_SIZE         (DEFAULT_WIDTH * DEFAULT_HEIGHT * 4 * 3)
+#define DEFAULT_OVERLAY_SIZE    (DEFAULT_WIDTH * DEFAULT_HEIGHT * 4 * 3)
+
+#define PIX_FMT_NONE   0
+#define PIX_FMT_RGB444 1
+#define PIX_FMT_RGB555 3
+#define PIX_FMT_RGB565 4
+#define PIX_FMT_RGB888 6
+
+#define CURSOR_FMT_DISALBE   0
+#define CURSOR_FMT_MASKED    1
+#define CURSOR_FMT_A8R8G8B8    2
+#define CURSOR_SIZE 32
+
+/*module param*/
+static uint irq = 0;
+module_param(irq, uint, 0644);
+static ulong reg_base = 0;
+module_param(reg_base, ulong, 0644);
+static uint reg_size = 64 << 10;
+module_param(reg_size, uint, 0644);
+
+
+static void __iomem *reg_virtual;
+static dma_addr_t framebuffer_phys = 0;
+static dma_addr_t overlay_phys = 0;
+static wait_queue_head_t vsync_wait;
+static struct fb_info *overlay_info = NULL;
+static u32 dst_global_alpha_mode = 0;
+static u32 dst_global_alpha_value = 0;
+static void *cursor_data = NULL;
+
+#if DEBUG
+static char __iomem *dest_virtual;
+static dma_addr_t dest_phys = 0;
+#endif
+
+/* ToDo */
+typedef struct _dc_last_overlay_scale_info {
+	unsigned int lastverfiltertap;
+	unsigned int lasthorfiltertap;
+	unsigned int lastheight;
+	unsigned int lastwidth;
+	unsigned int lastrectx;
+	unsigned int lastrecty;
+}
+dc_last_overlay_scale_info;
+
+struct ultrafb_info {
+	struct device  *dev;
+	struct clk     *clk;
+	struct fb_info *info;
+	void __iomem *reg_virtual;
+
+	dma_addr_t fb_start_dma;
+	dc_tile_mode tile_mode;
+
+	int format;
+	u32 pseudo_palette[16];
+
+	/* cursor info. */
+	u32 cursor_format;
+	int cursor_x;
+	int cursor_y;
+	int cursor_hot_x;
+	int cursor_hot_y;
+	dma_addr_t cursor_start_dma;
+	void *cursor_virtual;
+
+	/* frame buffer info. */
+	dma_addr_t fb_current_dma;
+	dc_frame_info framebuffersize;
+
+	/* overlay info. */
+	dma_addr_t overlay_current_dma;
+	dc_overlay_rect overlayrect;
+	dc_frame_info overlaysize;
+
+	/* alpha blending info. */
+	dc_global_alpha blending;
+	dc_alpha_blending_mode mode;
+
+	/* scale info. */
+	dc_filter_tap filtertap;
+	dc_sync_table synctable;
+
+	/* gamma info. */
+	dc_gamma_table gamma_table;
+
+	/* dither info. */
+	bool dither_enable;
+
+	/* rotation info. */
+	dc_rot_angle rotangle;
+
+	/* colorkey info. */
+	dc_color_key colorkey;
+
+	u32 vblank_count;
+};
+
+struct ultrafb_mach_info {
+	struct fb_videomode *modes;
+	int num_modes;
+	unsigned int pix_fmt;
+};
+
+struct fb_videomode video_modes[] = {
+	[0] = {
+		.refresh = 60,
+		.xres    = 1920,
+		.yres    = 1080,
+		.hsync_len = 32,
+		.left_margin = 120,
+		.right_margin = 128,
+		.vsync_len = 14,
+		.upper_margin = 21,
+		.lower_margin = 10,
+	},
+	[1] = {
+		.refresh = 60,
+		.xres    = 640,
+		.yres    = 480,
+		.hsync_len = 96,
+		.left_margin = 48,
+		.right_margin = 16,
+		.vsync_len = 2,
+		.upper_margin = 33,
+		.lower_margin = 10,
+	},
+	[2] = {
+		.refresh = 30,
+		.xres    = 1280,
+		.yres    = 720,
+		.hsync_len = 43,
+		.left_margin = 1917,
+		.right_margin = 60,
+		.vsync_len = 3,
+		.upper_margin = 17,
+		.lower_margin = 10,
+	},
+	[3] = {
+		.refresh = 60,
+		.xres    = 720,
+		.yres    = 1280,
+		.hsync_len = 10,
+		.left_margin = 45,
+		.right_margin = 40,
+		.vsync_len = 4,
+		.upper_margin = 10,
+		.lower_margin = 11,
+	},
+	[4] = {
+		.refresh = 50,
+		.xres    = 1280,
+		.yres    = 720,
+		.hsync_len = 43,
+		.left_margin = 597,
+		.right_margin = 60,
+		.vsync_len = 3,
+		.upper_margin = 17,
+		.lower_margin = 10,
+	},
+	[5] = {
+		.refresh = 60,
+		.xres    = 800,
+		.yres    = 480,
+		.hsync_len = 3,
+		.left_margin = 43,
+		.right_margin = 82,
+		.vsync_len = 3,
+		.upper_margin = 20,
+		.lower_margin = 22,
+	},
+};
+
+struct ultrafb_mach_info default_mach_info = {
+	// .modes     = &video_modes[5],	/* for RGB 7" LCD */
+	.modes     = &video_modes[3],		/* for MIPI LCD */
+	.num_modes = ARRAY_SIZE(video_modes),
+	.pix_fmt   = PIX_FMT_RGB888,
+};
+
+struct pix_fmt_info {
+	int pix_fmt;
+	int8_t bits_per_pixel;
+	int8_t transp_offset;
+	int8_t transp_length;
+	int8_t red_offset;
+	int8_t red_length;
+	int8_t green_offset;
+	int8_t green_length;
+	int8_t blue_offset;
+	int8_t blue_length;
+};
+
+static struct pix_fmt_info pix_fmt_xlate[] = {
+	{PIX_FMT_RGB444, 16,  12, 4,  8,  4,  4, 4,  0, 4},
+	{PIX_FMT_RGB444, 16,   0, 0,  8,  4,  4, 4,  0, 4},
+	{PIX_FMT_RGB565, 16,   0, 0,  11, 5,  5, 6,  0, 5},
+	{PIX_FMT_RGB555, 16,  15, 1,  10, 5,  5, 5,  0, 5},
+	{PIX_FMT_RGB555, 16,   0, 0,  10, 5,  5, 5,  0, 5},
+	{PIX_FMT_RGB888, 32,  24, 8,  16, 8,  8, 8,  0, 8},
+	{PIX_FMT_RGB888, 32,   0, 0,  16, 8,  8, 8,  0, 8},
+};
+
+/* Now, dma_alloc_writecombine is not supported in riscv systm yet,
+ * using kmalloc instead.
+ */
+static inline void *thead_dma_alloc(struct device *dev, size_t size,
+				    dma_addr_t *dma_addr, gfp_t gfp)
+{
+#ifdef __riscv
+	void *vaddr = kmalloc(size, GFP_KERNEL);
+	if (vaddr == NULL) {
+		printk("thead_dma_alloc(size=%zu) failed\n", size);
+		return NULL;
+	}
+
+	*dma_addr = virt_to_phys(vaddr);
+	return vaddr;
+#else
+	return dma_alloc_writecombine(dev, size, dma_addr, gfp);
+#endif
+}
+
+static inline void teahd_dma_free(struct device *dev, size_t size,
+				  void *cpu_addr, dma_addr_t dma_addr)
+{
+#ifdef __riscv
+	kfree(cpu_addr);
+#else
+	dma_free_writecombine(dev, size, cpu_addr, dma_addr);
+#endif
+}
+
+void write_register(uint32_t data, uint32_t addr)
+{
+	writel(data, reg_virtual + addr);
+#if DEBUG
+	printk("Write [0x%08x] 0x%08x\n", addr, data);
+#endif
+}
+
+uint32_t read_register(uint32_t addr)
+{
+	uint32_t data = 0;
+	data = readl(reg_virtual + addr);
+#if DEBUG
+	if (addr != INT_STATE)
+	{
+		printk("Read [0x%08x] 0x%08x\n", addr, data);
+	}
+#endif
+
+	return data;
+}
+
+static int determine_best_pix_fmt(struct fb_var_screeninfo *var)
+{
+	size_t i;
+
+	for (i = 0; i < ARRAY_SIZE(pix_fmt_xlate); i++) {
+		struct pix_fmt_info *info = &pix_fmt_xlate[i];
+
+		if ((var->bits_per_pixel == info->bits_per_pixel) &&
+			(var->transp.offset == info->transp_offset) &&
+			(var->transp.length == info->transp_length) &&
+			(var->red.offset == info->red_offset) &&
+			(var->red.length == info->red_length) &&
+			(var->green.offset == info->green_offset) &&
+			(var->green.length == info->green_length) &&
+			(var->blue.offset == info->blue_offset) &&
+			(var->blue.length == info->blue_length)) {
+			/* found format. */
+			return info->pix_fmt;
+		}
+	}
+
+	return 0;
+}
+
+static void set_pix_fmt(struct fb_var_screeninfo *var, int pix_fmt)
+{
+	size_t i;
+	struct pix_fmt_info *info = NULL;
+
+	for (i = 0; i < ARRAY_SIZE(pix_fmt_xlate); i++) {
+		if (pix_fmt_xlate[i].pix_fmt == pix_fmt) {
+			info = &pix_fmt_xlate[i];
+			break;
+		}
+	}
+
+	var->bits_per_pixel = info->bits_per_pixel;
+	var->transp.offset = info->transp_offset;
+	var->transp.length = info->transp_length;
+	var->red.offset = info->red_offset;
+	var->red.length = info->red_length;
+	var->green.offset = info->green_offset;
+	var->green.length = info->green_length;
+	var->blue.offset = info->blue_offset;
+	var->blue.length = info->blue_length;
+}
+
+static int get_bpp_by_format(int pix_fmt)
+{
+	size_t i;
+	struct pix_fmt_info *info = NULL;
+	int bpp = 0;
+
+	for (i = 0; i < ARRAY_SIZE(pix_fmt_xlate); i++) {
+		if (pix_fmt_xlate[i].pix_fmt == pix_fmt) {
+			info = &pix_fmt_xlate[i];
+			break;
+		}
+	}
+
+	bpp = info ->bits_per_pixel / 8;
+	return bpp;
+}
+
+static void set_mode(struct fb_var_screeninfo *var, struct fb_videomode *mode, int pix_fmt)
+{
+	set_pix_fmt(var, pix_fmt);
+	fb_videomode_to_var(var, mode);
+	var->grayscale = 0;
+}
+
+static void set_graphics_start(struct fb_info *info, int xoffset, int yoffset)
+{
+	struct ultrafb_info *fbi = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+	int pixel_offset;
+
+	pixel_offset = (yoffset * var->xres_virtual) + xoffset;
+
+	fbi->fb_current_dma = info->fix.smem_start + (pixel_offset * (var->bits_per_pixel >> 3));
+}
+
+static void set_overlay_graphics_start(struct fb_info *info, int xoffset, int yoffset)
+{
+	struct ultrafb_info *fbi = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+	int pixel_offset;
+
+	pixel_offset = (yoffset * var->xres_virtual) + xoffset;
+
+	fbi->overlay_current_dma = info->fix.smem_start + (pixel_offset * (var->bits_per_pixel >> 3));
+}
+
+static int ultrafb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct ultrafb_info *fbi = info->par;
+	struct device *dev = fbi->dev;
+	int pix_fmt;
+
+	pix_fmt = determine_best_pix_fmt(var);
+	if (!pix_fmt) {
+		dev_err(dev, "unsupport pixel format\n");
+		return -EINVAL;
+	}
+	fbi->format = pix_fmt;
+
+	/*
+	 * Basic geometry sanity checks.
+	 */
+	if (var->xres_virtual > var->xres) {
+		dev_err(dev, "unsupport stride\n");
+		return -EINVAL;
+	}
+
+	if (var->xres_virtual < var->xres)
+		var->xres_virtual = var->xres;
+	if (var->yres_virtual < var->yres)
+		var->yres_virtual = var->yres;
+
+	/*
+	 * Check size of framebuffer.
+	 */
+	if (var->xres_virtual * var->yres_virtual * (var->bits_per_pixel >> 3)
+		> info->fix.smem_len) {
+		dev_err(dev, "invalid framebuffer size requirement\n");
+		return -EINVAL;
+	}
+
+	set_graphics_start(info, var->xoffset, var->yoffset);
+	return 0;
+}
+
+static int ultrafb_set_par(struct fb_info *info)
+{
+	/* config dc register */
+	uint32_t h_end, h_total, hsync_start, hsync_end;
+	uint32_t v_end, v_total, vsync_start, vsync_end;
+	struct fb_var_screeninfo *var = &info->var;
+	struct ultrafb_info *fbi = info->par;
+	uint32_t data;
+	int j = 0;
+
+	info->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;
+	info->fix.ypanstep = var->yres;
+
+	/* Get the timing from var info */
+	h_end = var->xres;
+	h_total = var->xres + var->left_margin + var->right_margin + var->hsync_len;
+	hsync_start = var->xres + var->right_margin;
+	hsync_end = hsync_start + var->hsync_len;
+
+	v_end = var->yres;
+	v_total = var->yres + var->upper_margin + var->lower_margin + var->vsync_len;
+	vsync_start = var->yres + var->lower_margin;
+	vsync_end = vsync_start + var->vsync_len;
+
+	data = (h_total << 16) | h_end;
+	write_register(data, HDISPLAY);
+
+	data = (v_total << 16) | v_end;
+	write_register(data, VDISPLAY);
+
+	data = (0 << 31) | (1 << 30) | (hsync_end << 15) | (hsync_start);
+	write_register(data, HSYNC);
+
+	data = (0 << 31) | (1 << 30) | (vsync_end << 15) | (vsync_start);
+	write_register(data, VSYNC);
+
+	write_register(0x00000080, DBI_CONFIG);
+
+	write_register(0x00000005, DPI_CONFIG);
+
+	data = (1 << 0) | (0 << 1) | (1 << 4) | (0 << 5) | (1 << 8) | (0 << 9);
+	write_register(data, PANEL_CONFIG);
+
+	data = 0x0;
+	write_register(data, FRAMEBUFFER_UPLANAR_ADDRESS);
+
+	data = 0x0;
+	write_register(data, FRAMEBUFFER_VPLANAR_ADDRESS);
+
+	data = 0x0;
+	write_register(data, FRAMEBUFFER_USTRIDE);
+
+	data = 0x0;
+	write_register(data, FRAMEBUFFER_VSTRIDE);
+
+	write_register(0, INDEXCOLOR_TABLEINDEX);
+
+	data = (fbi->framebuffersize.height << 15) | (fbi->framebuffersize.width);
+	write_register(data, FRAMEBUFFER_SIZE);
+
+	if ((var->xres != fbi->framebuffersize.width) || (var->yres != fbi->framebuffersize.height))
+	{
+		data = ((fbi->framebuffersize.width - 1) << 16) / (var->xres - 1);
+		write_register(data , FRAMEBUFFER_SCALEFACTORX);
+
+		data = ((fbi->framebuffersize.height - 1) << 16) / (var->yres - 1);
+		if (data > (3 << 16))
+		{
+			data = (3 << 16);
+		}
+		write_register(data , FRAMEBUFFER_SCALEFACTORY);
+
+		write_register(0, HORIFILTER_KERNELINDEX);
+
+		for (j = 0; j < 128; j++)
+		{
+			data = fbi->synctable.horkernel[j];
+			write_register(data , HORIFILTER_KERNEL);
+		}
+
+		write_register(0, VERTIFILTER_KERNELINDEX);
+
+		for (j = 0; j < 128; j++)
+		{
+			data = fbi->synctable.verkernel[j];
+			write_register(data , VERTIFILTER_KERNEL);
+		}
+
+		data = (0x8000 << 0) | (0x8000 << 16);
+		write_register(data , FRAMEBUFFER_INITIALOFFSET);
+
+		data = (fbi->filtertap.vertical_filter_tap << 0) | (fbi->filtertap.horizontal_filter_tap << 4);
+		write_register(data , FRAMEBUFFER_SCALEFCONFIG);
+	}
+
+	data = fbi->colorkey.colorkey_low;
+	write_register(data, FRAMEBUFFER_COLORKEY);
+
+	data = fbi->colorkey.colorkey_high;
+	write_register(data, FRAMEBUFFER_COLORHIGHKEY);
+
+	data = fbi->colorkey.bg_color;
+	write_register(data, FRAMEBUFFER_BGCOLOR);
+
+	data = 0x0;
+	write_register(data, FRAMEBUFFER_CLEARVALUE);
+
+	data = 1 << 0;
+	write_register(data, DISPLAY_INTRENABLE);
+
+#if DEBUG
+	/* Set dest related function */
+	write_register(dest_phys, PANEL_DEST_ADDRESS);
+
+	write_register(dest_phys, MEM_DEST_ADDRESS);
+
+	data = (1 << 16) | (1 << 17);
+	write_register(data, DEST_CONFIG);
+
+	write_register(fbi->framebuffersize.stride, DEST_STRIDE);
+#endif
+	write_register(fbi->framebuffersize.stride, FRAMEBUFFER_STRIDE);
+	return 0;
+}
+
+static int ultrafb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	uint32_t data;
+	struct ultrafb_info *fbi = info->par;
+	int pixel_byte = 0;
+
+	pixel_byte = get_bpp_by_format(fbi->format);
+	set_graphics_start(info, var->xoffset, var->yoffset);
+	write_register(fbi->fb_current_dma, FRAMEBUFFER_ADDRESS);
+
+	if (((fbi->rotangle == DC_ROT_ANGLE_ROT90) || (fbi->rotangle == DC_ROT_ANGLE_ROT270)) && (fbi->tile_mode == DC_TILE_MODE_LINEAR))
+	{
+		return -EINVAL;
+	}
+	else
+	{
+		if ((var->xres != fbi->framebuffersize.width) || (var->yres != fbi->framebuffersize.height))
+		{
+			data = (1 << 0) | (fbi->gamma_table.gamma_enable << 2) |(1 << 4) | (0 << 8) | (fbi->colorkey.enable << 9) |
+				(fbi->rotangle << 11) | (fbi->tile_mode << 17) | (1 << 22) | (fbi->format << 26);
+		}
+		else
+		{
+			data = (1 << 0) | (fbi->gamma_table.gamma_enable << 2) |(1 << 4) | (0 << 8) | (fbi->colorkey.enable << 9) |
+				(fbi->rotangle << 11) | (fbi->tile_mode << 17) | (0 << 22) | (fbi->format << 26);
+		}
+		write_register(data, FRAMEBUFFER_CONFIG);
+	}
+
+	var->yoffset = var->yoffset + var->yres;
+	if (var->yoffset > info->var.yres_virtual - var->yres)
+	{
+		var->yoffset = 0;
+	}
+
+	fbi->gamma_table.gamma_enable = 0;
+	fbi->colorkey.enable = 0;
+	fbi->rotangle = DEFAULT_DC_ROT_ANGLE;
+	fbi->framebuffersize.width = DEFAULT_WIDTH;
+	fbi->framebuffersize.height = DEFAULT_HEIGHT;
+	fbi->framebuffersize.stride = DEFAULT_WIDTH * pixel_byte;
+	return 0;
+}
+
+static int ultrafb_cursor(struct fb_info *info, struct fb_cursor *cursor)
+{
+	uint32_t x, y, format;
+	uint32_t data;
+	int set = cursor->set;
+	struct ultrafb_info *fbi = info->par;
+
+	if (cursor->image.width > CURSOR_SIZE || cursor->image.height > CURSOR_SIZE)
+		return -EINVAL;
+
+	write_register(fbi->cursor_start_dma, CURSOR_ADDRESS);
+
+	if (set & FB_CUR_SETPOS)
+	{
+		y = cursor->image.dy;
+		x = cursor->image.dx;
+
+		data = (y << 16) | x;
+		write_register(data, CURSOR_LOCATION);
+	}
+
+	/*
+	 * FB_CUR_SETIMAGE - the cursor image has changed
+	 * FB_CUR_SETCMAP  - the cursor colors has changed
+	 * FB_CUR_SETSHAPE - the cursor bitmask has changed
+	 */
+	if (cursor->set & (FB_CUR_SETSHAPE | FB_CUR_SETCMAP | FB_CUR_SETIMAGE)) {
+		uint32_t image_size;
+		uint32_t bg, fg;
+
+		if (info->state != FBINFO_STATE_RUNNING)
+			return 0;
+
+		bg = cursor->image.bg_color;
+		fg = cursor->image.fg_color;
+
+		write_register(bg, CURSOR_BACKGROUND);
+		write_register(fg, CURSOR_FOREGROUND);
+
+		/* Use 32-bit operations on the data to improve performance */
+		image_size = cursor->image.width * cursor->image.height;
+		memcpy(fbi->cursor_virtual, (uint32_t *)cursor->image.data, image_size * 4);
+	}
+
+	if (cursor->enable)
+	{
+		/* Default ARGB8888 format */
+		format = CURSOR_FMT_A8R8G8B8;
+		data = format | (1 << 2) | (0 << 4) | (0 << 8) | (0 << 16);
+		write_register(data, CURSOR_CONFIG);
+	}
+	else
+	{
+		data = (0 << 0) | (1 << 2) | (0 << 4) | (0 << 8) | (0 << 16);
+		write_register(data, CURSOR_CONFIG);
+	}
+
+	return 0;
+}
+
+static int ultrafb_gamma(struct ultrafb_info *fbi)
+{
+	int i = 0;
+	u32 data;
+
+	for (i = 0; i < GAMMA_INDEX_MAX; i++)
+	{
+		data = i;
+		write_register(data, GAMMA_INDEX);
+
+		data = (fbi->gamma_table.gamma[i][2] << 0) | (fbi->gamma_table.gamma[i][1] << 10) |
+				(fbi->gamma_table.gamma[i][0] << 20);
+		write_register(data, GAMMA_DATA);
+	}
+	return 0;
+}
+
+static int ultrafb_dither(struct ultrafb_info *fbi)
+{
+	u32 data;
+
+	if (fbi->dither_enable)
+	{
+		write_register(0x7B48F3C0, DISPLAY_DITHER_TABLE_LOW);
+		write_register(0x596AD1E2, DISPLAY_DITHER_TABLE_HIGH);
+
+		data = fbi->dither_enable << 31;
+		write_register(data, DISPLAY_DITHER_CONFIG);
+	}
+	else
+	{
+		write_register(0, DISPLAY_DITHER_TABLE_LOW);
+		write_register(0, DISPLAY_DITHER_TABLE_HIGH);
+		write_register(0, DISPLAY_DITHER_CONFIG);
+	}
+	return 0;
+}
+
+static int ultrafb_blank(int blank, struct fb_info *info)
+{
+	u32 data, _new;
+
+	data = read_register(FRAMEBUFFER_CONFIG);
+	if (blank)
+		_new = data & ~(1 << 0);
+	else
+		_new = data | (1 << 0);
+	if (_new == data)
+		return 0;
+
+	write_register(_new, FRAMEBUFFER_CONFIG);
+
+	return 0;
+}
+
+static unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)
+{
+	return ((chan & 0xffff) >> (16 - bf->length)) << bf->offset;
+}
+
+static int ultrafb_setcolreg(unsigned int regno, unsigned int red, unsigned int green,
+		 unsigned int blue, unsigned int trans, struct fb_info *info)
+{
+	struct ultrafb_info *fbi = info->par;
+	u32 val;
+
+	if (info->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green +
+					7471 * blue) >> 16;
+
+	if (info->fix.visual == FB_VISUAL_TRUECOLOR && regno < 16) {
+		val =  chan_to_field(red,   &info->var.red);
+		val |= chan_to_field(green, &info->var.green);
+		val |= chan_to_field(blue , &info->var.blue);
+		fbi->pseudo_palette[regno] = val;
+	}
+
+	return 0;
+}
+
+static int ultrafb_mmap(struct fb_info *info, struct vm_area_struct * vma)
+{
+	unsigned long mmio_pgoff;
+	unsigned long start;
+	u32 len;
+
+	start = info->fix.smem_start;
+	len = info->fix.smem_len;
+	mmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;
+	if (vma->vm_pgoff >= mmio_pgoff) {
+		if (info->var.accel_flags) {
+			mutex_unlock(&info->mm_lock);
+			return -EINVAL;
+		}
+
+		vma->vm_pgoff -= mmio_pgoff;
+		start = info->fix.mmio_start;
+		len = info->fix.mmio_len;
+	}
+
+	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	return vm_iomap_memory(vma, start, len);
+}
+
+static int ultrafb_ioctl(struct fb_info *info, unsigned int cmd,
+		unsigned long argp)
+{
+	int ret, j;
+	u32 vblank_count;
+	dc_frame_info size;
+	dc_filter_tap filtertap;
+	dc_sync_table table;
+	struct fb_cursor cursor;
+	static dc_gamma_table gammatable;
+	bool ditherenable;
+	dc_rot_angle rotangle;
+	dc_tile_mode tilemode;
+	dc_color_key colorkey;
+
+	struct ultrafb_info *fbi = info->par;
+
+	switch (cmd) {
+	case ULTRAFBIO_CURSOR:
+		if (copy_from_user(&cursor, (void *)argp, sizeof(cursor)))
+			return -EFAULT;
+
+		cursor_data = kmalloc(CURSOR_SIZE * CURSOR_SIZE * 4, GFP_KERNEL);
+		if (copy_from_user(cursor_data, (void *)cursor.image.data, CURSOR_SIZE * CURSOR_SIZE * 4))
+			return -EFAULT;
+		cursor.image.data = (char *)cursor_data;
+
+		ret = ultrafb_cursor(info, &cursor);
+
+		/* free buffer */
+		kfree(cursor_data);
+		return ret;
+	case FBIO_WAITFORVSYNC:
+		vblank_count = fbi->vblank_count;
+		ret = wait_event_interruptible_timeout(vsync_wait, vblank_count != fbi->vblank_count, HZ /10);
+
+		if(ret == 0)
+		   return -ETIMEDOUT;
+		return 0;
+	case ULTRAFBIO_BUFFER_SIZE:
+		if (copy_from_user(&size, (void *)argp, sizeof(size)))
+			return -EFAULT;
+
+		fbi->framebuffersize.width = size.width;
+		fbi->framebuffersize.height = size.height;
+		fbi->framebuffersize.stride = size.stride;
+		return 0;
+	case ULTRAFBIO_SCALE_FILTER_TAP:
+		if (copy_from_user(&filtertap, (void *)argp, sizeof(filtertap)))
+			return -EFAULT;
+
+		fbi->filtertap.horizontal_filter_tap = filtertap.horizontal_filter_tap;
+		fbi->filtertap.vertical_filter_tap = filtertap.vertical_filter_tap;
+		return 0;
+	case ULTRAFBIO_SYNC_TABLE:
+		if (copy_from_user(&table, (void *)argp, sizeof(table)))
+			return -EFAULT;
+
+		for (j = 0; j < 128; j++)
+		{
+			fbi->synctable.horkernel[j] = table.horkernel[j];
+			fbi->synctable.verkernel[j] = table.verkernel[j];
+		}
+		return 0;
+	case ULTRAFBIO_GAMMA:
+		if (copy_from_user(&gammatable, (void *)argp, sizeof(gammatable)))
+			return -EFAULT;
+
+		fbi->gamma_table.gamma_enable = gammatable.gamma_enable;
+		for (j = 0; j < GAMMA_INDEX_MAX; j++)
+		{
+			fbi->gamma_table.gamma[j][0] = gammatable.gamma[j][0];
+			fbi->gamma_table.gamma[j][1] = gammatable.gamma[j][1];
+			fbi->gamma_table.gamma[j][2] = gammatable.gamma[j][2];
+		}
+
+		ret = ultrafb_gamma(fbi);
+		return ret;
+	case ULTRAFBIO_DITHER:
+		if (copy_from_user(&ditherenable, (void *)argp, sizeof(ditherenable)))
+			return -EFAULT;
+
+		fbi->dither_enable = ditherenable;
+
+		ret = ultrafb_dither(fbi);
+		return ret;
+	case ULTRAFBIO_ROTATION:
+		if (copy_from_user(&rotangle, (void *)argp, sizeof(rotangle)))
+			return -EFAULT;
+
+		fbi->rotangle = rotangle;
+		return 0;
+	case ULTRAFBIO_TILEMODE:
+		if (copy_from_user(&tilemode, (void *)argp, sizeof(tilemode)))
+			return -EFAULT;
+
+		fbi->tile_mode = tilemode;
+		return 0;
+	case ULTRAFBIO_COLORKEY:
+		if (copy_from_user(&colorkey, (void *)argp, sizeof(colorkey)))
+			return -EFAULT;
+
+		if (colorkey.enable)
+			fbi->colorkey.enable = 0x2;
+		else
+			fbi->colorkey.enable = 0x0;
+
+		fbi->colorkey.colorkey_low = colorkey.colorkey_low;
+		fbi->colorkey.colorkey_high = colorkey.colorkey_high;
+		fbi->colorkey.bg_color = colorkey.bg_color;
+		return 0;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int ultrafb_release(struct fb_info *info, int user)
+{
+	uint32_t data;
+
+	data = 0x0;
+	write_register(data, FRAMEBUFFER_CONFIG);
+	return 0;
+}
+
+static struct fb_ops ultrafb_ops = {
+	.owner = THIS_MODULE,
+	.fb_check_var = ultrafb_check_var,
+	.fb_set_par = ultrafb_set_par,
+	.fb_pan_display = ultrafb_pan_display,
+	.fb_blank = ultrafb_blank,
+	.fb_setcolreg = ultrafb_setcolreg,
+	.fb_mmap = ultrafb_mmap,
+	.fb_ioctl = ultrafb_ioctl,
+	.fb_release = ultrafb_release,
+};
+
+static irqreturn_t ultrafb_handle_irq(int irq, void *dev_id)
+{
+	struct ultrafb_info *fbi = dev_id;
+	uint32_t data;
+
+	data = read_register(INT_STATE);
+	fbi->vblank_count ++;
+	if (!(data & 0x1))
+		return IRQ_NONE;
+
+	/* TODO: set fb cursor here. */
+
+	return IRQ_HANDLED;
+}
+
+static void set_overlay_var(struct fb_var_screeninfo *var, struct fb_videomode *mode, int pix_fmt)
+{
+	set_pix_fmt(var, pix_fmt);
+
+	var->xres = mode ->xres;
+	var->yres = mode ->yres;
+	var->xres_virtual = mode ->xres;
+	var->yres_virtual = mode ->yres;
+	var->xoffset = 0;
+	var->yoffset = 0;
+	var->height = -1;
+	var->width = -1;
+	var->vmode = FB_VMODE_NONINTERLACED;
+	var->activate = FB_ACTIVATE_FORCE;
+}
+
+static int overlay_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct ultrafb_info *fbi = info->par;
+	struct device *dev = fbi->dev;
+	int pix_fmt;
+
+	pix_fmt = determine_best_pix_fmt(var);
+	if (!pix_fmt) {
+		dev_err(dev, "unsupport pixel format\n");
+		return -EINVAL;
+	}
+	fbi->format = pix_fmt;
+
+	/*
+	 * Basic geometry sanity checks.
+	 */
+	if (var->xres_virtual > var->xres) {
+		dev_err(dev, "unsupport stride\n");
+		return -EINVAL;
+	}
+
+	if (var->xres_virtual < var->xres)
+		var->xres_virtual = var->xres;
+	if (var->yres_virtual < var->yres)
+		var->yres_virtual = var->yres;
+
+	/*
+	 * Check size of framebuffer.
+	 */
+	if (var->xres_virtual * var->yres_virtual * (var->bits_per_pixel >> 3)
+		> info->fix.smem_len) {
+		dev_err(dev, "invalid framebuffer size requirement\n");
+		return -EINVAL;
+	}
+
+	set_overlay_graphics_start(info, var->xoffset, var->yoffset);
+	return 0;
+}
+
+static int overlay_set_par(struct fb_info *info)
+{
+	/* config overlay register */
+	struct ultrafb_info *fbi = info->par;
+	uint32_t data;
+	uint32_t rectx, recty;
+	int j = 0;
+
+	rectx = fbi->overlayrect.brx - fbi->overlayrect.tlx;
+	recty = fbi->overlayrect.bry - fbi->overlayrect.tly;
+
+	data = fbi->overlaysize.stride;
+	write_register(data, OVERLAY_STRIDE);
+
+	data = 0;
+	write_register(data, OVERLAY_USTRIDE);
+
+	data = 0;
+	write_register(data, OVERLAY_VSTRIDE);
+
+	data = (fbi->overlayrect.tlx << 0) | (fbi->overlayrect.tly << 15);
+	write_register(data, OVERLAY_TL);
+
+	data = (fbi->overlayrect.brx << 0) | (fbi->overlayrect.bry << 15);
+	write_register(data, OVERLAY_BR);
+
+	switch(fbi->mode)
+	{
+	case DC_BLEND_MODE_CLEAR:
+		data = (0 << 0) | (fbi->blending.global_alpha_mode << 3) | (0 << 5) | (0 << 8) |
+				  (0 << 9) | (dst_global_alpha_mode << 10) | (0 << 12) | (0 << 15);
+		break;
+	case DC_BLEND_MODE_SRC:
+		data = (0 << 0) | (fbi->blending.global_alpha_mode << 3) | (1 << 5) | (0 << 8) |
+				  (0 << 9) | (dst_global_alpha_mode << 10) | (0 << 12) | (0 << 15);
+		break;
+	case DC_BLEND_MODE_DST:
+		data = (0 << 0) | (fbi->blending.global_alpha_mode << 3) | (0 << 5) | (0 << 8) |
+				  (0 << 9) | (dst_global_alpha_mode << 10) | (1 << 12) | (0 << 15);
+		break;
+	case DC_BLEND_MODE_SRC_OVER:
+		data = (0 << 0) | (fbi->blending.global_alpha_mode << 3) | (1 << 5) | (0 << 8) |
+				  (0 << 9) | (dst_global_alpha_mode << 10) | (3 << 12) | (0 << 15);
+		break;
+	case DC_BLEND_MODE_DST_OVER:
+		data = (0 << 0) | (fbi->blending.global_alpha_mode << 3) | (3 << 5) | (0 << 8) |
+				  (0 << 9) | (dst_global_alpha_mode << 10) | (1 << 12) | (0 << 15);
+		break;
+	case DC_BLEND_MODE_SRC_IN:
+		data = (0 << 0) | (fbi->blending.global_alpha_mode << 3) | (2 << 5) | (0 << 8) |
+				  (0 << 9) | (dst_global_alpha_mode << 10) | (0 << 12) | (0 << 15);
+		break;
+	case DC_BLEND_MODE_DST_IN:
+		data = (0 << 0) | (fbi->blending.global_alpha_mode << 3) | (0 << 5) | (0 << 8) |
+				  (0 << 9) | (dst_global_alpha_mode << 10) | (2 << 12) | (0 << 15);
+		break;
+	case DC_BLEND_MODE_SRC_OUT:
+		data = (0 << 0) | (fbi->blending.global_alpha_mode << 3) | (3 << 5) | (0 << 8) |
+				  (0 << 9) | (dst_global_alpha_mode << 10) | (0 << 12) | (0 << 15);
+		break;
+	}
+	write_register(data, OVERLAY_ALPHA_BLEND_CONFIG);
+
+	data = fbi->blending.global_alpha_value;
+	write_register(data , OVERLAY_SRC_GLOBAL_COLOR);
+
+	data = dst_global_alpha_value;
+	write_register(data , OVERLAY_DST_GLOBAL_COLOR);
+
+	write_register(0, OVERLAY_CLEAR_VALUE);
+
+	data = (fbi->overlaysize.height << 15) | (fbi->overlaysize.width);
+	write_register(data, OVERLAY_SIZE);
+
+	data = fbi->colorkey.colorkey_low;
+	write_register(data, OVERLAY_COLOR_KEY);
+
+	data = fbi->colorkey.colorkey_high;
+	write_register(data, OVERLAY_COLOR_KEY_HIGH);
+
+	write_register(0, OVERLAY_UPLANAR_ADDRESS);
+
+	write_register(0, OVERLAY_VPLANAR_ADDRESS);
+
+	if ((rectx != fbi->overlaysize.width) || (recty != fbi->overlaysize.height))
+	{
+		data = ((fbi->overlaysize.width - 1) << 16) / (rectx - 1);
+		write_register(data , OVERLAY_SCALE_FACTOR_X);
+
+		data = ((fbi->overlaysize.height - 1) << 16) / (recty - 1);
+		if (data > (3 << 16))
+		{
+			data = (3 << 16);
+		}
+		write_register(data , OVERLAY_SCALE_FACTOR_Y);
+
+		write_register(0, OVERLAY_HORI_FILTER_KERNEL_INDEX);
+
+		for (j = 0; j < 128; j++)
+		{
+			data = fbi->synctable.horkernel[j];
+			write_register(data , OVERLAY_HORI_FILTER_KERNEL);
+		}
+
+		write_register(0, OVERLAY_VERTI_FILTER_KERNEL_INDEX);
+
+		for (j = 0; j < 128; j++)
+		{
+			data = fbi->synctable.verkernel[j];
+			write_register(data , OVERLAY_VERTI_FILTER_KERNEL);
+		}
+
+		data = (0x8000 << 0) | (0x8000 << 16);
+		write_register(data , OVERLAY_INITIAL_OFFSET);
+
+		data = (fbi->filtertap.vertical_filter_tap << 0) | (fbi->filtertap.horizontal_filter_tap << 4) | (1 << 8);
+		write_register(data , OVERLAY_SCALE_CONFIG);
+	}
+	else
+	{
+		write_register(0, OVERLAY_SCALE_CONFIG);
+	}
+
+	return 0;
+}
+
+static int overlay_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	uint32_t data;
+	struct ultrafb_info *fbi = info->par;
+
+	set_overlay_graphics_start(info, var->xoffset, var->yoffset);
+	write_register(fbi->overlay_current_dma, OVERLAY_ADDRESS);
+
+	if (((fbi->rotangle == DC_ROT_ANGLE_ROT90) || (fbi->rotangle == DC_ROT_ANGLE_ROT270)) && (fbi->tile_mode != DC_TILE_MODE_LINEAR))
+	{
+		return -EINVAL;
+	}
+	else
+	{
+		data = (fbi->colorkey.enable << 0) | (6 << 16) | (1 << 24) | (fbi->rotangle << 2) | (0 << 13) |
+			(0 << 0) | (0 << 25) | (fbi->tile_mode << 8);
+		write_register(data, OVERLAY_CONFIG);
+	}
+
+	var->yoffset = var->yoffset + var->yres;
+	if (var->yoffset > info->var.yres_virtual - var->yres)
+	{
+		var->yoffset = 0;
+	}
+
+	fbi->colorkey.enable = 0;
+	fbi->rotangle = DEFAULT_DC_ROT_ANGLE;
+	fbi->mode = DC_BLEND_MODE_SRC;
+	fbi->overlayrect.tlx = 0;
+	fbi->overlayrect.tly = 0;
+	fbi->overlayrect.brx = 320;
+	fbi->overlayrect.bry = 240;
+	fbi->overlaysize.width = 320;
+	fbi->overlaysize.height = 240;
+	return 0;
+}
+
+static int overlay_ioctl(struct fb_info *info, unsigned int cmd, unsigned long argp)
+{
+	int ret, j;
+	dc_global_alpha alpha;
+	dc_frame_info size;
+	dc_overlay_rect coordinate;
+	struct ultrafb_info *fbi = info->par;
+	dc_alpha_blending_mode mode;
+	dc_filter_tap filtertap;
+	dc_sync_table table;
+	dc_rot_angle rotangle;
+	dc_tile_mode tilemode;
+	dc_color_key colorkey;
+
+	switch (cmd) {
+	case ULTRAFBIO_BUFFER_SIZE:
+		if (copy_from_user(&size, (void *)argp, sizeof(size)))
+			return -EFAULT;
+
+		fbi->overlaysize.width = size.width;
+		fbi->overlaysize.height = size.height;
+		fbi->overlaysize.stride = size.stride;
+		return 0;
+	case ULTRAFBIO_OVERLAY_RECT:
+		if (copy_from_user(&coordinate, (void *)argp, sizeof(coordinate)))
+			return -EFAULT;
+
+		fbi->overlayrect.tlx = coordinate.tlx;
+		fbi->overlayrect.tly = coordinate.tly;
+		fbi->overlayrect.brx = coordinate.brx;
+		fbi->overlayrect.bry = coordinate.bry;
+		return 0;
+	case ULTRAFBIO_BLENDING_MODE:
+		if (copy_from_user(&mode, (void *)argp, sizeof(mode)))
+			return -EFAULT;
+
+		fbi->mode = mode;
+		return 0;
+	case ULTRAFBIO_GLOBAL_MODE_VALUE:
+		if (copy_from_user(&alpha, (void *)argp, sizeof(alpha)))
+			return -EFAULT;
+
+		fbi->blending.global_alpha_mode = alpha.global_alpha_mode;
+		fbi->blending.global_alpha_value = alpha.global_alpha_value;
+		return 0;
+	case ULTRAFBIO_SCALE_FILTER_TAP:
+		if (copy_from_user(&filtertap, (void *)argp, sizeof(filtertap)))
+			return -EFAULT;
+
+		fbi->filtertap.horizontal_filter_tap = filtertap.horizontal_filter_tap;
+		fbi->filtertap.vertical_filter_tap = filtertap.vertical_filter_tap;
+		return 0;
+	case ULTRAFBIO_SYNC_TABLE:
+		if (copy_from_user(&table, (void *)argp, sizeof(table)))
+			return -EFAULT;
+
+		for (j = 0; j < 128; j++)
+		{
+			fbi->synctable.horkernel[j] = table.horkernel[j];
+			fbi->synctable.verkernel[j] = table.verkernel[j];
+		}
+		return 0;
+	case ULTRAFBIO_ROTATION:
+		if (copy_from_user(&rotangle, (void *)argp, sizeof(rotangle)))
+			return -EFAULT;
+
+		fbi->rotangle = rotangle;
+		return 0;
+	case ULTRAFBIO_TILEMODE:
+		if (copy_from_user(&tilemode, (void *)argp, sizeof(tilemode)))
+			return -EFAULT;
+
+		fbi->tile_mode = tilemode;
+		return 0;
+	case ULTRAFBIO_COLORKEY:
+		if (copy_from_user(&colorkey, (void *)argp, sizeof(colorkey)))
+			return -EFAULT;
+
+		if (colorkey.enable)
+			fbi->colorkey.enable = 0x2;
+		else
+			fbi->colorkey.enable = 0x0;
+
+		fbi->colorkey.colorkey_low = colorkey.colorkey_low;
+		fbi->colorkey.colorkey_high = colorkey.colorkey_high;
+		return 0;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int overlay_release(struct fb_info *info, int user)
+{
+	uint32_t data;
+
+	data = 0x0;
+	write_register(data, OVERLAY_CONFIG);
+	return 0;
+}
+
+static struct fb_ops overlay_ops = {
+	.owner = THIS_MODULE,
+	.fb_check_var = overlay_check_var,
+	.fb_set_par = overlay_set_par,
+	.fb_pan_display = overlay_pan_display,
+	.fb_ioctl = overlay_ioctl,
+	.fb_release = overlay_release,
+};
+
+static int dcultra_overlay_init(struct platform_device *pdev)
+{
+	struct fb_info *info;
+	struct ultrafb_info *fbi;
+	struct ultrafb_mach_info *mi;
+	int ret = 0;
+
+	mi = &default_mach_info;
+
+	info = framebuffer_alloc(sizeof(struct ultrafb_info), &pdev->dev);
+	if (info == NULL) {
+		dev_err(&pdev->dev, "alloc overlay fb_info failed\n");
+		return -ENOMEM;
+	}
+
+	fbi = info->par;
+	fbi->info = info;
+	fbi->dev = info->dev = &pdev->dev;
+	fbi->format = mi->pix_fmt;
+	fbi->mode = DC_BLEND_MODE_SRC;
+	fbi->blending.global_alpha_mode = 0;
+	fbi->blending.global_alpha_value = 0;
+	fbi->filtertap.horizontal_filter_tap = 5;
+	fbi->filtertap.vertical_filter_tap = 3;
+	fbi->overlayrect.brx = 320;
+	fbi->overlayrect.bry = 240;
+	fbi->overlayrect.tlx = 0;
+	fbi->overlayrect.tly = 0;
+	fbi->overlaysize.height = 160;
+	fbi->overlaysize.width = 120;
+	fbi->rotangle = 0;
+	fbi->tile_mode = 0;
+	fbi->colorkey.enable = 0;
+
+	/* set other parameter*/
+	info->flags = FBINFO_DEFAULT | FBINFO_PARTIAL_PAN_OK |FBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;
+	info->node = -1;
+	info->pseudo_palette = NULL;
+	info->fbops = &overlay_ops;
+
+	/* set var parameter*/
+	set_overlay_var(&info->var, mi->modes, mi->pix_fmt);
+
+	/* set multibuffer. */
+	info->var.xres_virtual = info->var.xres;
+	info->var.yres_virtual = info->fix.smem_len /
+		(info->var.xres_virtual * (info->var.bits_per_pixel >> 3)) / info->var.yres * info->var.yres;
+	if (info->var.yres_virtual > 3 * info->var.yres)
+		info->var.yres_virtual = 3 * info->var.yres;
+
+	/* set fix parameter*/
+	strlcpy(info->fix.id, "dcultra overlay", 16);
+	info->fix.type = FB_TYPE_PACKED_PIXELS;
+	info->fix.type_aux = 0;
+	info->fix.xpanstep = 0;
+	info->fix.ypanstep = info->var.yres;
+	info->fix.ywrapstep = 0;
+	info->fix.smem_len = PAGE_ALIGN(DEFAULT_OVERLAY_SIZE);
+	info->screen_base = thead_dma_alloc(NULL, info->fix.smem_len, &overlay_phys, GFP_KERNEL);
+	info->fix.smem_start = (unsigned long)overlay_phys;
+
+	overlay_info = info;
+
+	overlay_check_var(&info->var, info);
+	overlay_set_par(info);
+
+	ret = register_framebuffer(info);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to register overlay fb_info\n");
+		ret = -ENOMEM;
+		goto on_error;
+	}
+
+	return 0;
+
+on_error:
+	teahd_dma_free(NULL, info->fix.smem_len, info->screen_base, overlay_phys);
+	framebuffer_release(overlay_info);
+
+	return ret;
+}
+
+static int ultrafb_probe(struct platform_device *pdev)
+{
+	struct fb_info *info;
+	struct ultrafb_info *fbi;
+	struct ultrafb_mach_info *mi;
+	int ret = 0;
+	int pixel_byte = 0;
+	_Static_assert(PAGE_ALIGN(DEFAULT_FB_SIZE) + 32 * 32 * 4 < 0x2000000, "error");
+
+	printk("%s probe.\n", __func__);
+
+	mi = &default_mach_info;
+	if (!reg_base) {
+		struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (!res) {
+			dev_err(&pdev->dev, "no IO memory defined\n");
+			return -ENOENT;
+		}
+
+		reg_base = res->start;
+		reg_size = resource_size(res);
+	}
+
+	if (irq < 0) {
+		dev_err(&pdev->dev, "no IRQ defined\n");
+		return -ENOENT;
+	}
+
+	info = framebuffer_alloc(sizeof(struct ultrafb_info), &pdev->dev);
+	if (info == NULL) {
+		dev_err(&pdev->dev, "alloc framebuffer failed\n");
+		return -ENOMEM;
+	}
+
+	fbi = info->par;
+	fbi->info = info;
+	fbi->dev = info->dev = &pdev->dev;
+	fbi->format = mi->pix_fmt;
+	fbi->vblank_count = 0;
+	fbi->rotangle = 0;
+	fbi->tile_mode = 0;
+	fbi->colorkey.enable = 0;
+	pixel_byte = get_bpp_by_format(fbi->format);
+	fbi->framebuffersize.width = DEFAULT_WIDTH;
+	fbi->framebuffersize.height = DEFAULT_HEIGHT;
+	fbi->framebuffersize.stride = DEFAULT_WIDTH * pixel_byte;
+	/*
+
+	 * Initialise static fb parameters.
+	 */
+	info->flags = FBINFO_DEFAULT | FBINFO_PARTIAL_PAN_OK |
+			  FBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;
+	info->node = -1;
+	strlcpy(info->fix.id, "Vivante dcultra", 16);
+	info->fix.type = FB_TYPE_PACKED_PIXELS;
+	info->fix.type_aux = 0;
+	info->fix.xpanstep = 0;
+	info->fix.ypanstep = 0;
+	info->fix.ywrapstep = 0;
+	info->fix.mmio_start = reg_base;
+	info->fix.mmio_len = reg_size;
+	info->fix.accel = FB_ACCEL_NONE;
+	info->fbops = &ultrafb_ops;
+	info->pseudo_palette = fbi->pseudo_palette;
+	info->fix.visual = FB_VISUAL_TRUECOLOR;
+
+	info->fix.smem_len = PAGE_ALIGN(DEFAULT_FB_SIZE);
+
+	ret = request_irq(irq, ultrafb_handle_irq,
+				   IRQF_SHARED, "dc_ultra", fbi);
+
+	init_waitqueue_head(&vsync_wait);
+
+	request_mem_region(reg_base, reg_size, "dc ultra region");
+
+	info->screen_base = thead_dma_alloc(NULL, info->fix.smem_len, &framebuffer_phys, GFP_KERNEL);
+	info->fix.smem_start = (unsigned long)framebuffer_phys;
+
+	fbi->reg_virtual = (void __iomem *)ioremap(reg_base, reg_size);
+	reg_virtual = fbi->reg_virtual;
+
+#if DEBUG
+	dest_virtual = thead_dma_alloc(NULL, info->fix.smem_len, &dest_phys, GFP_KERNEL);
+#endif
+
+	fbi->cursor_start_dma = PAGE_ALIGN(info->fix.smem_start + info->fix.smem_len);
+	fbi->cursor_virtual = thead_dma_alloc(NULL, CURSOR_SIZE * CURSOR_SIZE * 4, &fbi->cursor_start_dma, GFP_KERNEL);
+
+	set_mode(&info->var, mi->modes, mi->pix_fmt);
+
+	/* set multibuffer. */
+	info->var.xres_virtual = info->var.xres;
+	info->var.yres_virtual = info->fix.smem_len /
+		(info->var.xres_virtual * (info->var.bits_per_pixel >> 3)) / info->var.yres * info->var.yres;
+	if (info->var.yres_virtual > 3 * info->var.yres)
+		info->var.yres_virtual = 3 * info->var.yres;
+	info->var.activate = FB_ACTIVATE_FORCE;
+
+	ultrafb_check_var(&info->var, info);
+
+	write_register(0x0, FRAMEBUFFER_CONFIG);
+	write_register(0x00071900, AQHICLOCKCONTROL);
+	write_register(0x00070900, AQHICLOCKCONTROL);
+
+	ultrafb_set_par(info);
+
+	ret = fb_alloc_cmap(&info->cmap, 16, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "Fail to alloc cmap: %d\n", ret);
+		goto on_error;
+	}
+
+	ret = register_framebuffer(info);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to register dc-fb: %d\n", ret);
+		ret = -ENXIO;
+		goto on_error;
+	}
+
+	platform_set_drvdata(pdev, fbi);
+
+	ret = dcultra_overlay_init(pdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to init overlay\n");
+		return ret;
+	}
+
+	return 0;
+
+on_error:
+	if (&info->cmap)
+		fb_dealloc_cmap(&info->cmap);
+
+	teahd_dma_free(NULL, CURSOR_SIZE * CURSOR_SIZE * 4, fbi->cursor_virtual, fbi->cursor_start_dma);
+#if DEBUG
+	teahd_dma_free(NULL, info->fix.smem_len, dest_virtual, dest_phys);
+#endif
+	iounmap(fbi->reg_virtual);
+	teahd_dma_free(NULL, info->fix.smem_len, info->screen_base, framebuffer_phys);
+	framebuffer_release(info);
+
+	dev_err(&pdev->dev, "frame buffer device init failed with %d\n", ret);
+	return ret;
+}
+
+static int ultrafb_remove(struct platform_device *pdev)
+{
+	struct ultrafb_info *fbi = platform_get_drvdata(pdev);
+	struct fb_info *info = fbi->info;
+	uint32_t data;
+
+	/* Disable DE */
+	data = read_register(PANEL_CONFIG);
+	data = data & ~0x1;
+	write_register(data, PANEL_CONFIG);
+
+	/* Reset framebuffer */
+	write_register(0, FRAMEBUFFER_CONFIG);
+
+	unregister_framebuffer(overlay_info);
+	unregister_framebuffer(info);
+
+	if (&info->cmap)
+		fb_dealloc_cmap(&info->cmap);
+
+	teahd_dma_free(NULL, info->fix.smem_len, info->screen_base, overlay_phys);
+
+	teahd_dma_free(NULL, CURSOR_SIZE * CURSOR_SIZE * 4, fbi->cursor_virtual, fbi->cursor_start_dma);
+#if DEBUG
+	teahd_dma_free(NULL, info->fix.smem_len, dest_virtual, dest_phys);
+#endif
+	iounmap(fbi->reg_virtual);
+	teahd_dma_free(NULL, info->fix.smem_len, info->screen_base, framebuffer_phys);
+
+	release_mem_region(info->fix.mmio_start, info->fix.mmio_len);
+
+	framebuffer_release(overlay_info);
+	framebuffer_release(info);
+
+	/* release irq */
+	free_irq(irq, fbi);
+	return 0;
+}
+
+static const struct of_device_id ultrafb_of_dev_id[] = {
+	{ .compatible = "verisilicon,dc8000-fb", },
+	{ }
+};
+
+static struct platform_driver ultrafb_driver = {
+	.driver   = {
+		.name = "viv-dc",
+		.of_match_table = ultrafb_of_dev_id,
+	},
+	.probe = ultrafb_probe,
+	.remove = ultrafb_remove,
+};
+module_platform_driver(ultrafb_driver);
+
+MODULE_DESCRIPTION("Vivante dcultra Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 01ce3f41cc21..702ee62d74a0 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -724,6 +724,20 @@ config IMX2_WDT
 	  To compile this driver as a module, choose M here: the
 	  module will be called imx2_wdt.
 
+config ICE_WDT
+	tristate "ICE+ Watchdog"
+	depends on RISCV
+	default y
+	select WATCHDOG_CORE
+	help
+	  This is the driver for the hardware watchdog
+	  on the ice and later processors.
+	  If you have one of these processors and wish to have
+	  watchdog support enabled, say Y, otherwise say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ice_wdt.
+
 config IMX_SC_WDT
 	tristate "IMX SC Watchdog"
 	depends on HAVE_ARM_SMCCC
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index 071a2e50be98..929a06e21120 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -67,6 +67,7 @@ obj-$(CONFIG_STMP3XXX_RTC_WATCHDOG) += stmp3xxx_rtc_wdt.o
 obj-$(CONFIG_TS4800_WATCHDOG) += ts4800_wdt.o
 obj-$(CONFIG_TS72XX_WATCHDOG) += ts72xx_wdt.o
 obj-$(CONFIG_IMX2_WDT) += imx2_wdt.o
+obj-$(CONFIG_ICE_WDT) += ice_wdt.o
 obj-$(CONFIG_IMX_SC_WDT) += imx_sc_wdt.o
 obj-$(CONFIG_IMX7ULP_WDT) += imx7ulp_wdt.o
 obj-$(CONFIG_UX500_WATCHDOG) += ux500_wdt.o
diff --git a/drivers/watchdog/ice_wdt.c b/drivers/watchdog/ice_wdt.c
new file mode 100644
index 000000000000..6ebbe495e831
--- /dev/null
+++ b/drivers/watchdog/ice_wdt.c
@@ -0,0 +1,193 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/watchdog.h>
+
+#define DRV_NAME		"ice-wdt"
+
+#define WDT_LOCK		0x0
+#define WDT_OT_LOAD_H		0x4
+#define WDT_OT_LOAD_L		0x8
+#define WDT_RMOD		0xC
+#define WDT_EN			0x10
+#define WDT_KNOCK		0x14
+#define WDT_EOI 		0x18
+#define WDT_CUR_VALUE_H 	0x1C
+#define WDT_CUR_VALUE_L 	0x20
+#define WDT_INT_STATE		0x24
+
+#define REGS_WRITE_UNLOCK 	0x5ada7200
+#define REGS_WRITE_LOCK 	0x5ada7201
+
+#define TOUCH_WATCHDOG		0x55aadd22
+
+#define ICE_WDT_TIMEOUT 	120
+
+#define DEFAULT_TIMEOUT 	0xcccccccc
+
+static unsigned int timeout;
+
+struct ice_wdt_dev {
+	struct watchdog_device wdt_dev;
+	void __iomem *wdt_base;
+};
+
+static const struct watchdog_info ice_wdt_info = {
+	.identity       = DRV_NAME,
+	.options        = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,
+};
+
+static void ice_wdt_change_timeout(struct watchdog_device *wdt_dev,
+		unsigned int timeout)
+{
+	struct ice_wdt_dev *ice_wdt = watchdog_get_drvdata(wdt_dev);
+	u32 timetick;
+
+	timetick = (DEFAULT_TIMEOUT/120) * timeout;
+
+	writel(REGS_WRITE_UNLOCK, ice_wdt->wdt_base + WDT_LOCK);
+	writel(timetick, ice_wdt->wdt_base + WDT_OT_LOAD_L);
+	writel(REGS_WRITE_LOCK, ice_wdt->wdt_base + WDT_LOCK);
+}
+
+
+static int ice_wdt_restart(struct watchdog_device *wdt_dev,
+			     unsigned long action, void *data)
+{
+	struct ice_wdt_dev *ice_wdt = watchdog_get_drvdata(wdt_dev);
+
+	writel(REGS_WRITE_UNLOCK, ice_wdt->wdt_base + WDT_LOCK);
+	writel(0, ice_wdt->wdt_base + WDT_EN);
+	writel(0, ice_wdt->wdt_base + WDT_RMOD);
+	writel(0, ice_wdt->wdt_base + WDT_OT_LOAD_H);
+	writel(0xff, ice_wdt->wdt_base + WDT_OT_LOAD_L);
+	writel(1, ice_wdt->wdt_base + WDT_EN);
+	writel(REGS_WRITE_LOCK, ice_wdt->wdt_base + WDT_LOCK);
+
+	while (1);
+
+	return 0;
+}
+
+static int ice_wdt_ping(struct watchdog_device *wdt_dev)
+{
+	struct ice_wdt_dev *ice_wdt = watchdog_get_drvdata(wdt_dev);
+
+	writel(REGS_WRITE_UNLOCK, ice_wdt->wdt_base + WDT_LOCK);
+	writel(TOUCH_WATCHDOG, ice_wdt->wdt_base + WDT_KNOCK);
+	writel(REGS_WRITE_LOCK, ice_wdt->wdt_base + WDT_LOCK);
+
+	return 0;
+}
+
+static int ice_wdt_set_timeout(struct watchdog_device *wdt_dev,
+				 unsigned int timeout)
+{
+	wdt_dev->timeout = timeout;
+
+	ice_wdt_change_timeout(wdt_dev, timeout);
+	ice_wdt_ping(wdt_dev);
+
+	return 0;
+}
+
+static int ice_wdt_stop(struct watchdog_device *wdt_dev)
+{
+	struct ice_wdt_dev *ice_wdt = watchdog_get_drvdata(wdt_dev);
+
+	writel(REGS_WRITE_UNLOCK, ice_wdt->wdt_base + WDT_LOCK);
+	writel(0, ice_wdt->wdt_base + WDT_EN);
+	writel(REGS_WRITE_LOCK, ice_wdt->wdt_base + WDT_LOCK);
+
+	return 0;
+}
+
+static int ice_wdt_start(struct watchdog_device *wdt_dev)
+{
+	struct ice_wdt_dev *ice_wdt = watchdog_get_drvdata(wdt_dev);
+
+	writel(REGS_WRITE_UNLOCK, ice_wdt->wdt_base + WDT_LOCK);
+	writel(1, ice_wdt->wdt_base + WDT_RMOD);
+	writel(1, ice_wdt->wdt_base + WDT_EN);
+	writel(REGS_WRITE_LOCK, ice_wdt->wdt_base + WDT_LOCK);
+
+	return 0;
+}
+
+static const struct watchdog_ops ice_wdt_ops = {
+	.owner		= THIS_MODULE,
+	.start		= ice_wdt_start,
+	.stop		= ice_wdt_stop,
+	.ping		= ice_wdt_ping,
+	.set_timeout	= ice_wdt_set_timeout,
+	.restart        = ice_wdt_restart,
+};
+
+static const struct of_device_id ice_wdt_dt_ids[] = {
+	{ .compatible = "ice,ice-wdt",},
+	{ }
+};
+
+static int ice_wdt_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct ice_wdt_dev *ice_wdt;
+	int err;
+
+	ice_wdt = devm_kzalloc(dev, sizeof(*ice_wdt), GFP_KERNEL);
+	if (!ice_wdt) {
+		return -ENOMEM;
+	}
+
+	ice_wdt->wdt_base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(ice_wdt->wdt_base)) {
+		return PTR_ERR(ice_wdt->wdt_base);
+	}
+
+	ice_wdt->wdt_dev.parent = dev;
+	ice_wdt->wdt_dev.info = &ice_wdt_info;
+	ice_wdt->wdt_dev.ops = &ice_wdt_ops;
+	ice_wdt->wdt_dev.timeout = ICE_WDT_TIMEOUT;
+	ice_wdt->wdt_dev.min_timeout = 2;
+
+	watchdog_set_drvdata(&ice_wdt->wdt_dev, ice_wdt);
+
+	watchdog_init_timeout(&ice_wdt->wdt_dev, timeout, dev);
+	watchdog_set_restart_priority(&ice_wdt->wdt_dev, 128);
+
+	ice_wdt_stop(&ice_wdt->wdt_dev);
+
+	err = devm_watchdog_register_device(dev, &ice_wdt->wdt_dev);
+	if (err)
+		return err;
+
+	dev_info(dev, "Watchdog enabled (timeout=%d sec)\n", ice_wdt->wdt_dev.timeout);
+
+	return 0;
+}
+
+static struct platform_driver ice_wdt_driver = {
+	.probe		= ice_wdt_probe,
+	.driver		= {
+		.name		= DRV_NAME,
+		.of_match_table	= ice_wdt_dt_ids,
+	},
+};
+
+module_platform_driver(ice_wdt_driver);
+
+module_param(timeout, uint, 0);
+MODULE_PARM_DESC(timeout, "Watchdog heartbeat in seconds");
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Ice Watchdog Timer Driver");
diff --git a/include/dt-bindings/clock/cv180x-clock.h b/include/dt-bindings/clock/cv180x-clock.h
new file mode 100644
index 000000000000..b96f59dd0858
--- /dev/null
+++ b/include/dt-bindings/clock/cv180x-clock.h
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2021. All rights reserved.
+ *
+ * File Name: cv180x-clock.h
+ * Description:
+ */
+
+#ifndef __DT_BINDINGS_CLK_CV180X_H__
+#define __DT_BINDINGS_CLK_CV180X_H__
+
+#define CV180X_CLK_MPLL				0
+#define CV180X_CLK_TPLL				1
+#define CV180X_CLK_FPLL				2
+#define CV180X_CLK_MIPIMPLL			3
+#define CV180X_CLK_A0PLL				4
+#define CV180X_CLK_DISPPLL			5
+#define CV180X_CLK_CAM0PLL			6
+#define CV180X_CLK_CAM1PLL			7
+
+#define CV180X_CLK_MIPIMPLL_D3			8
+#define CV180X_CLK_CAM0PLL_D2			9
+#define CV180X_CLK_CAM0PLL_D3			10
+
+#define CV180X_CLK_A53				11
+#define CV180X_CLK_CPU_AXI0			12
+#define CV180X_CLK_CPU_GIC			13
+#define CV180X_CLK_XTAL_A53			14
+#define CV180X_CLK_TPU				15
+#define CV180X_CLK_TPU_FAB			16
+#define CV180X_CLK_AHB_ROM			17
+#define CV180X_CLK_DDR_AXI_REG			18
+#define CV180X_CLK_RTC_25M			19
+#define CV180X_CLK_TEMPSEN			20
+#define CV180X_CLK_SARADC				21
+#define CV180X_CLK_EFUSE				22
+#define CV180X_CLK_APB_EFUSE			23
+#define CV180X_CLK_DEBUG				24
+#define CV180X_CLK_XTAL_MISC			25
+#define CV180X_CLK_AXI4_EMMC			26
+#define CV180X_CLK_EMMC				27
+#define CV180X_CLK_100K_EMMC			28
+#define CV180X_CLK_AXI4_SD0			29
+#define CV180X_CLK_SD0				30
+#define CV180X_CLK_100K_SD0			31
+#define CV180X_CLK_AXI4_SD1			32
+#define CV180X_CLK_SD1				33
+#define CV180X_CLK_100K_SD1			34
+#define CV180X_CLK_SPI_NAND			35
+#define CV180X_CLK_500M_ETH0			36
+#define CV180X_CLK_AXI4_ETH0			37
+#define CV180X_CLK_500M_ETH1			38
+#define CV180X_CLK_AXI4_ETH1			39
+#define CV180X_CLK_APB_GPIO			40
+#define CV180X_CLK_APB_GPIO_INTR			41
+#define CV180X_CLK_GPIO_DB			42
+#define CV180X_CLK_AHB_SF				43
+#define CV180X_CLK_SDMA_AXI			44
+#define CV180X_CLK_SDMA_AUD0			45
+#define CV180X_CLK_SDMA_AUD1			46
+#define CV180X_CLK_SDMA_AUD2			47
+#define CV180X_CLK_SDMA_AUD3			48
+#define CV180X_CLK_APB_I2C			49
+#define CV180X_CLK_APB_WDT			50
+#define CV180X_CLK_PWM				51
+#define CV180X_CLK_APB_SPI0			52
+#define CV180X_CLK_APB_SPI1			53
+#define CV180X_CLK_APB_SPI2			54
+#define CV180X_CLK_APB_SPI3			55
+#define CV180X_CLK_CAM0_200			56
+#define CV180X_CLK_UART0				57
+#define CV180X_CLK_APB_UART0			58
+#define CV180X_CLK_UART1				59
+#define CV180X_CLK_APB_UART1			60
+#define CV180X_CLK_UART2				61
+#define CV180X_CLK_APB_UART2			62
+#define CV180X_CLK_UART3				63
+#define CV180X_CLK_APB_UART3			64
+#define CV180X_CLK_UART4				65
+#define CV180X_CLK_APB_UART4			66
+#define CV180X_CLK_APB_I2S0			67
+#define CV180X_CLK_APB_I2S1			68
+#define CV180X_CLK_APB_I2S2			69
+#define CV180X_CLK_APB_I2S3			70
+#define CV180X_CLK_AXI4_USB			71
+#define CV180X_CLK_APB_USB			72
+#define CV180X_CLK_125M_USB			73
+#define CV180X_CLK_33K_USB			74
+#define CV180X_CLK_12M_USB			75
+#define CV180X_CLK_AXI4				76
+#define CV180X_CLK_AXI6				77
+#define CV180X_CLK_DSI_ESC			78
+#define CV180X_CLK_AXI_VIP			79
+#define CV180X_CLK_SRC_VIP_SYS_0			80
+#define CV180X_CLK_SRC_VIP_SYS_1			81
+#define CV180X_CLK_DISP_SRC_VIP			82
+#define CV180X_CLK_AXI_VIDEO_CODEC		83
+#define CV180X_CLK_VC_SRC0			84
+#define CV180X_CLK_H264C				85
+#define CV180X_CLK_H265C				86
+#define CV180X_CLK_JPEG				87
+#define CV180X_CLK_APB_JPEG			88
+#define CV180X_CLK_APB_H264C			89
+#define CV180X_CLK_APB_H265C			90
+#define CV180X_CLK_CAM0				91
+#define CV180X_CLK_CAM1				92
+#define CV180X_CLK_CSI_MAC0_VIP			93
+#define CV180X_CLK_CSI_MAC1_VIP			94
+#define CV180X_CLK_ISP_TOP_VIP			95
+#define CV180X_CLK_IMG_D_VIP			96
+#define CV180X_CLK_IMG_V_VIP			97
+#define CV180X_CLK_SC_TOP_VIP			98
+#define CV180X_CLK_SC_D_VIP			99
+#define CV180X_CLK_SC_V1_VIP			100
+#define CV180X_CLK_SC_V2_VIP			101
+#define CV180X_CLK_SC_V3_VIP			102
+#define CV180X_CLK_DWA_VIP			103
+#define CV180X_CLK_BT_VIP				104
+#define CV180X_CLK_DISP_VIP			105
+#define CV180X_CLK_DSI_MAC_VIP			106
+#define CV180X_CLK_LVDS0_VIP			107
+#define CV180X_CLK_LVDS1_VIP			108
+#define CV180X_CLK_CSI0_RX_VIP			109
+#define CV180X_CLK_CSI1_RX_VIP			110
+#define CV180X_CLK_PAD_VI_VIP			111
+#define CV180X_CLK_1M				112
+#define CV180X_CLK_SPI				113
+#define CV180X_CLK_I2C				114
+#define CV180X_CLK_PM				115
+#define CV180X_CLK_TIMER0				116
+#define CV180X_CLK_TIMER1				117
+#define CV180X_CLK_TIMER2				118
+#define CV180X_CLK_TIMER3				119
+#define CV180X_CLK_TIMER4				120
+#define CV180X_CLK_TIMER5				121
+#define CV180X_CLK_TIMER6				122
+#define CV180X_CLK_TIMER7				123
+#define CV180X_CLK_APB_I2C0			124
+#define CV180X_CLK_APB_I2C1			125
+#define CV180X_CLK_APB_I2C2			126
+#define CV180X_CLK_APB_I2C3			127
+#define CV180X_CLK_APB_I2C4			128
+#define CV180X_CLK_WGN				129
+#define CV180X_CLK_WGN0				130
+#define CV180X_CLK_WGN1				131
+#define CV180X_CLK_WGN2				132
+#define CV180X_CLK_KEYSCAN			133
+#define CV180X_CLK_AHB_SF1			134
+#define CV180X_CLK_VC_SRC1			135
+#define CV180X_CLK_SRC_VIP_SYS_2			136
+#define CV180X_CLK_PAD_VI1_VIP			137
+#define CV180X_CLK_CFG_REG_VIP			138
+#define CV180X_CLK_CFG_REG_VC			139
+#define CV180X_CLK_AUDSRC				140
+#define CV180X_CLK_APB_AUDSRC			141
+#define CV180X_CLK_VC_SRC2			142
+#define CV180X_CLK_PWM_SRC			143
+#define CV180X_CLK_AP_DEBUG			144
+#define CV180X_CLK_SRC_RTC_SYS_0			145
+#define CV180X_CLK_PAD_VI2_VIP			146
+#define CV180X_CLK_CSI_BE_VIP			147
+#define CV180X_CLK_VIP_IP0			148
+#define CV180X_CLK_VIP_IP1			149
+#define CV180X_CLK_VIP_IP2			150
+#define CV180X_CLK_VIP_IP3			151
+#define CV180X_CLK_C906_0				152
+#define CV180X_CLK_C906_1				153
+#define CV180X_CLK_SRC_VIP_SYS_3			154
+#define CV180X_CLK_SRC_VIP_SYS_4			155
+#define CV180X_CLK_IVE_VIP			156
+#define CV180X_CLK_RAW_VIP			157
+#define CV180X_CLK_OSDC_VIP			158
+#define CV180X_CLK_CSI_MAC2_VIP			159
+#define CV180X_CLK_CAM0_VIP			160
+
+#endif /* __DT_BINDINGS_CLK_CV180X_H__ */
diff --git a/include/dt-bindings/clock/cv181x-clock.h b/include/dt-bindings/clock/cv181x-clock.h
new file mode 100644
index 000000000000..ed76e4d8ef95
--- /dev/null
+++ b/include/dt-bindings/clock/cv181x-clock.h
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2021. All rights reserved.
+ *
+ * File Name: cv181x-clock.h
+ * Description:
+ */
+
+#ifndef __DT_BINDINGS_CLK_CV181X_H__
+#define __DT_BINDINGS_CLK_CV181X_H__
+
+#define CV181X_CLK_MPLL				0
+#define CV181X_CLK_TPLL				1
+#define CV181X_CLK_FPLL				2
+#define CV181X_CLK_MIPIMPLL			3
+#define CV181X_CLK_A0PLL				4
+#define CV181X_CLK_DISPPLL			5
+#define CV181X_CLK_CAM0PLL			6
+#define CV181X_CLK_CAM1PLL			7
+
+#define CV181X_CLK_MIPIMPLL_D3			8
+#define CV181X_CLK_CAM0PLL_D2			9
+#define CV181X_CLK_CAM0PLL_D3			10
+
+#define CV181X_CLK_A53				11
+#define CV181X_CLK_CPU_AXI0			12
+#define CV181X_CLK_CPU_GIC			13
+#define CV181X_CLK_XTAL_A53			14
+#define CV181X_CLK_TPU				15
+#define CV181X_CLK_TPU_FAB			16
+#define CV181X_CLK_AHB_ROM			17
+#define CV181X_CLK_DDR_AXI_REG			18
+#define CV181X_CLK_RTC_25M			19
+#define CV181X_CLK_TEMPSEN			20
+#define CV181X_CLK_SARADC				21
+#define CV181X_CLK_EFUSE				22
+#define CV181X_CLK_APB_EFUSE			23
+#define CV181X_CLK_DEBUG				24
+#define CV181X_CLK_XTAL_MISC			25
+#define CV181X_CLK_AXI4_EMMC			26
+#define CV181X_CLK_EMMC				27
+#define CV181X_CLK_100K_EMMC			28
+#define CV181X_CLK_AXI4_SD0			29
+#define CV181X_CLK_SD0				30
+#define CV181X_CLK_100K_SD0			31
+#define CV181X_CLK_AXI4_SD1			32
+#define CV181X_CLK_SD1				33
+#define CV181X_CLK_100K_SD1			34
+#define CV181X_CLK_SPI_NAND			35
+#define CV181X_CLK_500M_ETH0			36
+#define CV181X_CLK_AXI4_ETH0			37
+#define CV181X_CLK_500M_ETH1			38
+#define CV181X_CLK_AXI4_ETH1			39
+#define CV181X_CLK_APB_GPIO			40
+#define CV181X_CLK_APB_GPIO_INTR			41
+#define CV181X_CLK_GPIO_DB			42
+#define CV181X_CLK_AHB_SF				43
+#define CV181X_CLK_SDMA_AXI			44
+#define CV181X_CLK_SDMA_AUD0			45
+#define CV181X_CLK_SDMA_AUD1			46
+#define CV181X_CLK_SDMA_AUD2			47
+#define CV181X_CLK_SDMA_AUD3			48
+#define CV181X_CLK_APB_I2C			49
+#define CV181X_CLK_APB_WDT			50
+#define CV181X_CLK_PWM				51
+#define CV181X_CLK_APB_SPI0			52
+#define CV181X_CLK_APB_SPI1			53
+#define CV181X_CLK_APB_SPI2			54
+#define CV181X_CLK_APB_SPI3			55
+#define CV181X_CLK_CAM0_200			56
+#define CV181X_CLK_UART0				57
+#define CV181X_CLK_APB_UART0			58
+#define CV181X_CLK_UART1				59
+#define CV181X_CLK_APB_UART1			60
+#define CV181X_CLK_UART2				61
+#define CV181X_CLK_APB_UART2			62
+#define CV181X_CLK_UART3				63
+#define CV181X_CLK_APB_UART3			64
+#define CV181X_CLK_UART4				65
+#define CV181X_CLK_APB_UART4			66
+#define CV181X_CLK_APB_I2S0			67
+#define CV181X_CLK_APB_I2S1			68
+#define CV181X_CLK_APB_I2S2			69
+#define CV181X_CLK_APB_I2S3			70
+#define CV181X_CLK_AXI4_USB			71
+#define CV181X_CLK_APB_USB			72
+#define CV181X_CLK_125M_USB			73
+#define CV181X_CLK_33K_USB			74
+#define CV181X_CLK_12M_USB			75
+#define CV181X_CLK_AXI4				76
+#define CV181X_CLK_AXI6				77
+#define CV181X_CLK_DSI_ESC			78
+#define CV181X_CLK_AXI_VIP			79
+#define CV181X_CLK_SRC_VIP_SYS_0			80
+#define CV181X_CLK_SRC_VIP_SYS_1			81
+#define CV181X_CLK_DISP_SRC_VIP			82
+#define CV181X_CLK_AXI_VIDEO_CODEC		83
+#define CV181X_CLK_VC_SRC0			84
+#define CV181X_CLK_H264C				85
+#define CV181X_CLK_H265C				86
+#define CV181X_CLK_JPEG				87
+#define CV181X_CLK_APB_JPEG			88
+#define CV181X_CLK_APB_H264C			89
+#define CV181X_CLK_APB_H265C			90
+#define CV181X_CLK_CAM0				91
+#define CV181X_CLK_CAM1				92
+#define CV181X_CLK_CSI_MAC0_VIP			93
+#define CV181X_CLK_CSI_MAC1_VIP			94
+#define CV181X_CLK_ISP_TOP_VIP			95
+#define CV181X_CLK_IMG_D_VIP			96
+#define CV181X_CLK_IMG_V_VIP			97
+#define CV181X_CLK_SC_TOP_VIP			98
+#define CV181X_CLK_SC_D_VIP			99
+#define CV181X_CLK_SC_V1_VIP			100
+#define CV181X_CLK_SC_V2_VIP			101
+#define CV181X_CLK_SC_V3_VIP			102
+#define CV181X_CLK_DWA_VIP			103
+#define CV181X_CLK_BT_VIP				104
+#define CV181X_CLK_DISP_VIP			105
+#define CV181X_CLK_DSI_MAC_VIP			106
+#define CV181X_CLK_LVDS0_VIP			107
+#define CV181X_CLK_LVDS1_VIP			108
+#define CV181X_CLK_CSI0_RX_VIP			109
+#define CV181X_CLK_CSI1_RX_VIP			110
+#define CV181X_CLK_PAD_VI_VIP			111
+#define CV181X_CLK_1M				112
+#define CV181X_CLK_SPI				113
+#define CV181X_CLK_I2C				114
+#define CV181X_CLK_PM				115
+#define CV181X_CLK_TIMER0				116
+#define CV181X_CLK_TIMER1				117
+#define CV181X_CLK_TIMER2				118
+#define CV181X_CLK_TIMER3				119
+#define CV181X_CLK_TIMER4				120
+#define CV181X_CLK_TIMER5				121
+#define CV181X_CLK_TIMER6				122
+#define CV181X_CLK_TIMER7				123
+#define CV181X_CLK_APB_I2C0			124
+#define CV181X_CLK_APB_I2C1			125
+#define CV181X_CLK_APB_I2C2			126
+#define CV181X_CLK_APB_I2C3			127
+#define CV181X_CLK_APB_I2C4			128
+#define CV181X_CLK_WGN				129
+#define CV181X_CLK_WGN0				130
+#define CV181X_CLK_WGN1				131
+#define CV181X_CLK_WGN2				132
+#define CV181X_CLK_KEYSCAN			133
+#define CV181X_CLK_AHB_SF1			134
+#define CV181X_CLK_VC_SRC1			135
+#define CV181X_CLK_SRC_VIP_SYS_2			136
+#define CV181X_CLK_PAD_VI1_VIP			137
+#define CV181X_CLK_CFG_REG_VIP			138
+#define CV181X_CLK_CFG_REG_VC			139
+#define CV181X_CLK_AUDSRC				140
+#define CV181X_CLK_APB_AUDSRC			141
+#define CV181X_CLK_VC_SRC2			142
+#define CV181X_CLK_PWM_SRC			143
+#define CV181X_CLK_AP_DEBUG			144
+#define CV181X_CLK_SRC_RTC_SYS_0			145
+#define CV181X_CLK_PAD_VI2_VIP			146
+#define CV181X_CLK_CSI_BE_VIP			147
+#define CV181X_CLK_VIP_IP0			148
+#define CV181X_CLK_VIP_IP1			149
+#define CV181X_CLK_VIP_IP2			150
+#define CV181X_CLK_VIP_IP3			151
+#define CV181X_CLK_C906_0				152
+#define CV181X_CLK_C906_1				153
+#define CV181X_CLK_SRC_VIP_SYS_3			154
+#define CV181X_CLK_SRC_VIP_SYS_4			155
+#define CV181X_CLK_IVE_VIP			156
+#define CV181X_CLK_RAW_VIP			157
+#define CV181X_CLK_OSDC_VIP			158
+#define CV181X_CLK_CSI_MAC2_VIP			159
+#define CV181X_CLK_CAM0_VIP			160
+
+#endif /* __DT_BINDINGS_CLK_CV181X_H__ */
diff --git a/include/dt-bindings/clock/cv182x-clock.h b/include/dt-bindings/clock/cv182x-clock.h
new file mode 100644
index 000000000000..71ee4bf18936
--- /dev/null
+++ b/include/dt-bindings/clock/cv182x-clock.h
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ * File Name: cv182x-clock.h
+ * Description:
+ */
+
+#ifndef __DT_BINDINGS_CLK_CV182X_H__
+#define __DT_BINDINGS_CLK_CV182X_H__
+
+#define CV182X_CLK_MPLL				0
+#define CV182X_CLK_TPLL				1
+#define CV182X_CLK_FPLL				2
+#define CV182X_CLK_MIPIMPLL			3
+#define CV182X_CLK_A0PLL			4
+#define CV182X_CLK_DISPPLL			5
+#define CV182X_CLK_CAM0PLL			6
+#define CV182X_CLK_CAM1PLL			7
+#define CV182X_CLK_XTAL_A53			8
+
+#define CV182X_CLK_AHB_ROM			9
+#define CV182X_CLK_DDR_AXI_REG			10
+#define CV182X_CLK_RTC_25M			11
+#define CV182X_CLK_TEMPSEN			12
+#define CV182X_CLK_SARADC			13
+#define CV182X_CLK_EFUSE			14
+#define CV182X_CLK_APB_EFUSE			15
+#define CV182X_CLK_XTAL_MISC			16
+#define CV182X_CLK_AXI4_EMMC			17
+#define CV182X_CLK_AXI4_SD0			18
+#define CV182X_CLK_AXI4_SD1			19
+#define CV182X_CLK_AXI4_ETH0			20
+#define CV182X_CLK_AXI4_ETH1			21
+#define CV182X_CLK_APB_GPIO			22
+#define CV182X_CLK_APB_GPIO_INTR		23
+#define CV182X_CLK_AHB_SF			24
+#define CV182X_CLK_SDMA_AXI			25
+#define CV182X_CLK_APB_I2C			26
+#define CV182X_CLK_APB_WDT			27
+#define CV182X_CLK_APB_SPI0			28
+#define CV182X_CLK_APB_SPI1			29
+#define CV182X_CLK_APB_SPI2			30
+#define CV182X_CLK_APB_SPI3			31
+#define CV182X_CLK_187P5M			32
+#define CV182X_CLK_APB_UART0			33
+#define CV182X_CLK_APB_UART1			34
+#define CV182X_CLK_APB_UART2			35
+#define CV182X_CLK_APB_UART3			36
+#define CV182X_CLK_APB_UART4			37
+#define CV182X_CLK_APB_I2S0			38
+#define CV182X_CLK_APB_I2S1			39
+#define CV182X_CLK_APB_I2S2			40
+#define CV182X_CLK_APB_I2S3			41
+#define CV182X_CLK_AXI4_USB			42
+#define CV182X_CLK_APB_USB			43
+#define CV182X_CLK_AXI4				44
+#define CV182X_CLK_AXI6				45
+#define CV182X_CLK_H264C			46
+#define CV182X_CLK_H265C			47
+#define CV182X_CLK_JPEG				48
+#define CV182X_CLK_APB_JPEG			49
+#define CV182X_CLK_APB_H264C			50
+#define CV182X_CLK_APB_H265C			51
+#define CV182X_CLK_CSI_MAC0_VIP			52
+#define CV182X_CLK_CSI_MAC1_VIP			53
+#define CV182X_CLK_ISP_TOP_VIP			54
+#define CV182X_CLK_IMG_D_VIP			55
+#define CV182X_CLK_IMG_V_VIP			56
+#define CV182X_CLK_SC_TOP_VIP			57
+#define CV182X_CLK_SC_D_VIP			58
+#define CV182X_CLK_SC_V1_VIP			59
+#define CV182X_CLK_SC_V2_VIP			60
+#define CV182X_CLK_SC_V3_VIP			61
+#define CV182X_CLK_LDC_VIP			62
+#define CV182X_CLK_BT_VIP			63
+#define CV182X_CLK_DISP_VIP			64
+#define CV182X_CLK_DSI_MAC_VIP			65
+#define CV182X_CLK_LVDS0_VIP			66
+#define CV182X_CLK_LVDS1_VIP			67
+#define CV182X_CLK_CSI0_RX_VIP			68
+#define CV182X_CLK_CSI1_RX_VIP			69
+#define CV182X_CLK_PAD_VI_VIP			70
+#define CV182X_CLK_1M				71
+#define CV182X_CLK_PM				72
+#define CV182X_CLK_TIMER0			73
+#define CV182X_CLK_TIMER1			74
+#define CV182X_CLK_TIMER2			75
+#define CV182X_CLK_TIMER3			76
+#define CV182X_CLK_TIMER4			77
+#define CV182X_CLK_TIMER5			78
+#define CV182X_CLK_TIMER6			79
+#define CV182X_CLK_TIMER7			80
+#define CV182X_CLK_APB_I2C0			81
+#define CV182X_CLK_APB_I2C1			82
+#define CV182X_CLK_APB_I2C2			83
+#define CV182X_CLK_APB_I2C3			84
+#define CV182X_CLK_APB_I2C4			85
+#define CV182X_CLK_WGN				86
+#define CV182X_CLK_WGN0				87
+#define CV182X_CLK_WGN1				88
+#define CV182X_CLK_WGN2				89
+#define CV182X_CLK_KEYSCAN			90
+#define CV182X_CLK_AHB_SF1			91
+#define CV182X_CLK_PAD_VI1_VIP			92
+#define CV182X_CLK_CFG_REG_VIP			93
+#define CV182X_CLK_CFG_REG_VC			94
+#define CV182X_CLK_APB_AUDSRC			95
+#define CV182X_CLK_PWM_SRC			96
+
+#define CV182X_CLK_MUX_AXI6			97
+#define CV182X_CLK_MUX_PWM_SRC			98
+
+#define CV182X_CLK_DIV_0_A53			99
+#define CV182X_CLK_DIV_1_A53			100
+#define CV182X_CLK_DIV_0_CPU_AXI0		101
+#define CV182X_CLK_DIV_1_CPU_AXI0		102
+#define CV182X_CLK_DIV_0_TPU			103
+#define CV182X_CLK_DIV_1_TPU			104
+#define CV182X_CLK_DIV_0_TPU_FAB		105
+#define CV182X_CLK_DIV_1_TPU_FAB		106
+#define CV182X_CLK_DIV_0_EMMC			107
+#define CV182X_CLK_DIV_1_EMMC			108
+#define CV182X_CLK_DIV_0_SD0			109
+#define CV182X_CLK_DIV_1_SD0			110
+#define CV182X_CLK_DIV_0_SD1			111
+#define CV182X_CLK_DIV_1_SD1			112
+#define CV182X_CLK_DIV_AXI4			113
+#define CV182X_CLK_DIV_0_AXI6			114
+#define CV182X_CLK_DIV_1_AXI6			115
+#define CV182X_CLK_DIV_0_AXI_VIP		116
+#define CV182X_CLK_DIV_1_AXI_VIP		117
+#define CV182X_CLK_DIV_0_SRC_VIP_SYS_0		118
+#define CV182X_CLK_DIV_1_SRC_VIP_SYS_0		119
+#define CV182X_CLK_DIV_0_SRC_VIP_SYS_1		120
+#define CV182X_CLK_DIV_1_SRC_VIP_SYS_1		121
+#define CV182X_CLK_DIV_0_AXI_VIDEO_CODEC	122
+#define CV182X_CLK_DIV_1_AXI_VIDEO_CODEC	123
+#define CV182X_CLK_DIV_0_VC_SRC0		124
+#define CV182X_CLK_DIV_1_VC_SRC0		125
+#define CV182X_CLK_DIV_1M			126
+#define CV182X_CLK_DIV_0_VC_SRC1		127
+#define CV182X_CLK_DIV_1_VC_SRC1		128
+#define CV182X_CLK_DIV_0_SRC_VIP_SYS_2		129
+#define CV182X_CLK_DIV_1_SRC_VIP_SYS_2		130
+#define CV182X_CLK_DIV_0_PWM_SRC		131
+#define CV182X_CLK_DIV_1_PWM_SRC		132
+#define CV182X_CLK_DIV_187P5M			133
+
+#define CV182X_CLK_A53				134
+#define CV182X_CLK_CPU_AXI0			135
+#define CV182X_CLK_TPU				136
+#define CV182X_CLK_TPU_FAB			137
+#define CV182X_CLK_DEBUG			138
+#define CV182X_CLK_EMMC				139
+#define CV182X_CLK_SD0				140
+#define CV182X_CLK_SD1				141
+#define CV182X_CLK_APB_PWM			142
+#define CV182X_CLK_UART0			143
+#define CV182X_CLK_UART1			144
+#define CV182X_CLK_UART2			145
+#define CV182X_CLK_UART3			146
+#define CV182X_CLK_UART4			147
+#define CV182X_CLK_AXI_VIP			148
+#define CV182X_CLK_SRC_VIP_SYS_0		149
+#define CV182X_CLK_SRC_VIP_SYS_1		150
+#define CV182X_CLK_AXI_VIDEO_CODEC		151
+#define CV182X_CLK_VC_SRC0			152
+#define CV182X_CLK_VC_SRC1			153
+#define CV182X_CLK_SRC_VIP_SYS_2		154
+#define CV182X_CLK_CPU_GIC			155
+#define CV182X_CLK_100K_EMMC			156
+#define CV182X_CLK_100K_SD0			157
+#define CV182X_CLK_100K_SD1			158
+#define CV182X_CLK_SPI_NAND			159
+#define CV182X_CLK_500M_ETH0			160
+#define CV182X_CLK_500M_ETH1			161
+#define CV182X_CLK_GPIO_DB			162
+#define CV182X_CLK_SDMA_AUD0			163
+#define CV182X_CLK_SDMA_AUD1			164
+#define CV182X_CLK_SDMA_AUD2			165
+#define CV182X_CLK_SDMA_AUD3			166
+#define CV182X_CLK_125M_USB			167
+#define CV182X_CLK_33K_USB			168
+#define CV182X_CLK_12M_USB			169
+#define CV182X_CLK_DSI_ESC			170
+#define CV182X_CLK_DISP_SRC_VIP			171
+#define CV182X_CLK_CAM0				172
+#define CV182X_CLK_CAM1				173
+#define CV182X_CLK_SPI				174
+#define CV182X_CLK_I2C				175
+#define CV182X_CLK_AUDSRC			176
+#define CV182X_CLK_VC_SRC2			177
+
+#define CV182x_CLK_AP_DEBUG			178
+#define CV182x_CLK_SRC_RTC_SYS_0		179
+#define CV182x_CLK_PAD_VI2_VIP			180
+#define CV182X_CLK_CSI_BE_VIP			181
+
+#define CV182X_CLK_MUX_AXI_VIDEO_CODEC		182
+
+#endif /* __DT_BINDINGS_CLK_CV182X_H__ */
diff --git a/include/dt-bindings/clock/cv1835-clock.h b/include/dt-bindings/clock/cv1835-clock.h
new file mode 100644
index 000000000000..ec818ade4523
--- /dev/null
+++ b/include/dt-bindings/clock/cv1835-clock.h
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ * File Name: cv1835-clock.h
+ * Description:
+ */
+
+#ifndef __DT_BINDINGS_CLK_CV1835_H__
+#define __DT_BINDINGS_CLK_CV1835_H__
+
+#define CV1835_CLK_MPLL				0
+#define CV1835_CLK_TPLL				1
+#define CV1835_CLK_FPLL				2
+#define CV1835_CLK_MIPIMPLL			3
+#define CV1835_CLK_A0PLL			4
+#define CV1835_CLK_DISPPLL			5
+#define CV1835_CLK_CAM0PLL			6
+#define CV1835_CLK_CAM1PLL			7
+#define CV1835_CLK_XTAL_A53			8
+
+#define CV1835_CLK_AHB_ROM			9
+#define CV1835_CLK_DDR_AXI_REG			10
+#define CV1835_CLK_RTC_25M			11
+#define CV1835_CLK_TEMPSEN			12
+#define CV1835_CLK_SARADC			13
+#define CV1835_CLK_EFUSE			14
+#define CV1835_CLK_APB_EFUSE			15
+#define CV1835_CLK_XTAL_MISC			16
+#define CV1835_CLK_AXI4_EMMC			17
+#define CV1835_CLK_AXI4_SD0			18
+#define CV1835_CLK_AXI4_SD1			19
+#define CV1835_CLK_AXI4_ETH0			20
+#define CV1835_CLK_AXI4_ETH1			21
+#define CV1835_CLK_APB_GPIO			22
+#define CV1835_CLK_APB_GPIO_INTR		23
+#define CV1835_CLK_AHB_SF			24
+#define CV1835_CLK_SDMA_AXI			25
+#define CV1835_CLK_APB_I2C			26
+#define CV1835_CLK_APB_WDT			27
+#define CV1835_CLK_APB_SPI0			28
+#define CV1835_CLK_APB_SPI1			29
+#define CV1835_CLK_APB_SPI2			30
+#define CV1835_CLK_APB_SPI3			31
+#define CV1835_CLK_187P5M			32
+#define CV1835_CLK_APB_UART0			33
+#define CV1835_CLK_APB_UART1			34
+#define CV1835_CLK_APB_UART2			35
+#define CV1835_CLK_APB_UART3			36
+#define CV1835_CLK_APB_UART4			37
+#define CV1835_CLK_APB_I2S0			38
+#define CV1835_CLK_APB_I2S1			39
+#define CV1835_CLK_APB_I2S2			40
+#define CV1835_CLK_APB_I2S3			41
+#define CV1835_CLK_AXI4_USB			42
+#define CV1835_CLK_APB_USB			43
+#define CV1835_CLK_AXI4				44
+#define CV1835_CLK_AXI6				45
+#define CV1835_CLK_H264C			46
+#define CV1835_CLK_H265C			47
+#define CV1835_CLK_JPEG				48
+#define CV1835_CLK_APB_JPEG			49
+#define CV1835_CLK_APB_H264C			50
+#define CV1835_CLK_APB_H265C			51
+#define CV1835_CLK_CSI_MAC0_VIP			52
+#define CV1835_CLK_CSI_MAC1_VIP			53
+#define CV1835_CLK_ISP_TOP_VIP			54
+#define CV1835_CLK_IMG_D_VIP			55
+#define CV1835_CLK_IMG_V_VIP			56
+#define CV1835_CLK_SC_TOP_VIP			57
+#define CV1835_CLK_SC_D_VIP			58
+#define CV1835_CLK_SC_V1_VIP			59
+#define CV1835_CLK_SC_V2_VIP			60
+#define CV1835_CLK_SC_V3_VIP			61
+#define CV1835_CLK_DWA_VIP			62
+#define CV1835_CLK_BT_VIP			63
+#define CV1835_CLK_DISP_VIP			64
+#define CV1835_CLK_DSI_MAC_VIP			65
+#define CV1835_CLK_LVDS0_VIP			66
+#define CV1835_CLK_LVDS1_VIP			67
+#define CV1835_CLK_CSI0_RX_VIP			68
+#define CV1835_CLK_CSI1_RX_VIP			69
+#define CV1835_CLK_PAD_VI_VIP			70
+#define CV1835_CLK_1M				71
+#define CV1835_CLK_PM				72
+#define CV1835_CLK_TIMER0			73
+#define CV1835_CLK_TIMER1			74
+#define CV1835_CLK_TIMER2			75
+#define CV1835_CLK_TIMER3			76
+#define CV1835_CLK_TIMER4			77
+#define CV1835_CLK_TIMER5			78
+#define CV1835_CLK_TIMER6			79
+#define CV1835_CLK_TIMER7			80
+#define CV1835_CLK_APB_I2C0			81
+#define CV1835_CLK_APB_I2C1			82
+#define CV1835_CLK_APB_I2C2			83
+#define CV1835_CLK_APB_I2C3			84
+#define CV1835_CLK_APB_I2C4			85
+#define CV1835_CLK_WGN				86
+#define CV1835_CLK_WGN0				87
+#define CV1835_CLK_WGN1				88
+#define CV1835_CLK_WGN2				89
+#define CV1835_CLK_KEYSCAN			90
+#define CV1835_CLK_AHB_SF1			91
+#define CV1835_CLK_PAD_VI1_VIP			92
+#define CV1835_CLK_CFG_REG_VIP			93
+#define CV1835_CLK_CFG_REG_VC			94
+#define CV1835_CLK_APB_AUDSRC			95
+#define CV1835_CLK_PWM_SRC			96
+
+#define CV1835_CLK_MUX_AXI6			97
+#define CV1835_CLK_MUX_PWM_SRC			98
+
+#define CV1835_CLK_DIV_0_A53			99
+#define CV1835_CLK_DIV_1_A53			100
+#define CV1835_CLK_DIV_0_CPU_AXI0		101
+#define CV1835_CLK_DIV_1_CPU_AXI0		102
+#define CV1835_CLK_DIV_0_TPU_AXI		103
+#define CV1835_CLK_DIV_1_TPU_AXI		104
+#define CV1835_CLK_DIV_0_TPU_FAB		105
+#define CV1835_CLK_DIV_1_TPU_FAB		106
+#define CV1835_CLK_DIV_0_EMMC			107
+#define CV1835_CLK_DIV_1_EMMC			108
+#define CV1835_CLK_DIV_0_SD0			109
+#define CV1835_CLK_DIV_1_SD0			110
+#define CV1835_CLK_DIV_0_SD1			111
+#define CV1835_CLK_DIV_1_SD1			112
+#define CV1835_CLK_DIV_AXI4			113
+#define CV1835_CLK_DIV_0_AXI6			114
+#define CV1835_CLK_DIV_1_AXI6			115
+#define CV1835_CLK_DIV_0_AXI_VIP		116
+#define CV1835_CLK_DIV_1_AXI_VIP		117
+#define CV1835_CLK_DIV_0_SRC_VIP_SYS_0		118
+#define CV1835_CLK_DIV_1_SRC_VIP_SYS_0		119
+#define CV1835_CLK_DIV_0_SRC_VIP_SYS_1		120
+#define CV1835_CLK_DIV_1_SRC_VIP_SYS_1		121
+#define CV1835_CLK_DIV_0_AXI_VIDEO_CODEC	122
+#define CV1835_CLK_DIV_1_AXI_VIDEO_CODEC	123
+#define CV1835_CLK_DIV_0_VC_SRC0		124
+#define CV1835_CLK_DIV_1_VC_SRC0		125
+#define CV1835_CLK_DIV_1M			126
+#define CV1835_CLK_DIV_0_VC_SRC1		127
+#define CV1835_CLK_DIV_1_VC_SRC1		128
+#define CV1835_CLK_DIV_0_SRC_VIP_SYS_2		129
+#define CV1835_CLK_DIV_1_SRC_VIP_SYS_2		130
+#define CV1835_CLK_DIV_0_PWM_SRC		131
+#define CV1835_CLK_DIV_1_PWM_SRC		132
+#define CV1835_CLK_DIV_187P5M			133
+
+#define CV1835_CLK_A53				134
+#define CV1835_CLK_CPU_AXI0			135
+#define CV1835_CLK_TPU_AXI			136
+#define CV1835_CLK_TPU_FAB			137
+#define CV1835_CLK_DEBUG			138
+#define CV1835_CLK_EMMC				139
+#define CV1835_CLK_SD0				140
+#define CV1835_CLK_SD1				141
+#define CV1835_CLK_APB_PWM			142
+#define CV1835_CLK_UART0			143
+#define CV1835_CLK_UART1			144
+#define CV1835_CLK_UART2			145
+#define CV1835_CLK_UART3			146
+#define CV1835_CLK_UART4			147
+#define CV1835_CLK_AXI_VIP			148
+#define CV1835_CLK_SRC_VIP_SYS_0		149
+#define CV1835_CLK_SRC_VIP_SYS_1		150
+#define CV1835_CLK_AXI_VIDEO_CODEC		151
+#define CV1835_CLK_VC_SRC0			152
+#define CV1835_CLK_VC_SRC1			153
+#define CV1835_CLK_SRC_VIP_SYS_2		154
+#define CV1835_CLK_CPU_GIC			155
+#define CV1835_CLK_100K_EMMC			156
+#define CV1835_CLK_100K_SD0			157
+#define CV1835_CLK_100K_SD1			158
+#define CV1835_CLK_SPI_NAND			159
+#define CV1835_CLK_500M_ETH0			160
+#define CV1835_CLK_500M_ETH1			161
+#define CV1835_CLK_GPIO_DB			162
+#define CV1835_CLK_SDMA_AUD0			163
+#define CV1835_CLK_SDMA_AUD1			164
+#define CV1835_CLK_SDMA_AUD2			165
+#define CV1835_CLK_SDMA_AUD3			166
+#define CV1835_CLK_125M_USB			167
+#define CV1835_CLK_33K_USB			168
+#define CV1835_CLK_12M_USB			169
+#define CV1835_CLK_DSI_ESC			170
+#define CV1835_CLK_DISP_SRC_VIP			171
+#define CV1835_CLK_CAM0				172
+#define CV1835_CLK_CAM1				173
+#define CV1835_CLK_SPI				174
+#define CV1835_CLK_I2C				175
+#define CV1835_CLK_AUDSRC			176
+#define CV1835_CLK_VC_SRC2			177
+
+#define CV1835_CLK_MUX_AXI_VIDEO_CODEC_1	178
+#define CV1835_CLK_MUX_AXI_VIDEO_CODEC		179
+
+#endif /* __DT_BINDINGS_CLK_CV1835_H__ */
diff --git a/include/dt-bindings/dma/cv180x-dmamap.h b/include/dt-bindings/dma/cv180x-dmamap.h
new file mode 100644
index 000000000000..6cbabe1fd219
--- /dev/null
+++ b/include/dt-bindings/dma/cv180x-dmamap.h
@@ -0,0 +1,48 @@
+#ifndef __DT_BINDINGS_CV180X_DMAMAP_H__
+#define __DT_BINDINGS_CV180X_DMAMAP_H__
+
+#define CVI_I2S0_RX     0
+#define CVI_I2S0_TX     1
+#define CVI_I2S1_RX     2
+#define CVI_I2S1_TX     3
+#define CVI_I2S2_RX     4
+#define CVI_I2S2_TX     5
+#define CVI_I2S3_RX     6
+#define CVI_I2S3_TX     7
+#define CVI_UART0_RX    8
+#define CVI_UART0_TX    9
+#define CVI_UART1_RX    10
+#define CVI_UART1_TX    11
+#define CVI_UART2_RX    12
+#define CVI_UART2_TX    13
+#define CVI_UART3_RX    14
+#define CVI_UART3_TX    15
+#define CVI_SPI0_RX     16
+#define CVI_SPI0_TX     17
+#define CVI_SPI1_RX     18
+#define CVI_SPI1_TX     19
+#define CVI_SPI2_RX     20
+#define CVI_SPI2_TX     21
+#define CVI_SPI3_RX     22
+#define CVI_SPI3_TX     23
+#define CVI_I2C0_RX     24
+#define CVI_I2C0_TX     25
+#define CVI_I2C1_RX     26
+#define CVI_I2C1_TX     27
+#define CVI_I2C2_RX     28
+#define CVI_I2C2_TX     29
+#define CVI_I2C3_RX     30
+#define CVI_I2C3_TX     31
+#define CVI_I2C4_RX     32
+#define CVI_I2C4_TX     33
+#define CVI_TDM0_RX     34
+#define CVI_TDM0_TX     35
+#define CVI_TDM1_RX     36
+#define CVI_AUDSRC      37
+#define CVI_SPI_NAND    38
+#define CVI_SPI_NOR     39
+#define CVI_UART4_RX    40
+#define CVI_UART4_TX    41
+#define CVI_SPI_NOR1    42
+
+#endif
diff --git a/include/dt-bindings/dma/cv181x-dmamap.h b/include/dt-bindings/dma/cv181x-dmamap.h
new file mode 100644
index 000000000000..84a4c3664ee1
--- /dev/null
+++ b/include/dt-bindings/dma/cv181x-dmamap.h
@@ -0,0 +1,48 @@
+#ifndef __DT_BINDINGS_CV181X_DMAMAP_H__
+#define __DT_BINDINGS_CV181X_DMAMAP_H__
+
+#define CVI_I2S0_RX     0
+#define CVI_I2S0_TX     1
+#define CVI_I2S1_RX     2
+#define CVI_I2S1_TX     3
+#define CVI_I2S2_RX     4
+#define CVI_I2S2_TX     5
+#define CVI_I2S3_RX     6
+#define CVI_I2S3_TX     7
+#define CVI_UART0_RX    8
+#define CVI_UART0_TX    9
+#define CVI_UART1_RX    10
+#define CVI_UART1_TX    11
+#define CVI_UART2_RX    12
+#define CVI_UART2_TX    13
+#define CVI_UART3_RX    14
+#define CVI_UART3_TX    15
+#define CVI_SPI0_RX     16
+#define CVI_SPI0_TX     17
+#define CVI_SPI1_RX     18
+#define CVI_SPI1_TX     19
+#define CVI_SPI2_RX     20
+#define CVI_SPI2_TX     21
+#define CVI_SPI3_RX     22
+#define CVI_SPI3_TX     23
+#define CVI_I2C0_RX     24
+#define CVI_I2C0_TX     25
+#define CVI_I2C1_RX     26
+#define CVI_I2C1_TX     27
+#define CVI_I2C2_RX     28
+#define CVI_I2C2_TX     29
+#define CVI_I2C3_RX     30
+#define CVI_I2C3_TX     31
+#define CVI_I2C4_RX     32
+#define CVI_I2C4_TX     33
+#define CVI_TDM0_RX     34
+#define CVI_TDM0_TX     35
+#define CVI_TDM1_RX     36
+#define CVI_AUDSRC      37
+#define CVI_SPI_NAND    38
+#define CVI_SPI_NOR     39
+#define CVI_UART4_RX    40
+#define CVI_UART4_TX    41
+#define CVI_SPI_NOR1    42
+
+#endif
diff --git a/include/dt-bindings/dma/cv182x-dmamap.h b/include/dt-bindings/dma/cv182x-dmamap.h
new file mode 100644
index 000000000000..e0e386029a39
--- /dev/null
+++ b/include/dt-bindings/dma/cv182x-dmamap.h
@@ -0,0 +1,48 @@
+#ifndef __DT_BINDINGS_CV1835_DMAMAP_H__
+#define __DT_BINDINGS_CV1835_DMAMAP_H__
+
+#define CVI_I2S0_RX     0
+#define CVI_I2S0_TX     1
+#define CVI_I2S1_RX     2
+#define CVI_I2S1_TX     3
+#define CVI_I2S2_RX     4
+#define CVI_I2S2_TX     5
+#define CVI_I2S3_RX     6
+#define CVI_I2S3_TX     7
+#define CVI_UART0_RX    8
+#define CVI_UART0_TX    9
+#define CVI_UART1_RX    10
+#define CVI_UART1_TX    11
+#define CVI_UART2_RX    12
+#define CVI_UART2_TX    13
+#define CVI_UART3_RX    14
+#define CVI_UART3_TX    15
+#define CVI_SPI0_RX     16
+#define CVI_SPI0_TX     17
+#define CVI_SPI1_RX     18
+#define CVI_SPI1_TX     19
+#define CVI_SPI2_RX     20
+#define CVI_SPI2_TX     21
+#define CVI_SPI3_RX     22
+#define CVI_SPI3_TX     23
+#define CVI_I2C0_RX     24
+#define CVI_I2C0_TX     25
+#define CVI_I2C1_RX     26
+#define CVI_I2C1_TX     27
+#define CVI_I2C2_RX     28
+#define CVI_I2C2_TX     29
+#define CVI_I2C3_RX     30
+#define CVI_I2C3_TX     31
+#define CVI_I2C4_RX     32
+#define CVI_I2C4_TX     33
+#define CVI_TDM0_RX     34
+#define CVI_TDM0_TX     35
+#define CVI_TDM1_RX     36
+#define CVI_AUDSRC      37
+#define CVI_SPI_NAND    38
+#define CVI_SPI_NOR     39
+#define CVI_UART4_RX    40
+#define CVI_UART4_TX    41
+#define CVI_SPI_NOR1    42
+
+#endif
diff --git a/include/dt-bindings/dma/cv1835-dmamap.h b/include/dt-bindings/dma/cv1835-dmamap.h
new file mode 100644
index 000000000000..e0e386029a39
--- /dev/null
+++ b/include/dt-bindings/dma/cv1835-dmamap.h
@@ -0,0 +1,48 @@
+#ifndef __DT_BINDINGS_CV1835_DMAMAP_H__
+#define __DT_BINDINGS_CV1835_DMAMAP_H__
+
+#define CVI_I2S0_RX     0
+#define CVI_I2S0_TX     1
+#define CVI_I2S1_RX     2
+#define CVI_I2S1_TX     3
+#define CVI_I2S2_RX     4
+#define CVI_I2S2_TX     5
+#define CVI_I2S3_RX     6
+#define CVI_I2S3_TX     7
+#define CVI_UART0_RX    8
+#define CVI_UART0_TX    9
+#define CVI_UART1_RX    10
+#define CVI_UART1_TX    11
+#define CVI_UART2_RX    12
+#define CVI_UART2_TX    13
+#define CVI_UART3_RX    14
+#define CVI_UART3_TX    15
+#define CVI_SPI0_RX     16
+#define CVI_SPI0_TX     17
+#define CVI_SPI1_RX     18
+#define CVI_SPI1_TX     19
+#define CVI_SPI2_RX     20
+#define CVI_SPI2_TX     21
+#define CVI_SPI3_RX     22
+#define CVI_SPI3_TX     23
+#define CVI_I2C0_RX     24
+#define CVI_I2C0_TX     25
+#define CVI_I2C1_RX     26
+#define CVI_I2C1_TX     27
+#define CVI_I2C2_RX     28
+#define CVI_I2C2_TX     29
+#define CVI_I2C3_RX     30
+#define CVI_I2C3_TX     31
+#define CVI_I2C4_RX     32
+#define CVI_I2C4_TX     33
+#define CVI_TDM0_RX     34
+#define CVI_TDM0_TX     35
+#define CVI_TDM1_RX     36
+#define CVI_AUDSRC      37
+#define CVI_SPI_NAND    38
+#define CVI_SPI_NOR     39
+#define CVI_UART4_RX    40
+#define CVI_UART4_TX    41
+#define CVI_SPI_NOR1    42
+
+#endif
diff --git a/include/dt-bindings/reset/cv180x-resets.h b/include/dt-bindings/reset/cv180x-resets.h
new file mode 100644
index 000000000000..191757cbb2cf
--- /dev/null
+++ b/include/dt-bindings/reset/cv180x-resets.h
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ * File Name: cvi_template.h
+ * Description:
+ */
+
+#ifndef __DT_BINDINGS_RST_CV180X_H__
+#define __DT_BINDINGS_RST_CV180X_H__
+
+#define RST_MAINRST_AP	0
+#define RST_SECONDRST_AP	1
+#define RST_DDR	2
+#define RST_H264C	3
+#define RST_JPEG	4
+#define RST_H265C	5
+#define RST_VIPSYS	6
+#define RST_TDMA	7
+#define RST_TPU	8
+#define RST_TPUSYS	9
+#define RST_TSM	10
+#define RST_USB	11
+#define RST_ETH0	12
+#define RST_ETH1	13
+#define RST_NAND	14
+#define RST_EMMC	15
+#define RST_SD0	16
+#define RST_SD1	17
+#define RST_SDMA	18
+#define RST_I2S0	19
+#define RST_I2S1	20
+#define RST_I2S2	21
+#define RST_I2S3	22
+#define RST_UART0	23
+#define RST_UART1	24
+#define RST_UART2	25
+#define RST_UART3	26
+#define RST_I2C0	27
+#define RST_I2C1	28
+#define RST_I2C2	29
+#define RST_I2C3	30
+#define RST_I2C4	31
+#define RST_PWM0	32
+#define RST_PWM1	33
+#define RST_PWM2	34
+#define RST_PWM3	35
+#define RST_PWM4	36
+#define RST_PWM5	37
+#define RST_PWM6	38
+#define RST_PWM7	39
+#define RST_SPI0	40
+#define RST_SPI1	41
+#define RST_SPI2	42
+#define RST_SPI3	43
+#define RST_GPIO0	44
+#define RST_GPIO1	45
+#define RST_GPIO2	46
+#define RST_EFUSE	47
+#define RST_WDT	48
+#define RST_AHBRST_ROM	49
+#define RST_SPIC	50
+#define RST_TEMPSEN	51
+#define RST_SARADC	52
+#define RST_PCIERST_CDMA	53
+#define RST_PCIERST_SMMU	54
+#define RST_PCIERST_PCIE	55
+#define RST_PCIERST_FABS	56
+#define RST_PCIERST_IRQ	57
+#define RST_COMBORST_PHY0	58
+#define RST_COMBORST_PHY1	59
+#define RST_USB1	60
+#define RST_SPIRST_NAND	61
+#define RST_SE	62
+#define RST_RTCRST_SWRST_ONLY	63
+#define RST_CPUCORE0	64
+#define RST_CPUCORE1	65
+#define RST_CPUCORE2	66
+#define RST_CPUCORE3	67
+#define RST_DSIPHY	68
+#define RST_DSIPHYRST_APB	69
+#define RST_CSIPHY0	70
+#define RST_CSIPHY0RST_APB	71
+#define RST_CSIPHY1	72
+#define RST_CSIPHY1RST_APB	73
+#define RST_UART4	74
+#define RST_GPIO3	75
+#define RST_SYSTEM	76
+#define RST_TIMER	77
+#define RST_TIMER0	78
+#define RST_TIMER1	79
+#define RST_TIMER2	80
+#define RST_TIMER3	81
+#define RST_TIMER4	82
+#define RST_TIMER5	83
+#define RST_TIMER6	84
+#define RST_TIMER7	85
+#define RST_WGN0	86
+#define RST_WGN1	87
+#define RST_WGN2	88
+#define RST_KEYSCAN	89
+#define RST_SPIC1	90
+#define RST_AUDDAC	91
+#define RST_AUDDACRST_APB	92
+#define RST_AUDADC	93
+#define RST_AUDADCRST_APB	94
+#define RST_VCSYS	95
+#define RST_ETHPHY	96
+#define RST_ETHPHYRST_APB	97
+#define RST_AUDSRC	98
+#define RST_AUTO_CLEAR_CPUCORE0	99
+#define RST_AUTO_CLEAR_CPUCORE1	100
+#define RST_AUTO_CLEAR_CPUCORE2	101
+#define RST_AUTO_CLEAR_CPUCORE3	102
+#define RST_AUTO_CLEAR_MAINRST_AP	103
+#define RST_AUTO_CLEAR_SECONDRST_AP	104
+
+#define CLK_RST_A53		0
+#define CLK_RST_50M_A53		1
+#define CLK_RST_AHB_ROM		2
+#define CLK_RST_AXI_SRAM	3
+#define CLK_RST_DDR_AXI		4
+#define CLK_RST_EFUSE		5
+#define CLK_RST_APB_EFUSE	6
+#define CLK_RST_AXI_EMMC	7
+#define CLK_RST_EMMC		8
+#define CLK_RST_100K_EMMC	9
+#define CLK_RST_AXI_SD		10
+#define CLK_RST_SD		11
+#define CLK_RST_100K_SD		12
+#define CLK_RST_500M_ETH0	13
+#define CLK_RST_AXI_ETH0	14
+#define CLK_RST_500M_ETH1	15
+#define CLK_RST_AXI_ETH1	16
+#define CLK_RST_AXI_GDMA	17
+#define CLK_RST_APB_GPIO	18
+#define CLK_RST_APB_GPIO_INTR	19
+#define CLK_RST_GPIO_DB		20
+#define CLK_RST_AXI_MINER	21
+#define CLK_RST_AHB_SF		22
+#define CLK_RST_SDMA_AXI	23
+#define CLK_RST_SDMA_AUD	24
+#define CLK_RST_APB_I2C		25
+#define CLK_RST_APB_WDT		26
+#define CLK_RST_APB_JPEG	27
+#define CLK_RST_JPEG_AXI	28
+#define CLK_RST_AXI_NF		29
+#define CLK_RST_APB_NF		30
+#define CLK_RST_NF		31
+#define CLK_RST_APB_PWM		32
+#define CLK_RST_RV		33
+#define CLK_RST_APB_SPI		34
+#define CLK_RST_TPU_AXI		35
+#define CLK_RST_UART_500M	36
+#define CLK_RST_APB_UART	37
+#define CLK_RST_APB_I2S		38
+#define CLK_RST_AXI_USB		39
+#define CLK_RST_APB_USB		40
+#define CLK_RST_125M_USB	41
+#define CLK_RST_33K_USB		42
+#define CLK_RST_12M_USB		43
+#define CLK_RST_APB_VIDEO	44
+#define CLK_RST_VIDEO_AXI	45
+#define CLK_RST_VPP_AXI		46
+#define CLK_RST_APB_VPP		47
+#define CLK_RST_AXI1		48
+#define CLK_RST_AXI2		49
+#define CLK_RST_AXI3		50
+#define CLK_RST_AXI4		51
+#define CLK_RST_AXI5		52
+#define CLK_RST_AXI6		53
+
+#endif /* _DT_BINDINGS_RST_CV1835_H_ */
diff --git a/include/dt-bindings/reset/cv181x-resets.h b/include/dt-bindings/reset/cv181x-resets.h
new file mode 100644
index 000000000000..e10d33b35446
--- /dev/null
+++ b/include/dt-bindings/reset/cv181x-resets.h
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ * File Name: cvi_template.h
+ * Description:
+ */
+
+#ifndef __DT_BINDINGS_RST_CV181X_H__
+#define __DT_BINDINGS_RST_CV181X_H__
+
+#define RST_MAINRST_AP	0
+#define RST_SECONDRST_AP	1
+#define RST_DDR	2
+#define RST_H264C	3
+#define RST_JPEG	4
+#define RST_H265C	5
+#define RST_VIPSYS	6
+#define RST_TDMA	7
+#define RST_TPU	8
+#define RST_TPUSYS	9
+#define RST_TSM	10
+#define RST_USB	11
+#define RST_ETH0	12
+#define RST_ETH1	13
+#define RST_NAND	14
+#define RST_EMMC	15
+#define RST_SD0	16
+#define RST_SD1	17
+#define RST_SDMA	18
+#define RST_I2S0	19
+#define RST_I2S1	20
+#define RST_I2S2	21
+#define RST_I2S3	22
+#define RST_UART0	23
+#define RST_UART1	24
+#define RST_UART2	25
+#define RST_UART3	26
+#define RST_I2C0	27
+#define RST_I2C1	28
+#define RST_I2C2	29
+#define RST_I2C3	30
+#define RST_I2C4	31
+#define RST_PWM0	32
+#define RST_PWM1	33
+#define RST_PWM2	34
+#define RST_PWM3	35
+#define RST_PWM4	36
+#define RST_PWM5	37
+#define RST_PWM6	38
+#define RST_PWM7	39
+#define RST_SPI0	40
+#define RST_SPI1	41
+#define RST_SPI2	42
+#define RST_SPI3	43
+#define RST_GPIO0	44
+#define RST_GPIO1	45
+#define RST_GPIO2	46
+#define RST_EFUSE	47
+#define RST_WDT	48
+#define RST_AHBRST_ROM	49
+#define RST_SPIC	50
+#define RST_TEMPSEN	51
+#define RST_SARADC	52
+#define RST_PCIERST_CDMA	53
+#define RST_PCIERST_SMMU	54
+#define RST_PCIERST_PCIE	55
+#define RST_PCIERST_FABS	56
+#define RST_PCIERST_IRQ	57
+#define RST_COMBORST_PHY0	58
+#define RST_COMBORST_PHY1	59
+#define RST_USB1	60
+#define RST_SPIRST_NAND	61
+#define RST_SE	62
+#define RST_RTCRST_SWRST_ONLY	63
+#define RST_CPUCORE0	64
+#define RST_CPUCORE1	65
+#define RST_CPUCORE2	66
+#define RST_CPUCORE3	67
+#define RST_DSIPHY	68
+#define RST_DSIPHYRST_APB	69
+#define RST_CSIPHY0	70
+#define RST_CSIPHY0RST_APB	71
+#define RST_CSIPHY1	72
+#define RST_CSIPHY1RST_APB	73
+#define RST_UART4	74
+#define RST_GPIO3	75
+#define RST_SYSTEM	76
+#define RST_TIMER	77
+#define RST_TIMER0	78
+#define RST_TIMER1	79
+#define RST_TIMER2	80
+#define RST_TIMER3	81
+#define RST_TIMER4	82
+#define RST_TIMER5	83
+#define RST_TIMER6	84
+#define RST_TIMER7	85
+#define RST_WGN0	86
+#define RST_WGN1	87
+#define RST_WGN2	88
+#define RST_KEYSCAN	89
+#define RST_SPIC1	90
+#define RST_AUDDAC	91
+#define RST_AUDDACRST_APB	92
+#define RST_AUDADC	93
+#define RST_AUDADCRST_APB	94
+#define RST_VCSYS	95
+#define RST_ETHPHY	96
+#define RST_ETHPHYRST_APB	97
+#define RST_AUDSRC	98
+#define RST_AUTO_CLEAR_CPUCORE0	99
+#define RST_AUTO_CLEAR_CPUCORE1	100
+#define RST_AUTO_CLEAR_CPUCORE2	101
+#define RST_AUTO_CLEAR_CPUCORE3	102
+#define RST_AUTO_CLEAR_MAINRST_AP	103
+#define RST_AUTO_CLEAR_SECONDRST_AP	104
+
+#define CLK_RST_A53		0
+#define CLK_RST_50M_A53		1
+#define CLK_RST_AHB_ROM		2
+#define CLK_RST_AXI_SRAM	3
+#define CLK_RST_DDR_AXI		4
+#define CLK_RST_EFUSE		5
+#define CLK_RST_APB_EFUSE	6
+#define CLK_RST_AXI_EMMC	7
+#define CLK_RST_EMMC		8
+#define CLK_RST_100K_EMMC	9
+#define CLK_RST_AXI_SD		10
+#define CLK_RST_SD		11
+#define CLK_RST_100K_SD		12
+#define CLK_RST_500M_ETH0	13
+#define CLK_RST_AXI_ETH0	14
+#define CLK_RST_500M_ETH1	15
+#define CLK_RST_AXI_ETH1	16
+#define CLK_RST_AXI_GDMA	17
+#define CLK_RST_APB_GPIO	18
+#define CLK_RST_APB_GPIO_INTR	19
+#define CLK_RST_GPIO_DB		20
+#define CLK_RST_AXI_MINER	21
+#define CLK_RST_AHB_SF		22
+#define CLK_RST_SDMA_AXI	23
+#define CLK_RST_SDMA_AUD	24
+#define CLK_RST_APB_I2C		25
+#define CLK_RST_APB_WDT		26
+#define CLK_RST_APB_JPEG	27
+#define CLK_RST_JPEG_AXI	28
+#define CLK_RST_AXI_NF		29
+#define CLK_RST_APB_NF		30
+#define CLK_RST_NF		31
+#define CLK_RST_APB_PWM		32
+#define CLK_RST_RV		33
+#define CLK_RST_APB_SPI		34
+#define CLK_RST_TPU_AXI		35
+#define CLK_RST_UART_500M	36
+#define CLK_RST_APB_UART	37
+#define CLK_RST_APB_I2S		38
+#define CLK_RST_AXI_USB		39
+#define CLK_RST_APB_USB		40
+#define CLK_RST_125M_USB	41
+#define CLK_RST_33K_USB		42
+#define CLK_RST_12M_USB		43
+#define CLK_RST_APB_VIDEO	44
+#define CLK_RST_VIDEO_AXI	45
+#define CLK_RST_VPP_AXI		46
+#define CLK_RST_APB_VPP		47
+#define CLK_RST_AXI1		48
+#define CLK_RST_AXI2		49
+#define CLK_RST_AXI3		50
+#define CLK_RST_AXI4		51
+#define CLK_RST_AXI5		52
+#define CLK_RST_AXI6		53
+
+#endif /* _DT_BINDINGS_RST_CV1835_H_ */
diff --git a/include/dt-bindings/reset/cv182x-resets.h b/include/dt-bindings/reset/cv182x-resets.h
new file mode 100644
index 000000000000..f1807754eebe
--- /dev/null
+++ b/include/dt-bindings/reset/cv182x-resets.h
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ * File Name: cvi_template.h
+ * Description:
+ */
+
+#ifndef __DT_BINDINGS_RST_CV1835_H__
+#define __DT_BINDINGS_RST_CV1835_H__
+
+#define RST_MAINRST_AP	0
+#define RST_SECONDRST_AP	1
+#define RST_DDR	2
+#define RST_H264C	3
+#define RST_JPEG	4
+#define RST_H265C	5
+#define RST_VIPSYS	6
+#define RST_TDMA	7
+#define RST_TPU	8
+#define RST_TPUSYS	9
+#define RST_TSM	10
+#define RST_USB	11
+#define RST_ETH0	12
+#define RST_ETH1	13
+#define RST_NAND	14
+#define RST_EMMC	15
+#define RST_SD0	16
+#define RST_SD1	17
+#define RST_SDMA	18
+#define RST_I2S0	19
+#define RST_I2S1	20
+#define RST_I2S2	21
+#define RST_I2S3	22
+#define RST_UART0	23
+#define RST_UART1	24
+#define RST_UART2	25
+#define RST_UART3	26
+#define RST_I2C0	27
+#define RST_I2C1	28
+#define RST_I2C2	29
+#define RST_I2C3	30
+#define RST_I2C4	31
+#define RST_PWM0	32
+#define RST_PWM1	33
+#define RST_PWM2	34
+#define RST_PWM3	35
+#define RST_PWM4	36
+#define RST_PWM5	37
+#define RST_PWM6	38
+#define RST_PWM7	39
+#define RST_SPI0	40
+#define RST_SPI1	41
+#define RST_SPI2	42
+#define RST_SPI3	43
+#define RST_GPIO0	44
+#define RST_GPIO1	45
+#define RST_GPIO2	46
+#define RST_EFUSE	47
+#define RST_WDT	48
+#define RST_AHBRST_ROM	49
+#define RST_SPIC	50
+#define RST_TEMPSEN	51
+#define RST_SARADC	52
+#define RST_PCIERST_CDMA	53
+#define RST_PCIERST_SMMU	54
+#define RST_PCIERST_PCIE	55
+#define RST_PCIERST_FABS	56
+#define RST_PCIERST_IRQ	57
+#define RST_COMBORST_PHY0	58
+#define RST_COMBORST_PHY1	59
+#define RST_USB1	60
+#define RST_SPIRST_NAND	61
+#define RST_SE	62
+#define RST_RTCRST_SWRST_ONLY	63
+#define RST_CPUCORE0	64
+#define RST_CPUCORE1	65
+#define RST_CPUCORE2	66
+#define RST_CPUCORE3	67
+#define RST_DSIPHY	68
+#define RST_DSIPHYRST_APB	69
+#define RST_CSIPHY0	70
+#define RST_CSIPHY0RST_APB	71
+#define RST_CSIPHY1	72
+#define RST_CSIPHY1RST_APB	73
+#define RST_UART4	74
+#define RST_GPIO3	75
+#define RST_SYSTEM	76
+#define RST_TIMER	77
+#define RST_TIMER0	78
+#define RST_TIMER1	79
+#define RST_TIMER2	80
+#define RST_TIMER3	81
+#define RST_TIMER4	82
+#define RST_TIMER5	83
+#define RST_TIMER6	84
+#define RST_TIMER7	85
+#define RST_WGN0	86
+#define RST_WGN1	87
+#define RST_WGN2	88
+#define RST_KEYSCAN	89
+#define RST_SPIC1	90
+#define RST_AUDDAC	91
+#define RST_AUDDACRST_APB	92
+#define RST_AUDADC	93
+#define RST_AUDADCRST_APB	94
+#define RST_VCSYS	95
+#define RST_ETHPHY	96
+#define RST_ETHPHYRST_APB	97
+#define RST_AUDSRC	98
+#define RST_AUTO_CLEAR_CPUCORE0	99
+#define RST_AUTO_CLEAR_CPUCORE1	100
+#define RST_AUTO_CLEAR_CPUCORE2	101
+#define RST_AUTO_CLEAR_CPUCORE3	102
+#define RST_AUTO_CLEAR_MAINRST_AP	103
+#define RST_AUTO_CLEAR_SECONDRST_AP	104
+
+#define CLK_RST_A53		0
+#define CLK_RST_50M_A53		1
+#define CLK_RST_AHB_ROM		2
+#define CLK_RST_AXI_SRAM	3
+#define CLK_RST_DDR_AXI		4
+#define CLK_RST_EFUSE		5
+#define CLK_RST_APB_EFUSE	6
+#define CLK_RST_AXI_EMMC	7
+#define CLK_RST_EMMC		8
+#define CLK_RST_100K_EMMC	9
+#define CLK_RST_AXI_SD		10
+#define CLK_RST_SD		11
+#define CLK_RST_100K_SD		12
+#define CLK_RST_500M_ETH0	13
+#define CLK_RST_AXI_ETH0	14
+#define CLK_RST_500M_ETH1	15
+#define CLK_RST_AXI_ETH1	16
+#define CLK_RST_AXI_GDMA	17
+#define CLK_RST_APB_GPIO	18
+#define CLK_RST_APB_GPIO_INTR	19
+#define CLK_RST_GPIO_DB		20
+#define CLK_RST_AXI_MINER	21
+#define CLK_RST_AHB_SF		22
+#define CLK_RST_SDMA_AXI	23
+#define CLK_RST_SDMA_AUD	24
+#define CLK_RST_APB_I2C		25
+#define CLK_RST_APB_WDT		26
+#define CLK_RST_APB_JPEG	27
+#define CLK_RST_JPEG_AXI	28
+#define CLK_RST_AXI_NF		29
+#define CLK_RST_APB_NF		30
+#define CLK_RST_NF		31
+#define CLK_RST_APB_PWM		32
+#define CLK_RST_RV		33
+#define CLK_RST_APB_SPI		34
+#define CLK_RST_TPU_AXI		35
+#define CLK_RST_UART_500M	36
+#define CLK_RST_APB_UART	37
+#define CLK_RST_APB_I2S		38
+#define CLK_RST_AXI_USB		39
+#define CLK_RST_APB_USB		40
+#define CLK_RST_125M_USB	41
+#define CLK_RST_33K_USB		42
+#define CLK_RST_12M_USB		43
+#define CLK_RST_APB_VIDEO	44
+#define CLK_RST_VIDEO_AXI	45
+#define CLK_RST_VPP_AXI		46
+#define CLK_RST_APB_VPP		47
+#define CLK_RST_AXI1		48
+#define CLK_RST_AXI2		49
+#define CLK_RST_AXI3		50
+#define CLK_RST_AXI4		51
+#define CLK_RST_AXI5		52
+#define CLK_RST_AXI6		53
+
+#endif /* _DT_BINDINGS_RST_CV1835_H_ */
diff --git a/include/dt-bindings/reset/cv1835-resets.h b/include/dt-bindings/reset/cv1835-resets.h
new file mode 100644
index 000000000000..f1807754eebe
--- /dev/null
+++ b/include/dt-bindings/reset/cv1835-resets.h
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.
+ *
+ * File Name: cvi_template.h
+ * Description:
+ */
+
+#ifndef __DT_BINDINGS_RST_CV1835_H__
+#define __DT_BINDINGS_RST_CV1835_H__
+
+#define RST_MAINRST_AP	0
+#define RST_SECONDRST_AP	1
+#define RST_DDR	2
+#define RST_H264C	3
+#define RST_JPEG	4
+#define RST_H265C	5
+#define RST_VIPSYS	6
+#define RST_TDMA	7
+#define RST_TPU	8
+#define RST_TPUSYS	9
+#define RST_TSM	10
+#define RST_USB	11
+#define RST_ETH0	12
+#define RST_ETH1	13
+#define RST_NAND	14
+#define RST_EMMC	15
+#define RST_SD0	16
+#define RST_SD1	17
+#define RST_SDMA	18
+#define RST_I2S0	19
+#define RST_I2S1	20
+#define RST_I2S2	21
+#define RST_I2S3	22
+#define RST_UART0	23
+#define RST_UART1	24
+#define RST_UART2	25
+#define RST_UART3	26
+#define RST_I2C0	27
+#define RST_I2C1	28
+#define RST_I2C2	29
+#define RST_I2C3	30
+#define RST_I2C4	31
+#define RST_PWM0	32
+#define RST_PWM1	33
+#define RST_PWM2	34
+#define RST_PWM3	35
+#define RST_PWM4	36
+#define RST_PWM5	37
+#define RST_PWM6	38
+#define RST_PWM7	39
+#define RST_SPI0	40
+#define RST_SPI1	41
+#define RST_SPI2	42
+#define RST_SPI3	43
+#define RST_GPIO0	44
+#define RST_GPIO1	45
+#define RST_GPIO2	46
+#define RST_EFUSE	47
+#define RST_WDT	48
+#define RST_AHBRST_ROM	49
+#define RST_SPIC	50
+#define RST_TEMPSEN	51
+#define RST_SARADC	52
+#define RST_PCIERST_CDMA	53
+#define RST_PCIERST_SMMU	54
+#define RST_PCIERST_PCIE	55
+#define RST_PCIERST_FABS	56
+#define RST_PCIERST_IRQ	57
+#define RST_COMBORST_PHY0	58
+#define RST_COMBORST_PHY1	59
+#define RST_USB1	60
+#define RST_SPIRST_NAND	61
+#define RST_SE	62
+#define RST_RTCRST_SWRST_ONLY	63
+#define RST_CPUCORE0	64
+#define RST_CPUCORE1	65
+#define RST_CPUCORE2	66
+#define RST_CPUCORE3	67
+#define RST_DSIPHY	68
+#define RST_DSIPHYRST_APB	69
+#define RST_CSIPHY0	70
+#define RST_CSIPHY0RST_APB	71
+#define RST_CSIPHY1	72
+#define RST_CSIPHY1RST_APB	73
+#define RST_UART4	74
+#define RST_GPIO3	75
+#define RST_SYSTEM	76
+#define RST_TIMER	77
+#define RST_TIMER0	78
+#define RST_TIMER1	79
+#define RST_TIMER2	80
+#define RST_TIMER3	81
+#define RST_TIMER4	82
+#define RST_TIMER5	83
+#define RST_TIMER6	84
+#define RST_TIMER7	85
+#define RST_WGN0	86
+#define RST_WGN1	87
+#define RST_WGN2	88
+#define RST_KEYSCAN	89
+#define RST_SPIC1	90
+#define RST_AUDDAC	91
+#define RST_AUDDACRST_APB	92
+#define RST_AUDADC	93
+#define RST_AUDADCRST_APB	94
+#define RST_VCSYS	95
+#define RST_ETHPHY	96
+#define RST_ETHPHYRST_APB	97
+#define RST_AUDSRC	98
+#define RST_AUTO_CLEAR_CPUCORE0	99
+#define RST_AUTO_CLEAR_CPUCORE1	100
+#define RST_AUTO_CLEAR_CPUCORE2	101
+#define RST_AUTO_CLEAR_CPUCORE3	102
+#define RST_AUTO_CLEAR_MAINRST_AP	103
+#define RST_AUTO_CLEAR_SECONDRST_AP	104
+
+#define CLK_RST_A53		0
+#define CLK_RST_50M_A53		1
+#define CLK_RST_AHB_ROM		2
+#define CLK_RST_AXI_SRAM	3
+#define CLK_RST_DDR_AXI		4
+#define CLK_RST_EFUSE		5
+#define CLK_RST_APB_EFUSE	6
+#define CLK_RST_AXI_EMMC	7
+#define CLK_RST_EMMC		8
+#define CLK_RST_100K_EMMC	9
+#define CLK_RST_AXI_SD		10
+#define CLK_RST_SD		11
+#define CLK_RST_100K_SD		12
+#define CLK_RST_500M_ETH0	13
+#define CLK_RST_AXI_ETH0	14
+#define CLK_RST_500M_ETH1	15
+#define CLK_RST_AXI_ETH1	16
+#define CLK_RST_AXI_GDMA	17
+#define CLK_RST_APB_GPIO	18
+#define CLK_RST_APB_GPIO_INTR	19
+#define CLK_RST_GPIO_DB		20
+#define CLK_RST_AXI_MINER	21
+#define CLK_RST_AHB_SF		22
+#define CLK_RST_SDMA_AXI	23
+#define CLK_RST_SDMA_AUD	24
+#define CLK_RST_APB_I2C		25
+#define CLK_RST_APB_WDT		26
+#define CLK_RST_APB_JPEG	27
+#define CLK_RST_JPEG_AXI	28
+#define CLK_RST_AXI_NF		29
+#define CLK_RST_APB_NF		30
+#define CLK_RST_NF		31
+#define CLK_RST_APB_PWM		32
+#define CLK_RST_RV		33
+#define CLK_RST_APB_SPI		34
+#define CLK_RST_TPU_AXI		35
+#define CLK_RST_UART_500M	36
+#define CLK_RST_APB_UART	37
+#define CLK_RST_APB_I2S		38
+#define CLK_RST_AXI_USB		39
+#define CLK_RST_APB_USB		40
+#define CLK_RST_125M_USB	41
+#define CLK_RST_33K_USB		42
+#define CLK_RST_12M_USB		43
+#define CLK_RST_APB_VIDEO	44
+#define CLK_RST_VIDEO_AXI	45
+#define CLK_RST_VPP_AXI		46
+#define CLK_RST_APB_VPP		47
+#define CLK_RST_AXI1		48
+#define CLK_RST_AXI2		49
+#define CLK_RST_AXI3		50
+#define CLK_RST_AXI4		51
+#define CLK_RST_AXI5		52
+#define CLK_RST_AXI6		53
+
+#endif /* _DT_BINDINGS_RST_CV1835_H_ */
diff --git a/include/dt-bindings/sound/cv1835-audio.h b/include/dt-bindings/sound/cv1835-audio.h
new file mode 100644
index 000000000000..963429cc3284
--- /dev/null
+++ b/include/dt-bindings/sound/cv1835-audio.h
@@ -0,0 +1,9 @@
+#ifndef __CV1835_AUDIO_H__
+#define __CV1835_AUDIO_H__
+
+//#define CV1835_CONCURRENT_I2S
+//#define CV1835_PDM_EN
+#define CV1835_EXT_CARD_1_EN
+#define CV1835_EXT_CARD_2_EN
+//#define CV1835_AUDIO_CODEC_EN
+#endif /* __CV1835_AUDIO_H__ */
diff --git a/include/linux/compat.h b/include/linux/compat.h
index 14d514233e1d..a17f39f3f41d 100644
--- a/include/linux/compat.h
+++ b/include/linux/compat.h
@@ -451,8 +451,6 @@ extern long compat_arch_ptrace(struct task_struct *child, compat_long_t request,
 
 struct epoll_event;	/* fortunately, this one is fixed-layout */
 
-extern void __user *compat_alloc_user_space(unsigned long len);
-
 int compat_restore_altstack(const compat_stack_t __user *uss);
 int __compat_save_altstack(compat_stack_t __user *, unsigned long);
 #define unsafe_compat_save_altstack(uss, sp, label) do { \
diff --git a/include/linux/cpuhotplug.h b/include/linux/cpuhotplug.h
index cb87247da5ba..8027467fb68a 100644
--- a/include/linux/cpuhotplug.h
+++ b/include/linux/cpuhotplug.h
@@ -185,6 +185,7 @@ enum cpuhp_state {
 	CPUHP_AP_PERF_POWERPC_TRACE_IMC_ONLINE,
 	CPUHP_AP_PERF_POWERPC_HV_24x7_ONLINE,
 	CPUHP_AP_PERF_POWERPC_HV_GPCI_ONLINE,
+	CPUHP_AP_PERF_CSKY_ONLINE,
 	CPUHP_AP_WATCHDOG_ONLINE,
 	CPUHP_AP_WORKQUEUE_ONLINE,
 	CPUHP_AP_RANDOM_ONLINE,
diff --git a/include/linux/early_time_log.h b/include/linux/early_time_log.h
new file mode 100644
index 000000000000..df1186572eae
--- /dev/null
+++ b/include/linux/early_time_log.h
@@ -0,0 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+#ifndef __KERNEL_TIME_ARCH_TIMER_H__
+#define __KERNEL_TIME_ARCH_TIMER_H__
+
+void early_time_log(const char *name);
+
+#endif /* __KERNEL_TIME_ARCH_TIMER_H__ */
diff --git a/include/linux/i2c.h b/include/linux/i2c.h
index a670ae129f4b..f5f5130155e4 100644
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@ -713,6 +713,9 @@ struct i2c_adapter {
 #define I2C_ALF_SUSPEND_REPORTED	1
 
 	int nr;
+#if defined(CONFIG_ARCH_CVITEK)
+	int i2c_idx;
+#endif
 	char name[48];
 	struct completion dev_released;
 
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index ef870d1f4f5f..df5c1d169e34 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -271,6 +271,7 @@ struct mmc_card {
 #define MMC_QUIRK_TRIM_BROKEN	(1<<12)		/* Skip trim */
 #define MMC_QUIRK_BROKEN_HPI	(1<<13)		/* Disable broken HPI support */
 #define MMC_QUIRK_BROKEN_SD_DISCARD	(1<<14)	/* Disable broken SD discard support */
+#define MMC_QUIRK_EXTRA_LONG_READ_TIME (1<<15)	/* For Micron eMMC need very long read time after power loss boot */
 
 	bool			reenable_cmdq;	/* Re-enable Command Queue */
 
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index fb294cbb9081..454aef43c29e 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -281,6 +281,7 @@ struct mmc_host {
 	unsigned int		f_min;
 	unsigned int		f_max;
 	unsigned int		f_init;
+	unsigned int		f_src;
 	u32			ocr_avail;
 	u32			ocr_avail_sdio;	/* SDIO-specific OCR */
 	u32			ocr_avail_sd;	/* SD-specific OCR */
@@ -467,7 +468,7 @@ struct mmc_host {
 	int			cqe_qdepth;
 	bool			cqe_enabled;
 	bool			cqe_on;
-
+	bool			ever_unplugged;
 	/* Host Software Queue support */
 	bool			hsq_enabled;
 
diff --git a/include/linux/mmc/slot-gpio.h b/include/linux/mmc/slot-gpio.h
index 4ae2f2908f99..adcaed50e0c8 100644
--- a/include/linux/mmc/slot-gpio.h
+++ b/include/linux/mmc/slot-gpio.h
@@ -13,6 +13,15 @@
 
 struct mmc_host;
 
+struct mmc_gpio {
+	struct gpio_desc *ro_gpio;
+	struct gpio_desc *cd_gpio;
+	irqreturn_t (*cd_gpio_isr)(int irq, void *dev_id);
+	char *ro_label;
+	char *cd_label;
+	u32 cd_debounce_delay_ms;
+};
+
 int mmc_gpio_get_ro(struct mmc_host *host);
 int mmc_gpio_get_cd(struct mmc_host *host);
 int mmc_gpiod_request_cd(struct mmc_host *host, const char *con_id,
diff --git a/include/linux/mtd/spi-nor.h b/include/linux/mtd/spi-nor.h
index 60bac2c0ec45..6744676682b8 100644
--- a/include/linux/mtd/spi-nor.h
+++ b/include/linux/mtd/spi-nor.h
@@ -26,6 +26,7 @@
 #define SPINOR_OP_WRSR		0x01	/* Write status register 1 byte */
 #define SPINOR_OP_RDSR2		0x3f	/* Read status register 2 */
 #define SPINOR_OP_WRSR2		0x3e	/* Write status register 2 */
+#define SPINOR_OP_WRSR2_JY	0x31    /* Write status register 2 like juyang */
 #define SPINOR_OP_READ		0x03	/* Read data bytes (low frequency) */
 #define SPINOR_OP_READ_FAST	0x0b	/* Read data bytes (high frequency) */
 #define SPINOR_OP_READ_1_1_2	0x3b	/* Read data bytes (Dual Output SPI) */
diff --git a/include/linux/sched.h b/include/linux/sched.h
index aa015416c569..e3bed06952eb 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1699,7 +1699,11 @@ extern int sched_setscheduler_nocheck(struct task_struct *, int, const struct sc
 extern void sched_set_fifo(struct task_struct *p);
 extern void sched_set_fifo_low(struct task_struct *p);
 extern void sched_set_normal(struct task_struct *p, int nice);
+#ifdef CONFIG_SCHED_CVITEK
+extern int sched_setattr(struct task_struct *, struct sched_attr *);
+#else
 extern int sched_setattr(struct task_struct *, const struct sched_attr *);
+#endif
 extern int sched_setattr_nocheck(struct task_struct *, const struct sched_attr *);
 extern struct task_struct *idle_task(int cpu);
 
diff --git a/include/linux/streamline_annotate.h b/include/linux/streamline_annotate.h
new file mode 100644
index 000000000000..2661672a6b05
--- /dev/null
+++ b/include/linux/streamline_annotate.h
@@ -0,0 +1,275 @@
+/**
+ * Copyright (c) 2014-2016, Arm Limited
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef STREAMLINE_ANNOTATE_H
+#define STREAMLINE_ANNOTATE_H
+
+/*
+ *  User-space only macros:
+ *  ANNOTATE_DEFINE            Deprecated and no longer used
+ *  ANNOTATE_SETUP             Execute at the start of the program before other ANNOTATE macros are called
+ *  ANNOTATE_DELTA_COUNTER     Define a delta counter for use
+ *  ANNOTATE_ABSOLUTE_COUNTER  Define an absolute counter for use
+ *  ANNOTATE_COUNTER_VALUE     Emit a counter value
+ *  CAM_TRACK                  Create a new custom activity map track
+ *  CAM_JOB                    Add a new job to a CAM track, use gator_get_time() to obtain the time in nanoseconds
+ *  CAM_VIEW_NAME              Name the custom activity map view
+ *
+ *  User-space and Kernel-space macros:
+ *  ANNOTATE(str)                                String annotation
+ *  ANNOTATE_CHANNEL(channel, str)               String annotation on a channel
+ *  ANNOTATE_COLOR(color, str)                   String annotation with color
+ *  ANNOTATE_CHANNEL_COLOR(channel, color, str)  String annotation on a channel with color
+ *  ANNOTATE_END()                               Terminate an annotation
+ *  ANNOTATE_CHANNEL_END(channel)                Terminate an annotation on a channel
+ *  ANNOTATE_NAME_CHANNEL(channel, group, str)   Name a channel and link it to a group
+ *  ANNOTATE_NAME_GROUP(group, str)              Name a group
+ *  ANNOTATE_VISUAL(data, length, str)           Image annotation with optional string
+ *  ANNOTATE_MARKER()                            Marker annotation
+ *  ANNOTATE_MARKER_STR(str)                     Marker annotation with a string
+ *  ANNOTATE_MARKER_COLOR(color)                 Marker annotation with a color
+ *  ANNOTATE_MARKER_COLOR_STR(color, str)        Marker annotation with a string and color
+ *
+ *  Channels and groups are defined per thread. This means that if the same
+ *  channel number is used on different threads they are in fact separate
+ *  channels. A channel can belong to only one group per thread. This means
+ *  channel 1 cannot be part of both group 1 and group 2 on the same thread.
+ *
+ *  NOTE: Kernel annotations are not supported in interrupt context.
+ */
+
+/* ESC character, hex RGB (little endian) */
+#define ANNOTATE_RED    0x0000ff1b
+#define ANNOTATE_BLUE   0xff00001b
+#define ANNOTATE_GREEN  0x00ff001b
+#define ANNOTATE_PURPLE 0xff00ff1b
+#define ANNOTATE_YELLOW 0x00ffff1b
+#define ANNOTATE_CYAN   0xffff001b
+#define ANNOTATE_WHITE  0xffffff1b
+#define ANNOTATE_LTGRAY 0xbbbbbb1b
+#define ANNOTATE_DKGRAY 0x5555551b
+#define ANNOTATE_BLACK  0x0000001b
+
+#define ANNOTATE_COLOR_CYCLE 0x00000000
+#define ANNOTATE_COLOR_T1    0x00000001
+#define ANNOTATE_COLOR_T2    0x00000002
+#define ANNOTATE_COLOR_T3    0x00000003
+#define ANNOTATE_COLOR_T4    0x00000004
+
+#ifdef __KERNEL__  /* Start of kernel-space macro definitions */
+
+#include <linux/module.h>
+
+void gator_annotate(const char* str);
+void gator_annotate_channel(int channel, const char* str);
+void gator_annotate_color(int color, const char* str);
+void gator_annotate_channel_color(int channel, int color, const char* str);
+void gator_annotate_end(void);
+void gator_annotate_channel_end(int channel);
+void gator_annotate_name_channel(int channel, int group, const char* str);
+void gator_annotate_name_group(int group, const char* str);
+void gator_annotate_visual(const char* data, unsigned int length, const char* str);
+void gator_annotate_marker(void);
+void gator_annotate_marker_str(const char* str);
+void gator_annotate_marker_color(int color);
+void gator_annotate_marker_color_str(int color, const char* str);
+
+#define ANNOTATE_INVOKE(func, args) \
+    func##_ptr = symbol_get(gator_##func); \
+    if (func##_ptr) { \
+        func##_ptr args; \
+        symbol_put(gator_##func); \
+    } \
+
+#define ANNOTATE(str) do { \
+    void (*annotate_ptr)(const char*); \
+    ANNOTATE_INVOKE(annotate, (str)); \
+    } while(0)
+
+#define ANNOTATE_CHANNEL(channel, str) do { \
+    void (*annotate_channel_ptr)(int, const char*); \
+    ANNOTATE_INVOKE(annotate_channel, (channel, str)); \
+    } while(0)
+
+#define ANNOTATE_COLOR(color, str) do { \
+    void (*annotate_color_ptr)(int, const char*); \
+    ANNOTATE_INVOKE(annotate_color, (color, str)); \
+    } while(0)
+
+#define ANNOTATE_CHANNEL_COLOR(channel, color, str) do { \
+    void (*annotate_channel_color_ptr)(int, int, const char*); \
+    ANNOTATE_INVOKE(annotate_channel_color, (channel, color, str)); \
+    } while(0)
+
+#define ANNOTATE_END() do { \
+    void (*annotate_end_ptr)(void); \
+    ANNOTATE_INVOKE(annotate_end, ()); \
+    } while(0)
+
+#define ANNOTATE_CHANNEL_END(channel) do { \
+    void (*annotate_channel_end_ptr)(int); \
+    ANNOTATE_INVOKE(annotate_channel_end, (channel)); \
+    } while(0)
+
+#define ANNOTATE_NAME_CHANNEL(channel, group, str) do { \
+    void (*annotate_name_channel_ptr)(int, int, const char*); \
+    ANNOTATE_INVOKE(annotate_name_channel, (channel, group, str)); \
+    } while(0)
+
+#define ANNOTATE_NAME_GROUP(group, str) do { \
+    void (*annotate_name_group_ptr)(int, const char*); \
+    ANNOTATE_INVOKE(annotate_name_group, (group, str)); \
+    } while(0)
+
+#define ANNOTATE_VISUAL(data, length, str) do { \
+    void (*annotate_visual_ptr)(const char*, unsigned int, const char*); \
+    ANNOTATE_INVOKE(annotate_visual, (data, length, str)); \
+    } while(0)
+
+#define ANNOTATE_MARKER() do { \
+    void (*annotate_marker_ptr)(void); \
+    ANNOTATE_INVOKE(annotate_marker, ()); \
+    } while(0)
+
+#define ANNOTATE_MARKER_STR(str) do { \
+    void (*annotate_marker_str_ptr)(const char*); \
+    ANNOTATE_INVOKE(annotate_marker_str, (str)); \
+    } while(0)
+
+#define ANNOTATE_MARKER_COLOR(color) do { \
+    void (*annotate_marker_color_ptr)(int); \
+    ANNOTATE_INVOKE(annotate_marker_color, (color)); \
+    } while(0)
+
+#define ANNOTATE_MARKER_COLOR_STR(color, str) do { \
+    void (*annotate_marker_color_str_ptr)(int, const char*); \
+    ANNOTATE_INVOKE(annotate_marker_color_str, (color, str)); \
+    } while(0)
+
+#else  /* Start of user-space macro definitions */
+
+#include <stddef.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum gator_annotate_counter_class {
+  ANNOTATE_DELTA = 1,
+  ANNOTATE_ABSOLUTE,
+  ANNOTATE_ACTIVITY
+};
+
+enum gator_annotate_display {
+  ANNOTATE_AVERAGE = 1,
+  ANNOTATE_ACCUMULATE,
+  ANNOTATE_HERTZ,
+  ANNOTATE_MAXIMUM,
+  ANNOTATE_MINIMUM
+};
+
+enum gator_annotate_series_composition {
+  ANNOTATE_STACKED = 1,
+  ANNOTATE_OVERLAY,
+  ANNOTATE_LOG10
+};
+
+enum gator_annotate_rendering_type {
+  ANNOTATE_FILL = 1,
+  ANNOTATE_LINE,
+  ANNOTATE_BAR
+};
+
+void gator_annotate_setup(void);
+uint64_t gator_get_time(void);
+void gator_annotate_fork_child(void);
+void gator_annotate_flush(void);
+void gator_annotate_str(const uint32_t channel, const char *const str);
+void gator_annotate_color(const uint32_t channel, const uint32_t color, const char *const str);
+void gator_annotate_name_channel(const uint32_t channel, const uint32_t group, const char *const str);
+void gator_annotate_name_group(const uint32_t group, const char *const str);
+void gator_annotate_visual(const void *const data, const uint32_t length, const char *const str);
+void gator_annotate_marker(const char *const str);
+void gator_annotate_marker_color(const uint32_t color, const char *const str);
+void gator_annotate_counter(const uint32_t id, const char *const title, const char *const name, const int per_cpu, const enum gator_annotate_counter_class counter_class, const enum gator_annotate_display display, const char *const units, const uint32_t modifier, const enum gator_annotate_series_composition series_composition, const enum gator_annotate_rendering_type rendering_type, const int average_selection, const int average_cores, const int percentage, const size_t activity_count, const char *const *const activities, const uint32_t *const activity_colors, const uint32_t cores, const uint32_t color, const char *const description);
+void gator_annotate_counter_value(const uint32_t core, const uint32_t id, const uint32_t value);
+void gator_annotate_activity_switch(const uint32_t core, const uint32_t id, const uint32_t activity, const uint32_t tid);
+void gator_cam_track(const uint32_t view_uid, const uint32_t track_uid, const uint32_t parent_track, const char *const name);
+void gator_cam_job(const uint32_t view_uid, const uint32_t job_uid, const char *const name, const uint32_t track, const uint64_t start_time, const uint64_t duration, const uint32_t color, const uint32_t primary_dependency, const size_t dependency_count, const uint32_t *const dependencies);
+void gator_cam_job_start(const uint32_t view_uid, const uint32_t job_uid, const char *const name, const uint32_t track, const uint64_t time, const uint32_t color);
+void gator_cam_job_set_dependencies(const uint32_t view_uid, const uint32_t job_uid, const uint64_t time, const uint32_t primary_dependency, const size_t dependency_count, const uint32_t *const dependencies);
+void gator_cam_job_stop(const uint32_t view_uid, const uint32_t job_uid, const uint64_t time);
+void gator_cam_view_name(const uint32_t view_uid, const char *const name);
+
+#define ANNOTATE_DEFINE extern int gator_annotate_unused
+
+#define ANNOTATE_SETUP gator_annotate_setup()
+
+#define ANNOTATE(str) gator_annotate_str(0, str)
+#define ANNOTATE_CHANNEL(channel, str) gator_annotate_str(channel, str)
+#define ANNOTATE_COLOR(color, str) gator_annotate_color(0, color, str)
+#define ANNOTATE_CHANNEL_COLOR(channel, color, str) gator_annotate_color(channel, color, str)
+#define ANNOTATE_END() gator_annotate_str(0, NULL)
+#define ANNOTATE_CHANNEL_END(channel) gator_annotate_str(channel, NULL)
+#define ANNOTATE_NAME_CHANNEL(channel, group, str) gator_annotate_name_channel(channel, group, str)
+#define ANNOTATE_NAME_GROUP(group, str) gator_annotate_name_group(group, str)
+#define ANNOTATE_VISUAL(data, length, str) gator_annotate_visual(data, length, str)
+#define ANNOTATE_MARKER() gator_annotate_marker(NULL)
+#define ANNOTATE_MARKER_STR(str) gator_annotate_marker(str)
+#define ANNOTATE_MARKER_COLOR(color) gator_annotate_marker_color(color, NULL)
+#define ANNOTATE_MARKER_COLOR_STR(color, str) gator_annotate_marker_color(color, str)
+#define ANNOTATE_DELTA_COUNTER(id, title, name) gator_annotate_counter(id, title, name, 0, ANNOTATE_DELTA, ANNOTATE_ACCUMULATE, NULL, 1, ANNOTATE_STACKED, ANNOTATE_FILL, 0, 0, 0, 0, NULL, NULL, 0, ANNOTATE_COLOR_CYCLE, NULL)
+#define ANNOTATE_ABSOLUTE_COUNTER(id, title, name) gator_annotate_counter(id, title, name, 0, ANNOTATE_ABSOLUTE, ANNOTATE_MAXIMUM, NULL, 1, ANNOTATE_STACKED, ANNOTATE_FILL, 0, 0, 0, 0, NULL, NULL, 0, ANNOTATE_COLOR_CYCLE, NULL)
+#define ANNOTATE_COUNTER_VALUE(id, value) gator_annotate_counter_value(0, id, value)
+#define CAM_TRACK(view_uid, track_uid, parent_track, name) gator_cam_track(view_uid, track_uid, parent_track, name)
+#define CAM_JOB(view_uid, job_uid, name, track, start_time, duration, color) gator_cam_job(view_uid, job_uid, name, track, start_time, duration, color, -1, 0, 0)
+#define CAM_JOB_DEP(view_uid, job_uid, name, track, start_time, duration, color, dependency) { \
+    uint32_t __dependency = dependency; \
+    gator_cam_job(view_uid, job_uid, name, track, start_time, duration, color, -1, 1, &__dependency); \
+}
+#define CAM_JOB_DEPS(view_uid, job_uid, name, track, start_time, duration, color, dependency_count, dependencies) gator_cam_job(view_uid, job_uid, name, track, start_time, duration, color, -1, dependency_count, dependencies)
+#define CAM_JOB_START(view_uid, job_uid, name, track, time, color) gator_cam_job_start(view_uid, job_uid, name, track, time, color)
+#define CAM_JOB_SET_DEP(view_uid, job_uid, time, dependency) { \
+    uint32_t __dependency = dependency; \
+    gator_cam_job_set_dependencies(view_uid, job_uid, time, -1, 1, &__dependency); \
+}
+#define CAM_JOB_SET_DEPS(view_uid, job_uid, time, dependency_count, dependencies) gator_cam_job_set_dependencies(view_uid, job_uid, time, -1, dependency_count, dependencies)
+#define CAM_JOB_STOP(view_uid, job_uid, time) gator_cam_job_stop(view_uid, job_uid, time)
+#define CAM_VIEW_NAME(view_uid, name) gator_cam_view_name(view_uid, name)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _KERNEL_ */
+#endif /* STREAMLINE_ANNOTATE_H */
diff --git a/include/linux/uaccess.h b/include/linux/uaccess.h
index 20668760daa0..34e9036ed4d2 100644
--- a/include/linux/uaccess.h
+++ b/include/linux/uaccess.h
@@ -11,6 +11,7 @@
 #include <asm/uaccess.h>
 
 #ifdef CONFIG_SET_FS
+
 /*
  * Force the uaccess routines to be wired up for actual userspace access,
  * overriding any possible set_fs(KERNEL_DS) still lingering around.  Undone
@@ -200,16 +201,6 @@ copy_to_user(void __user *to, const void *from, unsigned long n)
 		n = _copy_to_user(to, from, n);
 	return n;
 }
-#ifdef CONFIG_COMPAT
-static __always_inline unsigned long __must_check
-copy_in_user(void __user *to, const void __user *from, unsigned long n)
-{
-	might_fault();
-	if (access_ok(to, n) && access_ok(from, n))
-		n = raw_copy_in_user(to, from, n);
-	return n;
-}
-#endif
 
 #ifndef copy_mc_to_kernel
 /*
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index 11df3d5b40c6..07c0977666b3 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -122,6 +122,9 @@ struct usb_request {
 
 	int			status;
 	unsigned		actual;
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+	int req_map;
+#endif
 };
 
 /*-------------------------------------------------------------------------*/
@@ -722,6 +725,22 @@ struct usb_gadget_driver {
 };
 
 
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+/*-------------------------------------------------------------------------*/
+
+/**
+ * struct otg_gadget_ops - Interface between OTG core and gadget
+ *
+ * Provided by the gadget core to allow the OTG core to start/stop the gadget
+ *
+ * @start: function to start the gadget
+ * @stop: function to stop the gadget
+ */
+struct otg_gadget_ops {
+	int (*start)(struct usb_gadget *gadget);
+	int (*stop)(struct usb_gadget *gadget);
+};
+#endif
 
 /*-------------------------------------------------------------------------*/
 
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 528be670006f..7c3dd813e0f8 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -415,6 +415,22 @@ struct hc_driver {
 
 };
 
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+/**
+ * struct otg_hcd_ops - Interface between OTG core and HCD
+ *
+ * Provided by the HCD core to allow the OTG core to start/stop the HCD
+ *
+ * @add: function to add the HCD
+ * @remove: function to remove the HCD
+ */
+struct otg_hcd_ops {
+	int (*add)(struct usb_hcd *hcd,
+		   unsigned int irqnum, unsigned long irqflags);
+	void (*remove)(struct usb_hcd *hcd);
+};
+#endif
+
 static inline int hcd_giveback_urb_in_bh(struct usb_hcd *hcd)
 {
 	return hcd->driver->flags & HCD_BH;
diff --git a/include/linux/usb/otg-fsm.h b/include/linux/usb/otg-fsm.h
index 8ef7d148c149..f802ea831eba 100644
--- a/include/linux/usb/otg-fsm.h
+++ b/include/linux/usb/otg-fsm.h
@@ -19,6 +19,9 @@
 #ifndef __LINUX_USB_OTG_FSM_H
 #define __LINUX_USB_OTG_FSM_H
 
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+#include <linux/device.h>
+#endif
 #include <linux/mutex.h>
 #include <linux/errno.h>
 
@@ -35,8 +38,11 @@
 					 * OTG and EH 2.0 Charpter 6.2.3
 					 * Table:6-5
 					 */
-
+#if defined(CONFIG_CVITEK_USB_LEGACY) && defined(USB_SIM_SPEED_UP)
+#define T_HOST_REQ_POLL		(10)
+#else
 #define T_HOST_REQ_POLL		(1500)	/* 1500ms, HNP polling interval */
+#endif
 
 enum otg_fsm_timer {
 	/* Standard OTG timers */
@@ -69,11 +75,13 @@ enum otg_fsm_timer {
  *		ADP measurement taken at n-2, differs by more than CADP_THR
  * @power_up:	TRUE when the OTG device first powers up its USB system and
  *		ADP measurement taken if ADP capable
+ * @overcurrent: TRUE when overcurrent condition detected
  *
  *	A-Device state inputs
  * @a_srp_det:	TRUE if the A-device detects SRP
  * @a_vbus_vld:	TRUE when VBUS voltage is in regulation
  * @b_conn:	TRUE if the A-device detects connection from the B-device
+ * @a_srp_det_not_compliant_dev: TRUE if A-device detected not compliant device
  * @a_bus_resume: TRUE when the B-device detects that the A-device is signaling
  *		  a resume (K state)
  *	B-Device state inputs
@@ -133,12 +141,21 @@ enum otg_fsm_timer {
  * a_clr_err:	Asserted (by application ?) to clear a_vbus_err due to an
  *		overcurrent condition and causes the A-device to transition
  *		to a_wait_vfall
+ *
+ *       Timers
+ * @a_bidl_adis_tmout: TRUE when TA_BIDL_ADIS timer interrupt occurs
+ * @b_aidl_bdis_tmout: TRUE when TB_AIDL_BDIS timer interrupt occurs
+ *
  */
 struct otg_fsm {
 	/* Input */
 	int id;
 	int adp_change;
 	int power_up;
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+	int overcurrent;
+	int a_srp_det_not_compliant_dev;
+#endif
 	int a_srp_det;
 	int a_vbus_vld;
 	int b_conn;
@@ -187,6 +204,9 @@ struct otg_fsm {
 	int a_aidl_bdis_tmout;
 	int b_ase0_brst_tmout;
 	int a_bidl_adis_tmout;
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+	int b_aidl_bdis_tmout;
+#endif
 
 	struct otg_fsm_ops *ops;
 	struct usb_otg *otg;
@@ -198,6 +218,10 @@ struct otg_fsm {
 	struct delayed_work hnp_polling_work;
 	bool hnp_work_inited;
 	bool state_changed;
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+	/* for debug prints */
+	struct device *dev;
+#endif
 };
 
 struct otg_fsm_ops {
@@ -212,6 +236,9 @@ struct otg_fsm_ops {
 	void	(*del_timer)(struct otg_fsm *fsm, enum otg_fsm_timer timer);
 	int	(*start_host)(struct otg_fsm *fsm, int on);
 	int	(*start_gadget)(struct otg_fsm *fsm, int on);
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+	int	(*start_enum)(struct usb_bus *bus, unsigned int port_num);
+#endif
 };
 
 
diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 69f1b6328532..a3de13b7ec01 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -12,7 +12,76 @@
 
 #include <linux/phy/phy.h>
 #include <linux/usb/phy.h>
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+#include <linux/device.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb/otg-fsm.h>
+#endif
 
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+/**
+ * struct otg_hcd - host controller state and interface
+ *
+ * @hcd: host controller
+ * @irqnum: irq number
+ * @irqflags: irq flags
+ * @ops: otg to host controller interface
+ */
+struct otg_hcd {
+	struct usb_hcd *hcd;
+	unsigned int irqnum;
+	unsigned long irqflags;
+	struct otg_hcd_ops *ops;
+};
+
+struct usb_otg;
+
+/**
+ * struct otg_timer - otg timer data
+ *
+ * @timer: high resolution timer
+ * @timeout: timeout value
+ * @timetout_bit: pointer to variable that is set on timeout
+ * @otgd: usb otg data
+ */
+struct otg_timer {
+	struct hrtimer timer;
+	ktime_t timeout;
+	/* callback data */
+	int *timeout_bit;
+	struct usb_otg *otgd;
+};
+#endif
+
+/**
+ * struct usb_otg - usb otg controller state
+ *
+ * @default_a: Indicates we are an A device. i.e. Host.
+ * @phy: USB phy interface
+ * @usb_phy: old usb_phy interface
+ * @host: host controller bus
+ * @gadget: gadget device
+ * @state: current otg state
+ * @dev: otg controller device
+ * @caps: otg capabilities revision, hnp, srp, etc
+ * @fsm: otg finite state machine
+ * @fsm_ops: controller hooks for the state machine
+ * ------- internal use only -------
+ * @primary_hcd: primary host state and interface
+ * @shared_hcd: shared host state and interface
+ * @gadget_ops: gadget interface
+ * @timers: otg timers for state machine
+ * @list: list of otg controllers
+ * @work: otg state machine work
+ * @wq: otg state machine work queue
+ * @fsm_running: state machine running/stopped indicator
+ * @flags: to track if host/gadget is running
+ * @drd_only: dual-role mode. no otg features.
+ */
 struct usb_otg {
 	u8			default_a;
 
@@ -24,6 +93,27 @@ struct usb_otg {
 
 	enum usb_otg_state	state;
 
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+	struct device *dev;
+	struct usb_otg_caps *caps;
+	struct otg_fsm fsm;
+	struct otg_fsm_ops fsm_ops;
+
+	/* internal use only */
+	struct otg_hcd primary_hcd;
+	struct otg_hcd shared_hcd;
+	struct otg_gadget_ops *gadget_ops;
+	struct otg_timer timers[NUM_OTG_FSM_TIMERS];
+	struct list_head list;
+	struct work_struct work;
+	struct workqueue_struct *wq;
+	bool fsm_running;
+	u32 flags;
+#define OTG_FLAG_GADGET_RUNNING (1 << 0)
+#define OTG_FLAG_HOST_RUNNING (1 << 1)
+	/* use otg->fsm.lock for serializing access */
+	bool drd_only;
+#endif
 	/* bind/unbind the host controller */
 	int	(*set_host)(struct usb_otg *otg, struct usb_bus *host);
 
@@ -59,6 +149,98 @@ struct usb_otg_caps {
 
 extern const char *usb_otg_state_string(enum usb_otg_state state);
 
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+/**
+ * struct usb_otg_config - otg controller configuration
+ * @caps: otg capabilities of the controller
+ * @ops: otg fsm operations
+ * @otg_timeouts: override default otg fsm timeouts
+ */
+struct usb_otg_config {
+	struct usb_otg_caps otg_caps;
+	struct otg_fsm_ops *fsm_ops;
+	unsigned int otg_timeouts[NUM_OTG_FSM_TIMERS];
+};
+
+#if IS_ENABLED(CONFIG_USB_OTG)
+struct otg_fsm *usb_otg_register(struct device *dev,
+				 struct usb_otg_config *config,
+				 work_func_t usb_otg_specific_work);
+int usb_otg_unregister(struct device *dev);
+int usb_otg_register_hcd(struct usb_hcd *hcd, unsigned int irqnum,
+			 unsigned long irqflags, struct otg_hcd_ops *ops);
+int usb_otg_unregister_hcd(struct usb_hcd *hcd);
+int usb_otg_register_gadget(struct usb_gadget *gadget,
+			    struct otg_gadget_ops *ops);
+int usb_otg_unregister_gadget(struct usb_gadget *gadget);
+void usb_otg_sync_inputs(struct otg_fsm *fsm);
+int usb_otg_kick_fsm(struct device *hcd_gcd_device);
+struct device *usb_otg_fsm_to_dev(struct otg_fsm *fsm);
+int usb_otg_start_host(struct otg_fsm *fsm, int on);
+int usb_otg_start_gadget(struct otg_fsm *fsm, int on);
+
+#else /* CONFIG_USB_OTG */
+
+static inline struct otg_fsm *usb_otg_register(struct device *dev,
+					       struct usb_otg_config *config,
+						   work_func_t usb_otg_specific_work)
+{
+	return ERR_PTR(-ENOTSUPP);
+}
+
+static inline int usb_otg_unregister(struct device *dev)
+{
+	return -ENOTSUPP;
+}
+
+static inline int usb_otg_register_hcd(struct usb_hcd *hcd, unsigned int irqnum,
+				       unsigned long irqflags,
+				       struct otg_hcd_ops *ops)
+{
+	return -ENOTSUPP;
+}
+
+static inline int usb_otg_unregister_hcd(struct usb_hcd *hcd)
+{
+	return -ENOTSUPP;
+}
+
+static inline int usb_otg_register_gadget(struct usb_gadget *gadget,
+					  struct otg_gadget_ops *ops)
+{
+	return -ENOTSUPP;
+}
+
+static inline int usb_otg_unregister_gadget(struct usb_gadget *gadget)
+{
+	return -ENOTSUPP;
+}
+
+static inline void usb_otg_sync_inputs(struct otg_fsm *fsm)
+{
+}
+
+static inline int usb_otg_kick_fsm(struct device *hcd_gcd_device)
+{
+	return -ENOTSUPP;
+}
+
+static inline struct device *usb_otg_fsm_to_dev(struct otg_fsm *fsm)
+{
+	return NULL;
+}
+
+static inline int usb_otg_start_host(struct otg_fsm *fsm, int on)
+{
+	return -ENOTSUPP;
+}
+
+static inline int usb_otg_start_gadget(struct otg_fsm *fsm, int on)
+{
+	return -ENOTSUPP;
+}
+#endif /* CONFIG_USB_OTG */
+#endif
 /* Context: can sleep */
 static inline int
 otg_start_hnp(struct usb_otg *otg)
diff --git a/include/linux/usb/phy.h b/include/linux/usb/phy.h
index e4de6bc1f69b..5eb34ab590ab 100644
--- a/include/linux/usb/phy.h
+++ b/include/linux/usb/phy.h
@@ -61,6 +61,10 @@ enum usb_otg_state {
 	OTG_STATE_A_PERIPHERAL,
 	OTG_STATE_A_WAIT_VFALL,
 	OTG_STATE_A_VBUS_ERR,
+#if defined(CONFIG_CVITEK_USB_LEGACY)
+	/* for hnp dual role */
+	OTG_STATE_A_EXIT_HNP,
+#endif
 };
 
 struct usb_phy;
diff --git a/include/sound/cv1835_i2s.h b/include/sound/cv1835_i2s.h
new file mode 100644
index 000000000000..d2c74cb737f4
--- /dev/null
+++ b/include/sound/cv1835_i2s.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright by CV (2019)
+ */
+
+#ifndef __SOUND_CVITEK_I2S_H
+#define __SOUND_CVITEK_I2S_H
+
+#include <linux/dmaengine.h>
+#include <linux/types.h>
+
+/*
+ * struct i2s_clk_config_data - represent i2s clk configuration data
+ * @chan_nr: number of channel
+ * @data_size: number of bits per sample (8/16/24/32 bit)
+ * @sample_rate: sampling frequency (8Khz, 16Khz, 32Khz, 44Khz, 48Khz)
+ */
+struct i2s_clk_config_data {
+	int chan_nr;
+	u32 data_size;
+	u32 sample_rate;
+};
+
+struct i2s_platform_data {
+#define CVI_I2S_PLAY	(1 << 0)
+#define CVI_I2S_RECORD	(1 << 1)
+#define CVI_I2S_SLAVE	(1 << 2)
+#define CVI_I2S_MASTER	(1 << 3)
+	unsigned int cap;
+	int channel;
+	u32 snd_fmts;
+	u32 snd_rates;
+
+#define CVI_I2S_QUIRK_COMP_REG_OFFSET	(1 << 0)
+#define CVI_I2S_QUIRK_COMP_PARAM1	(1 << 1)
+	unsigned int quirks;
+	unsigned int i2s_reg_comp1;
+	unsigned int i2s_reg_comp2;
+
+	void *play_dma_data;
+	void *capture_dma_data;
+	bool (*filter)(struct dma_chan *chan, void *slave);
+	int (*i2s_clk_cfg)(struct i2s_clk_config_data *config);
+};
+
+struct i2s_dma_data {
+	void *data;
+	dma_addr_t addr;
+	u32 max_burst;
+	enum dma_slave_buswidth addr_width;
+	bool (*filter)(struct dma_chan *chan, void *slave);
+};
+
+#define ONE_CHANNEL_SUPPORT	1	/* up to 2.0 */
+#define TWO_CHANNEL_SUPPORT	2	/* up to 2.0 */
+#define FOUR_CHANNEL_SUPPORT	4	/* up to 3.1 */
+#define SIX_CHANNEL_SUPPORT	6	/* up to 5.1 */
+#define EIGHT_CHANNEL_SUPPORT	8	/* up to 7.1 */
+
+#endif /*  __SOUND_CVITEK_I2S_H */
diff --git a/include/trace/events/kmem.h b/include/trace/events/kmem.h
index f65b1f6db22d..0d8c3ca55d92 100644
--- a/include/trace/events/kmem.h
+++ b/include/trace/events/kmem.h
@@ -363,6 +363,48 @@ TRACE_EVENT(rss_stat,
 		__entry->member,
 		__entry->size)
 	);
+
+TRACE_EVENT(ion_heap_shrink,
+
+	TP_PROTO(const char *heap_name,
+		 size_t len,
+		 long total_allocated),
+
+	TP_ARGS(heap_name, len, total_allocated),
+
+	TP_STRUCT__entry(
+		__field(const char *, heap_name)
+		__field(size_t, len)
+		__field(long, total_allocated)
+	),
+
+	TP_fast_assign(
+		__entry->heap_name = heap_name;
+		__entry->len = len;
+		__entry->total_allocated = total_allocated;
+	),
+
+	TP_printk("heap_name=%s, len=%zu, total_allocated=%ld",
+		  __entry->heap_name, __entry->len, __entry->total_allocated)
+	);
+
+TRACE_EVENT(ion_heap_grow,
+		TP_PROTO(const char *heap_name, size_t len, long total_allocated),
+
+		TP_ARGS(heap_name, len, total_allocated),
+
+		TP_STRUCT__entry(__field(const char *, heap_name)
+				     __field(size_t, len)
+					     __field(long, total_allocated)),
+
+		TP_fast_assign(__entry->heap_name = heap_name; __entry->len = len;
+			   __entry->total_allocated = total_allocated;),
+
+		TP_printk("heap_name=%s, len=%zu, total_allocated=%ld",
+		      __entry->heap_name, __entry->len,
+		      __entry->total_allocated)
+		);
+
 #endif /* _TRACE_KMEM_H */
 
 /* This part must be outside protection */
diff --git a/include/uapi/asm-generic/unistd.h b/include/uapi/asm-generic/unistd.h
index 2056318988f7..15279e8d8300 100644
--- a/include/uapi/asm-generic/unistd.h
+++ b/include/uapi/asm-generic/unistd.h
@@ -383,7 +383,7 @@ __SYSCALL(__NR_syslog, sys_syslog)
 
 /* kernel/ptrace.c */
 #define __NR_ptrace 117
-__SYSCALL(__NR_ptrace, sys_ptrace)
+__SC_COMP(__NR_ptrace, sys_ptrace, compat_sys_ptrace)
 
 /* kernel/sched/core.c */
 #define __NR_sched_setparam 118
@@ -779,7 +779,7 @@ __SYSCALL(__NR_rseq, sys_rseq)
 #define __NR_kexec_file_load 294
 __SYSCALL(__NR_kexec_file_load,     sys_kexec_file_load)
 /* 295 through 402 are unassigned to sync up with generic numbers, don't use */
-#if __BITS_PER_LONG == 32
+#if defined(__SYSCALL_COMPAT) || __BITS_PER_LONG == 32
 #define __NR_clock_gettime64 403
 __SYSCALL(__NR_clock_gettime64, sys_clock_gettime)
 #define __NR_clock_settime64 404
diff --git a/include/uapi/linux/elf.h b/include/uapi/linux/elf.h
index 30f68b42eeb5..00a944834013 100644
--- a/include/uapi/linux/elf.h
+++ b/include/uapi/linux/elf.h
@@ -431,6 +431,7 @@ typedef struct elf64_shdr {
 #define NT_MIPS_DSP	0x800		/* MIPS DSP ASE registers */
 #define NT_MIPS_FP_MODE	0x801		/* MIPS floating-point mode */
 #define NT_MIPS_MSA	0x802		/* MIPS SIMD registers */
+#define NT_RISCV_VECTOR	0x900		/* RISC-V vector registers */
 
 /* Note types with note name "GNU" */
 #define NT_GNU_PROPERTY_TYPE_0	5
diff --git a/include/uapi/linux/i2c.h b/include/uapi/linux/i2c.h
index f71a1751cacf..f9832697a4ff 100644
--- a/include/uapi/linux/i2c.h
+++ b/include/uapi/linux/i2c.h
@@ -71,6 +71,7 @@ struct i2c_msg {
 	__u16 flags;
 #define I2C_M_RD		0x0001	/* read data, from slave to master */
 					/* I2C_M_RD is guaranteed to be 0x0001! */
+#define I2C_M_WRSTOP        0x0002  /* if allow stop between msg. */
 #define I2C_M_TEN		0x0010	/* this is a ten bit chip address */
 #define I2C_M_DMA_SAFE		0x0200	/* the buffer of this message is DMA safe */
 					/* makes only sense in kernelspace */
diff --git a/include/uapi/linux/media-bus-format.h b/include/uapi/linux/media-bus-format.h
index 84fa53ffb13f..52aa3e866eb2 100644
--- a/include/uapi/linux/media-bus-format.h
+++ b/include/uapi/linux/media-bus-format.h
@@ -153,6 +153,16 @@
 /* S5C73M3 sensor specific interleaved UYVY and JPEG */
 #define MEDIA_BUS_FMT_S5C_UYVY_JPEG_1X8		0x5001
 
+/* CVITEK RGBIR specific formats */
+#define MEDIA_BUS_FMT_CVI_BAYER_GRGBI_1x12	0x5101
+#define MEDIA_BUS_FMT_CVI_BAYER_RGBGI_1x12	0x5102
+#define MEDIA_BUS_FMT_CVI_BAYER_GBGRI_1x12	0x5103
+#define MEDIA_BUS_FMT_CVI_BAYER_BGRGI_1x12	0x5104
+#define MEDIA_BUS_FMT_CVI_BAYER_IGRGB_1x12	0x5105
+#define MEDIA_BUS_FMT_CVI_BAYER_IRGBG_1x12	0x5106
+#define MEDIA_BUS_FMT_CVI_BAYER_IBGRG_1x12	0x5107
+#define MEDIA_BUS_FMT_CVI_BAYER_IGBGR_1x12	0x5108
+
 /* HSV - next is	0x6002 */
 #define MEDIA_BUS_FMT_AHSV8888_1X32		0x6001
 
diff --git a/include/uapi/linux/usb/video.h b/include/uapi/linux/usb/video.h
index c58854fb7d94..d160d5bdd730 100644
--- a/include/uapi/linux/usb/video.h
+++ b/include/uapi/linux/usb/video.h
@@ -597,5 +597,63 @@ struct UVC_FRAME_MJPEG(n) {				\
 	__le32 dwFrameInterval[n];			\
 } __attribute__ ((packed))
 
+/* Frame Based Payload - 3.1.1. Frame Based Video Format Descriptor */
+struct uvc_format_framebased {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDescriptorSubType;
+	__u8  bFormatIndex;
+	__u8  bNumFrameDescriptors;
+	__u8  guidFormat[16];
+	__u8  bBitsPerPixel;
+	__u8  bDefaultFrameIndex;
+	__u8  bAspectRatioX;
+	__u8  bAspectRatioY;
+	__u8  bmInterfaceFlags;
+	__u8  bCopyProtect;
+	__u8  bVariableSize;
+} __attribute__((__packed__));
+
+#define UVC_DT_FORMAT_FRAMEBASED_SIZE			28
+
+/* Frame Based Payload - 3.1.2. Frame Based Video Frame Descriptor */
+struct uvc_frame_framebased {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDescriptorSubType;
+	__u8  bFrameIndex;
+	__u8  bmCapabilities;
+	__u16 wWidth;
+	__u16 wHeight;
+	__u32 dwMinBitRate;
+	__u32 dwMaxBitRate;
+	__u32 dwDefaultFrameInterval;
+	__u8  bFrameIntervalType;
+	__u32 dwBytesPerLine;
+	__u32 dwFrameInterval[];
+} __attribute__((__packed__));
+
+#define UVC_DT_FRAME_FRAMEBASED_SIZE(n)                        (26+4*(n))
+
+#define UVC_FRAME_FRAMEBASED(n) \
+	uvc_frame_framebased_##n
+
+#define DECLARE_UVC_FRAME_FRAMEBASED(n)		\
+struct UVC_FRAME_FRAMEBASED(n) {		\
+	__u8  bLength;				\
+	__u8  bDescriptorType;			\
+	__u8  bDescriptorSubType;		\
+	__u8  bFrameIndex;			\
+	__u8  bmCapabilities;			\
+	__u16 wWidth;				\
+	__u16 wHeight;				\
+	__u32 dwMinBitRate;			\
+	__u32 dwMaxBitRate;			\
+	__u32 dwDefaultFrameInterval;		\
+	__u8  bFrameIntervalType;		\
+	__u32 dwBytesPerLine;			\
+	__u32 dwFrameInterval[n];		\
+} __attribute__ ((packed))
+
 #endif /* __LINUX_USB_VIDEO_H */
 
diff --git a/include/uapi/linux/videodev2.h b/include/uapi/linux/videodev2.h
index 55b8c4b82479..a4856f683c61 100644
--- a/include/uapi/linux/videodev2.h
+++ b/include/uapi/linux/videodev2.h
@@ -1110,6 +1110,10 @@ static inline __u64 v4l2_timeval_to_ns(const struct timeval *tv)
 #define V4L2_BUF_FLAG_LAST			0x00100000
 /* request_fd is valid */
 #define V4L2_BUF_FLAG_REQUEST_FD		0x00800000
+/* cvitek define buf from isp_fe_0 */
+#define V4L2_BUF_FLAG_FRAME_ISP_0		0x00200000
+/* cvitek define buf from isp_fe_1 */
+#define V4L2_BUF_FLAG_FRAME_ISP_1		0x00400000
 
 /**
  * struct v4l2_exportbuffer - export of video buffer as DMABUF file descriptor
diff --git a/init/Kconfig b/init/Kconfig
index 9807c66b24bb..66ca31e52e78 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1232,6 +1232,13 @@ config SCHED_AUTOGROUP
 	  desktop applications.  Task group autogeneration is currently based
 	  upon task session.
 
+config SCHED_CVITEK
+	bool "CVITEK scheduler optimization"
+	help
+	  This option optimizes the scheduler priority and set cvitek drivers
+	  priority automatically.
+	  select it if it's cvitek bsp.
+
 config SYSFS_DEPRECATED
 	bool "Enable deprecated sysfs features to support old userspace tools"
 	depends on SYSFS
diff --git a/init/main.c b/init/main.c
index 298989b0d4e8..37f3ac318153 100644
--- a/init/main.c
+++ b/init/main.c
@@ -97,6 +97,7 @@
 #include <linux/jump_label.h>
 #include <linux/kcsan.h>
 #include <linux/init_syscalls.h>
+#include <linux/early_time_log.h>
 
 #include <asm/io.h>
 #include <asm/setup.h>
@@ -1279,6 +1280,8 @@ static void __init do_initcalls(void)
 	size_t len = strlen(saved_command_line) + 1;
 	char *command_line;
 
+	early_time_log(__func__);
+
 	command_line = kzalloc(len, GFP_KERNEL);
 	if (!command_line)
 		panic("%s: Failed to allocate %zu bytes\n", __func__, len);
@@ -1330,6 +1333,8 @@ static int run_init_process(const char *init_filename)
 	pr_debug("  with environment:\n");
 	for (p = envp_init; *p; p++)
 		pr_debug("    %s\n", *p);
+
+	early_time_log(__func__);
 	return kernel_execve(init_filename, argv_init, envp_init);
 }
 
diff --git a/kernel/Kconfig.hz b/kernel/Kconfig.hz
index 38ef6d06888e..6b3590b24c38 100644
--- a/kernel/Kconfig.hz
+++ b/kernel/Kconfig.hz
@@ -16,6 +16,8 @@ choice
 	 environment leading to NR_CPUS * HZ number of timer interrupts
 	 per second.
 
+	config HZ_12
+		bool "12 HZ"
 
 	config HZ_100
 		bool "100 HZ"
@@ -50,6 +52,7 @@ endchoice
 
 config HZ
 	int
+	default 12 if HZ_12
 	default 100 if HZ_100
 	default 250 if HZ_250
 	default 300 if HZ_300
diff --git a/kernel/compat.c b/kernel/compat.c
index f9f7a79e07c5..fb50f29d9b36 100644
--- a/kernel/compat.c
+++ b/kernel/compat.c
@@ -269,24 +269,3 @@ get_compat_sigset(sigset_t *set, const compat_sigset_t __user *compat)
 	return 0;
 }
 EXPORT_SYMBOL_GPL(get_compat_sigset);
-
-/*
- * Allocate user-space memory for the duration of a single system call,
- * in order to marshall parameters inside a compat thunk.
- */
-void __user *compat_alloc_user_space(unsigned long len)
-{
-	void __user *ptr;
-
-	/* If len would occupy more than half of the entire compat space... */
-	if (unlikely(len > (((compat_uptr_t)~0) >> 1)))
-		return NULL;
-
-	ptr = arch_compat_alloc_user_space(len);
-
-	if (unlikely(!access_ok(ptr, len)))
-		return NULL;
-
-	return ptr;
-}
-EXPORT_SYMBOL_GPL(compat_alloc_user_space);
diff --git a/kernel/module.c b/kernel/module.c
index 72a5dcdccf7b..ae1f16041e4b 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -4584,8 +4584,9 @@ static int modules_open(struct inode *inode, struct file *file)
 	int err = seq_open(file, &modules_op);
 
 	if (!err) {
-		struct seq_file *m = file->private_data;
-		m->private = kallsyms_show_value(file->f_cred) ? NULL : (void *)8ul;
+		// Show ko base address as default during KALLSYM disable.
+		// struct seq_file *m = file->private_data;
+		// m->private = kallsyms_show_value(file->f_cred) ? NULL : (void *)8ul;
 	}
 
 	return err;
diff --git a/kernel/reboot.c b/kernel/reboot.c
index af6f23d8bea1..cc5687a2f82d 100644
--- a/kernel/reboot.c
+++ b/kernel/reboot.c
@@ -416,7 +416,7 @@ void ctrl_alt_del(void)
 		kill_cad_pid(SIGINT, 1);
 }
 
-char poweroff_cmd[POWEROFF_CMD_PATH_LEN] = "/sbin/poweroff";
+char poweroff_cmd[POWEROFF_CMD_PATH_LEN] = "/sbin/poweroff -f";
 static const char reboot_cmd[] = "/sbin/reboot";
 
 static int run_cmd(const char *cmd)
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 40f40f359c5d..f4af664a0ff5 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -24,6 +24,10 @@
 #include "../../io_uring/io-wq.h"
 #include "../smpboot.h"
 
+#ifdef CONFIG_SCHED_CVITEK
+#include "cvi_sched.h"
+#endif
+
 #include "pelt.h"
 #include "smp.h"
 
@@ -5502,7 +5506,9 @@ static int _sched_setscheduler(struct task_struct *p, int policy,
 		policy &= ~SCHED_RESET_ON_FORK;
 		attr.sched_policy = policy;
 	}
-
+#ifdef CONFIG_SCHED_CVITEK
+	cvi_checkpriority(p, &attr);
+#endif
 	return __sched_setscheduler(p, &attr, check, true);
 }
 /**
@@ -5522,11 +5528,19 @@ int sched_setscheduler(struct task_struct *p, int policy,
 {
 	return _sched_setscheduler(p, policy, param, true);
 }
+EXPORT_SYMBOL_GPL(sched_setscheduler);
 
+#ifdef CONFIG_SCHED_CVITEK
+int sched_setattr(struct task_struct *p, struct sched_attr *attr)
+{
+	cvi_checkpriority(p, attr);
+#else
 int sched_setattr(struct task_struct *p, const struct sched_attr *attr)
 {
+#endif
 	return __sched_setscheduler(p, attr, true, true);
 }
+EXPORT_SYMBOL_GPL(sched_setattr);
 
 int sched_setattr_nocheck(struct task_struct *p, const struct sched_attr *attr)
 {
@@ -5551,6 +5565,7 @@ int sched_setscheduler_nocheck(struct task_struct *p, int policy,
 {
 	return _sched_setscheduler(p, policy, param, false);
 }
+EXPORT_SYMBOL_GPL(sched_setscheduler_nocheck);
 
 /*
  * SCHED_FIFO is a broken scheduler model; that is, it is fundamentally
diff --git a/kernel/sched/cvi_sched.h b/kernel/sched/cvi_sched.h
new file mode 100644
index 000000000000..eb48b0c9a4b7
--- /dev/null
+++ b/kernel/sched/cvi_sched.h
@@ -0,0 +1,49 @@
+#ifdef CONFIG_SCHED_CVITEK
+struct cvi_priority_info {
+	char comm[TASK_COMM_LEN];
+	u32 sched_policy;
+	u32 sched_priority;
+};
+static struct cvi_priority_info priority_list[] = {
+	{ "cvitask_isp_pre", SCHED_FIFO, 90 },
+	{ "cvitask_isp_pos", SCHED_FIFO, 90 },
+	{ "cvitask_vc_sb0", SCHED_RR, 99 },
+	{ "cvitask_vc_wt0", SCHED_RR, 95 },
+	{ "cvitask_vc_wt1", SCHED_RR, 95 },
+	{ "cvitask_vc_bh0", SCHED_RR, 95 },
+	{ "cvitask_vpss_0", SCHED_FIFO, 90 },
+	{ "cvitask_vpss_1", SCHED_FIFO, 90 },
+	{ "cvitask_tpu_wor", SCHED_RR, 85 }
+};
+#define MAX_OPT_RT_PRIORITY 80
+static inline void cvi_checkpriority(struct task_struct *p,
+				     struct sched_attr *attr)
+{
+	/*
+	 * Set the priority for the tasks which are in the priority_list automatically.
+	 * In the meantime, we will check the priority if the task is not belong cvitek soc driver,
+	 * modify the priority if it's trying to set scheduler to realtime scheduler and
+	 * priority higher than 80
+	 * to make sure soc driver tasks are able to finish first.
+	 */
+	int i = 0;
+
+	if (!strncmp(p->comm, "cvitask_", 8)) {
+		for (i = 0; i < sizeof(priority_list) /
+					sizeof(struct cvi_priority_info);
+		     i++) {
+			if (strcmp(priority_list[i].comm, p->comm))
+				continue;
+			attr->sched_policy = priority_list[i].sched_policy;
+			attr->sched_priority = priority_list[i].sched_priority;
+			break;
+		}
+	} else if (attr->sched_policy == SCHED_FIFO ||
+		   attr->sched_policy == SCHED_RR) {
+		attr->sched_priority =
+			attr->sched_priority > MAX_OPT_RT_PRIORITY ?
+				      MAX_OPT_RT_PRIORITY :
+				      attr->sched_priority;
+	}
+}
+#endif
diff --git a/kernel/time/Makefile b/kernel/time/Makefile
index c8f00168afe8..ac09e0420970 100644
--- a/kernel/time/Makefile
+++ b/kernel/time/Makefile
@@ -1,4 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
+obj-y += early_time_log.o
 obj-y += time.o timer.o hrtimer.o
 obj-y += timekeeping.o ntp.o clocksource.o jiffies.o timer_list.o
 obj-y += timeconv.o timecounter.o alarmtimer.o
diff --git a/kernel/time/early_time_log.c b/kernel/time/early_time_log.c
new file mode 100644
index 000000000000..8ff17f9cf0c7
--- /dev/null
+++ b/kernel/time/early_time_log.c
@@ -0,0 +1,86 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ *  linux/kernel/archtimer.c
+ *
+ *  Use arch timer before time_init()
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/seq_file.h>
+#include <linux/time.h>
+#include <linux/time_namespace.h>
+#include <linux/timex.h>
+#include <linux/kernel_stat.h>
+#include <linux/early_time_log.h>
+
+#define MAX_EARLY_TIME_LOGS 16
+
+struct early_time_entry {
+	u64 us;
+	const char *name;
+};
+
+static struct early_time_entry early_time_logs[MAX_EARLY_TIME_LOGS];
+static int early_time_logs_idx;
+
+#if defined(CONFIG_ARM_ARCH_TIMER)
+#include <asm/arch_timer.h>
+
+u64 early_time_get_us(void)
+{
+	u64 c = __arch_counter_get_cntpct();
+	u64 f = arch_timer_get_cntfrq();
+
+	do_div(f, 1000000);
+
+	do_div(c, f);
+	return c;
+}
+#elif defined(CONFIG_RISCV_TIMER)
+u64 early_time_get_us(void)
+{
+	cycles_t c = get_cycles();
+	u32 f = 25000000 / 1000000;
+
+	do_div(c, f);
+	return c;
+}
+#endif
+
+void early_time_log(const char *name)
+{
+	u64 now_us = early_time_get_us();
+
+	pr_info("%s: %s: %lluus\n", __func__, name, (unsigned long long)now_us);
+
+	if (early_time_logs_idx < MAX_EARLY_TIME_LOGS) {
+		early_time_logs[early_time_logs_idx].us = now_us;
+		early_time_logs[early_time_logs_idx].name = name;
+		early_time_logs_idx++;
+	}
+}
+EXPORT_SYMBOL_GPL(early_time_log);
+
+static int early_time_log_proc_show(struct seq_file *m, void *v)
+{
+	int i;
+
+	seq_printf(m, "now: %lluus\n", early_time_get_us());
+	for (i = 0; i < early_time_logs_idx; i++) {
+		seq_printf(m, "%s: %lluus\n", early_time_logs[i].name,
+			   (unsigned long long)early_time_logs[i].us);
+	}
+	return 0;
+}
+
+static int __init early_time_log_init(void)
+{
+	proc_create_single("early_time_log", 0, NULL, early_time_log_proc_show);
+	return 0;
+}
+fs_initcall(early_time_log_init);
diff --git a/scripts/dtc/include-prefixes/cvi_board_memmap.h b/scripts/dtc/include-prefixes/cvi_board_memmap.h
new file mode 120000
index 000000000000..bb6306658aef
--- /dev/null
+++ b/scripts/dtc/include-prefixes/cvi_board_memmap.h
@@ -0,0 +1 @@
+../../../../build/output/cv1800b_wdmb_0008a_spinor/cvi_board_memmap.h
\ No newline at end of file
diff --git a/scripts/kconfig/Makefile b/scripts/kconfig/Makefile
index e46df0a2d4f9..3bb1708bab7b 100644
--- a/scripts/kconfig/Makefile
+++ b/scripts/kconfig/Makefile
@@ -25,6 +25,38 @@ xconfig: $(obj)/qconf
 gconfig: $(obj)/gconf
 	$(Q)$< $(silent) $(Kconfig)
 
+PHONY += scriptconfig iscriptconfig kmenuconfig guiconfig dumpvarsconfig setconfig
+
+PYTHONCMD ?= python
+kpython := PYTHONPATH=$(srctree)/Kconfiglib:$$PYTHONPATH $(PYTHONCMD)
+
+ifneq ($(filter scriptconfig,$(MAKECMDGOALS)),)
+ifndef SCRIPT
+$(error Use "make scriptconfig SCRIPT=<path to script> [SCRIPT_ARG=<argument>]")
+endif
+endif
+
+scriptconfig:
+	$(Q)$(kpython) $(SCRIPT) $(Kconfig) $(if $(SCRIPT_ARG),"$(SCRIPT_ARG)")
+
+setconfig:
+	$(Q)$(kpython) $(srctree)/Kconfiglib/setconfig.py --kconfig $(Kconfig) $(SCRIPT_ARG)
+
+iscriptconfig:
+	$(Q)$(kpython) -i -c \
+	  "import kconfiglib; \
+	   kconf = kconfiglib.Kconfig('$(Kconfig)'); \
+	   print('A Kconfig instance \'kconf\' for the architecture $(ARCH) has been created.')"
+
+kmenuconfig:
+	$(Q)$(kpython) $(srctree)/Kconfiglib/menuconfig.py $(Kconfig)
+
+guiconfig:
+	$(Q)$(kpython) $(srctree)/Kconfiglib/guiconfig.py $(Kconfig)
+
+dumpvarsconfig:
+	$(Q)$(kpython) $(srctree)/Kconfiglib/examples/dumpvars.py $(Kconfig)
+
 menuconfig: $(obj)/mconf
 	$(Q)$< $(silent) $(Kconfig)
 
diff --git a/sound/last.c b/sound/last.c
index f0bb98780e70..319992c9bddc 100644
--- a/sound/last.c
+++ b/sound/last.c
@@ -16,7 +16,7 @@ static int __init alsa_sound_last_init(void)
 	for (idx = 0; idx < SNDRV_CARDS; idx++) {
 		card = snd_card_ref(idx);
 		if (card) {
-			printk(KERN_INFO "  #%i: %s\n", idx, card->longname);
+			//printk(KERN_INFO "  #%i: %s\n", idx, card->longname);
 			snd_card_unref(card);
 			ok++;
 		}
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index 71a6fe87d1a1..6bd3aff51c80 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -47,6 +47,7 @@ source "sound/soc/atmel/Kconfig"
 source "sound/soc/au1x/Kconfig"
 source "sound/soc/bcm/Kconfig"
 source "sound/soc/cirrus/Kconfig"
+source "sound/soc/cvitek/Kconfig"
 source "sound/soc/dwc/Kconfig"
 source "sound/soc/fsl/Kconfig"
 source "sound/soc/hisilicon/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index ddbac3a2169f..a73694edb5f6 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -30,6 +30,7 @@ obj-$(CONFIG_SND_SOC)	+= atmel/
 obj-$(CONFIG_SND_SOC)	+= au1x/
 obj-$(CONFIG_SND_SOC)	+= bcm/
 obj-$(CONFIG_SND_SOC)	+= cirrus/
+obj-$(CONFIG_SND_SOC)	+= cvitek/
 obj-$(CONFIG_SND_SOC)	+= dwc/
 obj-$(CONFIG_SND_SOC)	+= fsl/
 obj-$(CONFIG_SND_SOC)	+= hisilicon/
diff --git a/sound/soc/codecs/cv181xadac.h b/sound/soc/codecs/cv181xadac.h
new file mode 100644
index 000000000000..9271644e62d7
--- /dev/null
+++ b/sound/soc/codecs/cv181xadac.h
@@ -0,0 +1,683 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later
+ * CV1835 ADC driver on CVITEK CV1835
+ *
+ * Copyright 2019 CVITEK
+ *
+ * Author: EthanChen
+ *
+ */
+
+#ifndef __CV181XADAC_H__
+#define __CV181XADAC_H__
+
+#include <linux/clk.h>
+#include <linux/miscdevice.h>
+
+#define  CV182XA_ADC_BASE_OFFSET	0x100
+
+#define  AUDIO_PHY_TXDAC_CTRL0  0x0
+#define  AUDIO_PHY_TXDAC_CTRL1  0x4
+#define  AUDIO_PHY_TXDAC_STATUS  0x8
+#define  AUDIO_PHY_TXDAC_AFE0  0xc
+#define  AUDIO_PHY_TXDAC_AFE1  0x10
+#define  AUDIO_PHY_TXDAC_AFE2  0x14
+#define  AUDIO_PHY_TXDAC_CLK  0x18
+#define  AUDIO_PHY_TXDAC_ANA0  0x20
+#define  AUDIO_PHY_TXDAC_ANA1  0x24
+#define  AUDIO_PHY_TXDAC_ANA2  0x28
+#define  AUDIO_PHY_TXDAC_ANA3  0x2c
+#define  AUDIO_PHY_TXDAC_TEST  0x30
+#define  AUDIO_PHY_TXDAC_DSM_VAL  0x34
+#define  AUDIO_PHY_TXDAC_DSM_OW  0x38
+#define  AUDIO_PHY_TXDAC_EXTRA_SRC_SEL  0x3c
+
+#define  AUDIO_PHY_RXADC_CTRL0  (0x100 - CV182XA_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_CTRL1  (0x104 - CV182XA_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_STATUS  (0x108 - CV182XA_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_CLK  (0x10c - CV182XA_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_ANA0  (0x110 - CV182XA_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_ANA1  (0x114 - CV182XA_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_ANA2  (0x118 - CV182XA_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_ANA3  (0x11c - CV182XA_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_ANA4  (0x120 - CV182XA_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_ANA5  (0x124 - CV182XA_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_ANA6  (0x128 - CV182XA_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_GPIO_ANA  (0x12c - CV182XA_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_EXTRA_SRC_SEL  (0x130 - CV182XA_ADC_BASE_OFFSET)
+
+#define  AUDIO_PHY_SPARE_0  (0xff0 - CV182XA_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_SPARE_1  (0xff4 - CV182XA_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_SPARE_RO  (0xff8 - CV182XA_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_DATE_CODE  (0xffc - CV182XA_ADC_BASE_OFFSET)
+
+#define  AUDIO_PHY_REG_TXDAC_EN   0x0
+#define  AUDIO_PHY_REG_TXDAC_EN_OFFSET 0
+#define  AUDIO_PHY_REG_TXDAC_EN_MASK   0x1
+#define  AUDIO_PHY_REG_TXDAC_EN_BITS   0x1
+#define  AUDIO_PHY_REG_I2S_RX_EN   0x0
+#define  AUDIO_PHY_REG_I2S_RX_EN_OFFSET 1
+#define  AUDIO_PHY_REG_I2S_RX_EN_MASK   0x2
+#define  AUDIO_PHY_REG_I2S_RX_EN_BITS   0x1
+#define  AUDIO_PHY_REG_TXDAC_EN_ON		0x1
+#define  AUDIO_PHY_REG_TXDAC_EN_OFF		0xFFFFFFFE
+#define  AUDIO_PHY_REG_I2S_RX_EN_ON		0x2
+#define  AUDIO_PHY_REG_I2S_RX_EN_OFF	0xFFFFFFFD
+
+#define  AUDIO_PHY_REG_TXDAC_CIC_OPT   0x4
+#define  AUDIO_PHY_REG_TXDAC_CIC_OPT_OFFSET 0
+#define  AUDIO_PHY_REG_TXDAC_CIC_OPT_MASK   0x3
+#define  AUDIO_PHY_REG_TXDAC_CIC_OPT_BITS   0x2
+#define  TXDAC_CIC_DS_64	0xFFFFFFFE
+#define  TXDAC_CIC_DS_128	0x00000001
+#define  TXDAC_CIC_DS_256	0x00000002
+#define  TXDAC_CIC_DS_512	0x00000003
+#define  AUDIO_PHY_REG_TXDAC_DEM_TYPE   0x4
+#define  AUDIO_PHY_REG_TXDAC_DEM_TYPE_OFFSET 4
+#define  AUDIO_PHY_REG_TXDAC_DEM_TYPE_MASK   0x30
+#define  AUDIO_PHY_REG_TXDAC_DEM_TYPE_BITS   0x2
+#define  AUDIO_PHY_REG_TXDAC_DSM_OPT   0x4
+#define  AUDIO_PHY_REG_TXDAC_DSM_OPT_OFFSET 8
+#define  AUDIO_PHY_REG_TXDAC_DSM_OPT_MASK   0x100
+#define  AUDIO_PHY_REG_TXDAC_DSM_OPT_BITS   0x1
+#define  AUDIO_PHY_REG_TXDAC_ZCD_EN   0x4
+#define  AUDIO_PHY_REG_TXDAC_ZCD_EN_OFFSET 9
+#define  AUDIO_PHY_REG_TXDAC_ZCD_EN_MASK   0x200
+#define  AUDIO_PHY_REG_TXDAC_ZCD_EN_BITS   0x1
+#define  AUDIO_PHY_REG_TXDAC_FSM_SRC_SEL   0x4
+#define  AUDIO_PHY_REG_TXDAC_FSM_SRC_SEL_OFFSET 10
+#define  AUDIO_PHY_REG_TXDAC_FSM_SRC_SEL_MASK   0x400
+#define  AUDIO_PHY_REG_TXDAC_FSM_SRC_SEL_BITS   0x1
+#define  AUDIO_PHY_REG_TXDAC_DITHER_OPT   0x4
+#define  AUDIO_PHY_REG_TXDAC_DITHER_OPT_OFFSET 12
+#define  AUDIO_PHY_REG_TXDAC_DITHER_OPT_MASK   0x7000
+#define  AUDIO_PHY_REG_TXDAC_DITHER_OPT_BITS   0x3
+
+#define  AUDIO_PHY_REG_TXDAC_FSM   0x8
+#define  AUDIO_PHY_REG_TXDAC_FSM_OFFSET 0
+#define  AUDIO_PHY_REG_TXDAC_FSM_MASK   0x7
+#define  AUDIO_PHY_REG_TXDAC_FSM_BITS   0x3
+#define  AUDIO_PHY_REG_TXDAC_AFE_FSM   0x8
+#define  AUDIO_PHY_REG_TXDAC_AFE_FSM_OFFSET 4
+#define  AUDIO_PHY_REG_TXDAC_AFE_FSM_MASK   0x70
+#define  AUDIO_PHY_REG_TXDAC_AFE_FSM_BITS   0x3
+#define  AUDIO_PHY_REG_TXDAC_GAIN0   0x8
+#define  AUDIO_PHY_REG_TXDAC_GAIN0_OFFSET 8
+#define  AUDIO_PHY_REG_TXDAC_GAIN0_MASK   0x1ff00
+#define  AUDIO_PHY_REG_TXDAC_GAIN0_BITS   0x9
+#define  AUDIO_PHY_REG_TXDAC_GAIN1   0x8
+#define  AUDIO_PHY_REG_TXDAC_GAIN1_OFFSET 20
+#define  AUDIO_PHY_REG_TXDAC_GAIN1_MASK   0x1ff00000
+#define  AUDIO_PHY_REG_TXDAC_GAIN1_BITS   0x9
+
+#define  AUDIO_PHY_REG_TXDAC_INIT_DLY_CNT   0xc
+#define  AUDIO_PHY_REG_TXDAC_INIT_DLY_CNT_OFFSET 0
+#define  AUDIO_PHY_REG_TXDAC_INIT_DLY_CNT_MASK   0x3f
+#define  AUDIO_PHY_REG_TXDAC_INIT_DLY_CNT_BITS   0x6
+#define  AUDIO_PHY_REG_TXDAC_VALUE_TICK   0xc
+#define  AUDIO_PHY_REG_TXDAC_VALUE_TICK_OFFSET 8
+#define  AUDIO_PHY_REG_TXDAC_VALUE_TICK_MASK   0xff00
+#define  AUDIO_PHY_REG_TXDAC_VALUE_TICK_BITS   0x8
+#define  AUDIO_PHY_REG_TXDAC_GAIN_TICK   0xc
+#define  AUDIO_PHY_REG_TXDAC_GAIN_TICK_OFFSET 16
+#define  AUDIO_PHY_REG_TXDAC_GAIN_TICK_MASK   0xfff0000
+#define  AUDIO_PHY_REG_TXDAC_GAIN_TICK_BITS   0xc
+
+#define  AUDIO_PHY_REG_TXDAC_GAIN_UB_0   0x10
+#define  AUDIO_PHY_REG_TXDAC_GAIN_UB_0_OFFSET 0
+#define  AUDIO_PHY_REG_TXDAC_GAIN_UB_0_MASK   0x1ff
+#define  AUDIO_PHY_REG_TXDAC_GAIN_UB_0_BITS   0x9
+#define  AUDIO_PHY_REG_TXDAC_GAIN_UB_1   0x10
+#define  AUDIO_PHY_REG_TXDAC_GAIN_UB_1_OFFSET 16
+#define  AUDIO_PHY_REG_TXDAC_GAIN_UB_1_MASK   0x1ff0000
+#define  AUDIO_PHY_REG_TXDAC_GAIN_UB_1_BITS   0x9
+#define  AUDIO_PHY_REG_TXDAC_RAMP_BP   0x10
+#define  AUDIO_PHY_REG_TXDAC_RAMP_BP_OFFSET 28
+#define  AUDIO_PHY_REG_TXDAC_RAMP_BP_MASK   0x10000000
+#define  AUDIO_PHY_REG_TXDAC_RAMP_BP_BITS   0x1
+
+#define  AUDIO_PHY_REG_TXDAC_MIN_G_RAMP_VAL   0x14
+#define  AUDIO_PHY_REG_TXDAC_MIN_G_RAMP_VAL_OFFSET 0
+#define  AUDIO_PHY_REG_TXDAC_MIN_G_RAMP_VAL_MASK   0x1ff
+#define  AUDIO_PHY_REG_TXDAC_MIN_G_RAMP_VAL_BITS   0x9
+
+#define  AUDIO_PHY_REG_TXDAC_CLK_INV   0x18
+#define  AUDIO_PHY_REG_TXDAC_CLK_INV_OFFSET 0
+#define  AUDIO_PHY_REG_TXDAC_CLK_INV_MASK   0x1
+#define  AUDIO_PHY_REG_TXDAC_CLK_INV_BITS   0x1
+
+#define  AUDIO_PHY_REG_ADDI_TXDAC   0x20
+#define  AUDIO_PHY_REG_ADDI_TXDAC_OFFSET 0
+#define  AUDIO_PHY_REG_ADDI_TXDAC_MASK   0x1
+#define  AUDIO_PHY_REG_ADDI_TXDAC_BITS   0x1
+#define  ADDI_TXDAC_GAIN_RATIO_1	0xFFFFFFFE
+#define  ADDI_TXDAC_GAIN_RATIO_2_5	0x00000001
+#define  AUDIO_PHY_REG_TSEL_TXDAC   0x20
+#define  AUDIO_PHY_REG_TSEL_TXDAC_OFFSET 4
+#define  AUDIO_PHY_REG_TSEL_TXDAC_MASK   0x30
+#define  AUDIO_PHY_REG_TSEL_TXDAC_BITS   0x2
+#define  AUDIO_PHY_REG_VSEL_TXDAC   0x20
+#define  AUDIO_PHY_REG_VSEL_TXDAC_OFFSET 8
+#define  AUDIO_PHY_REG_VSEL_TXDAC_MASK   0x300
+#define  AUDIO_PHY_REG_VSEL_TXDAC_BITS   0x2
+
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_OW_VAL   0x24
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_OW_VAL_OFFSET 0
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_OW_VAL_MASK   0x1
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_OW_VAL_BITS   0x1
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_OW_VAL   0x24
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_OW_VAL_OFFSET 1
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_OW_VAL_MASK   0x2
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_OW_VAL_BITS   0x1
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_OW_EN   0x24
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_OW_EN_OFFSET 16
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_OW_EN_MASK   0x10000
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_OW_EN_BITS   0x1
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_OW_EN   0x24
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_OW_EN_OFFSET 17
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_OW_EN_MASK   0x20000
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_OW_EN_BITS   0x1
+
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_VAL   0x28
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_VAL_OFFSET 0
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_VAL_MASK   0xff
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_VAL_BITS   0x8
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_VAL   0x28
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_VAL_OFFSET 8
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_VAL_MASK   0xff00
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_VAL_BITS   0x8
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN   0x28
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_OFFSET 16
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_MASK   0x10000
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_BITS   0x1
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN   0x28
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_OFFSET 17
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_MASK   0x20000
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_BITS   0x1
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_ON   0x10000
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_OFF  0xFFFEFFFF
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_ON   0x20000
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_OFF  0xFFFDFFFF
+
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_STATUS   0x2c
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_STATUS_OFFSET 0
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_STATUS_MASK   0x1
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_STATUS_BITS   0x1
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_STATUS   0x2c
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_STATUS_OFFSET 1
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_STATUS_MASK   0x2
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_STATUS_BITS   0x1
+#define  AUDIO_PHY_REG_TXDAC_GAIN_RAMP_DONE   0x2c
+#define  AUDIO_PHY_REG_TXDAC_GAIN_RAMP_DONE_OFFSET 2
+#define  AUDIO_PHY_REG_TXDAC_GAIN_RAMP_DONE_MASK   0x4
+#define  AUDIO_PHY_REG_TXDAC_GAIN_RAMP_DONE_BITS   0x1
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_STATUS   0x2c
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_STATUS_OFFSET 16
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_STATUS_MASK   0xff0000
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_STATUS_BITS   0x8
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_STATUS   0x2c
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_STATUS_OFFSET 24
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_STATUS_MASK   0xff000000
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_STATUS_BITS   0x8
+
+#define  AUDIO_PHY_REG_TXDAC_I2S_BP   0x30
+#define  AUDIO_PHY_REG_TXDAC_I2S_BP_OFFSET 0
+#define  AUDIO_PHY_REG_TXDAC_I2S_BP_MASK   0x1
+#define  AUDIO_PHY_REG_TXDAC_I2S_BP_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_TO_TXDAC   0x30
+#define  AUDIO_PHY_REG_RXADC_TO_TXDAC_OFFSET 1
+#define  AUDIO_PHY_REG_RXADC_TO_TXDAC_MASK   0x2
+#define  AUDIO_PHY_REG_RXADC_TO_TXDAC_BITS   0x1
+
+#define  AUDIO_PHY_REG_TXDAC_DSM0_OW_VAL   0x34
+#define  AUDIO_PHY_REG_TXDAC_DSM0_OW_VAL_OFFSET 0
+#define  AUDIO_PHY_REG_TXDAC_DSM0_OW_VAL_MASK   0xffff
+#define  AUDIO_PHY_REG_TXDAC_DSM0_OW_VAL_BITS   0x10
+#define  AUDIO_PHY_REG_TXDAC_DSM1_OW_VAL   0x34
+#define  AUDIO_PHY_REG_TXDAC_DSM1_OW_VAL_OFFSET 16
+#define  AUDIO_PHY_REG_TXDAC_DSM1_OW_VAL_MASK   0xffff0000
+#define  AUDIO_PHY_REG_TXDAC_DSM1_OW_VAL_BITS   0x10
+
+#define  AUDIO_PHY_REG_TXDAC_DSM0_OW_EN   0x38
+#define  AUDIO_PHY_REG_TXDAC_DSM0_OW_EN_OFFSET 0
+#define  AUDIO_PHY_REG_TXDAC_DSM0_OW_EN_MASK   0x1
+#define  AUDIO_PHY_REG_TXDAC_DSM0_OW_EN_BITS   0x1
+#define  AUDIO_PHY_REG_TXDAC_DSM1_OW_EN   0x38
+#define  AUDIO_PHY_REG_TXDAC_DSM1_OW_EN_OFFSET 1
+#define  AUDIO_PHY_REG_TXDAC_DSM1_OW_EN_MASK   0x2
+#define  AUDIO_PHY_REG_TXDAC_DSM1_OW_EN_BITS   0x1
+
+#define  AUDIO_PHY_REG_TXDAC_CH0_SRC_SEL   0x3c
+#define  AUDIO_PHY_REG_TXDAC_CH0_SRC_SEL_OFFSET 0
+#define  AUDIO_PHY_REG_TXDAC_CH0_SRC_SEL_MASK   0x3
+#define  AUDIO_PHY_REG_TXDAC_CH0_SRC_SEL_BITS   0x2
+#define  AUDIO_PHY_REG_TXDAC_CH1_SRC_SEL   0x3c
+#define  AUDIO_PHY_REG_TXDAC_CH1_SRC_SEL_OFFSET 2
+#define  AUDIO_PHY_REG_TXDAC_CH1_SRC_SEL_MASK   0xc
+#define  AUDIO_PHY_REG_TXDAC_CH1_SRC_SEL_BITS   0x2
+
+#define  AUDIO_PHY_REG_RXADC_EN   0x100
+#define  AUDIO_PHY_REG_RXADC_EN_OFFSET 0
+#define  AUDIO_PHY_REG_RXADC_EN_MASK   0x1
+#define  AUDIO_PHY_REG_RXADC_EN_BITS   0x1
+#define  AUDIO_PHY_REG_I2S_TX_EN   0x100
+#define  AUDIO_PHY_REG_I2S_TX_EN_OFFSET 1
+#define  AUDIO_PHY_REG_I2S_TX_EN_MASK   0x2
+#define  AUDIO_PHY_REG_I2S_TX_EN_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_EN_ON		0x1
+#define  AUDIO_PHY_REG_RXADC_EN_OFF		0xFFFFFFFE
+#define  AUDIO_PHY_REG_I2S_TX_EN_ON		0x2
+#define  AUDIO_PHY_REG_I2S_TX_EN_OFF	0xFFFFFFFD
+
+#define  AUDIO_PHY_REG_RXADC_CIC_OPT   0x104
+#define  AUDIO_PHY_REG_RXADC_CIC_OPT_OFFSET 0
+#define  AUDIO_PHY_REG_RXADC_CIC_OPT_MASK   0x3
+#define  AUDIO_PHY_REG_RXADC_CIC_OPT_BITS   0x2
+#define  RXADC_CIC_DS_64	0xFFFFFFFE
+#define  RXADC_CIC_DS_128	0x00000001
+#define  RXADC_CIC_DS_256	0x00000002
+#define  RXADC_CIC_DS_512	0x00000003
+#define  AUDIO_PHY_REG_RXADC_CHN_SWAP   0x104
+#define  AUDIO_PHY_REG_RXADC_CHN_SWAP_OFFSET 2
+#define  AUDIO_PHY_REG_RXADC_CHN_SWAP_MASK   0x4
+#define  AUDIO_PHY_REG_RXADC_CHN_SWAP_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_SINGLE   0x104
+#define  AUDIO_PHY_REG_RXADC_SINGLE_OFFSET 3
+#define  AUDIO_PHY_REG_RXADC_SINGLE_MASK   0x8
+#define  AUDIO_PHY_REG_RXADC_SINGLE_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_DCB_OPT   0x104
+#define  AUDIO_PHY_REG_RXADC_DCB_OPT_OFFSET 4
+#define  AUDIO_PHY_REG_RXADC_DCB_OPT_MASK   0x70
+#define  AUDIO_PHY_REG_RXADC_DCB_OPT_BITS   0x3
+#define  AUDIO_PHY_REG_RXADC_IGR_INIT   0x104
+#define  AUDIO_PHY_REG_RXADC_IGR_INIT_OFFSET 8
+#define  AUDIO_PHY_REG_RXADC_IGR_INIT_MASK   0x100
+#define  AUDIO_PHY_REG_RXADC_IGR_INIT_BITS   0x1
+#define  AUDIO_ADC_IGR_INIT_EN	0x100
+#define  AUDIO_ADC_IGR_INIT_OFF	0xFFFFFEFF
+#define  AUDIO_PHY_REG_RXADC_CLK_FORCE_EN   0x104
+#define  AUDIO_PHY_REG_RXADC_CLK_FORCE_EN_OFFSET 9
+#define  AUDIO_PHY_REG_RXADC_CLK_FORCE_EN_MASK   0x200
+#define  AUDIO_PHY_REG_RXADC_CLK_FORCE_EN_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_FSM_SRC_SEL   0x104
+#define  AUDIO_PHY_REG_RXADC_FSM_SRC_SEL_OFFSET 10
+#define  AUDIO_PHY_REG_RXADC_FSM_SRC_SEL_MASK   0x400
+#define  AUDIO_PHY_REG_RXADC_FSM_SRC_SEL_BITS   0x1
+
+#define  AUDIO_PHY_REG_RXADC_CIC0_INIT_DONE   0x108
+#define  AUDIO_PHY_REG_RXADC_CIC0_INIT_DONE_OFFSET 0
+#define  AUDIO_PHY_REG_RXADC_CIC0_INIT_DONE_MASK   0x1
+#define  AUDIO_PHY_REG_RXADC_CIC0_INIT_DONE_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_FIR1_0_INIT_DONE   0x108
+#define  AUDIO_PHY_REG_RXADC_FIR1_0_INIT_DONE_OFFSET 1
+#define  AUDIO_PHY_REG_RXADC_FIR1_0_INIT_DONE_MASK   0x2
+#define  AUDIO_PHY_REG_RXADC_FIR1_0_INIT_DONE_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_FIR2_0_INIT_DONE   0x108
+#define  AUDIO_PHY_REG_RXADC_FIR2_0_INIT_DONE_OFFSET 2
+#define  AUDIO_PHY_REG_RXADC_FIR2_0_INIT_DONE_MASK   0x4
+#define  AUDIO_PHY_REG_RXADC_FIR2_0_INIT_DONE_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_CIC1_INIT_DONE   0x108
+#define  AUDIO_PHY_REG_RXADC_CIC1_INIT_DONE_OFFSET 4
+#define  AUDIO_PHY_REG_RXADC_CIC1_INIT_DONE_MASK   0x10
+#define  AUDIO_PHY_REG_RXADC_CIC1_INIT_DONE_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_FIR1_1_INIT_DONE   0x108
+#define  AUDIO_PHY_REG_RXADC_FIR1_1_INIT_DONE_OFFSET 5
+#define  AUDIO_PHY_REG_RXADC_FIR1_1_INIT_DONE_MASK   0x20
+#define  AUDIO_PHY_REG_RXADC_FIR1_1_INIT_DONE_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_FIR2_1_INIT_DONE   0x108
+#define  AUDIO_PHY_REG_RXADC_FIR2_1_INIT_DONE_OFFSET 6
+#define  AUDIO_PHY_REG_RXADC_FIR2_1_INIT_DONE_MASK   0x40
+#define  AUDIO_PHY_REG_RXADC_FIR2_1_INIT_DONE_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_FSM   0x108
+#define  AUDIO_PHY_REG_RXADC_FSM_OFFSET 8
+#define  AUDIO_PHY_REG_RXADC_FSM_MASK   0x700
+#define  AUDIO_PHY_REG_RXADC_FSM_BITS   0x3
+
+#define  AUDIO_PHY_REG_RXADC_CLK_INV   0x10c
+#define  AUDIO_PHY_REG_RXADC_CLK_INV_OFFSET 0
+#define  AUDIO_PHY_REG_RXADC_CLK_INV_MASK   0x1
+#define  AUDIO_PHY_REG_RXADC_CLK_INV_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_SCK_DIV   0x10c
+#define  AUDIO_PHY_REG_RXADC_SCK_DIV_OFFSET 8
+#define  AUDIO_PHY_REG_RXADC_SCK_DIV_MASK   0xff00
+#define  AUDIO_PHY_REG_RXADC_SCK_DIV_BITS   0x8
+#define  AUDIO_PHY_REG_RXADC_DLYEN   0x10c
+#define  AUDIO_PHY_REG_RXADC_DLYEN_OFFSET 16
+#define  AUDIO_PHY_REG_RXADC_DLYEN_MASK   0xff0000
+#define  AUDIO_PHY_REG_RXADC_DLYEN_BITS   0x8
+#define  AUDIO_RXADC_SCK_DIV_MASK		0x0000FF00
+#define  RXADC_SCK_DIV(l)		((l-1) << 8)
+#define  AUDIO_RXADC_DLYEN_MASK		0x00FF0000
+#define  RXADC_DLYEN(l)		(l << 16)
+
+
+#define  AUDIO_PHY_REG_GSTEPL_RXPGA   0x110
+#define  AUDIO_PHY_REG_GSTEPL_RXPGA_OFFSET 0
+#define  AUDIO_PHY_REG_GSTEPL_RXPGA_MASK   0x1fff
+#define  AUDIO_PHY_REG_GSTEPL_RXPGA_BITS   0xd
+#define  AUDIO_PHY_REG_G6DBL_RXPGA   0x110
+#define  AUDIO_PHY_REG_G6DBL_RXPGA_OFFSET 13
+#define  AUDIO_PHY_REG_G6DBL_RXPGA_MASK   0x2000
+#define  AUDIO_PHY_REG_G6DBL_RXPGA_BITS   0x1
+#define  AUDIO_PHY_REG_GAINL_RXADC   0x110
+#define  AUDIO_PHY_REG_GAINL_RXADC_OFFSET 14
+#define  AUDIO_PHY_REG_GAINL_RXADC_MASK   0xc000
+#define  AUDIO_PHY_REG_GAINL_RXADC_BITS   0x2
+#define  AUDIO_PHY_REG_GSTEPR_RXPGA   0x110
+#define  AUDIO_PHY_REG_GSTEPR_RXPGA_OFFSET 16
+#define  AUDIO_PHY_REG_GSTEPR_RXPGA_MASK   0x1fff0000
+#define  AUDIO_PHY_REG_GSTEPR_RXPGA_BITS   0xd
+#define  AUDIO_PHY_REG_G6DBR_RXPGA   0x110
+#define  AUDIO_PHY_REG_G6DBR_RXPGA_OFFSET 29
+#define  AUDIO_PHY_REG_G6DBR_RXPGA_MASK   0x20000000
+#define  AUDIO_PHY_REG_G6DBR_RXPGA_BITS   0x1
+#define  AUDIO_PHY_REG_GAINR_RXADC   0x110
+#define  AUDIO_PHY_REG_GAINR_RXADC_OFFSET 30
+#define  AUDIO_PHY_REG_GAINR_RXADC_MASK   0xc0000000
+#define  AUDIO_PHY_REG_GAINR_RXADC_BITS   0x2
+#define  AUDIO_PHY_REG_ADC_VOLL_MASK	  0xffff
+#define  AUDIO_PHY_REG_ADC_VOLR_MASK	  0xffff0000
+
+#define DAC_VOL_L_MASK		0x000001FF
+#define CV181X_DAC_VOL_STEP	0x8
+#define DAC_VOL_L(V) (V == 0 ? 0 : (V * CV181X_DAC_VOL_STEP) - 1)
+#define DAC_VOL_R(V) ((V == 0 ? 0 : (V * CV181X_DAC_VOL_STEP) - 1) << 16)
+
+#define  ADC_VOL_GAIN_0		0x0001 /* 0dB */
+#define  ADC_VOL_GAIN_1		0x0002 /* 2dB */
+#define  ADC_VOL_GAIN_2		0x0004 /* 4dB */
+#define  ADC_VOL_GAIN_3		0x0008 /* 6dB */
+#define  ADC_VOL_GAIN_4		0x0010 /* 8dB */
+#define  ADC_VOL_GAIN_5		0x0020 /* 10dB */
+#define  ADC_VOL_GAIN_6		0x0040 /* 12dB */
+#define  ADC_VOL_GAIN_7		0x0080 /* 14dB */
+#define  ADC_VOL_GAIN_8		0x0100 /* 16dB */
+#define  ADC_VOL_GAIN_9		0x0200 /* 18dB */
+#define  ADC_VOL_GAIN_10		0x0400 /* 20dB */
+#define  ADC_VOL_GAIN_11		0x0800 /* 22dB */
+#define  ADC_VOL_GAIN_12		0x1000 /* 24dB */
+#define  ADC_VOL_GAIN_13		0x2400 /* 26dB */
+#define  ADC_VOL_GAIN_14		0x2800 /* 28dB */
+#define  ADC_VOL_GAIN_15		0x3000 /* 30dB */
+#define  ADC_VOL_GAIN_16		0x6400 /* 32dB */
+#define  ADC_VOL_GAIN_17		0x6800 /* 34dB */
+#define  ADC_VOL_GAIN_18		0x7000 /* 36dB */
+#define  ADC_VOL_GAIN_19		0xA400 /* 38dB */
+#define  ADC_VOL_GAIN_20		0xA800 /* 40dB */
+#define  ADC_VOL_GAIN_21		0xB000 /* 42dB */
+#define  ADC_VOL_GAIN_22		0xE400 /* 44dB */
+#define  ADC_VOL_GAIN_23		0xE800 /* 46dB */
+#define  ADC_VOL_GAIN_24		0xF000 /* 48dB */
+
+#define ADC_VOL_L(V) (ADC_VOL_GAIN_##V)
+#define ADC_VOL_R(V) (ADC_VOL_GAIN_##V << 16)
+
+#define  AUDIO_PHY_REG_GAINL_STATUS   0x114
+#define  AUDIO_PHY_REG_GAINL_STATUS_OFFSET 0
+#define  AUDIO_PHY_REG_GAINL_STATUS_MASK   0xffff
+#define  AUDIO_PHY_REG_GAINL_STATUS_BITS   0x10
+#define  AUDIO_PHY_REG_GAINR_STATUS   0x114
+#define  AUDIO_PHY_REG_GAINR_STATUS_OFFSET 16
+#define  AUDIO_PHY_REG_GAINR_STATUS_MASK   0xffff0000
+#define  AUDIO_PHY_REG_GAINR_STATUS_BITS   0x10
+
+
+#define  AUDIO_PHY_REG_MUTEL_RXPGA   0x118
+#define  AUDIO_PHY_REG_MUTEL_RXPGA_OFFSET 0
+#define  AUDIO_PHY_REG_MUTEL_RXPGA_MASK   0x1
+#define  AUDIO_PHY_REG_MUTEL_RXPGA_BITS   0x1
+#define  AUDIO_PHY_REG_MUTER_RXPGA   0x118
+#define  AUDIO_PHY_REG_MUTER_RXPGA_OFFSET 1
+#define  AUDIO_PHY_REG_MUTER_RXPGA_MASK   0x2
+#define  AUDIO_PHY_REG_MUTER_RXPGA_BITS   0x1
+#define  AUDIO_PHY_REG_DIFF_EN_RXPGA   0x118
+#define  AUDIO_PHY_REG_DIFF_EN_RXPGA_OFFSET 16
+#define  AUDIO_PHY_REG_DIFF_EN_RXPGA_MASK   0x10000
+#define  AUDIO_PHY_REG_DIFF_EN_RXPGA_BITS   0x1
+#define  AUDIO_PHY_REG_TRISTATE_RXPGA   0x118
+#define  AUDIO_PHY_REG_TRISTATE_RXPGA_OFFSET 17
+#define  AUDIO_PHY_REG_TRISTATE_RXPGA_MASK   0x20000
+#define  AUDIO_PHY_REG_TRISTATE_RXPGA_BITS   0x1
+#define  AUDIO_PHY_REG_MUTEL_ON   0x1
+#define  AUDIO_PHY_REG_MUTEL_OFF  0xFFFFFFFE
+#define  AUDIO_PHY_REG_MUTER_ON   0x2
+#define  AUDIO_PHY_REG_MUTER_OFF  0xFFFFFFFD
+
+#define  AUDIO_PHY_REG_ADDI_RXADC   0x11c
+#define  AUDIO_PHY_REG_ADDI_RXADC_OFFSET 0
+#define  AUDIO_PHY_REG_ADDI_RXADC_MASK   0x1
+#define  AUDIO_PHY_REG_ADDI_RXADC_BITS   0x1
+#define  AUDIO_PHY_REG_CKSEL_RXADC   0x11c
+#define  AUDIO_PHY_REG_CKSEL_RXADC_OFFSET 1
+#define  AUDIO_PHY_REG_CKSEL_RXADC_MASK   0x2
+#define  AUDIO_PHY_REG_CKSEL_RXADC_BITS   0x1
+#define  AUDIO_PHY_REG_EN_ASAR_I_RXADC   0x11c
+#define  AUDIO_PHY_REG_EN_ASAR_I_RXADC_OFFSET 2
+#define  AUDIO_PHY_REG_EN_ASAR_I_RXADC_MASK   0x4
+#define  AUDIO_PHY_REG_EN_ASAR_I_RXADC_BITS   0x1
+#define  AUDIO_PHY_REG_EN_ASAR_Q_RXADC   0x11c
+#define  AUDIO_PHY_REG_EN_ASAR_Q_RXADC_OFFSET 3
+#define  AUDIO_PHY_REG_EN_ASAR_Q_RXADC_MASK   0x8
+#define  AUDIO_PHY_REG_EN_ASAR_Q_RXADC_BITS   0x1
+#define  AUDIO_PHY_REG_DEM_TYPE_RXADC   0x11c
+#define  AUDIO_PHY_REG_DEM_TYPE_RXADC_OFFSET 4
+#define  AUDIO_PHY_REG_DEM_TYPE_RXADC_MASK   0x30
+#define  AUDIO_PHY_REG_DEM_TYPE_RXADC_BITS   0x2
+#define  AUDIO_PHY_REG_CTUNE_RXADC   0x11c
+#define  AUDIO_PHY_REG_CTUNE_RXADC_OFFSET 8
+#define  AUDIO_PHY_REG_CTUNE_RXADC_MASK   0xf00
+#define  AUDIO_PHY_REG_CTUNE_RXADC_BITS   0x4
+#define  RXADC_CTUNE_MCLK_4096	(0xF << AUDIO_PHY_REG_CTUNE_RXADC_OFFSET)
+#define  RXADC_CTUNE_MCLK_5644	(0xA << AUDIO_PHY_REG_CTUNE_RXADC_OFFSET)
+#define  RXADC_CTUNE_MCLK_8192	(0x4 << AUDIO_PHY_REG_CTUNE_RXADC_OFFSET)
+#define  RXADC_CTUNE_MCLK_11298	(0xD << AUDIO_PHY_REG_CTUNE_RXADC_OFFSET)
+#define  RXADC_CTUNE_MCLK_12288	(0xC << AUDIO_PHY_REG_CTUNE_RXADC_OFFSET)
+#define  RXADC_CTUNE_MCLK_16384	(0x8 << AUDIO_PHY_REG_CTUNE_RXADC_OFFSET)
+#define  AUDIO_PHY_REG_EN_DITHER_RXADC   0x11c
+#define  AUDIO_PHY_REG_EN_DITHER_RXADC_OFFSET 12
+#define  AUDIO_PHY_REG_EN_DITHER_RXADC_MASK   0x1000
+#define  AUDIO_PHY_REG_EN_DITHER_RXADC_BITS   0x1
+#define  AUDIO_PHY_REG_RSTSDM_RXADC   0x11c
+#define  AUDIO_PHY_REG_RSTSDM_RXADC_OFFSET 13
+#define  AUDIO_PHY_REG_RSTSDM_RXADC_MASK   0x2000
+#define  AUDIO_PHY_REG_RSTSDM_RXADC_BITS   0x1
+#define  AUDIO_PHY_REG_EN_VCMT_RXADC   0x11c
+#define  AUDIO_PHY_REG_EN_VCMT_RXADC_OFFSET 14
+#define  AUDIO_PHY_REG_EN_VCMT_RXADC_MASK   0x4000
+#define  AUDIO_PHY_REG_EN_VCMT_RXADC_BITS   0x1
+#define  AUDIO_PHY_REG_VLDO0P9_RXADC   0x11c
+#define  AUDIO_PHY_REG_VLDO0P9_RXADC_OFFSET 16
+#define  AUDIO_PHY_REG_VLDO0P9_RXADC_MASK   0x30000
+#define  AUDIO_PHY_REG_VLDO0P9_RXADC_BITS   0x2
+#define  AUDIO_PHY_REG_VLDO12_RXADC   0x11c
+#define  AUDIO_PHY_REG_VLDO12_RXADC_OFFSET 18
+#define  AUDIO_PHY_REG_VLDO12_RXADC_MASK   0xc0000
+#define  AUDIO_PHY_REG_VLDO12_RXADC_BITS   0x2
+#define  AUDIO_PHY_REG_RNLVL_RXADC   0x11c
+#define  AUDIO_PHY_REG_RNLVL_RXADC_OFFSET 20
+#define  AUDIO_PHY_REG_RNLVL_RXADC_MASK   0x300000
+#define  AUDIO_PHY_REG_RNLVL_RXADC_BITS   0x2
+
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_STATUS   0x120
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_STATUS_OFFSET 0
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_STATUS_MASK   0x1
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_STATUS_BITS   0x1
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_STATUS   0x120
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_STATUS_OFFSET 1
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_STATUS_MASK   0x2
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_STATUS_BITS   0x1
+#define  AUDIO_PHY_REG_DA_EN_RXADC_STATUS   0x120
+#define  AUDIO_PHY_REG_DA_EN_RXADC_STATUS_OFFSET 2
+#define  AUDIO_PHY_REG_DA_EN_RXADC_STATUS_MASK   0x4
+#define  AUDIO_PHY_REG_DA_EN_RXADC_STATUS_BITS   0x1
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_STATUS   0x120
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_STATUS_OFFSET 3
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_STATUS_MASK   0x8
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_STATUS_BITS   0x1
+#define  AUDIO_PHY_REG_AD_DOL_RXADC   0x120
+#define  AUDIO_PHY_REG_AD_DOL_RXADC_OFFSET 16
+#define  AUDIO_PHY_REG_AD_DOL_RXADC_MASK   0x70000
+#define  AUDIO_PHY_REG_AD_DOL_RXADC_BITS   0x3
+#define  AUDIO_PHY_REG_AD_DOR_RXADC   0x120
+#define  AUDIO_PHY_REG_AD_DOR_RXADC_OFFSET 20
+#define  AUDIO_PHY_REG_AD_DOR_RXADC_MASK   0x700000
+#define  AUDIO_PHY_REG_AD_DOR_RXADC_BITS   0x3
+
+#define  AUDIO_PHY_REG_TESTEN_AUDBIAS   0x124
+#define  AUDIO_PHY_REG_TESTEN_AUDBIAS_OFFSET 0
+#define  AUDIO_PHY_REG_TESTEN_AUDBIAS_MASK   0x1
+#define  AUDIO_PHY_REG_TESTEN_AUDBIAS_BITS   0x1
+#define  AUDIO_PHY_REG_TESTEN_RXPGA   0x124
+#define  AUDIO_PHY_REG_TESTEN_RXPGA_OFFSET 1
+#define  AUDIO_PHY_REG_TESTEN_RXPGA_MASK   0x2
+#define  AUDIO_PHY_REG_TESTEN_RXPGA_BITS   0x1
+#define  AUDIO_PHY_REG_TSEL_RXADC   0x124
+#define  AUDIO_PHY_REG_TSEL_RXADC_OFFSET 2
+#define  AUDIO_PHY_REG_TSEL_RXADC_MASK   0xc
+#define  AUDIO_PHY_REG_TSEL_RXADC_BITS   0x2
+#define  AUDIO_PHY_REG_AUD_VREF_FC   0x124
+#define  AUDIO_PHY_REG_AUD_VREF_FC_OFFSET 8
+#define  AUDIO_PHY_REG_AUD_VREF_FC_MASK   0x100
+#define  AUDIO_PHY_REG_AUD_VREF_FC_BITS   0x1
+
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_OW_VAL   0x128
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_OW_VAL_OFFSET 0
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_OW_VAL_MASK   0x1
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_OW_VAL_BITS   0x1
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_OW_VAL   0x128
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_OW_VAL_OFFSET 1
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_OW_VAL_MASK   0x2
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_OW_VAL_BITS   0x1
+#define  AUDIO_PHY_REG_DA_EN_RXADC_OW_VAL   0x128
+#define  AUDIO_PHY_REG_DA_EN_RXADC_OW_VAL_OFFSET 2
+#define  AUDIO_PHY_REG_DA_EN_RXADC_OW_VAL_MASK   0x4
+#define  AUDIO_PHY_REG_DA_EN_RXADC_OW_VAL_BITS   0x1
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_OW_VAL   0x128
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_OW_VAL_OFFSET 3
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_OW_VAL_MASK   0x8
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_OW_VAL_BITS   0x1
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_OW_EN   0x128
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_OW_EN_OFFSET 16
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_OW_EN_MASK   0x10000
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_OW_EN_BITS   0x1
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_OW_EN   0x128
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_OW_EN_OFFSET 17
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_OW_EN_MASK   0x20000
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_OW_EN_BITS   0x1
+#define  AUDIO_PHY_REG_DA_EN_RXADC_OW_EN   0x128
+#define  AUDIO_PHY_REG_DA_EN_RXADC_OW_EN_OFFSET 18
+#define  AUDIO_PHY_REG_DA_EN_RXADC_OW_EN_MASK   0x40000
+#define  AUDIO_PHY_REG_DA_EN_RXADC_OW_EN_BITS   0x1
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_OW_EN   0x128
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_OW_EN_OFFSET 19
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_OW_EN_MASK   0x80000
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_OW_EN_BITS   0x1
+
+#define  AUDIO_PHY_REG_GPIO_IEN   0x12c
+#define  AUDIO_PHY_REG_GPIO_IEN_OFFSET 0
+#define  AUDIO_PHY_REG_GPIO_IEN_MASK   0xf
+#define  AUDIO_PHY_REG_GPIO_IEN_BITS   0x4
+#define  AUDIO_PHY_REG_GPIO_DRV   0x12c
+#define  AUDIO_PHY_REG_GPIO_DRV_OFFSET 4
+#define  AUDIO_PHY_REG_GPIO_DRV_MASK   0xf0
+#define  AUDIO_PHY_REG_GPIO_DRV_BITS   0x4
+#define  AUDIO_PHY_REG_GPIO_C   0x12c
+#define  AUDIO_PHY_REG_GPIO_C_OFFSET 16
+#define  AUDIO_PHY_REG_GPIO_C_MASK   0xf0000
+#define  AUDIO_PHY_REG_GPIO_C_BITS   0x4
+
+#define  AUDIO_PHY_REG_SPARE0   0xff0
+#define  AUDIO_PHY_REG_SPARE0_OFFSET 0
+#define  AUDIO_PHY_REG_SPARE0_MASK   0xffffffff
+#define  AUDIO_PHY_REG_SPARE0_BITS   0x20
+
+#define  AUDIO_PHY_REG_RXADC_CH0_SRC_SEL   0x130
+#define  AUDIO_PHY_REG_RXADC_CH0_SRC_SEL_OFFSET 0
+#define  AUDIO_PHY_REG_RXADC_CH0_SRC_SEL_MASK   0x3
+#define  AUDIO_PHY_REG_RXADC_CH0_SRC_SEL_BITS   0x2
+#define  AUDIO_PHY_REG_RXADC_CH1_SRC_SEL   0x130
+#define  AUDIO_PHY_REG_RXADC_CH1_SRC_SEL_OFFSET 2
+#define  AUDIO_PHY_REG_RXADC_CH1_SRC_SEL_MASK   0xc
+#define  AUDIO_PHY_REG_RXADC_CH1_SRC_SEL_BITS   0x2
+
+#define  AUDIO_PHY_REG_SPARE0   0xff0
+#define  AUDIO_PHY_REG_SPARE0_OFFSET 0
+#define  AUDIO_PHY_REG_SPARE0_MASK   0xffffffff
+#define  AUDIO_PHY_REG_SPARE0_BITS   0x20
+
+#define  AUDIO_PHY_REG_SPARE1   0xff4
+#define  AUDIO_PHY_REG_SPARE1_OFFSET 0
+#define  AUDIO_PHY_REG_SPARE1_MASK   0xffff
+#define  AUDIO_PHY_REG_SPARE1_BITS   0x10
+
+#define  AUDIO_PHY_REG_SPARE_RO   0xff8
+#define  AUDIO_PHY_REG_SPARE_RO_OFFSET 0
+#define  AUDIO_PHY_REG_SPARE_RO_MASK   0xffffffff
+#define  AUDIO_PHY_REG_SPARE_RO_BITS   0x20
+
+#define  AUDIO_PHY_REG_DATE_CODE   0xffc
+#define  AUDIO_PHY_REG_DATE_CODE_OFFSET 0
+#define  AUDIO_PHY_REG_DATE_CODE_MASK   0xffffffff
+#define  AUDIO_PHY_REG_DATE_CODE_BITS   0x20
+
+#define CVI_I2S_EN						0x18
+#define CVI_I2S_CLK_CTRL0				0x60
+#define CVI_I2S_CLK_CTRL1				0x64
+#define CVI_I2S_MCLK_OUT_EN_MASK		0x00000080
+#define CVI_I2S_MCLK_OUT_EN				BIT(7)
+#define CVI_I2S_MCLK_OUT_OFF			0xFFFFFF7F
+#define CVI_I2S_AU_EN_MASK				0x00000100
+#define CVI_I2S_AU_EN					BIT(8)
+#define CVI_I2S_AU_OFF					0xFFFFFEFF
+
+#define CVI_I2S_MCLK_MASK		0x0000FFFF
+#define CVI_I2S_MCLK_DIV(l)             ((l << 0) & 0x0000FFFF)
+
+
+#ifdef CONFIG_PM_SLEEP
+/* Store GPIO context across system-wide suspend/resume transitions */
+struct cv181xadc_context {
+	u32 ctl0;
+	u32 ctl1;
+	u32 status;
+	u32 ana0;
+	u32 ana2;
+	u32 ana3;
+};
+
+struct cv181xdac_context {
+	u32 ctl0;
+	u32 ctl1;
+	u32 afe0;
+	u32 afe1;
+	u32 ana0;
+	u32 ana1;
+	u32 ana2;
+};
+#endif
+
+struct cv181xadc {
+	void __iomem *adc_base;
+	struct clk *clk;
+	struct device *dev;
+	struct miscdevice miscdev;
+	void __iomem *mclk_source;
+	struct mutex mutex;
+#ifdef CONFIG_PM_SLEEP
+	struct cv181xadc_context *reg_ctx;
+#endif
+};
+
+struct cv181xdac {
+	void __iomem *dac_base;
+	struct clk *clk;
+	struct device *dev;
+	struct miscdevice miscdev;
+	struct mutex mutex;
+#ifdef CONFIG_PM_SLEEP
+	struct cv181xdac_context *reg_ctx;
+#endif
+};
+
+extern struct proc_dir_entry *proc_audio_dir;
+
+#endif  /* __CV181XADAC_H__ */
diff --git a/sound/soc/codecs/cv182xadac.h b/sound/soc/codecs/cv182xadac.h
new file mode 100644
index 000000000000..23a2b3c7d6a6
--- /dev/null
+++ b/sound/soc/codecs/cv182xadac.h
@@ -0,0 +1,578 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later
+ * CV1835 ADC driver on CVITEK CV1835
+ *
+ * Copyright 2019 CVITEK
+ *
+ * Author: EthanChen
+ *
+ */
+
+#ifndef __CV182XADAC_H__
+#define __CV182XADAC_H__
+
+#include <linux/clk.h>
+#include <linux/miscdevice.h>
+
+#define  CV182X_ADC_BASE_OFFSET	0x100
+
+#define  AUDIO_PHY_TXDAC_CTRL0  0x0
+#define  AUDIO_PHY_TXDAC_CTRL1  0x4
+#define  AUDIO_PHY_TXDAC_STATUS  0x8
+#define  AUDIO_PHY_TXDAC_AFE0  0xc
+#define  AUDIO_PHY_TXDAC_AFE1  0x10
+#define  AUDIO_PHY_TXDAC_ANA0  0x20
+#define  AUDIO_PHY_TXDAC_ANA1  0x24
+#define  AUDIO_PHY_TXDAC_ANA2  0x28
+#define  AUDIO_PHY_TXDAC_ANA3  0x2c
+#define  AUDIO_PHY_TXDAC_TEST  0x30
+#define  AUDIO_PHY_RXADC_CTRL0  (0x100 - CV182X_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_CTRL1  (0x104 - CV182X_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_STATUS  (0x108 - CV182X_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_ANA0  (0x110 - CV182X_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_ANA1  (0x114 - CV182X_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_ANA2  (0x118 - CV182X_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_ANA3  (0x11c - CV182X_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_ANA4  (0x120 - CV182X_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_ANA5  (0x124 - CV182X_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_RXADC_ANA6  (0x128 - CV182X_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_GPIO_ANA  (0x12c - CV182X_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_SPARE_0  (0xff0 - CV182X_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_SPARE_1  (0xff4 - CV182X_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_SPARE_RO  (0xff8 - CV182X_ADC_BASE_OFFSET)
+#define  AUDIO_PHY_DATE_CODE  (0xffc - CV182X_ADC_BASE_OFFSET)
+
+#define  AUDIO_PHY_REG_TXDAC_EN   0x0
+#define  AUDIO_PHY_REG_TXDAC_EN_OFFSET 0
+#define  AUDIO_PHY_REG_TXDAC_EN_MASK   0x1
+#define  AUDIO_PHY_REG_TXDAC_EN_BITS   0x1
+#define  AUDIO_PHY_REG_I2S_RX_EN   0x0
+#define  AUDIO_PHY_REG_I2S_RX_EN_OFFSET 1
+#define  AUDIO_PHY_REG_I2S_RX_EN_MASK   0x2
+#define  AUDIO_PHY_REG_I2S_RX_EN_BITS   0x1
+#define  AUDIO_PHY_REG_TXDAC_EN_ON		0x1
+#define  AUDIO_PHY_REG_TXDAC_EN_OFF		0xFFFFFFFE
+#define  AUDIO_PHY_REG_I2S_RX_EN_ON		0x2
+#define  AUDIO_PHY_REG_I2S_RX_EN_OFF	0xFFFFFFFD
+
+#define  AUDIO_PHY_REG_TXDAC_CIC_OPT   0x4
+#define  AUDIO_PHY_REG_TXDAC_CIC_OPT_OFFSET 0
+#define  AUDIO_PHY_REG_TXDAC_CIC_OPT_MASK   0x1
+#define  AUDIO_PHY_REG_TXDAC_CIC_OPT_BITS   0x1
+#define  TXDAC_CIC_DS_64	0xFFFFFFFE
+#define  TXDAC_CIC_DS_128	0x00000001
+#define  AUDIO_PHY_REG_TXDAC_FSM_SRC_SEL   0x4
+#define  AUDIO_PHY_REG_TXDAC_FSM_SRC_SEL_OFFSET 1
+#define  AUDIO_PHY_REG_TXDAC_FSM_SRC_SEL_MASK   0x2
+#define  AUDIO_PHY_REG_TXDAC_FSM_SRC_SEL_BITS   0x1
+#define  AUDIO_PHY_REG_TXDAC_DEM_TYPE   0x4
+#define  AUDIO_PHY_REG_TXDAC_DEM_TYPE_OFFSET 4
+#define  AUDIO_PHY_REG_TXDAC_DEM_TYPE_MASK   0x30
+#define  AUDIO_PHY_REG_TXDAC_DEM_TYPE_BITS   0x2
+#define  AUDIO_PHY_REG_TXDAC_DSM_OPT   0x4
+#define  AUDIO_PHY_REG_TXDAC_DSM_OPT_OFFSET 8
+#define  AUDIO_PHY_REG_TXDAC_DSM_OPT_MASK   0x100
+#define  AUDIO_PHY_REG_TXDAC_DSM_OPT_BITS   0x1
+#define  AUDIO_PHY_REG_TXDAC_DITHER_OPT   0x4
+#define  AUDIO_PHY_REG_TXDAC_DITHER_OPT_OFFSET 12
+#define  AUDIO_PHY_REG_TXDAC_DITHER_OPT_MASK   0x7000
+#define  AUDIO_PHY_REG_TXDAC_DITHER_OPT_BITS   0x3
+
+#define  AUDIO_PHY_REG_TXDAC_FSM   0x8
+#define  AUDIO_PHY_REG_TXDAC_FSM_OFFSET 0
+#define  AUDIO_PHY_REG_TXDAC_FSM_MASK   0x7
+#define  AUDIO_PHY_REG_TXDAC_FSM_BITS   0x3
+#define  AUDIO_PHY_REG_TXDAC_AFE_FSM   0x8
+#define  AUDIO_PHY_REG_TXDAC_AFE_FSM_OFFSET 4
+#define  AUDIO_PHY_REG_TXDAC_AFE_FSM_MASK   0x70
+#define  AUDIO_PHY_REG_TXDAC_AFE_FSM_BITS   0x3
+#define  AUDIO_PHY_REG_TXDAC_GAIN0   0x8
+#define  AUDIO_PHY_REG_TXDAC_GAIN0_OFFSET 8
+#define  AUDIO_PHY_REG_TXDAC_GAIN0_MASK   0x1ff00
+#define  AUDIO_PHY_REG_TXDAC_GAIN0_BITS   0x9
+#define  AUDIO_PHY_REG_TXDAC_GAIN1   0x8
+#define  AUDIO_PHY_REG_TXDAC_GAIN1_OFFSET 20
+#define  AUDIO_PHY_REG_TXDAC_GAIN1_MASK   0x1ff00000
+#define  AUDIO_PHY_REG_TXDAC_GAIN1_BITS   0x9
+#define  AUDIO_PHY_REG_TXDAC_TICK_NUM   0xc
+#define  AUDIO_PHY_REG_TXDAC_TICK_NUM_OFFSET 0
+#define  AUDIO_PHY_REG_TXDAC_TICK_NUM_MASK   0xff
+#define  AUDIO_PHY_REG_TXDAC_TICK_NUM_BITS   0x8
+
+#define  AUDIO_PHY_REG_TXDAC_GAIN_UB_0   0x10
+#define  AUDIO_PHY_REG_TXDAC_GAIN_UB_0_OFFSET 0
+#define  AUDIO_PHY_REG_TXDAC_GAIN_UB_0_MASK   0x1ff
+#define  AUDIO_PHY_REG_TXDAC_GAIN_UB_0_BITS   0x9
+#define  AUDIO_PHY_REG_TXDAC_GAIN_UB_1   0x10
+#define  AUDIO_PHY_REG_TXDAC_GAIN_UB_1_OFFSET 16
+#define  AUDIO_PHY_REG_TXDAC_GAIN_UB_1_MASK   0x1ff0000
+#define  AUDIO_PHY_REG_TXDAC_GAIN_UB_1_BITS   0x9
+#define  AUDIO_PHY_REG_TXDAC_RAMP_BP   0x10
+#define  AUDIO_PHY_REG_TXDAC_RAMP_BP_OFFSET 28
+#define  AUDIO_PHY_REG_TXDAC_RAMP_BP_MASK   0x10000000
+#define  AUDIO_PHY_REG_TXDAC_RAMP_BP_BITS   0x1
+
+#define  AUDIO_PHY_REG_ADDI_TXDAC   0x20
+#define  AUDIO_PHY_REG_ADDI_TXDAC_OFFSET 0
+#define  AUDIO_PHY_REG_ADDI_TXDAC_MASK   0x1
+#define  AUDIO_PHY_REG_ADDI_TXDAC_BITS   0x1
+#define  ADDI_TXDAC_GAIN_RATIO_1	0xFFFFFFFE
+#define  ADDI_TXDAC_GAIN_RATIO_2_5	0x00000001
+#define  AUDIO_PHY_REG_TSEL_TXDAC   0x20
+#define  AUDIO_PHY_REG_TSEL_TXDAC_OFFSET 4
+#define  AUDIO_PHY_REG_TSEL_TXDAC_MASK   0x30
+#define  AUDIO_PHY_REG_TSEL_TXDAC_BITS   0x2
+#define  AUDIO_PHY_REG_VSEL_TXDAC   0x20
+#define  AUDIO_PHY_REG_VSEL_TXDAC_OFFSET 8
+#define  AUDIO_PHY_REG_VSEL_TXDAC_MASK   0x300
+#define  AUDIO_PHY_REG_VSEL_TXDAC_BITS   0x2
+
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_OW_VAL   0x24
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_OW_VAL_OFFSET 0
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_OW_VAL_MASK   0x1
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_OW_VAL_BITS   0x1
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_OW_VAL   0x24
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_OW_VAL_OFFSET 1
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_OW_VAL_MASK   0x2
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_OW_VAL_BITS   0x1
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_OW_EN   0x24
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_OW_EN_OFFSET 16
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_OW_EN_MASK   0x10000
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_OW_EN_BITS   0x1
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_OW_EN   0x24
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_OW_EN_OFFSET 17
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_OW_EN_MASK   0x20000
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_OW_EN_BITS   0x1
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_VAL   0x28
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_VAL_OFFSET 0
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_VAL_MASK   0xff
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_VAL_BITS   0x8
+
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_VAL   0x28
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_VAL_OFFSET 8
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_VAL_MASK   0xff00
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_VAL_BITS   0x8
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN   0x28
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_OFFSET 16
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_MASK   0x10000
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_BITS   0x1
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN   0x28
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_OFFSET 17
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_MASK   0x20000
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_BITS   0x1
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_ON   0x10000
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_OFF  0xFFFEFFFF
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_ON   0x20000
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_OFF  0xFFFDFFFF
+
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_STATUS   0x2c
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_STATUS_OFFSET 0
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_STATUS_MASK   0x1
+#define  AUDIO_PHY_REG_DA_EN_TXDAC_STATUS_BITS   0x1
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_STATUS   0x2c
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_STATUS_OFFSET 1
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_STATUS_MASK   0x2
+#define  AUDIO_PHY_REG_DA_END2US_TXDAC_STATUS_BITS   0x1
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_STATUS   0x2c
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_STATUS_OFFSET 16
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_STATUS_MASK   0xff0000
+#define  AUDIO_PHY_REG_DA_DEML_TXDAC_STATUS_BITS   0x8
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_STATUS   0x2c
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_STATUS_OFFSET 24
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_STATUS_MASK   0xff000000
+#define  AUDIO_PHY_REG_DA_DEMR_TXDAC_STATUS_BITS   0x8
+#define  AUDIO_PHY_REG_TXDAC_I2S_BP   0x30
+#define  AUDIO_PHY_REG_TXDAC_I2S_BP_OFFSET 0
+#define  AUDIO_PHY_REG_TXDAC_I2S_BP_MASK   0x1
+#define  AUDIO_PHY_REG_TXDAC_I2S_BP_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_TO_TXDAC   0x30
+#define  AUDIO_PHY_REG_RXADC_TO_TXDAC_OFFSET 1
+#define  AUDIO_PHY_REG_RXADC_TO_TXDAC_MASK   0x2
+#define  AUDIO_PHY_REG_RXADC_TO_TXDAC_BITS   0x1
+
+#define  AUDIO_PHY_REG_RXADC_EN   0x100
+#define  AUDIO_PHY_REG_RXADC_EN_OFFSET 0
+#define  AUDIO_PHY_REG_RXADC_EN_MASK   0x1
+#define  AUDIO_PHY_REG_RXADC_EN_BITS   0x1
+#define  AUDIO_PHY_REG_I2S_TX_EN   0x100
+#define  AUDIO_PHY_REG_I2S_TX_EN_OFFSET 1
+#define  AUDIO_PHY_REG_I2S_TX_EN_MASK   0x2
+#define  AUDIO_PHY_REG_I2S_TX_EN_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_EN_ON		0x1
+#define  AUDIO_PHY_REG_RXADC_EN_OFF		0xFFFFFFFE
+#define  AUDIO_PHY_REG_I2S_TX_EN_ON		0x2
+#define  AUDIO_PHY_REG_I2S_TX_EN_OFF	0xFFFFFFFD
+
+#define  AUDIO_PHY_REG_RXADC_CIC_OPT   0x104
+#define  AUDIO_PHY_REG_RXADC_CIC_OPT_OFFSET 0
+#define  AUDIO_PHY_REG_RXADC_CIC_OPT_MASK   0x1
+#define  AUDIO_PHY_REG_RXADC_CIC_OPT_BITS   0x1
+#define  RXADC_CIC_DS_64	0xFFFFFFFE
+#define  RXADC_CIC_DS_128	0x00000001
+#define  AUDIO_PHY_REG_RXADC_FSM_SRC_SEL   0x104
+#define  AUDIO_PHY_REG_RXADC_FSM_SRC_SEL_OFFSET 1
+#define  AUDIO_PHY_REG_RXADC_FSM_SRC_SEL_MASK   0x2
+#define  AUDIO_PHY_REG_RXADC_FSM_SRC_SEL_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_CHN_SWAP   0x104
+#define  AUDIO_PHY_REG_RXADC_CHN_SWAP_OFFSET 2
+#define  AUDIO_PHY_REG_RXADC_CHN_SWAP_MASK   0x4
+#define  AUDIO_PHY_REG_RXADC_CHN_SWAP_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_SINGLE   0x104
+#define  AUDIO_PHY_REG_RXADC_SINGLE_OFFSET 3
+#define  AUDIO_PHY_REG_RXADC_SINGLE_MASK   0x8
+#define  AUDIO_PHY_REG_RXADC_SINGLE_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_DCB_OPT   0x104
+#define  AUDIO_PHY_REG_RXADC_DCB_OPT_OFFSET 4
+#define  AUDIO_PHY_REG_RXADC_DCB_OPT_MASK   0x70
+#define  AUDIO_PHY_REG_RXADC_DCB_OPT_BITS   0x3
+#define  AUDIO_PHY_REG_RXADC_IGR_INIT   0x104
+#define  AUDIO_PHY_REG_RXADC_IGR_INIT_OFFSET 8
+#define  AUDIO_PHY_REG_RXADC_IGR_INIT_MASK   0x100
+#define  AUDIO_PHY_REG_RXADC_IGR_INIT_BITS   0x1
+#define  AUDIO_ADC_IGR_INIT_EN	0x100
+#define  AUDIO_ADC_IGR_INIT_OFF	0xFFFFFEFF
+#define  AUDIO_PHY_REG_RXADC_CLK_FORCE_EN   0x104
+#define  AUDIO_PHY_REG_RXADC_CLK_FORCE_EN_OFFSET 9
+#define  AUDIO_PHY_REG_RXADC_CLK_FORCE_EN_MASK   0x200
+#define  AUDIO_PHY_REG_RXADC_CLK_FORCE_EN_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_CIC0_INIT_DONE   0x108
+#define  AUDIO_PHY_REG_RXADC_CIC0_INIT_DONE_OFFSET 0
+#define  AUDIO_PHY_REG_RXADC_CIC0_INIT_DONE_MASK   0x1
+#define  AUDIO_PHY_REG_RXADC_CIC0_INIT_DONE_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_FIR1_0_INIT_DONE   0x108
+#define  AUDIO_PHY_REG_RXADC_FIR1_0_INIT_DONE_OFFSET 1
+#define  AUDIO_PHY_REG_RXADC_FIR1_0_INIT_DONE_MASK   0x2
+#define  AUDIO_PHY_REG_RXADC_FIR1_0_INIT_DONE_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_FIR2_0_INIT_DONE   0x108
+#define  AUDIO_PHY_REG_RXADC_FIR2_0_INIT_DONE_OFFSET 2
+#define  AUDIO_PHY_REG_RXADC_FIR2_0_INIT_DONE_MASK   0x4
+#define  AUDIO_PHY_REG_RXADC_FIR2_0_INIT_DONE_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_CIC1_INIT_DONE   0x108
+#define  AUDIO_PHY_REG_RXADC_CIC1_INIT_DONE_OFFSET 4
+#define  AUDIO_PHY_REG_RXADC_CIC1_INIT_DONE_MASK   0x10
+#define  AUDIO_PHY_REG_RXADC_CIC1_INIT_DONE_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_FIR1_1_INIT_DONE   0x108
+#define  AUDIO_PHY_REG_RXADC_FIR1_1_INIT_DONE_OFFSET 5
+#define  AUDIO_PHY_REG_RXADC_FIR1_1_INIT_DONE_MASK   0x20
+#define  AUDIO_PHY_REG_RXADC_FIR1_1_INIT_DONE_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_FIR2_1_INIT_DONE   0x108
+#define  AUDIO_PHY_REG_RXADC_FIR2_1_INIT_DONE_OFFSET 6
+#define  AUDIO_PHY_REG_RXADC_FIR2_1_INIT_DONE_MASK   0x40
+#define  AUDIO_PHY_REG_RXADC_FIR2_1_INIT_DONE_BITS   0x1
+#define  AUDIO_PHY_REG_RXADC_FSM   0x108
+#define  AUDIO_PHY_REG_RXADC_FSM_OFFSET 8
+#define  AUDIO_PHY_REG_RXADC_FSM_MASK   0x700
+#define  AUDIO_PHY_REG_RXADC_FSM_BITS   0x3
+
+#define  AUDIO_PHY_REG_GSTEPL_RXPGA   0x110
+#define  AUDIO_PHY_REG_GSTEPL_RXPGA_OFFSET 0
+#define  AUDIO_PHY_REG_GSTEPL_RXPGA_MASK   0x1fff
+#define  AUDIO_PHY_REG_GSTEPL_RXPGA_BITS   0xd
+#define  AUDIO_PHY_REG_G6DBL_RXPGA   0x110
+#define  AUDIO_PHY_REG_G6DBL_RXPGA_OFFSET 13
+#define  AUDIO_PHY_REG_G6DBL_RXPGA_MASK   0x2000
+#define  AUDIO_PHY_REG_G6DBL_RXPGA_BITS   0x1
+#define  AUDIO_PHY_REG_GAINL_RXADC   0x110
+#define  AUDIO_PHY_REG_GAINL_RXADC_OFFSET 14
+#define  AUDIO_PHY_REG_GAINL_RXADC_MASK   0xc000
+#define  AUDIO_PHY_REG_GAINL_RXADC_BITS   0x2
+#define  AUDIO_PHY_REG_GSTEPR_RXPGA   0x110
+#define  AUDIO_PHY_REG_GSTEPR_RXPGA_OFFSET 16
+#define  AUDIO_PHY_REG_GSTEPR_RXPGA_MASK   0x1fff0000
+#define  AUDIO_PHY_REG_GSTEPR_RXPGA_BITS   0xd
+#define  AUDIO_PHY_REG_G6DBR_RXPGA   0x110
+#define  AUDIO_PHY_REG_G6DBR_RXPGA_OFFSET 29
+#define  AUDIO_PHY_REG_G6DBR_RXPGA_MASK   0x20000000
+#define  AUDIO_PHY_REG_G6DBR_RXPGA_BITS   0x1
+#define  AUDIO_PHY_REG_GAINR_RXADC   0x110
+#define  AUDIO_PHY_REG_GAINR_RXADC_OFFSET 30
+#define  AUDIO_PHY_REG_GAINR_RXADC_MASK   0xc0000000
+#define  AUDIO_PHY_REG_GAINR_RXADC_BITS   0x2
+#define  AUDIO_PHY_REG_ADC_VOLL_MASK	  0xffff
+#define  AUDIO_PHY_REG_ADC_VOLR_MASK	  0xffff0000
+
+#define DAC_VOL_L_MASK		0x000001FF
+#define CV182x_DAC_VOL_STEP	0x8
+#define DAC_VOL_L(V) (V == 0 ? 0 : (V * CV182x_DAC_VOL_STEP) - 1)
+#define DAC_VOL_R(V) ((V == 0 ? 0 : (V * CV182x_DAC_VOL_STEP) - 1) << 16)
+
+#define  ADC_VOL_GAIN_0		0x0001 /* 0dB */
+#define  ADC_VOL_GAIN_1		0x0002 /* 2dB */
+#define  ADC_VOL_GAIN_2		0x0004 /* 4dB */
+#define  ADC_VOL_GAIN_3		0x0008 /* 6dB */
+#define  ADC_VOL_GAIN_4		0x0010 /* 8dB */
+#define  ADC_VOL_GAIN_5		0x0020 /* 10dB */
+#define  ADC_VOL_GAIN_6		0x0040 /* 12dB */
+#define  ADC_VOL_GAIN_7		0x0080 /* 14dB */
+#define  ADC_VOL_GAIN_8		0x0100 /* 16dB */
+#define  ADC_VOL_GAIN_9		0x0200 /* 18dB */
+#define  ADC_VOL_GAIN_10		0x0400 /* 20dB */
+#define  ADC_VOL_GAIN_11		0x0800 /* 22dB */
+#define  ADC_VOL_GAIN_12		0x1000 /* 24dB */
+#define  ADC_VOL_GAIN_13		0x2400 /* 26dB */
+#define  ADC_VOL_GAIN_14		0x2800 /* 28dB */
+#define  ADC_VOL_GAIN_15		0x3000 /* 30dB */
+#define  ADC_VOL_GAIN_16		0x6400 /* 32dB */
+#define  ADC_VOL_GAIN_17		0x6800 /* 34dB */
+#define  ADC_VOL_GAIN_18		0x7000 /* 36dB */
+#define  ADC_VOL_GAIN_19		0xA400 /* 38dB */
+#define  ADC_VOL_GAIN_20		0xA800 /* 40dB */
+#define  ADC_VOL_GAIN_21		0xB000 /* 42dB */
+#define  ADC_VOL_GAIN_22		0xE400 /* 44dB */
+#define  ADC_VOL_GAIN_23		0xE800 /* 46dB */
+#define  ADC_VOL_GAIN_24		0xF000 /* 48dB */
+
+#define ADC_VOL_L(V) (ADC_VOL_GAIN_##V)
+#define ADC_VOL_R(V) (ADC_VOL_GAIN_##V << 16)
+
+#define  AUDIO_PHY_REG_GAINL_STATUS   0x114
+#define  AUDIO_PHY_REG_GAINL_STATUS_OFFSET 0
+#define  AUDIO_PHY_REG_GAINL_STATUS_MASK   0xffff
+#define  AUDIO_PHY_REG_GAINL_STATUS_BITS   0x10
+#define  AUDIO_PHY_REG_GAINR_STATUS   0x114
+#define  AUDIO_PHY_REG_GAINR_STATUS_OFFSET 16
+#define  AUDIO_PHY_REG_GAINR_STATUS_MASK   0xffff0000
+#define  AUDIO_PHY_REG_GAINR_STATUS_BITS   0x10
+
+
+#define  AUDIO_PHY_REG_MUTEL_RXPGA   0x118
+#define  AUDIO_PHY_REG_MUTEL_RXPGA_OFFSET 0
+#define  AUDIO_PHY_REG_MUTEL_RXPGA_MASK   0x1
+#define  AUDIO_PHY_REG_MUTEL_RXPGA_BITS   0x1
+#define  AUDIO_PHY_REG_MUTER_RXPGA   0x118
+#define  AUDIO_PHY_REG_MUTER_RXPGA_OFFSET 1
+#define  AUDIO_PHY_REG_MUTER_RXPGA_MASK   0x2
+#define  AUDIO_PHY_REG_MUTER_RXPGA_BITS   0x1
+#define  AUDIO_PHY_REG_DIFF_EN_RXPGA   0x118
+#define  AUDIO_PHY_REG_DIFF_EN_RXPGA_OFFSET 16
+#define  AUDIO_PHY_REG_DIFF_EN_RXPGA_MASK   0x10000
+#define  AUDIO_PHY_REG_DIFF_EN_RXPGA_BITS   0x1
+#define  AUDIO_PHY_REG_TRISTATE_RXPGA   0x118
+#define  AUDIO_PHY_REG_TRISTATE_RXPGA_OFFSET 17
+#define  AUDIO_PHY_REG_TRISTATE_RXPGA_MASK   0x20000
+#define  AUDIO_PHY_REG_TRISTATE_RXPGA_BITS   0x1
+#define  AUDIO_PHY_REG_MUTEL_ON   0x1
+#define  AUDIO_PHY_REG_MUTEL_OFF  0xFFFFFFFE
+#define  AUDIO_PHY_REG_MUTER_ON   0x2
+#define  AUDIO_PHY_REG_MUTER_OFF  0xFFFFFFFD
+
+#define  AUDIO_PHY_REG_ADDI_RXADC   0x11c
+#define  AUDIO_PHY_REG_ADDI_RXADC_OFFSET 0
+#define  AUDIO_PHY_REG_ADDI_RXADC_MASK   0x1
+#define  AUDIO_PHY_REG_ADDI_RXADC_BITS   0x1
+#define  AUDIO_PHY_REG_CKSEL_RXADC   0x11c
+#define  AUDIO_PHY_REG_CKSEL_RXADC_OFFSET 1
+#define  AUDIO_PHY_REG_CKSEL_RXADC_MASK   0x2
+#define  AUDIO_PHY_REG_CKSEL_RXADC_BITS   0x1
+#define  AUDIO_PHY_REG_EN_ASAR_I_RXADC   0x11c
+#define  AUDIO_PHY_REG_EN_ASAR_I_RXADC_OFFSET 2
+#define  AUDIO_PHY_REG_EN_ASAR_I_RXADC_MASK   0x4
+#define  AUDIO_PHY_REG_EN_ASAR_I_RXADC_BITS   0x1
+#define  AUDIO_PHY_REG_EN_ASAR_Q_RXADC   0x11c
+#define  AUDIO_PHY_REG_EN_ASAR_Q_RXADC_OFFSET 3
+#define  AUDIO_PHY_REG_EN_ASAR_Q_RXADC_MASK   0x8
+#define  AUDIO_PHY_REG_EN_ASAR_Q_RXADC_BITS   0x1
+#define  AUDIO_PHY_REG_DEM_TYPE_RXADC   0x11c
+#define  AUDIO_PHY_REG_DEM_TYPE_RXADC_OFFSET 4
+#define  AUDIO_PHY_REG_DEM_TYPE_RXADC_MASK   0x30
+#define  AUDIO_PHY_REG_DEM_TYPE_RXADC_BITS   0x2
+#define  AUDIO_PHY_REG_CTUNE_RXADC   0x11c
+#define  AUDIO_PHY_REG_CTUNE_RXADC_OFFSET 8
+#define  AUDIO_PHY_REG_CTUNE_RXADC_MASK   0xf00
+#define  AUDIO_PHY_REG_CTUNE_RXADC_BITS   0x4
+#define  RXADC_CTUNE_MCLK_4096	(0xF << AUDIO_PHY_REG_CTUNE_RXADC_OFFSET)
+#define  RXADC_CTUNE_MCLK_5644	(0xA << AUDIO_PHY_REG_CTUNE_RXADC_OFFSET)
+#define  RXADC_CTUNE_MCLK_8192	(0x4 << AUDIO_PHY_REG_CTUNE_RXADC_OFFSET)
+#define  RXADC_CTUNE_MCLK_11298	(0xD << AUDIO_PHY_REG_CTUNE_RXADC_OFFSET)
+#define  RXADC_CTUNE_MCLK_12288	(0xC << AUDIO_PHY_REG_CTUNE_RXADC_OFFSET)
+#define  RXADC_CTUNE_MCLK_16384	(0x8 << AUDIO_PHY_REG_CTUNE_RXADC_OFFSET)
+#define  AUDIO_PHY_REG_EN_DITHER_RXADC   0x11c
+#define  AUDIO_PHY_REG_EN_DITHER_RXADC_OFFSET 12
+#define  AUDIO_PHY_REG_EN_DITHER_RXADC_MASK   0x1000
+#define  AUDIO_PHY_REG_EN_DITHER_RXADC_BITS   0x1
+#define  AUDIO_PHY_REG_RSTSDM_RXADC   0x11c
+#define  AUDIO_PHY_REG_RSTSDM_RXADC_OFFSET 13
+#define  AUDIO_PHY_REG_RSTSDM_RXADC_MASK   0x2000
+#define  AUDIO_PHY_REG_RSTSDM_RXADC_BITS   0x1
+#define  AUDIO_PHY_REG_EN_VCMT_RXADC   0x11c
+#define  AUDIO_PHY_REG_EN_VCMT_RXADC_OFFSET 14
+#define  AUDIO_PHY_REG_EN_VCMT_RXADC_MASK   0x4000
+#define  AUDIO_PHY_REG_EN_VCMT_RXADC_BITS   0x1
+#define  AUDIO_PHY_REG_VLDO0P9_RXADC   0x11c
+#define  AUDIO_PHY_REG_VLDO0P9_RXADC_OFFSET 16
+#define  AUDIO_PHY_REG_VLDO0P9_RXADC_MASK   0x30000
+#define  AUDIO_PHY_REG_VLDO0P9_RXADC_BITS   0x2
+#define  AUDIO_PHY_REG_VLDO12_RXADC   0x11c
+#define  AUDIO_PHY_REG_VLDO12_RXADC_OFFSET 18
+#define  AUDIO_PHY_REG_VLDO12_RXADC_MASK   0xc0000
+#define  AUDIO_PHY_REG_VLDO12_RXADC_BITS   0x2
+#define  AUDIO_PHY_REG_RNLVL_RXADC   0x11c
+#define  AUDIO_PHY_REG_RNLVL_RXADC_OFFSET 20
+#define  AUDIO_PHY_REG_RNLVL_RXADC_MASK   0x300000
+#define  AUDIO_PHY_REG_RNLVL_RXADC_BITS   0x2
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_STATUS   0x120
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_STATUS_OFFSET 0
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_STATUS_MASK   0x1
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_STATUS_BITS   0x1
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_STATUS   0x120
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_STATUS_OFFSET 1
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_STATUS_MASK   0x2
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_STATUS_BITS   0x1
+#define  AUDIO_PHY_REG_DA_EN_RXADC_STATUS   0x120
+#define  AUDIO_PHY_REG_DA_EN_RXADC_STATUS_OFFSET 2
+#define  AUDIO_PHY_REG_DA_EN_RXADC_STATUS_MASK   0x4
+#define  AUDIO_PHY_REG_DA_EN_RXADC_STATUS_BITS   0x1
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_STATUS   0x120
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_STATUS_OFFSET 3
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_STATUS_MASK   0x8
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_STATUS_BITS   0x1
+#define  AUDIO_PHY_REG_AD_DOL_RXADC   0x120
+#define  AUDIO_PHY_REG_AD_DOL_RXADC_OFFSET 16
+#define  AUDIO_PHY_REG_AD_DOL_RXADC_MASK   0x70000
+#define  AUDIO_PHY_REG_AD_DOL_RXADC_BITS   0x3
+#define  AUDIO_PHY_REG_AD_DOR_RXADC   0x120
+#define  AUDIO_PHY_REG_AD_DOR_RXADC_OFFSET 20
+#define  AUDIO_PHY_REG_AD_DOR_RXADC_MASK   0x700000
+#define  AUDIO_PHY_REG_AD_DOR_RXADC_BITS   0x3
+#define  AUDIO_PHY_REG_TESTEN_AUDBIAS   0x124
+#define  AUDIO_PHY_REG_TESTEN_AUDBIAS_OFFSET 0
+#define  AUDIO_PHY_REG_TESTEN_AUDBIAS_MASK   0x1
+#define  AUDIO_PHY_REG_TESTEN_AUDBIAS_BITS   0x1
+#define  AUDIO_PHY_REG_TESTEN_RXPGA   0x124
+#define  AUDIO_PHY_REG_TESTEN_RXPGA_OFFSET 1
+#define  AUDIO_PHY_REG_TESTEN_RXPGA_MASK   0x2
+#define  AUDIO_PHY_REG_TESTEN_RXPGA_BITS   0x1
+#define  AUDIO_PHY_REG_TSEL_RXADC   0x124
+#define  AUDIO_PHY_REG_TSEL_RXADC_OFFSET 2
+#define  AUDIO_PHY_REG_TSEL_RXADC_MASK   0xc
+#define  AUDIO_PHY_REG_TSEL_RXADC_BITS   0x2
+#define  AUDIO_PHY_REG_AUD_VREF_FC   0x124
+#define  AUDIO_PHY_REG_AUD_VREF_FC_OFFSET 8
+#define  AUDIO_PHY_REG_AUD_VREF_FC_MASK   0x100
+#define  AUDIO_PHY_REG_AUD_VREF_FC_BITS   0x1
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_OW_VAL   0x128
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_OW_VAL_OFFSET 0
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_OW_VAL_MASK   0x1
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_OW_VAL_BITS   0x1
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_OW_VAL   0x128
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_OW_VAL_OFFSET 1
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_OW_VAL_MASK   0x2
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_OW_VAL_BITS   0x1
+#define  AUDIO_PHY_REG_DA_EN_RXADC_OW_VAL   0x128
+#define  AUDIO_PHY_REG_DA_EN_RXADC_OW_VAL_OFFSET 2
+#define  AUDIO_PHY_REG_DA_EN_RXADC_OW_VAL_MASK   0x4
+#define  AUDIO_PHY_REG_DA_EN_RXADC_OW_VAL_BITS   0x1
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_OW_VAL   0x128
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_OW_VAL_OFFSET 3
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_OW_VAL_MASK   0x8
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_OW_VAL_BITS   0x1
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_OW_EN   0x128
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_OW_EN_OFFSET 16
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_OW_EN_MASK   0x10000
+#define  AUDIO_PHY_REG_DA_EN_RXPGA_OW_EN_BITS   0x1
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_OW_EN   0x128
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_OW_EN_OFFSET 17
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_OW_EN_MASK   0x20000
+#define  AUDIO_PHY_REG_DA_END2US_RXPGA_OW_EN_BITS   0x1
+#define  AUDIO_PHY_REG_DA_EN_RXADC_OW_EN   0x128
+#define  AUDIO_PHY_REG_DA_EN_RXADC_OW_EN_OFFSET 18
+#define  AUDIO_PHY_REG_DA_EN_RXADC_OW_EN_MASK   0x40000
+#define  AUDIO_PHY_REG_DA_EN_RXADC_OW_EN_BITS   0x1
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_OW_EN   0x128
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_OW_EN_OFFSET 19
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_OW_EN_MASK   0x80000
+#define  AUDIO_PHY_REG_DA_EN_AUDBIAS_OW_EN_BITS   0x1
+#define  AUDIO_PHY_REG_GPIO_IEN   0x12c
+#define  AUDIO_PHY_REG_GPIO_IEN_OFFSET 0
+#define  AUDIO_PHY_REG_GPIO_IEN_MASK   0xf
+#define  AUDIO_PHY_REG_GPIO_IEN_BITS   0x4
+#define  AUDIO_PHY_REG_GPIO_DRV   0x12c
+#define  AUDIO_PHY_REG_GPIO_DRV_OFFSET 4
+#define  AUDIO_PHY_REG_GPIO_DRV_MASK   0xf0
+#define  AUDIO_PHY_REG_GPIO_DRV_BITS   0x4
+#define  AUDIO_PHY_REG_GPIO_C   0x12c
+#define  AUDIO_PHY_REG_GPIO_C_OFFSET 16
+#define  AUDIO_PHY_REG_GPIO_C_MASK   0xf0000
+#define  AUDIO_PHY_REG_GPIO_C_BITS   0x4
+
+#define  AUDIO_PHY_REG_SPARE0   0xff0
+#define  AUDIO_PHY_REG_SPARE0_OFFSET 0
+#define  AUDIO_PHY_REG_SPARE0_MASK   0xffffffff
+#define  AUDIO_PHY_REG_SPARE0_BITS   0x20
+#define  AUDIO_ADC_SCK_DIV_MASK		0x00ff0000
+#define  SPARE_SCK_DIV(l)		((l-1) << 16)
+
+#define  AUDIO_PHY_REG_SPARE1   0xff4
+#define  AUDIO_PHY_REG_SPARE1_OFFSET 0
+#define  AUDIO_PHY_REG_SPARE1_MASK   0xffff
+#define  AUDIO_PHY_REG_SPARE1_BITS   0x10
+#define  AUDIO_PHY_REG_SPARE_RO   0xff8
+#define  AUDIO_PHY_REG_SPARE_RO_OFFSET 0
+#define  AUDIO_PHY_REG_SPARE_RO_MASK   0xffffffff
+#define  AUDIO_PHY_REG_SPARE_RO_BITS   0x20
+#define  AUDIO_PHY_REG_DATE_CODE   0xffc
+#define  AUDIO_PHY_REG_DATE_CODE_OFFSET 0
+#define  AUDIO_PHY_REG_DATE_CODE_MASK   0xffffffff
+#define  AUDIO_PHY_REG_DATE_CODE_BITS   0x20
+
+#define CVI_I2S_EN						0x18
+#define CVI_I2S_CLK_CTRL0				0x60
+#define CVI_I2S_CLK_CTRL1				0x64
+#define CVI_I2S_MCLK_OUT_EN_MASK		0x00000080
+#define CVI_I2S_MCLK_OUT_EN				BIT(7)
+#define CVI_I2S_MCLK_OUT_OFF			0xFFFFFF7F
+#define CVI_I2S_AU_EN_MASK				0x00000100
+#define CVI_I2S_AU_EN					BIT(8)
+#define CVI_I2S_AU_OFF					0xFFFFFEFF
+
+#define CVI_I2S_MCLK_MASK		0x0000FFFF
+#define CVI_I2S_MCLK_DIV(l)             ((l << 0) & 0x0000FFFF)
+
+
+#ifdef CONFIG_PM_SLEEP
+/* Store GPIO context across system-wide suspend/resume transitions */
+struct cv182xadc_context {
+	u32 ctl0;
+	u32 ctl1;
+	u32 status;
+	u32 ana0;
+	u32 ana2;
+	u32 ana3;
+};
+
+struct cv182xdac_context {
+	u32 ctl0;
+	u32 ctl1;
+	u32 afe0;
+	u32 afe1;
+	u32 ana0;
+	u32 ana1;
+	u32 ana2;
+};
+#endif
+
+struct cv182xadc {
+	void __iomem *adc_base;
+	struct clk *clk;
+	struct device *dev;
+	struct miscdevice miscdev;
+	void __iomem *mclk_source;
+	struct mutex mutex;
+#ifdef CONFIG_PM_SLEEP
+	struct cv182xadc_context *reg_ctx;
+#endif
+};
+
+struct cv182xdac {
+	void __iomem *dac_base;
+	struct clk *clk;
+	struct device *dev;
+	struct miscdevice miscdev;
+	struct mutex mutex;
+#ifdef CONFIG_PM_SLEEP
+	struct cv182xdac_context *reg_ctx;
+#endif
+};
+
+extern struct proc_dir_entry *proc_audio_dir;
+
+#endif  /* __CV182XADAC_H__ */
diff --git a/sound/soc/codecs/cv1835adc.h b/sound/soc/codecs/cv1835adc.h
new file mode 100644
index 000000000000..b23f57f1685e
--- /dev/null
+++ b/sound/soc/codecs/cv1835adc.h
@@ -0,0 +1,99 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later
+ * CV1835 ADC driver on CVITEK CV1835
+ *
+ * Copyright 2019 CVITEK
+ *
+ * Author: EthanChen
+ *
+ */
+
+#ifndef __CV1835ADC_H__
+#define __CV1835ADC_H__
+
+#include <linux/clk.h>
+#include <linux/miscdevice.h>
+
+#define CVI_ADC_GSEL_REG			0x00
+#define CVI_ADC_GSELR_MASK			0xFFFFFFE0
+#define CVI_ADC_GSELR(v)			(v << 0)
+#define CVI_ADC_GSELL_MASK			0xFFFFE0FF
+#define CVI_ADC_GSELL(v)			(v << 8)
+#define CVI_ADC_GSELR_MIC_MASK		0xFFF8FFFF
+#define CVI_ADC_GSELR_MIC(v)		(v << 16)
+#define CVI_ADC_GSELL_MIC_MASK		0xF8FFFFFF
+#define CVI_ADC_GSELL_MIC(v)		(v << 24)
+
+#define CVI_ADC_CTRL_REG			0x04
+#define CVI_ADC_INSELR_LINE			0xFFFFFFFE	/* bit[0] == 0*/
+#define CVI_ADC_INSELR_MIC			(1 << 0)
+#define CVI_ADC_INSELL_LINE			0xFFFFFFFD	/* bit[1] == 0*/
+#define CVI_ADC_INSELL_MIC			(1 << 1)
+#define CVI_ADC_POWER_MASK			0xFFFCFF0C	/* use to reset power on/off related bits */
+#define CVI_ADC_ENADR_POWER_DOWN	0xFFFFFFFB	/* bit[2] == 0*/
+#define CVI_ADC_ENADR_NORMAL		(1 << 2)
+#define CVI_ADC_ENADL_POWER_DOWN	0xFFFFFFF7	/* bit[3] == 0*/
+#define CVI_ADC_ENADL_NORMAL		(1 << 3)
+#define CVI_ADC_VREF_POWER_DOWN		0xFFFFFFEF	/* bit[4] == 0*/
+#define CVI_ADC_VERF_NORMAL			(1 << 4)
+#define CVI_ADC_ZCD_DISABLE			0xFFFFFFDF	/* bit[5] == 0*/
+#define CVI_ADC_ZCD_ENABLE			(1 << 5)
+#define CVI_ADC_HPR_BYPASS			0xFFFFFFBF	/* bit[6] == 0*/
+#define CVI_ADC_HPR_ENABLE			(1 << 6)
+#define CVI_ADC_HPL_BYPASS			0xFFFFFF7F	/* bit[7] == 0*/
+#define CVI_ADC_HPL_ENABLE			(1 << 7)
+#define CVI_ADC_OVRS_MASK			0xFFFCFFFF
+#define CVI_ADC_OVRS(v)				(v << 16)
+
+#define CVI_ADC_OVTOP_REG			0x08
+
+#define CVI_ADC_TEST_MODE_REG		0x0C
+#define CVI_ADC_TM_NORMAL			0x0
+#define CVI_ADC_TM_READ_ROM			0x2
+#define CVI_ADC_TM_R_PCM			0x6
+#define CVI_ADC_TM_L_PCM			0x7
+
+#define CVI_ADC_RSEL_REG			0x10
+
+#define CVI_ADC_FS_SEL_REG			0x14 /* ADMCLK/LRCK ratio */
+#define CVI_ADC_RATIO_256			0x0
+#define CVI_ADC_RATIO_512			0x1
+#define CVI_ADC_RATIO_1024			0x2
+
+#define CVI_ADC_DAGC_CTRL_REG		0x20 /* digital AGC control */
+#define CVI_ADC_DAGC_DISABLE		0xFFFFFFFE /* bit[0] == 0 */
+#define CVI_ADC_DAGC_ENABLE			(1 << 0)
+#define CVI_ADC_DAGC_RMS_MODE		0xFFFFFFFD /* bit[1] == 1 */
+#define CVI_ADC_DAGC_PEAK_MODE		(1 << 1)
+#define CVI_ADC_DAGC_ZCD_DISABLE	0xFFFFFFFB /* bit[2] == 0 */
+#define CVI_ADC_DAGC_ZCD_ENABLE		(1 << 2)
+
+#define CVI_ADC_DAGC_THOLD_REG		0x24
+#define CVI_ADC_DAGC_THOLD_MASK		0xFFFFFF81
+#define CVI_ADC_DAGC_THOLD(v)		(v << 0) /* maximum is 0x7f, minimum is 0x01 */
+#define CVI_ADC_DAGC_UPDATE_THOLD_MASK	0x8000FFFF
+#define CVI_ADC_DAGC_UPDATE_THOLD(v)	(v << 16) /* maximum is 0x7fff */
+
+#define CVI_ADC_DAGC_ATTACKTIME_REG		0x28
+
+#define CVI_ADC_DAGC_SRC_DM_REG			0x2C
+#define CVI_SDC_DAGC_UPDATE_FREQ_MASK	0xFFFFF000
+#define CVI_SDC_DAGC_UPDATE_FREQ(v)		(v << 0)
+#define CVI_ADC_DAGC_SRC_DM_MASK		0xFFFFCFFF
+#define CVI_ADC_DAGC_SRC_DM_MONO_L		(0 << 12)
+
+#define CVI_ADC_DAGC_PGAG_REG			0x30
+#define CVI_ADC_DAGC_PGAG_R				0x0000001F
+#define CVI_ADC_DAGC_PGAG_L				0x00001F00
+
+#define CVI_ADC_ADCO_REG				0x34
+
+struct cvi1835adc {
+	void __iomem *adc_base;
+	struct clk *clk;
+	struct device *dev;
+	struct miscdevice miscdev;
+};
+
+extern struct proc_dir_entry *proc_audio_dir;
+
+#endif  /* __CV1835ADC_H__ */
diff --git a/sound/soc/codecs/cv1835dac.h b/sound/soc/codecs/cv1835dac.h
new file mode 100644
index 000000000000..41afd6ef30cd
--- /dev/null
+++ b/sound/soc/codecs/cv1835dac.h
@@ -0,0 +1,73 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later
+ * CV1835 DAC driver on CVITEK CV1835
+ *
+ * Copyright 2019 CVITEK
+ *
+ * Author: EthanChen
+ *
+ */
+
+#ifndef __CV1835DAC_H__
+#define __CV1835DAC_H__
+
+#include <linux/clk.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <linux/miscdevice.h>
+
+#define CVI_DAC_FS_REG				0x00
+#define CVI_DAC_FS_16_32			0x0
+#define CVI_DAC_FS_32_64			0x1
+#define CVI_DAC_FS_64_128			0x2
+#define CVI_DAC_FS_128_192			0x3
+
+#define CVI_DAC_CTRL_REG			0x04
+#define CVI_DAC_PWDAR_MASK			0x00000001
+#define CVI_DAC_PWDAR_NORMAL		0xFFFFFFFE
+#define CVI_DAC_PWDAR_DOWN			(1 << 0)
+#define CVI_DAC_PWDAL_MASK			0x00000002
+#define CVI_DAC_PWDAL_NORMAL		0xFFFFFFFD
+#define CVI_DAC_PWDAL_DOWN			(1 << 1)
+#define CVI_DAC_EN_REF_DISABLE		0xFFFFFFFB
+#define CVI_DAC_EN_REF_ENABLE		(1 << 2)
+#define CVI_DAC_DEN_ENABLE			0xFFFFFFF7
+#define CVI_DAC_DEN_DISABLE			(1 << 3)
+#define CVI_DAC_AEN_ENABLE			0xFFFFFFEF
+#define CVI_DAC_AEN_DISABLE			(1 << 4)
+#define CVI_DAC_STR_DISABLE			0xFFFFFFDF
+#define CVI_DAC_STR_ENABLE			(1 << 5)
+#define CVI_DAC_DISTHER_DISABLE		0xFFFFFFBF
+#define CVI_DAC_DISTHER_ENABLE		(1 << 6)
+#define CVI_DAC_MUTE_MODE			0xFFFFFCFF
+#define CVI_DAC_DEMUTE_MODE			(0x3 << 8)
+#define CVI_DAC_CKINV_NODELAY		0xFFFFFBFF
+#define CVI_DAC_CKINV_DELAY			(1 << 10)
+#define CVI_DAC_S_MASK				0xFFFF0FFF
+#define CVI_DAC_S(v)				(v << 12)
+#define CVI_DAC_ZCD_DISABLE			0xFFFEFFFF
+#define CVI_DAC_ZCD_ENABLE			(1 << 16)
+
+#define CVI_DAC_TEST_MODE_REG		0x08
+#define CVI_DAC_TM_NORMAL			0x0
+#define CVI_DAC_TM_DF				0x1 /* DAC digital filter test mode */
+#define CVI_DAC_TM_SDM				0x2 /* DAC delta sigma modulator */
+
+#define CVI_DAC_AIO_DA_REG			0x0C
+#define CVI_DAV_AIO_ALL_GPIO		0x0
+#define CVI_DAV_AIO_2CH				0x1
+
+#define CVI_DAC_AS_LEVEL_REG	0x10
+
+struct cvi1835dac {
+	void __iomem *dac_base;
+	struct clk *clk;
+	struct device *dev;
+	struct miscdevice miscdev;
+};
+
+extern bool cv1835dac_is_mute(struct snd_pcm_substream *substream);
+
+extern struct proc_dir_entry *proc_audio_dir;
+
+#endif  /* __CV1835DAC_H__ */
diff --git a/sound/soc/cvitek/Kconfig b/sound/soc/cvitek/Kconfig
new file mode 100644
index 000000000000..b2540aa8ebce
--- /dev/null
+++ b/sound/soc/cvitek/Kconfig
@@ -0,0 +1,192 @@
+#
+# CVITEK Audio Sound SoC drivers
+#
+
+config SND_SOC_CV1835_ADAU1372
+	tristate "Support for the CV1835-ADAU1372 card"
+	help
+	  Say y or m if you want to add support for the analog
+	  codec ADAU1372 connect to the CVITEK CV1835 boards.
+	  Then select it for built in or module.
+	  If not, please don't select it
+
+config SND_SOC_CV1835_CV1835PDM
+	tristate "Support for the CV1835-CV1835PDM card"
+	help
+	 Say Y or M if you want to add support for CVITEK PDM connect
+	 to CVITEK CV1835 I2S device.
+	 Then select it for built in or module.
+	 Say N, if not support
+
+config SND_SOC_CV182X_CV182XPDM
+	tristate "Support for the CV182X-CV182XPDM card"
+	help
+	 Say Y or M if you want to add support for CVITEK PDM connect
+	 to CVITEK CV182X I2S device.
+	 Then select it for built in or module.
+	 Say N, if not support
+
+config SND_SOC_CV1835_CV1835ADC
+	tristate "Support for the CV1835-CV1835ADC card"
+	help
+	 Say Y or M if you want to add support for CVITEK ADC connect
+	 to CVITEK CV1835 I2S device.
+	 Then select it for built in or module.
+	 Say N, if not support
+
+config SND_SOC_CV1835_CV1835DAC
+	tristate "Support for the CV1835-CV1835ADC card"
+	help
+	 Say Y or M if you want to add support for CVITEK DAC connect
+	 to CVITEK CV1835 I2S device.
+	 Then select it for built in or module.
+	 Say N, if not support
+
+config SND_SOC_CV182X_CV182XADC
+	tristate "Support for the CV182X-CV182XADC card"
+	help
+	 Say Y or M if you want to add support for CV182X ADC connect
+	 to CVITEK CV182X I2S device.
+	 Then select it for built in or module.
+	 Say N, if not support
+
+config SND_SOC_CV182X_CV182XDAC
+	tristate "Support for the CV182X-CV182XADC card"
+	help
+	 Say Y or M if you want to add support for CVITEK DAC connect
+	 to CVITEK CV182X I2S device.
+	 Then select it for built in or module.
+	 Say N, if not support
+
+config SND_SOC_CV182XA_CV182XAADC
+	tristate "Support for the CV182XA-CV182XAADC card"
+	help
+	 Say Y or M if you want to add support for CV182XA ADC connect
+	 to CVITEK CV182XA I2S device.
+	 Then select it for built in or module.
+	 Say N, if not support
+
+config SND_SOC_CV182XA_CV182XADAC
+	tristate "Support for the CV182XA-CV182XADAC card"
+	help
+	 Say Y or M if you want to add support for CVITEK DAC connect
+	 to CVITEK CV182XA I2S device.
+	 Then select it for built in or module.
+	 Say N, if not support
+
+config SND_CV1835_I2S
+	tristate "CVITEK CV1835 I2S Device Driver"
+	depends on CLKDEV_LOOKUP
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	 Say y or m if you want to add support for I2S driver for
+	 CVITEK CV1835 I2S device. The device supports upto maximum of
+	 2 channels each for play and record.
+	 Say N, if not support
+
+config SND_SOC_CV1835PDM
+    tristate "CVITEK CV1835 PDM device driver"
+	depends on SND
+	help
+	 Say y or m if you want to add support for CVITEK PDM driver for
+	 CVITEK CV1835 I2S device. The device supports digital external
+	 MICs.
+	 Say N, if not support
+
+config SND_SOC_CV1835ADC
+    tristate "CVITEK CV1835 ADC device driver"
+	depends on SND
+	help
+	 Say y or m if you want to add support for CVITEK ADC driver for
+	 CVITEK CV1835 I2S device. The device supports analog external
+	 MICs.
+	 Say N, if not support
+
+config SND_SOC_CV182XADC
+    tristate "CVITEK CV182X ADC device driver"
+	depends on SND
+	help
+	 Say y or m if you want to add support for CVITEK ADC driver for
+	 CVITEK CV182X I2S device. The device supports analog external
+	 MICs.
+	 Say N, if not support
+
+config SND_SOC_CV182XAADC
+    tristate "CVITEK CV182XA ADC device driver"
+	depends on SND
+	help
+	 Say y or m if you want to add support for CVITEK ADC driver for
+	 CVITEK CV182XA I2S device. The device supports analog external
+	 MICs.
+	 Say N, if not support
+
+config SND_SOC_CV1835DAC
+    tristate "CVITEK CV1835 DAC device driver"
+	depends on SND
+	help
+	 Say y or m if you want to add support for CVITEK DAC driver for
+	 CVITEK CV1835 I2S device. The device supports analog external
+	 devices (ex. headphone or speaker).
+	 Say N, if not support
+
+config SND_SOC_CV182XDAC
+    tristate "CVITEK CV182X DAC device driver"
+	depends on SND
+	help
+	 Say y or m if you want to add support for CVITEK DAC driver for
+	 CVITEK CV182X I2S device. The device supports analog external
+	 devices (ex. headphone or speaker).
+	 Say N, if not support
+
+config SND_SOC_CV182XADAC
+    tristate "CVITEK CV182XA DAC device driver"
+	depends on SND
+	help
+	 Say y or m if you want to add support for CVITEK DAC driver for
+	 CVITEK CV182XA I2S device. The device supports analog external
+	 devices (ex. headphone or speaker).
+	 Say N, if not support
+
+config SND_SOC_CV1835_CONCURRENT_I2S
+	tristate "Support concurrent TX and RX by one I2S and the other I2S"
+	depends on SND
+	help
+	  Say Y, ex. if you want to receive audio data from I2S1 FIFO and
+	  transfer audio data to I2S0 FIFO concurrently. This is because
+	  of 1 I2S IP only has 1 FIFO, we need to bind 2 I2S IPs with 1 I/O
+
+	  If this device never do concurrent TX/RX, please don't select it
+
+config SND_SOC_CV183x_DUMMY_CARD
+	tristate "Support concurrent TX and RX by one I2S and the other I2S"
+	depends on SND
+	help
+	  Say Y, ex. if you want to receive audio data from I2S1 FIFO and
+	  transfer audio data to I2S0 FIFO concurrently. This is because
+	  of 1 I2S IP only has 1 FIFO, we need to bind 2 I2S IPs with 1 I/O
+
+	  If this device never do concurrent TX/RX, please don't select it
+
+config SND_SOC_CV1835_USE_AUDIO_PLL
+	tristate "Use internal audio PLL as I2S clock source"
+	depends on SND
+	help
+	  Say Y, ex. if you want to use internal audio PLL (24.576Mhz) as
+	  I2S MCLK input. Enable this configuration, we don't need to use
+	  external oscillator to provide MCLK clock. But be remember to enable
+	  MCLK out if codec also need MCLK clock.
+
+config CV1835_I2S_SUBSYS
+	bool "cvitek i2s tdm sub-system driver"
+	depends on SND
+	help
+	  Enable cvitek i2s_tdm sub-system driver to do i2s_tdm configuration.
+	  One need to set this sub-system if he want to do multi-record at the same
+	  time.
+	  Or do TX/RX simutaneously. ex. set I2S0 as RX and I2S1 as TX.
+	  Due to 1 I2S IP only has 1 FIFO. One must do this setting.
+
+config SND_SOC_CV1835_LT9611
+	tristate "Support for the lt9611 card"
+	help
+	  lt9611 codec enable.
diff --git a/sound/soc/cvitek/Makefile b/sound/soc/cvitek/Makefile
new file mode 100644
index 000000000000..b2a6d8b54c54
--- /dev/null
+++ b/sound/soc/cvitek/Makefile
@@ -0,0 +1,81 @@
+# Cvitek Platform Support
+obj-$(CONFIG_SND_CV1835_I2S) += cv1835_i2s.o
+
+# Cvitek Machine Support
+snd-soc-cv1835-adau1372-objs := cv1835_adau1372.o
+
+obj-$(CONFIG_SND_SOC_CV1835_ADAU1372) += snd-soc-cv1835-adau1372.o
+
+obj-$(CONFIG_SND_SOC_CV1835_CV1835PDM) += cv1835_cv1835pdm.o
+
+obj-$(CONFIG_SND_SOC_CV182X_CV182XPDM) += cv182x_cv182xpdm.o
+
+obj-$(CONFIG_SND_SOC_CV1835PDM) += cv1835pdm.o
+
+obj-$(CONFIG_SND_SOC_CV1835_CV1835ADC) += cv1835_cv1835adc.o
+
+ifeq ($(CONFIG_SND_SOC_CV1835ADC),m)
+obj-$(CONFIG_SND_SOC_CV1835ADC) += cvi_ai.o
+cvi_ai-objs += cv1835adc.o
+else
+obj-$(CONFIG_SND_SOC_CV1835ADC) += cv1835adc.o
+endif
+
+
+obj-$(CONFIG_SND_SOC_CV1835_CV1835DAC) += cv1835_cv1835dac.o
+
+ifeq ($(CONFIG_SND_SOC_CV1835DAC),m)
+obj-$(CONFIG_SND_SOC_CV1835DAC) += cvi_ao.o
+cvi_ao-objs += cv1835dac.o
+else
+obj-$(CONFIG_SND_SOC_CV1835DAC) += cv1835dac.o
+endif
+
+obj-$(CONFIG_SND_SOC_CV183x_DUMMY_CARD) += cv1835_dummy_codec.o
+obj-$(CONFIG_SND_SOC_CV183x_DUMMY_CARD) += dummy_codec.o
+
+obj-$(CONFIG_SND_SOC_CV182X_CV182XADC) += cv182x_cv182xadc.o
+
+obj-$(CONFIG_SND_SOC_CV182XA_CV182XAADC) += cv181x_cv181xadc.o
+
+ifeq ($(CONFIG_SND_SOC_CV182XADC),m)
+obj-$(CONFIG_SND_SOC_CV182XADC) += cvi_ai.o
+cvi_ai-objs += cv182xadc.o
+else
+obj-$(CONFIG_SND_SOC_CV182XADC) += cv182xadc.o
+endif
+
+ifeq ($(CONFIG_SND_SOC_CV182XAADC),m)
+obj-$(CONFIG_SND_SOC_CV182XAADC) += cv182xa_ai.o
+cv182xa_ai-objs += cv181xadc.o
+else
+obj-$(CONFIG_SND_SOC_CV182XAADC) += cv181xadc.o
+endif
+
+#obj-y += cv1835_dummy_codec.o
+#obj-y += dummy_codec.o
+
+
+
+obj-$(CONFIG_SND_SOC_CV182X_CV182XDAC) += cv182x_cv182xdac.o
+
+obj-$(CONFIG_SND_SOC_CV182XA_CV182XADAC) += cv181x_cv181xdac.o
+
+ifeq ($(CONFIG_SND_SOC_CV182XDAC),m)
+obj-$(CONFIG_SND_SOC_CV182XDAC) += cvi_ao.o
+cvi_ao-objs += cv182xdac.o
+else
+obj-$(CONFIG_SND_SOC_CV182XDAC) += cv182xdac.o
+endif
+
+ifeq ($(CONFIG_SND_SOC_CV182XADAC),m)
+obj-$(CONFIG_SND_SOC_CV182XADAC) += cv182xa_ao.o
+cv182xa_ao-objs += cv181xdac.o
+else
+obj-$(CONFIG_SND_SOC_CV182XADAC) += cv181xdac.o
+endif
+
+# Cvitek audio subsys support
+obj-$(CONFIG_CV1835_I2S_SUBSYS) += cv1835_i2s_subsys.o
+
+obj-$(CONFIG_SND_SOC_CV1835_LT9611) += cv1835_lt9611.o
diff --git a/sound/soc/cvitek/cv181x_cv181xadc.c b/sound/soc/cvitek/cv181x_cv181xadc.c
new file mode 100644
index 000000000000..2f0de83ac76d
--- /dev/null
+++ b/sound/soc/cvitek/cv181x_cv181xadc.c
@@ -0,0 +1,289 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Machine driver for CVITEK ADC on CVITEK CV181X
+ *
+ * Copyright 2019 CVITEK
+ *
+ * Author: EthanChen
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <linux/io.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+#include "../codecs/cv181xadac.h"
+#include <linux/version.h>
+
+bool proc_ai_not_allocted = true;
+
+static int cv181x_adc_vol_list[25] = {
+	ADC_VOL_GAIN_0,
+	ADC_VOL_GAIN_1,
+	ADC_VOL_GAIN_2,
+	ADC_VOL_GAIN_3,
+	ADC_VOL_GAIN_4,
+	ADC_VOL_GAIN_5,
+	ADC_VOL_GAIN_6,
+	ADC_VOL_GAIN_7,
+	ADC_VOL_GAIN_8,
+	ADC_VOL_GAIN_9,
+	ADC_VOL_GAIN_10,
+	ADC_VOL_GAIN_11,
+	ADC_VOL_GAIN_12,
+	ADC_VOL_GAIN_13,
+	ADC_VOL_GAIN_14,
+	ADC_VOL_GAIN_15,
+	ADC_VOL_GAIN_16,
+	ADC_VOL_GAIN_17,
+	ADC_VOL_GAIN_18,
+	ADC_VOL_GAIN_19,
+	ADC_VOL_GAIN_20,
+	ADC_VOL_GAIN_21,
+	ADC_VOL_GAIN_22,
+	ADC_VOL_GAIN_23,
+	ADC_VOL_GAIN_24
+};
+
+static int cv181x_adc_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	return 0;
+}
+
+static int cv181x_adc_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+	return 0;
+}
+static struct snd_soc_ops cv181x_adc_ops = {
+	.hw_params = cv181x_adc_hw_params,
+};
+
+static struct snd_soc_dai_link_component cv181x_adc_cpus = {
+	.name = "4100000.i2s",
+	.dai_name = "4100000.i2s",
+
+};
+
+static struct snd_soc_dai_link_component cv181x_adc_codecs = {
+	.name = "300a100.adc",
+	.dai_name = "cvitekaadc",
+
+};
+
+static struct snd_soc_dai_link_component cv181x_adc_platform = {
+	.name = "4100000.i2s",
+	.dai_name = "4100000.i2s",
+
+};
+
+static struct snd_soc_dai_link cv181x_adc_dai = {
+	.name = "cviteka-i2s-adc",
+	.stream_name = "cviteka-adc",
+	.cpus = &cv181x_adc_cpus,
+	.num_cpus = 1,
+	.codecs = &cv181x_adc_codecs,
+	.num_codecs = 1,
+	.platforms = &cv181x_adc_platform,
+	.num_platforms = 1,
+	.ops = &cv181x_adc_ops,
+	.init = cv181x_adc_codec_init,
+	.dai_fmt = SND_SOC_DAIFMT_I2S
+	| SND_SOC_DAIFMT_IB_NF
+	| SND_SOC_DAIFMT_CBM_CFM,
+	.capture_only = 1,
+};
+
+static struct snd_soc_card cv181x_adc = {
+	//.owner = THIS_MODULE,
+	.name = "cviteka-i2s-adc",
+	.dai_link = &cv181x_adc_dai,
+	.num_links = 1,
+
+};
+
+
+static const struct of_device_id cvi_audio_match_ids[] = {
+	{
+		.compatible = "cvitek,cv182xa-adc",
+		//.data = (void *) &cv182xa_adc_dai,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, cvi_audio_match_ids);
+
+static int cv181x_adc_proc_show(struct seq_file *m, void *v)
+{
+	void __iomem *i2s0;
+	void __iomem *adc;
+	void __iomem *audio_pll;
+	void __iomem *sdma_pll;
+	u32 audio_freq;
+	u32 val1, val2, val3;
+	u32 temp1, temp2;
+
+	i2s0 = ioremap(0x04100000, 0x100);
+	adc = ioremap(0x0300A100, 0x100);
+	audio_pll = ioremap(0x3002854, 0x10);
+	sdma_pll = ioremap(0x3002004, 0x10);
+	if (readl(audio_pll) == 0x179EDCFA)
+		audio_freq = 22579200;
+	else if (readl(audio_pll) == 0x249f0000) {
+		audio_freq = 16384000;
+	} else
+		audio_freq = 24576000;
+
+
+	seq_puts(m, "\n------------- CVI AI ATTRIBUTE -------------\n");
+	seq_puts(m, "AiDev    Workmode    SampleRate    BitWidth\n");
+	val1 = (readl(i2s0) >> 1) & 0x1;
+	val2 = audio_freq / ((readl(i2s0 + 0x64) >> 16) * ((readl(i2s0 + 0x4) & 0x000001ff) + 1) * 2);
+	val3 = ((readl(i2s0 + 0x10) >> 1) & 0x3) * 16;
+	seq_printf(m, "  %d       %s        %6d        %2d\n", 0, val1 == 0 ? "slave" : "master", val2, val3);
+	seq_puts(m, "\n");
+	seq_puts(m, "-------------  CVI AI STATUS   -------------\n");
+
+	val1 = (readl(i2s0 + 0x18));
+	seq_printf(m, "I2S0 is %s\n", val1 == 1 ? "on" : "off");
+	seq_puts(m, "\n");
+	val1 = (readl(sdma_pll) & 0x00000002) >> 1;
+	seq_printf(m, "SDMA clk is %s\n", val1 == 1 ? "on" : "off");
+	seq_puts(m, "\n");
+
+	val1 = (readl(adc + AUDIO_PHY_RXADC_CTRL0) &
+		(AUDIO_PHY_REG_RXADC_EN_MASK | AUDIO_PHY_REG_I2S_TX_EN_MASK));
+	seq_printf(m, "ADC is %s (%d)\n", val1 == 3 ? "on" : "off", val1);
+	seq_puts(m, "\n");
+
+	val1 = (readl(adc + AUDIO_PHY_RXADC_ANA2) & AUDIO_PHY_REG_MUTEL_RXPGA_MASK);
+	val2 = (readl(adc + AUDIO_PHY_RXADC_ANA2) & AUDIO_PHY_REG_MUTER_RXPGA_MASK) >> 1;
+	seq_puts(m, "L-Mute   R-Mute\n");
+	seq_printf(m, "  %s       %s\n", val1 == 1 ? "yes" : "no", val2 == 1 ? "yes" : "no");
+	seq_puts(m, "\n");
+
+	val1 = (readl(adc + AUDIO_PHY_RXADC_ANA0) & 0xffff);
+	val2 = (readl(adc + AUDIO_PHY_RXADC_ANA0) & 0xffff0000) >> 16;
+
+	for (temp1 = 0; temp1 < 25; temp1++) {
+		if (val1 == cv181x_adc_vol_list[temp1])
+			break;
+	}
+	for (temp2 = 0; temp2 < 25; temp2++) {
+		if (val2 == cv181x_adc_vol_list[temp2])
+			break;
+	}
+
+	seq_puts(m, "L-Vol           R-Vol\n");
+	seq_printf(m, "  %d              %d\n", temp1, temp2);
+	seq_puts(m, "\n");
+
+
+
+	iounmap(i2s0);
+	iounmap(adc);
+	iounmap(audio_pll);
+	iounmap(sdma_pll);
+	return 0;
+}
+
+static int seq_cv181x_adc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, cv181x_adc_proc_show, PDE_DATA(inode));
+}
+
+static const struct proc_ops cv181x_adc_proc_ops = {
+	.proc_read	= seq_read,
+	.proc_open	= seq_cv181x_adc_open,
+	.proc_release	= single_release,
+};
+
+
+static int cv181x_adc_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card;
+	struct device_node *np = pdev->dev.of_node;
+	struct proc_dir_entry *proc_ai;
+
+
+	dev_info(&pdev->dev, "cviteka_adc_probe, dev name=%s\n", dev_name(&pdev->dev));
+	card = &cv181x_adc;
+
+	if (np) {
+
+		of_property_read_string(np, "cvi,card_name", &card->name);
+		card->dev = &pdev->dev;
+
+		if (!proc_audio_dir) {
+			proc_audio_dir = proc_mkdir("audio_debug", NULL);
+			if (!proc_audio_dir)
+				dev_err(&pdev->dev, "Error creating audio_debug proc folder entry\n");
+		}
+
+		if (proc_audio_dir && (proc_ai_not_allocted == true)) {
+			proc_ai = proc_create_data("cviteka_adc", 0444, proc_audio_dir, &cv181x_adc_proc_ops, np);
+			if (!proc_ai)
+				dev_err(&pdev->dev, "Create cviteka_adc proc failed!\n");
+			else
+				proc_ai_not_allocted = false;
+		}
+
+		platform_set_drvdata(pdev, card);
+		dev_info(&pdev->dev, "cviteka_adc_probe start devm_snd_soc_register_card\n");
+		return devm_snd_soc_register_card(&pdev->dev, card);
+	}
+	return 0;
+
+}
+
+#ifdef CONFIG_PM
+int cv181x_cv181xadc_suspend(struct device *dev)
+{
+	return 0;
+}
+
+int cv181x_cv181xadc_resume(struct device *dev)
+{
+	return 0;
+}
+
+int cv181x_cv181xadc_poweroff(struct device *dev)
+{
+	return 0;
+}
+
+#else
+#define cv181x_cv181xadc_suspend	NULL
+#define cv181x_cv181xadc_resume		NULL
+#define cv181x_cv181xadc_poweroff	NULL
+#endif
+
+const struct dev_pm_ops cv181x_cv181xadc_pm_ops = {
+	.suspend = cv181x_cv181xadc_suspend,
+	.resume = cv181x_cv181xadc_resume,
+	.freeze = cv181x_cv181xadc_suspend,
+	.thaw = cv181x_cv181xadc_resume,
+	.poweroff = cv181x_cv181xadc_poweroff,
+	.restore = cv181x_cv181xadc_resume,
+};
+
+static struct platform_driver cv181x_adc_driver = {
+	.driver = {
+		.name = "cviteka-adc",
+		.pm = &cv181x_cv181xadc_pm_ops,
+		.of_match_table = cvi_audio_match_ids,
+	},
+	.probe = cv181x_adc_probe,
+};
+
+module_platform_driver(cv181x_adc_driver);
+
+MODULE_AUTHOR("EthanChen");
+MODULE_DESCRIPTION("ALSA SoC cviteka adc driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:cviteka-adc");
diff --git a/sound/soc/cvitek/cv181x_cv181xdac.c b/sound/soc/cvitek/cv181x_cv181xdac.c
new file mode 100644
index 000000000000..1e83f0e81aa0
--- /dev/null
+++ b/sound/soc/cvitek/cv181x_cv181xdac.c
@@ -0,0 +1,246 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Machine driver for CVITEK DAC on CVITEK CV181X
+ *
+ * Copyright 2019 CVITEK
+ *
+ * Author: EthanChen
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <linux/io.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+#include "../codecs/cv181xadac.h"
+#include <linux/version.h>
+
+bool proc_ao_not_allocted = true;
+
+static int cv181x_dac_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	return 0;
+}
+
+static int cv181x_dac_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+	return 0;
+}
+
+static struct snd_soc_ops cv181x_dac_ops = {
+	.hw_params = cv181x_dac_hw_params,
+};
+
+static struct snd_soc_dai_link_component cv181x_dac_cpus = {
+	.name = "4130000.i2s",
+	.dai_name = "4130000.i2s",
+
+};
+
+static struct snd_soc_dai_link_component cv181x_dac_codecs = {
+	.name = "300a000.dac",
+	.dai_name = "cvitekadac",
+
+};
+
+static struct snd_soc_dai_link_component cv181x_dac_platform = {
+	.name = "4130000.i2s",
+	.dai_name = "4130000.i2s",
+
+};
+static struct snd_soc_dai_link cv181x_dac_dai = {
+	.name = "cviteka-i2s-dac",
+	.stream_name = "cviteka-dac",
+	.cpus = &cv181x_dac_cpus,
+	.num_cpus = 1,
+	.codecs = &cv181x_dac_codecs,
+	.num_codecs = 1,
+	.platforms = &cv181x_dac_platform,
+	.num_platforms = 1,
+	.ops = &cv181x_dac_ops,
+	.init = cv181x_dac_codec_init,
+	.dai_fmt = SND_SOC_DAIFMT_I2S
+	| SND_SOC_DAIFMT_IB_IF
+	| SND_SOC_DAIFMT_CBS_CFS,
+	.playback_only = 1,
+};
+
+
+static struct snd_soc_card cv181x_dac = {
+	.owner = THIS_MODULE,
+	.dai_link = &cv181x_dac_dai,
+	.num_links = 1,
+
+};
+
+
+static int cv181x_dac_proc_show(struct seq_file *m, void *v)
+{
+
+	void __iomem *i2s3;
+	void __iomem *dac;
+	void __iomem *audio_pll;
+	void __iomem *sdma_pll;
+	u32 audio_freq;
+	u32 val1, val2, val3;
+
+	i2s3 = ioremap(0x04130000, 0x100);
+	dac = ioremap(0x0300A000, 0x100);
+	audio_pll = ioremap(0x3002854, 0x10);
+	sdma_pll = ioremap(0x3002004, 0x10);
+	if (readl(audio_pll) == 0x179EDCFA)//406.4256MHz
+		audio_freq = 22579200;
+	else if (readl(audio_pll) == 0x249f0000) {
+		audio_freq = 16384000;
+	} else
+		audio_freq = 24576000;
+
+	seq_puts(m, "\n------------- CVI AO ATTRIBUTE -------------\n");
+	seq_puts(m, "AiDev    Workmode    SampleRate    BitWidth\n");
+	val1 = (readl(i2s3) >> 1) & 0x1;
+	val2 = audio_freq/((readl(i2s3 + 0x64) & 0x0000ffff)*(0x1 << (readl(dac + AUDIO_PHY_TXDAC_CTRL1) & 0x3))*64*4);
+	val3 = ((readl(i2s3 + 0x10) >> 1) & 0x3) * 16;
+	seq_printf(m, "  %d       %s        %6d        %2d\n", 1, val1 == 0 ? "slave" : "master", val2, val3);
+	seq_puts(m, "\n");
+	seq_puts(m, "-------------  CVI AO STATUS   -------------\n");
+	val1 = (readl(i2s3 + 0x18));
+	seq_printf(m, "I2S3 is %s\n", val1 == 1 ? "on" : "off");
+	seq_puts(m, "\n");
+
+	val1 = (readl(sdma_pll) & 0x00000002) >> 1;
+	seq_printf(m, "SDMA clk is %s\n", val1 == 1 ? "on" : "off");
+
+	val1 = (readl(dac + AUDIO_PHY_TXDAC_CTRL0)
+		& (AUDIO_PHY_REG_TXDAC_EN_MASK | AUDIO_PHY_REG_I2S_RX_EN_MASK));
+	seq_printf(m, "DAC is %s (%d)\n", val1 == 3 ? "on" : "off", val1);
+
+	val2 = (readl(dac + AUDIO_PHY_TXDAC_ANA2) & AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_MASK) >> 16;
+	val3 = (readl(dac + AUDIO_PHY_TXDAC_ANA2) & AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_MASK) >> 17;
+	seq_puts(m, "L-Mute   R-Mute\n");
+	seq_printf(m, "  %s       %s\n", val2 == 1 ? "yes" : "no", val3 == 1 ? "yes" : "no");
+	seq_puts(m, "\n");
+
+	val2 = ((readl(dac + AUDIO_PHY_TXDAC_AFE1) & AUDIO_PHY_REG_TXDAC_GAIN_UB_0_MASK) + 1)
+					/ CV181X_DAC_VOL_STEP;
+	val3 = (((readl(dac + AUDIO_PHY_TXDAC_AFE1) & AUDIO_PHY_REG_TXDAC_GAIN_UB_1_MASK) >> 16) + 1)
+					/ CV181X_DAC_VOL_STEP;
+	seq_puts(m, "L-Vol           R-Vol\n");
+	seq_printf(m, "  %d             %d\n", val2, val3);
+	seq_puts(m, "\n");
+
+	iounmap(i2s3);
+	iounmap(dac);
+	iounmap(audio_pll);
+	iounmap(sdma_pll);
+	return 0;
+}
+
+static int seq_cv181x_dac_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, cv181x_dac_proc_show, PDE_DATA(inode));
+}
+
+static const struct proc_ops cv181x_dac_proc_ops = {
+	.proc_read	= seq_read,
+	.proc_open	= seq_cv181x_dac_open,
+	.proc_release	= single_release,
+};
+
+static const struct of_device_id cvi_audio_match_ids[] = {
+	{
+		.compatible = "cvitek,cv182xa-dac",
+		//.data = (void *) &cv182xa_dac_dai,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, cvi_audio_match_ids);
+
+static int cv181x_dac_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card;
+	struct device_node *np = pdev->dev.of_node;
+	struct proc_dir_entry *proc_ao;
+
+	dev_info(&pdev->dev, "cviteka_dac_probe, dev name=%s\n", dev_name(&pdev->dev));
+
+	/* Ethan add, set pinmux by hard code temporary */
+	card = &cv181x_dac;
+
+	if (np) {
+
+		of_property_read_string(np, "cvi,card_name", &card->name);
+		card->dev = &pdev->dev;
+
+		if (!proc_audio_dir) {
+			proc_audio_dir = proc_mkdir("audio_debug", NULL);
+			if (!proc_audio_dir)
+				dev_err(&pdev->dev, "Error creating audio_debug proc folder entry\n");
+		}
+
+		if (proc_audio_dir && (proc_ao_not_allocted == true)) {
+			proc_ao = proc_create_data("cviteka_dac", 0444, proc_audio_dir, &cv181x_dac_proc_ops, np);
+			if (!proc_ao)
+				dev_err(&pdev->dev, "Create cviteka_dac proc failed!\n");
+			proc_ao_not_allocted = false;
+		}
+
+		platform_set_drvdata(pdev, card);
+		return devm_snd_soc_register_card(&pdev->dev, card);
+	}
+	return 0;
+
+}
+
+#ifdef CONFIG_PM
+int cv181x_cv181xdac_suspend(struct device *dev)
+{
+	return 0;
+}
+
+int cv181x_cv181xdac_resume(struct device *dev)
+{
+	return 0;
+}
+
+int cv181x_cv181xdac_poweroff(struct device *dev)
+{
+	return 0;
+}
+
+#else
+#define cv181x_cv181xdac_suspend	NULL
+#define cv181x_cv181xdac_resume		NULL
+#define cv181x_cv181xdac_poweroff	NULL
+#endif
+
+const struct dev_pm_ops cv181x_cv181xdac_pm_ops = {
+	.suspend = cv181x_cv181xdac_suspend,
+	.resume = cv181x_cv181xdac_resume,
+	.freeze = cv181x_cv181xdac_suspend,
+	.thaw = cv181x_cv181xdac_resume,
+	.poweroff = cv181x_cv181xdac_poweroff,
+	.restore = cv181x_cv181xdac_resume,
+};
+
+static struct platform_driver cv181x_dac_driver = {
+	.driver = {
+		.name = "cviteka-dac",
+		.pm = &cv181x_cv181xdac_pm_ops,
+		.of_match_table = cvi_audio_match_ids,
+	},
+	.probe = cv181x_dac_probe,
+};
+
+module_platform_driver(cv181x_dac_driver);
+
+MODULE_AUTHOR("EthanChen");
+MODULE_DESCRIPTION("ALSA SoC cviteka dac driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:cviteka-dac");
diff --git a/sound/soc/cvitek/cv181xadc.c b/sound/soc/cvitek/cv181xadc.c
new file mode 100644
index 000000000000..91d101b62ea9
--- /dev/null
+++ b/sound/soc/cvitek/cv181xadc.c
@@ -0,0 +1,966 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * CVITEK CV181X ADC driver
+ *
+ * Copyright 2020 CVITEK Inc.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/pm.h>
+#include <linux/mutex.h>
+#include <linux/miscdevice.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/control.h>
+#include "cv1835_ioctl.h"
+#include "../codecs/cv181xadac.h"
+#include "cv1835_i2s_subsys.h"
+
+static DEFINE_MUTEX(cv181xadc_mutex);
+
+static int adc_vol_list[25] = {
+	ADC_VOL_GAIN_0,
+	ADC_VOL_GAIN_1,
+	ADC_VOL_GAIN_2,
+	ADC_VOL_GAIN_3,
+	ADC_VOL_GAIN_4,
+	ADC_VOL_GAIN_5,
+	ADC_VOL_GAIN_6,
+	ADC_VOL_GAIN_7,
+	ADC_VOL_GAIN_8,
+	ADC_VOL_GAIN_9,
+	ADC_VOL_GAIN_10,
+	ADC_VOL_GAIN_11,
+	ADC_VOL_GAIN_12,
+	ADC_VOL_GAIN_13,
+	ADC_VOL_GAIN_14,
+	ADC_VOL_GAIN_15,
+	ADC_VOL_GAIN_16,
+	ADC_VOL_GAIN_17,
+	ADC_VOL_GAIN_18,
+	ADC_VOL_GAIN_19,
+	ADC_VOL_GAIN_20,
+	ADC_VOL_GAIN_21,
+	ADC_VOL_GAIN_22,
+	ADC_VOL_GAIN_23,
+	ADC_VOL_GAIN_24
+};
+
+u32 old_adc_voll;
+u32 old_adc_volr;
+
+static int adc_open(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&cv181xadc_mutex))
+		return -EINTR;
+	mutex_unlock(&cv181xadc_mutex);
+	pr_debug("%s\n", __func__);
+	return 0;
+}
+
+static int adc_close(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&cv181xadc_mutex))
+		return -EINTR;
+	mutex_unlock(&cv181xadc_mutex);
+	pr_debug("%s\n", __func__);
+	return 0;
+}
+
+static inline void adc_write_reg(void __iomem *io_base, int reg, u32 val)
+{
+	writel(val, io_base + reg);
+}
+
+static inline u32 adc_read_reg(void __iomem *io_base, int reg)
+{
+	return readl(io_base + reg);
+}
+
+static void cv181xadc_clk_on(struct cv181xadc *adc)
+{
+
+	u32 clk_ctrl0;
+
+	mutex_lock(&cv181xadc_mutex);
+
+	clk_ctrl0 = readl(adc->mclk_source + CVI_I2S_CLK_CTRL0);
+
+	if (!(clk_ctrl0 & CVI_I2S_AU_EN_MASK)) {
+		dev_info(adc->dev, "turn I2S3 aud_en on\n");
+		clk_ctrl0 |= CVI_I2S_AU_EN;
+	}
+
+	if (!(clk_ctrl0 & CVI_I2S_MCLK_OUT_EN_MASK)) {
+		dev_info(adc->dev, "turn I2S3 mclk_out_en on\n");
+		clk_ctrl0 |= CVI_I2S_MCLK_OUT_EN;
+	}
+
+	writel(clk_ctrl0, adc->mclk_source + CVI_I2S_CLK_CTRL0);
+	dev_info(adc->dev, "adc_clk_on, I2S3 clk_ctrl0 = 0x%x\n", readl(adc->mclk_source + CVI_I2S_CLK_CTRL0));
+
+	mutex_unlock(&cv181xadc_mutex);
+}
+
+static void cv181xadc_set_mclk(struct cv181xadc *adc, u32 rate)
+{
+
+	u32 clk_ctrl1, audio_clk;
+
+	mutex_lock(&cv181xadc_mutex);
+
+	clk_ctrl1 = readl(adc->mclk_source + CVI_I2S_CLK_CTRL1) & ~CVI_I2S_MCLK_MASK;
+
+	dev_dbg(adc->dev, "adc_set_mclk, I2S3 ctrl1=0x%x\n", clk_ctrl1);
+
+	switch (rate) {
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+		audio_clk = CVI_22579_MHZ;
+		break;
+	case 8000:
+	case 16000:
+	case 32000:
+		audio_clk = CVI_16384_MHZ;
+		break;
+	case 12000:
+	case 24000:
+	case 48000:
+	case 96000:
+	case 192000:
+		audio_clk = CVI_24576_MHZ;
+		break;
+	default:
+		dev_err(adc->dev, "Warning!!! this sample rate is not supported\n");
+		return;
+	}
+
+	dev_dbg(adc->dev, "Audio system clk=%d, sample rate=%d\n", audio_clk, rate);
+	cv1835_set_mclk(audio_clk);
+
+	/* cv182xa internal adc codec need dynamic MCLK frequency input */
+	switch (rate) {
+	case 8000:
+	case 16000:
+	case 32000:
+		clk_ctrl1 |= CVI_I2S_MCLK_DIV(1);
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 48000:
+		clk_ctrl1 |= CVI_I2S_MCLK_DIV(2);
+		break;
+	default:
+		dev_err(adc->dev, "adc_set_mclk doesn't support this sample rate\n");
+		break;
+	}
+	writel(clk_ctrl1, adc->mclk_source + CVI_I2S_CLK_CTRL1);
+	dev_dbg(adc->dev, "adc_set_mclk I2S3 clk_ctrl1 = 0x%x\n", readl(adc->mclk_source + CVI_I2S_CLK_CTRL1));
+	mutex_unlock(&cv181xadc_mutex);
+}
+
+static void cv181xadc_clk_off(struct cv181xadc *adc)
+{
+	u32 i2s_en;
+	u32 clk_ctrl0;
+
+	mutex_lock(&cv181xadc_mutex);
+
+	i2s_en = readl(adc->mclk_source + CVI_I2S_EN);
+	clk_ctrl0 = readl(adc->mclk_source + CVI_I2S_CLK_CTRL0);
+
+	if (!i2s_en) {
+		if ((clk_ctrl0 & CVI_I2S_AU_EN_MASK)) {
+			dev_info(adc->dev, "turn I2S3 aud_en off\n");
+			clk_ctrl0 &= CVI_I2S_AU_OFF;
+		}
+	}
+
+	if (!(clk_ctrl0 & CVI_I2S_MCLK_OUT_EN_MASK)) {
+		dev_info(adc->dev, "turn I2S3 mclk_out_en on\n");
+		clk_ctrl0 &= CVI_I2S_MCLK_OUT_OFF;
+	}
+
+	writel(clk_ctrl0, adc->mclk_source + CVI_I2S_CLK_CTRL0);
+	dev_info(adc->dev, "adc_clk_off, I2S3 clk_ctrl0 = 0x%x\n", readl(adc->mclk_source + CVI_I2S_CLK_CTRL0));
+
+	mutex_unlock(&cv181xadc_mutex);
+}
+
+static int cv181xadc_set_dai_fmt(struct snd_soc_dai *dai,
+					unsigned int fmt)
+{
+
+	struct cv181xadc *adc = snd_soc_dai_get_drvdata(dai);
+
+	if (!adc->dev)
+		dev_err(adc->dev, "dev is NULL\n");
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		dev_dbg(adc->dev, "Set ADC to MASTER mode\n");
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		dev_err(adc->dev, "Cannot set DAC to SLAVE mode, only support MASTER mode\n");
+		break;
+	default:
+		dev_err(adc->dev, "Cannot support this role mode\n");
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_IF:
+		dev_dbg(adc->dev, "set codec to NB_IF\n");
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		dev_dbg(adc->dev, "set codec to IB_NF\n");
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		dev_dbg(adc->dev, "set codec to IB_IF\n");
+		break;
+	case SND_SOC_DAIFMT_NB_NF:
+		dev_dbg(adc->dev, "set codec to NB_NF\n");
+		break;
+	default:
+		dev_err(adc->dev, "Cannot support this format\n");
+		break;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		dev_dbg(adc->dev, "set codec to I2S mode\n");
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		dev_dbg(adc->dev, "set codec to LEFT-JUSTIFY mode\n");
+		break;
+	default:
+		dev_err(adc->dev, "Cannot support this mode\n");
+		break;
+	}
+	return 0;
+}
+
+static int cv181xadc_hw_params(struct snd_pcm_substream *substream,
+				  struct snd_pcm_hw_params *params,
+				  struct snd_soc_dai *dai)
+{
+	struct cv181xadc *adc = snd_soc_dai_get_drvdata(dai);
+	int rate;
+	u32 ctrl1 = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL1) & ~AUDIO_PHY_REG_RXADC_CIC_OPT_MASK;
+	u32 ana3 = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA3) & ~AUDIO_PHY_REG_CTUNE_RXADC_MASK;
+	u32 ana0;
+	u32 clk = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CLK) &
+			~(AUDIO_RXADC_SCK_DIV_MASK | AUDIO_RXADC_DLYEN_MASK);
+	void __iomem *dac;
+
+	/* ECO function, register naming is not corrected, use ioremap to access register of DAC */
+	dac = ioremap(0x0300A000, 0x30);
+	ana0 = readl(dac + AUDIO_PHY_TXDAC_ANA0) & ~AUDIO_PHY_REG_ADDI_TXDAC_MASK;
+
+	rate = params_rate(params);
+	if (rate >= 8000 && rate <= 48000) {
+		dev_info(adc->dev, "adc_hw_params, set rate to %d\n", rate);
+		cv181xadc_set_mclk(adc, rate);
+
+		switch (rate) {
+		case 8000:
+			ctrl1 |= RXADC_CIC_DS_512;
+			ana3 |= RXADC_CTUNE_MCLK_16384;
+			ana0 &= ADDI_TXDAC_GAIN_RATIO_1;
+			clk |= RXADC_SCK_DIV(32) | RXADC_DLYEN(0x21); /* 16384 / 8 / 32 / 2 */
+			break;
+		case 11025:
+			ctrl1 |= RXADC_CIC_DS_256;
+			ana3 |= RXADC_CTUNE_MCLK_11298;
+			ana0 &= ADDI_TXDAC_GAIN_RATIO_1;
+			clk |= RXADC_SCK_DIV(16) | RXADC_DLYEN(0x17); /* 112896 / 11.025 / 32 / 2 */
+			break;
+		case 16000:
+			ctrl1 |= RXADC_CIC_DS_256;
+			ana3 |= RXADC_CTUNE_MCLK_16384;
+			ana0 &= ADDI_TXDAC_GAIN_RATIO_1;
+			clk |= RXADC_SCK_DIV(16) | RXADC_DLYEN(0x21); /* 16384 / 16 / 32 / 2 */
+			break;
+		case 22050:
+			ctrl1 |= RXADC_CIC_DS_128;
+			ana3 |= RXADC_CTUNE_MCLK_11298;
+			ana0 &= ADDI_TXDAC_GAIN_RATIO_1;
+			clk |= RXADC_SCK_DIV(8) | RXADC_DLYEN(0x17); /* 112896 / 22.05 / 32 / 2 */
+			break;
+		case 32000:
+			ctrl1 |= RXADC_CIC_DS_128;
+			ana3 |= RXADC_CTUNE_MCLK_16384;
+			ana0 &= ADDI_TXDAC_GAIN_RATIO_1;
+			clk |= RXADC_SCK_DIV(8) | RXADC_DLYEN(0x21); /* 16384 / 32 / 32 / 2 */
+			break;
+		case 44100:
+			ctrl1 &= RXADC_CIC_DS_64;
+			ana3 |= RXADC_CTUNE_MCLK_11298;
+			ana0 &= ADDI_TXDAC_GAIN_RATIO_1;
+			clk |= RXADC_SCK_DIV(4) | RXADC_DLYEN(0x17); /* 112896 / 44.1 / 32 / 2 */
+			break;
+		case 48000:
+			ctrl1 &= RXADC_CIC_DS_64;
+			ana3 |= RXADC_CTUNE_MCLK_12288;
+			ana0 &= ADDI_TXDAC_GAIN_RATIO_1;
+			clk |= RXADC_SCK_DIV(4) | RXADC_DLYEN(0x19); /* 16384 / 16 / 32 / 2 */
+			break;
+		default:
+			ctrl1 |= RXADC_CIC_DS_256;
+			ana3 |= RXADC_CTUNE_MCLK_16384;
+			ana0 &= ADDI_TXDAC_GAIN_RATIO_1;
+			clk |= RXADC_SCK_DIV(16) | RXADC_DLYEN(0x21); /* 16384 / 16 / 32 / 2 */
+			dev_dbg(adc->dev, "adc_hw_params, unsupported sample rate. Set with default 16KHz\n");
+			break;
+		}
+
+		adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL1, ctrl1);
+		adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA3, ana3);
+		adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CLK, clk);
+		writel(ana0, dac + AUDIO_PHY_TXDAC_ANA0);
+
+		iounmap(dac);
+	} else {
+		dev_err(adc->dev, "adc_hw_params, unsupported sample rate\n");
+		return 0;
+	}
+
+	if (params_width(params) != 16) {
+		dev_err(adc->dev, "Only support I2S channel width with 16 bits\n");
+		dev_err(adc->dev, "Set I2S channel width with 16bits\n");
+		return 0;
+	}
+	return 0;
+}
+
+static int cv181xadc_startup(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct cv181xadc *adc = snd_soc_dai_get_drvdata(dai);
+
+	dev_dbg(adc->dev, "adc_startup\n");
+	cv181xadc_clk_on(adc);
+
+	return 0;
+}
+
+static void cv181xadc_on(struct cv181xadc *adc)
+{
+
+	u32 val = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+
+	dev_info(adc->dev, "adc_on, before rxadc reg val=0x%08x\n",
+	adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0));
+
+	if ((val & AUDIO_PHY_REG_RXADC_EN_ON) | (val & AUDIO_PHY_REG_I2S_TX_EN_ON))
+		dev_info(adc->dev, "ADC or I2S TX already switched ON!!, val=0x%08x\n", val);
+
+	val |= AUDIO_PHY_REG_RXADC_EN_ON | AUDIO_PHY_REG_I2S_TX_EN_ON;
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, val);
+
+	dev_info(adc->dev, "adc_on, after rxadc reg val=0x%08x\n",
+	adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0));
+
+}
+
+static void cv181xadc_off(struct cv181xadc *adc)
+{
+
+	u32 val = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+
+	val &= AUDIO_PHY_REG_RXADC_EN_OFF & AUDIO_PHY_REG_I2S_TX_EN_OFF;
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, val);
+
+	dev_dbg(adc->dev, "adc_off, after rxadc reg val=0x%08x\n",
+	adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0));
+
+}
+
+static void cv181xadc_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct cv181xadc *adc = snd_soc_dai_get_drvdata(dai);
+
+	dev_dbg(adc->dev, "adc_shutdown\n");
+	cv181xadc_off(adc);
+	cv182xa_reset_adc();
+	cv181xadc_clk_off(adc);
+}
+
+static int cv181xadc_trigger(struct snd_pcm_substream *substream,
+		int cmd, struct snd_soc_dai *dai)
+{
+	struct cv181xadc *adc = snd_soc_dai_get_drvdata(dai);
+	int ret = 0;
+
+	dev_dbg(adc->dev, "adc_trigger, cmd=%d\n", cmd);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		//cv182xaadc_on(adc);//move to prepare function to meet adc on(clock out) before i2s reset
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		//cv182xaadc_off(adc);//move to shutdown function as adc on move to prepare
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int cv181xadc_prepare(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct cv181xadc *adc = snd_soc_dai_get_drvdata(dai);
+	u32 val;
+
+	//need to rewrite the register if called cv182xa_reset_adc
+	val = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2);
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2, val);
+	val = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0);
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0, val);
+	cv181xadc_on(adc);
+	return 0;
+}
+
+
+static struct cv181xadc *file_adc_dev(struct file *file)
+{
+	return container_of(file->private_data, struct cv181xadc, miscdev);
+}
+
+
+static long adc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+
+	unsigned int __user *argp = (unsigned int __user *)arg;
+	struct cv181xadc *adc = file_adc_dev(file);
+	struct cvi_vol_ctrl vol;
+	u32 val, val2;
+	u32 temp;
+
+	if (argp != NULL) {
+		if (!copy_from_user(&val, argp, sizeof(val))) {
+			if (mutex_lock_interruptible(&cv181xadc_mutex)) {
+				pr_debug("cvitekaadc: signal arrives while waiting for lock\n");
+				return -EINTR;
+			}
+		} else
+			return -EFAULT;
+	}
+
+	pr_debug("%s, received cmd=%u, val=%d\n", __func__, cmd, val);
+
+	switch (cmd) {
+	case ACODEC_SOFT_RESET_CTRL:
+		cv182xa_reset_adc();
+		break;
+
+	case ACODEC_SET_INPUT_VOL:
+		pr_debug("adc: ACODEC_SET_INPUT_VOL\n");
+		if ((val < 0) | (val > 24))
+			pr_err("Only support range 0 [0dB] ~ 24 [48dB]\n");
+		else if (val == 0) {
+			/* set mute */
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2)
+				| AUDIO_PHY_REG_MUTEL_ON
+				| AUDIO_PHY_REG_MUTER_ON;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2, temp);
+			temp = (adc_vol_list[val] | (adc_vol_list[val] << 16));
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0, temp);
+		} else {
+			val2 = (adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & AUDIO_PHY_REG_ADC_VOLL_MASK);
+			for (temp = 0; temp < 25; temp++) {
+				if (val2 == adc_vol_list[temp])
+					break;
+			}
+			if (temp == 0) {
+				/* unmute */
+				temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2)
+					& AUDIO_PHY_REG_MUTEL_OFF
+					& AUDIO_PHY_REG_MUTEL_OFF;
+				adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2, temp);
+			}
+			temp = (adc_vol_list[val] | (adc_vol_list[val] << 16));
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0, temp);
+		}
+		break;
+
+	case ACODEC_GET_INPUT_VOL:
+		pr_debug("adc: ACODEC_GET_INPUT_VOL\n");
+		val = (adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & AUDIO_PHY_REG_ADC_VOLL_MASK);
+		for (temp = 0; temp < 25; temp++) {
+			if (val == adc_vol_list[temp])
+				break;
+		}
+		if (temp == 25)
+			pr_info("adc: cannot find, out of range\n");
+
+		if (copy_to_user(argp, &temp, sizeof(temp)))
+			pr_err("adc, failed to return input vol\n");
+		break;
+
+	case ACODEC_SET_I2S1_FS:
+		pr_info("adc: ACODEC_SET_I2S1_FS is not support\n");
+		break;
+
+	case ACODEC_SET_MIXER_MIC:
+		pr_info("ACODEC_SET_MIXER_MIC is not support\n");
+		break;
+	case ACODEC_SET_GAIN_MICL:
+		pr_debug("adc: ACODEC_SET_GAIN_MICL\n");
+		if ((val < 0) | (val > 24))
+			pr_err("Only support range 0 [0dB] ~ 24 [48dB]\n");
+		else {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & ~AUDIO_PHY_REG_ADC_VOLL_MASK;
+			temp |= adc_vol_list[val];
+			old_adc_voll = val;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0, temp);
+		}
+		break;
+	case ACODEC_SET_GAIN_MICR:
+		pr_debug("adc: ACODEC_SET_GAIN_MICR\n");
+		if ((val < 0) | (val > 24))
+			pr_err("Only support range 0 [0dB] ~ 24 [48dB]\n");
+		else {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & ~AUDIO_PHY_REG_ADC_VOLR_MASK;
+			temp |= (adc_vol_list[val] << 16);
+			old_adc_volr = val;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0, temp);
+		}
+		break;
+
+	case ACODEC_SET_ADCL_VOL:
+
+		if (copy_from_user(&vol, argp, sizeof(vol))) {
+			if (mutex_is_locked(&cv181xadc_mutex))
+				mutex_unlock(&cv181xadc_mutex);
+
+			return -EFAULT;
+		}
+
+		pr_info("adc: ACODEC_SET_ADCL_VOL to %d, mute=%d\n", vol.vol_ctrl, vol.vol_ctrl_mute);
+
+		if (vol.vol_ctrl_mute == 1) {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) | AUDIO_PHY_REG_MUTEL_ON;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2, temp);
+		} else if ((vol.vol_ctrl < 0) | (vol.vol_ctrl > 24))
+			pr_err("adc-L: Only support range 0 [0dB] ~ 24 [48dB]\n");
+		else {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & ~AUDIO_PHY_REG_ADC_VOLL_MASK;
+			temp |= adc_vol_list[val];
+			old_adc_voll = val;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0, temp);
+
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) & AUDIO_PHY_REG_MUTEL_OFF;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2, temp);
+		}
+
+		break;
+
+	case ACODEC_SET_ADCR_VOL:
+		if (copy_from_user(&vol, argp, sizeof(vol))) {
+			if (mutex_is_locked(&cv181xadc_mutex))
+				mutex_unlock(&cv181xadc_mutex);
+
+			return -EFAULT;
+		}
+
+		pr_debug("adc: ACODEC_SET_ADCR_VOL to %d, mute=%d\n", vol.vol_ctrl, vol.vol_ctrl_mute);
+
+		if (vol.vol_ctrl_mute == 1) {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) | AUDIO_PHY_REG_MUTER_ON;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2, temp);
+		} else if ((vol.vol_ctrl < 0) | (vol.vol_ctrl > 24))
+			pr_err("adc-R: Only support range 0 [0dB] ~ 24 [48dB]\n");
+		else {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & ~AUDIO_PHY_REG_ADC_VOLR_MASK;
+			temp |= (adc_vol_list[val] << 16);
+			old_adc_volr = val;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0, temp);
+
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) & AUDIO_PHY_REG_MUTER_OFF;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2, temp);
+		}
+		break;
+	case ACODEC_SET_MICL_MUTE:
+		pr_debug("adc: ACODEC_SET_MICL_MUTE\n");
+		if (val == 0)
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) & AUDIO_PHY_REG_MUTEL_OFF;
+		else
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) | AUDIO_PHY_REG_MUTEL_ON;
+
+		adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2, temp);
+		break;
+	case ACODEC_SET_MICR_MUTE:
+		pr_debug("adc: ACODEC_SET_MICR_MUTE\n");
+		if (val == 0)
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) & AUDIO_PHY_REG_MUTER_OFF;
+		else
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) | AUDIO_PHY_REG_MUTER_ON;
+
+		adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2, temp);
+		break;
+
+	case ACODEC_GET_GAIN_MICL:
+		pr_debug("adc: ACODEC_GET_GAIN_MICL\n");
+		val = (adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & AUDIO_PHY_REG_ADC_VOLL_MASK);
+
+		for (temp = 0; temp < 25; temp++) {
+			if (val == adc_vol_list[temp])
+				break;
+		}
+
+		if (copy_to_user(argp, &temp, sizeof(temp)))
+			pr_err("failed to return MICL gain\n");
+		break;
+	case ACODEC_GET_GAIN_MICR:
+		pr_debug("adc: ACODEC_GET_GAIN_MICR\n");
+		val = (adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & AUDIO_PHY_REG_ADC_VOLR_MASK) >> 16;
+
+		for (temp = 0; temp < 25; temp++) {
+			if (val == adc_vol_list[temp])
+				break;
+		}
+		if (copy_to_user(argp, &temp, sizeof(temp)))
+			pr_err("failed to return MICR gain\n");
+		break;
+
+	case ACODEC_GET_ADCL_VOL:
+		pr_debug("adc: ACODEC_GET_ADCL_VOL\n");
+
+		val = (adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & AUDIO_PHY_REG_ADC_VOLL_MASK);
+		for (temp = 0; temp < 25; temp++) {
+			if (val == adc_vol_list[temp])
+				break;
+		}
+		vol.vol_ctrl = temp;
+		vol.vol_ctrl_mute = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) & AUDIO_PHY_REG_MUTEL_RXPGA_MASK;
+
+		if (copy_to_user(argp, &vol, sizeof(vol)))
+			pr_err("failed to return ADCL vol\n");
+
+		break;
+	case ACODEC_GET_ADCR_VOL:
+		pr_debug("adc: ACODEC_GET_ADCR_VOL\n");
+
+		val = (adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & AUDIO_PHY_REG_ADC_VOLR_MASK) >> 16;
+		for (temp = 0; temp < 25; temp++) {
+			if (val == adc_vol_list[temp])
+				break;
+		}
+		vol.vol_ctrl = temp;
+		vol.vol_ctrl_mute = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) & AUDIO_PHY_REG_MUTER_RXPGA_MASK;
+
+		if (copy_to_user(argp, &vol, sizeof(vol)))
+			pr_err("failed to return ADCR vol\n");
+
+		break;
+
+	case ACODEC_SET_PD_ADCL:
+		pr_debug("adc: ACODEC_SET_PD_ADCL, val=%d\n", val);
+		if (val == 0) {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+			temp |= AUDIO_PHY_REG_RXADC_EN_ON | AUDIO_PHY_REG_I2S_TX_EN_ON;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, temp);
+		} else {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+			temp &= AUDIO_PHY_REG_RXADC_EN_OFF & AUDIO_PHY_REG_I2S_TX_EN_OFF;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, temp);
+		}
+		break;
+	case ACODEC_SET_PD_ADCR:
+		pr_debug("adc: ACODEC_SET_PD_ADCR, val=%d\n", val);
+		if (val == 0) {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+			temp |= AUDIO_PHY_REG_RXADC_EN_ON | AUDIO_PHY_REG_I2S_TX_EN_ON;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, temp);
+		} else {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+			temp &= AUDIO_PHY_REG_RXADC_EN_OFF & AUDIO_PHY_REG_I2S_TX_EN_OFF;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, temp);
+		}
+		break;
+
+	case ACODEC_SET_PD_LINEINL:
+		pr_debug("adc: ACODEC_SET_PD_LINEINL, val=%d\n", val);
+		if (val == 0) {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+			temp |= AUDIO_PHY_REG_RXADC_EN_ON | AUDIO_PHY_REG_I2S_TX_EN_ON;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, temp);
+		} else {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+			temp &= AUDIO_PHY_REG_RXADC_EN_OFF & AUDIO_PHY_REG_I2S_TX_EN_OFF;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, temp);
+		}
+		break;
+	case ACODEC_SET_PD_LINEINR:
+		pr_debug("adc: ACODEC_SET_PD_LINEINR, val=%d\n", val);
+		if (val == 0) {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+			temp |= AUDIO_PHY_REG_RXADC_EN_ON | AUDIO_PHY_REG_I2S_TX_EN_ON;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, temp);
+		} else {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+			temp &= AUDIO_PHY_REG_RXADC_EN_OFF & AUDIO_PHY_REG_I2S_TX_EN_OFF;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, temp);
+		}
+		break;
+	case ACODEC_SET_ADC_HP_FILTER:
+		pr_info("adc: ACODEC_SET_ADC_HP_FILTER is not support\n");
+		break;
+	default:
+		pr_info("%s, received unsupport cmd=%u\n", __func__, cmd);
+		break;
+	}
+
+	if (mutex_is_locked(&cv181xadc_mutex))
+		mutex_unlock(&cv181xadc_mutex);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops cv181xadc_dai_ops = {
+	.hw_params	= cv181xadc_hw_params,
+	.set_fmt	= cv181xadc_set_dai_fmt,
+	.startup	= cv181xadc_startup,
+	.shutdown	= cv181xadc_shutdown,
+	.trigger	= cv181xadc_trigger,
+	.prepare	= cv181xadc_prepare,
+};
+
+static struct snd_soc_dai_driver cv181xadc_dai = {
+	.name		= "cvitekaadc",
+	.capture	= {
+		.stream_name	= "Capture",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates = SNDRV_PCM_RATE_8000_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.ops		= &cv181xadc_dai_ops,
+};
+
+static const struct snd_kcontrol_new cv181xadc_controls[] = {
+	SOC_DOUBLE("ADC Power", AUDIO_PHY_RXADC_CTRL0, 0, 1, 1, 0),
+	SOC_DOUBLE("ADC Capture Volume", AUDIO_PHY_RXADC_ANA0, 0, 16, 24, 0),
+	SOC_DOUBLE("ADC Capture Mute", AUDIO_PHY_RXADC_ANA2, 0, 1, 1, 0),
+};
+
+unsigned int cv181xadc_reg_read(struct snd_soc_component *codec, unsigned int reg)
+{
+	int ret, lidx, ridx;
+	struct cv181xadc *adc = dev_get_drvdata(codec->dev);
+
+	ret = adc_read_reg(adc->adc_base, reg);
+	if (reg == AUDIO_PHY_RXADC_ANA0) {
+		for (lidx = 0; lidx < 25; lidx++)
+			if ((ret & 0xffff) == adc_vol_list[lidx])
+				break;
+		for (ridx = 0; ridx < 25; ridx++)
+			if (((ret>>16) & 0xffff) == adc_vol_list[ridx])
+				break;
+		dev_info(adc->dev, "ADC get Vol, reg:%d,ret:%#x, idx=%d.\n", reg, ret, lidx);
+		ret = (lidx << 16) | ridx;
+	}
+
+	dev_dbg(adc->dev, "adc_reg_read reg:%d,ret:%#x.\n", reg, ret);
+
+	return ret;
+}
+
+int cv181xadc_reg_write(struct snd_soc_component *codec, unsigned int reg, unsigned int value)
+{
+	struct cv181xadc *adc = dev_get_drvdata(codec->dev);
+	u32 temp_lval;
+	u32 temp_rval;
+
+	if (reg == AUDIO_PHY_RXADC_ANA0) {
+		temp_lval = value & 0xffff;
+		temp_rval = (value >> 16) & 0xffff;
+		if (temp_lval > 24)
+			temp_lval = 24;
+		if (temp_rval > 24)
+			temp_rval = 24;
+		value = (adc_vol_list[temp_rval]<<16) | adc_vol_list[temp_lval];
+		dev_info(adc->dev, "Set ADC Vol, get input val=%d, output val=0x%x\n", value, temp_lval);
+	}
+
+
+	adc_write_reg(adc->adc_base, reg, value);
+	dev_dbg(adc->dev, "adc_reg_write reg:%d,value:%#x.\n", reg, value);
+
+	return 0;
+}
+
+static const struct snd_soc_component_driver soc_component_dev_cv181xadc = {
+	.controls = cv181xadc_controls,
+	.num_controls = ARRAY_SIZE(cv181xadc_controls),
+	.read = cv181xadc_reg_read,
+	.write = cv181xadc_reg_write,
+};
+
+static const struct file_operations adc_fops = {
+	.owner = THIS_MODULE,
+	.open = adc_open,
+	.release = adc_close,
+	.unlocked_ioctl = adc_ioctl,
+	.compat_ioctl = adc_ioctl,
+};
+
+static int adc_device_register(struct cv181xadc *adc)
+{
+	struct miscdevice *miscdev = &adc->miscdev;
+	int ret;
+
+	miscdev->minor = MISC_DYNAMIC_MINOR;
+	miscdev->name = "cvitekaadc";
+	miscdev->fops = &adc_fops;
+	miscdev->parent = NULL;
+
+	ret = misc_register(miscdev);
+	if (ret) {
+		pr_err("adc: failed to register misc device.\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int cv181xadc_probe(struct platform_device *pdev)
+{
+	struct cv181xadc *adc;
+	struct resource *res;
+	u32 mclk_source_addr = 0x0;
+	u32 ctrl1;
+	int ret;
+
+	dev_info(&pdev->dev, "cvitekaadc_probe\n");
+
+	adc = devm_kzalloc(&pdev->dev, sizeof(*adc), GFP_KERNEL);
+	if (!adc)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	adc->adc_base = devm_ioremap_resource(&pdev->dev, res);
+	dev_dbg(&pdev->dev, "cvitekaadc get adc_base=0x%p\n", adc->adc_base);
+	if (IS_ERR(adc->adc_base))
+		return PTR_ERR(adc->adc_base);
+
+	dev_set_drvdata(&pdev->dev, adc);
+	adc->dev = &pdev->dev;
+
+	ret = adc_device_register(adc);
+	if (ret < 0) {
+		pr_err("adc: register device error\n");
+		return ret;
+	}
+
+	of_property_read_u32(pdev->dev.of_node, "clk_source", &mclk_source_addr);
+
+	if (mclk_source_addr)
+		adc->mclk_source = ioremap(mclk_source_addr, 0x100);
+	else
+		dev_err(&pdev->dev, "get MCLK source failed !!\n");
+
+	/* set default input vol gain to maxmum 48dB, vol range is 0~24 */
+	ctrl1 = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL1);
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL1, ctrl1 | AUDIO_ADC_IGR_INIT_EN);
+
+	return devm_snd_soc_register_component(&pdev->dev, &soc_component_dev_cv181xadc,
+					  &cv181xadc_dai, 1);
+}
+
+static int cv181xadc_remove(struct platform_device *pdev)
+{
+	struct cv181xadc *adc = dev_get_drvdata(&pdev->dev);
+
+	dev_dbg(&pdev->dev, "cvitekaadc_remove\n");
+	iounmap(adc->mclk_source);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id cvitek_adc_of_match[] = {
+	{ .compatible = "cvitek,cv182xaadc", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, cvitek_adc_of_match);
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+static int cv181xadc_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct cv181xadc *adc = platform_get_drvdata(pdev);
+
+	if (!adc->reg_ctx) {
+		adc->reg_ctx = devm_kzalloc(adc->dev, sizeof(struct cv181xadc_context), GFP_KERNEL);
+		if (!adc->reg_ctx)
+			return -ENOMEM;
+	}
+
+	adc->reg_ctx->ctl0 = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+	adc->reg_ctx->ctl1 = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL1);
+	adc->reg_ctx->status = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_STATUS);
+	adc->reg_ctx->ana0 = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0);
+	adc->reg_ctx->ana2 = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2);
+	adc->reg_ctx->ana3 = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA3);
+
+	return 0;
+}
+
+static int cv181xadc_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct cv181xadc *adc = platform_get_drvdata(pdev);
+
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, adc->reg_ctx->ctl0);
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL1, adc->reg_ctx->ctl1);
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_STATUS, adc->reg_ctx->status);
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0, adc->reg_ctx->ana0);
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2, adc->reg_ctx->ana2);
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA3, adc->reg_ctx->ana3);
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(cv181xadc_pm_ops, cv181xadc_suspend,
+			 cv181xadc_resume);
+#endif
+
+
+static struct platform_driver cv181xadc_platform_driver = {
+	.probe		= cv181xadc_probe,
+	.remove		= cv181xadc_remove,
+	.driver		= {
+		.name	= "cvitekaadc",
+		.of_match_table = of_match_ptr(cvitek_adc_of_match),
+#ifdef CONFIG_PM_SLEEP
+		.pm	= &cv181xadc_pm_ops,
+#endif
+	},
+};
+module_platform_driver(cv181xadc_platform_driver);
+
+MODULE_DESCRIPTION("ASoC CVITEK cvitekaADC driver");
+MODULE_AUTHOR("Ethan Chen <ethan.chen@wisecore.com.tw>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:cvitekaadc");
diff --git a/sound/soc/cvitek/cv181xdac.c b/sound/soc/cvitek/cv181xdac.c
new file mode 100644
index 000000000000..6c8b520cc40e
--- /dev/null
+++ b/sound/soc/cvitek/cv181xdac.c
@@ -0,0 +1,738 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * CVITEK CV181X DAC driver
+ *
+ * Copyright 2020 CVITEK Inc.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/pm.h>
+#include <linux/mutex.h>
+#include <linux/miscdevice.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/control.h>
+#include "cv1835_ioctl.h"
+#include "../codecs/cv181xadac.h"
+#include "cv1835_i2s_subsys.h"
+#include <linux/gpio.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/of_gpio.h>
+
+static DEFINE_MUTEX(cv181xdac_mutex);
+int mute_pin_l; // 495
+int mute_pin_r; // 510
+
+
+void muteAmp(bool enable)
+{
+	if (enable) {
+		if (mute_pin_l != -EINVAL) {
+			gpio_set_value(mute_pin_l, 0);
+		}
+		if (mute_pin_r != -EINVAL) {
+			gpio_set_value(mute_pin_r, 0);
+		}
+	} else {
+		if (mute_pin_l != -EINVAL) {
+			gpio_set_value(mute_pin_l, 1);
+		}
+		if (mute_pin_r != -EINVAL) {
+			gpio_set_value(mute_pin_r, 1);
+		}
+	}
+}
+
+static inline void dac_write_reg(void __iomem *io_base, int reg, u32 val)
+{
+	writel(val, io_base + reg);
+}
+
+static inline u32 dac_read_reg(void __iomem *io_base, int reg)
+{
+	return readl(io_base + reg);
+}
+
+static int dac_open(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&cv181xdac_mutex))
+		return -EINTR;
+	mutex_unlock(&cv181xdac_mutex);
+	pr_debug("%s\n", __func__);
+	return 0;
+}
+
+static int dac_close(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&cv181xdac_mutex))
+		return -EINTR;
+	mutex_unlock(&cv181xdac_mutex);
+	pr_debug("%s\n", __func__);
+	return 0;
+}
+
+
+static int cv181xdac_set_dai_fmt(struct snd_soc_dai *dai,
+					unsigned int fmt)
+{
+
+	struct cv181xdac *dac = snd_soc_dai_get_drvdata(dai);
+
+	if (!dac->dev)
+		dev_err(dac->dev, "dev is NULL\n");
+
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		dev_err(dac->dev, "Cannot set DAC to MASTER mode\n");
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		dev_dbg(dac->dev, "Set DAC to SLAVE mode\n");
+		break;
+	default:
+		dev_err(dac->dev, "Cannot support this role mode\n");
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		dev_dbg(dac->dev, "set codec to NB_NF\n");
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		dev_dbg(dac->dev, "set codec to IB_NF\n");
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		dev_dbg(dac->dev, "set codec to IB_IF\n");
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		dev_dbg(dac->dev, "set codec to NB_IF\n");
+		break;
+	default:
+		dev_err(dac->dev, "Cannot support this format\n");
+		break;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		dev_dbg(dac->dev, "set codec to I2S mode\n");
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		dev_dbg(dac->dev, "set codec to LEFT-JUSTIFY mode\n");
+		break;
+	default:
+		dev_err(dac->dev, "Cannot support this mode\n");
+		break;
+	}
+	return 0;
+}
+
+static int cv181xdac_hw_params(struct snd_pcm_substream *substream,
+				  struct snd_pcm_hw_params *params,
+				  struct snd_soc_dai *dai)
+{
+	struct cv181xdac *dac = snd_soc_dai_get_drvdata(dai);
+	int rate;
+	u32 ctrl1 = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL1) & ~AUDIO_PHY_REG_TXDAC_CIC_OPT_MASK;
+	u32 tick = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE0) & ~AUDIO_PHY_REG_TXDAC_INIT_DLY_CNT_MASK;
+	u32 chan_nr = 0;
+	u32 ana2 = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+
+	chan_nr = params_channels(params);
+
+	switch (chan_nr) {
+	case 1:
+		//ana2 |= AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_ON; /* turn R-channel off */
+		ana2 &= AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_OFF; /* turn R-channel on */
+		dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2, ana2);
+		break;
+	default:
+		ana2 &= AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_OFF; /* turn R-channel on */
+		dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2, ana2);
+		break;
+	}
+
+	rate = params_rate(params);
+	if (rate >= 8000 && rate <= 48000) {
+		dev_dbg(dac->dev, "dac_hw_params, set rate to %d\n", rate);
+
+		switch (rate) {
+		case 8000:
+			ctrl1 |= TXDAC_CIC_DS_512;
+			tick |= 0x21;
+			break;
+		case 11025:
+			ctrl1 |= TXDAC_CIC_DS_256;
+			tick |= 0x17;
+			break;
+		case 16000:
+			ctrl1 |= TXDAC_CIC_DS_256;
+			tick |= 0x21;
+			break;
+		case 22050:
+			ctrl1 |= TXDAC_CIC_DS_128;
+			tick |= 0x17;
+			break;
+		case 32000:
+			ctrl1 |= TXDAC_CIC_DS_128;
+			tick |= 0x21;
+			break;
+		case 44100:
+			ctrl1 &= TXDAC_CIC_DS_64;
+			tick |= 0x17;
+			break;
+		case 48000:
+			ctrl1 &= TXDAC_CIC_DS_64;
+			tick |= 0x19;
+			break;
+		default:
+			ctrl1 |= TXDAC_CIC_DS_256;
+			tick |= 0x21;
+			dev_dbg(dac->dev, "dac_hw_params, set sample rate with default 16KHz\n");
+			break;
+		}
+	} else {
+		dev_err(dac->dev, "dac_hw_params, unsupported sample rate\n");
+		return 0;
+	}
+	dev_dbg(dac->dev, "dac_hw_params, ctrl1=0x%x\n", ctrl1);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL1, ctrl1);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE0, tick);
+
+	return 0;
+}
+
+static int cv181xdac_startup(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static void cv181xdac_on(struct cv181xdac *dac)
+{
+
+	u32 val = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0);
+
+	dev_dbg(dac->dev, "dac_on, before ctrl0_reg val=0x%08x\n", val);
+
+	if ((val & AUDIO_PHY_REG_TXDAC_EN_ON) | (val & AUDIO_PHY_REG_I2S_RX_EN_ON))
+		dev_info(dac->dev, "DAC already switched ON!!, val=0x%08x\n", val);
+
+	val |= AUDIO_PHY_REG_TXDAC_EN_ON | AUDIO_PHY_REG_I2S_RX_EN_ON;
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0, val);
+
+	dev_dbg(dac->dev, "dac_on, after ctrl0_reg val=0x%08x\n",
+	dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0));
+
+}
+
+static void cv181xdac_off(struct cv181xdac *dac)
+{
+	u32 val = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0);
+
+	dev_dbg(dac->dev, "dac_off, before ctrl_reg val=0x%08x\n",
+	 dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0));
+
+	val &= AUDIO_PHY_REG_TXDAC_EN_OFF & AUDIO_PHY_REG_I2S_RX_EN_OFF;
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0, val);
+
+	dev_dbg(dac->dev, "dac_off, after ctrl_reg val=0x%08x\n",
+	dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0));
+}
+
+static void cv181xdac_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct cv181xdac *dac = snd_soc_dai_get_drvdata(dai);
+
+	dev_dbg(dac->dev, "dac_shutdown\n");
+	muteAmp(true);
+	cv182xa_reset_dac();
+}
+
+static int cv181xdac_trigger(struct snd_pcm_substream *substream,
+		int cmd, struct snd_soc_dai *dai)
+{
+	struct cv181xdac *dac = snd_soc_dai_get_drvdata(dai);
+	int ret = 0;
+
+	dev_dbg(dac->dev, "dac_trigger, cmd=%d\n", cmd);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		snd_pcm_stream_unlock_irq(substream);
+		cv181xdac_on(dac);
+		muteAmp(false);
+		snd_pcm_stream_lock_irq(substream);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		snd_pcm_stream_unlock_irq(substream);
+		muteAmp(true);
+		cv181xdac_off(dac);
+		snd_pcm_stream_lock_irq(substream);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int cv181xdac_prepare(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct cv181xdac *dac = snd_soc_dai_get_drvdata(dai);
+	u32 val;
+
+	//need to rewrite the register if called cv182xa_reset_dac
+	val = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1, val);
+	val = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2, val);
+	val = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0, val);
+
+	return 0;
+}
+
+static struct cv181xdac *file_dac_dev(struct file *file)
+{
+	return container_of(file->private_data, struct cv181xdac, miscdev);
+}
+
+static long dac_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+
+	unsigned int __user *argp = (unsigned int __user *)arg;
+	struct cv181xdac *dac = file_dac_dev(file);
+	struct cvi_vol_ctrl vol;
+	u32 val;
+	u32 temp;
+
+	if (argp != NULL) {
+		if (!copy_from_user(&val, argp, sizeof(val))) {
+			if (mutex_lock_interruptible(&cv181xdac_mutex)) {
+				pr_debug("cvitekadac: signal arrives while waiting for lock\n");
+				return -EINTR;
+			}
+		} else
+			return -EFAULT;
+	}
+
+	switch (cmd) {
+	case ACODEC_SOFT_RESET_CTRL:
+		cv182xa_reset_dac();
+		break;
+
+	case ACODEC_SET_OUTPUT_VOL:
+		pr_debug("dac: ACODEC_SET_OUTPUT_VOL with val=%d\n", val);
+
+		if ((val < 0) | (val > 32))
+			pr_err("Only support range 0 [mute] ~ 32 [maximum]\n");
+		else {
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1)
+					& ~(AUDIO_PHY_REG_TXDAC_GAIN_UB_0_MASK | AUDIO_PHY_REG_TXDAC_GAIN_UB_1_MASK);
+			temp |= DAC_VOL_L(val) | DAC_VOL_R(val);
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1, temp);
+		}
+		break;
+
+	case ACODEC_GET_OUTPUT_VOL:
+		pr_debug("dac: ACODEC_GET_OUTPUT_VOL\n");
+		temp = ((dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1)
+				& AUDIO_PHY_REG_TXDAC_GAIN_UB_0_MASK) + 1) / CV181X_DAC_VOL_STEP;
+		pr_debug("dac: return val=%d\n", temp);
+		if (copy_to_user(argp, &temp, sizeof(temp)))
+			pr_err("dac, failed to return output vol\n");
+		break;
+
+	case ACODEC_SET_I2S1_FS:
+		pr_debug("dac: ACODEC_SET_I2S1_FS is not support\n");
+		break;
+
+	case ACODEC_SET_DACL_VOL:
+		pr_debug("dac: ACODEC_SET_DACL_VOL\n");
+		if (copy_from_user(&vol, argp, sizeof(vol))) {
+			if (mutex_is_locked(&cv181xdac_mutex))
+				mutex_unlock(&cv181xdac_mutex);
+
+			return -EFAULT;
+		}
+		if (vol.vol_ctrl_mute == 1) {
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+			temp |= AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_ON;
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2, temp);
+		} else if ((vol.vol_ctrl < 0) | (vol.vol_ctrl > 32))
+			pr_err("dac-L: Only support range 0 [mute] ~ 32 [maximum]\n");
+		else {
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1) & ~AUDIO_PHY_REG_TXDAC_GAIN_UB_0_MASK;
+			temp |= DAC_VOL_L(vol.vol_ctrl);
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1, temp);
+
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+			temp &= AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_OFF;
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2, temp);
+		}
+		break;
+
+	case ACODEC_SET_DACR_VOL:
+		pr_debug("dac: ACODEC_SET_DACR_VOL\n");
+		if (copy_from_user(&vol, argp, sizeof(vol)))
+			return -EFAULT;
+
+		if (vol.vol_ctrl_mute == 1) {
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+			temp |= AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_ON;
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2, temp);
+		} else if ((vol.vol_ctrl < 0) | (vol.vol_ctrl > 32))
+			pr_err("dac-L: Only support range 0 [mute] ~ 32 [maximum]\n");
+		else {
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1) & ~AUDIO_PHY_REG_TXDAC_GAIN_UB_1_MASK;
+			temp |= DAC_VOL_R(vol.vol_ctrl);
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1, temp);
+
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+			temp &= AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_OFF;
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2, temp);
+		}
+		break;
+
+	case ACODEC_SET_DACL_MUTE:
+		pr_debug("dac: ACODEC_SET_DACL_MUTE, val=%d\n", val);
+		temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+		if (val == 0)
+			temp &= AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_OFF;
+		else
+			temp |= AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_ON;
+
+		dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2, temp);
+		break;
+	case ACODEC_SET_DACR_MUTE:
+		pr_debug("dac: ACODEC_SET_DACR_MUTE, val=%d\n", val);
+		temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+		if (val == 0)
+			temp &= AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_OFF;
+		else
+			temp |= AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_ON;
+		dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2, temp);
+		break;
+
+	case ACODEC_GET_DACL_VOL:
+		pr_debug("dac: ACODEC_GET_DACL_VOL\n");
+		temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+		if (temp & AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_MASK) {
+			vol.vol_ctrl = 0;
+			vol.vol_ctrl_mute = 1;
+		} else {
+			temp = ((dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1)
+			& AUDIO_PHY_REG_TXDAC_GAIN_UB_0_MASK) + 1) / CV181X_DAC_VOL_STEP;
+			vol.vol_ctrl = temp;
+			vol.vol_ctrl_mute = 0;
+		}
+		if (copy_to_user(argp, &vol, sizeof(vol)))
+			pr_err("failed to return DACL vol\n");
+		break;
+	case ACODEC_GET_DACR_VOL:
+		temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+		pr_debug("dac: ACODEC_GET_DACR_VOL, txdac_ana2=0x%x\n", temp);
+		if (temp & AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_MASK) {
+			vol.vol_ctrl = 0;
+			vol.vol_ctrl_mute = 1;
+		} else {
+			temp = (((dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1)
+			& AUDIO_PHY_REG_TXDAC_GAIN_UB_1_MASK) >> 16) + 1) / CV181X_DAC_VOL_STEP;
+			vol.vol_ctrl = temp;
+			vol.vol_ctrl_mute = 0;
+		}
+		if (copy_to_user(argp, &vol, sizeof(vol)))
+			pr_err("failed to return DACR vol\n");
+		break;
+
+	case ACODEC_SET_PD_DACL:
+		pr_debug("dac: ACODEC_SET_PD_DACL, val=%d\n", val);
+		if (val == 0) {
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0);
+			temp &= AUDIO_PHY_REG_TXDAC_EN_ON | AUDIO_PHY_REG_I2S_RX_EN_ON;
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0, temp);
+		} else {
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0);
+			temp &= AUDIO_PHY_REG_TXDAC_EN_OFF & AUDIO_PHY_REG_I2S_RX_EN_OFF;
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0, temp);
+		}
+		break;
+	case ACODEC_SET_PD_DACR:
+		pr_debug("dac: ACODEC_SET_PD_DACR, val=%d\n", val);
+		if (val == 0) {
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0);
+			temp &= AUDIO_PHY_REG_TXDAC_EN_ON | AUDIO_PHY_REG_I2S_RX_EN_ON;
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0, temp);
+		} else {
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0);
+			temp &= AUDIO_PHY_REG_TXDAC_EN_OFF & AUDIO_PHY_REG_I2S_RX_EN_OFF;
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0, temp);
+		}
+		break;
+	case ACODEC_SET_DAC_DE_EMPHASIS:
+		pr_info("dac: ACODEC_SET_DAC_DE_EMPHASIS is not support\n");
+		break;
+	default:
+		pr_info("%s, received unsupported cmd=%u\n", __func__, cmd);
+		break;
+	}
+
+	if (mutex_is_locked(&cv181xdac_mutex))
+		mutex_unlock(&cv181xdac_mutex);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops cv181xdac_dai_ops = {
+	.hw_params	= cv181xdac_hw_params,
+	.set_fmt	= cv181xdac_set_dai_fmt,
+	.startup	= cv181xdac_startup,
+	.shutdown	= cv181xdac_shutdown,
+	.trigger	= cv181xdac_trigger,
+	.prepare	= cv181xdac_prepare,
+};
+
+static struct snd_soc_dai_driver cv181xdac_dai = {
+	.name		= "cvitekadac",
+	.playback	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates = SNDRV_PCM_RATE_8000_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.ops		= &cv181xdac_dai_ops,
+};
+
+static const struct snd_kcontrol_new cv181xdac_controls[] = {
+	SOC_DOUBLE("DAC Playback Power Up/Down", AUDIO_PHY_TXDAC_CTRL0, 1, 0, 1, 1),
+	SOC_DOUBLE("DAC Playback Volume", AUDIO_PHY_TXDAC_AFE1, 0, 16, 32, 1),
+	SOC_DOUBLE("DAC Playback MUTE", AUDIO_PHY_TXDAC_ANA2, 16, 17, 1, 0),
+};
+
+unsigned int cv181xdac_reg_read(struct snd_soc_component *codec, unsigned int reg)
+{
+	struct cv181xdac *dac = dev_get_drvdata(codec->dev);
+	int ret;
+	u32 temp_lval = 0;
+	u32 temp_rval = 0;
+
+	ret = dac_read_reg(dac->dac_base, reg);
+
+	if (reg == AUDIO_PHY_TXDAC_AFE1) {
+		temp_lval = ((ret & 0x000001ff) + 1) / 16;
+		temp_rval = (((ret >> 16) & 0x000001ff) + 1) / 16;
+		dev_info(dac->dev, "Get DAC Vol reg:%d,ret:0x%x temp_lval=%d.\n", reg, ret, temp_lval);
+		ret = (temp_rval<<16)|temp_lval;
+	}
+
+	dev_info(dac->dev, "dac_reg_read reg:%d,ret:%#x.\n", reg, ret);
+
+	return ret;
+}
+
+int cv181xdac_reg_write(struct snd_soc_component *codec, unsigned int reg, unsigned int value)
+{
+	struct cv181xdac *dac = dev_get_drvdata(codec->dev);
+	u32 temp_lval;
+	u32 temp_rval;
+
+	if (reg == AUDIO_PHY_TXDAC_AFE1 && value) {
+		temp_lval = value & 0xffff;
+		temp_rval = (value >> 16) & 0xffff;
+		if (temp_lval > 32)
+			temp_lval = 32;
+		if (temp_rval > 32)
+			temp_rval = 32;
+		value = DAC_VOL_L(temp_lval)|DAC_VOL_R(temp_rval);
+	}
+
+	dac_write_reg(dac->dac_base, reg, value);
+	dev_info(dac->dev, "dac_reg_write reg:%d,value:%#x.\n", reg, value);
+
+	return 0;
+}
+
+static const struct snd_soc_component_driver soc_component_dev_cv181xdac = {
+	.controls = cv181xdac_controls,
+	.num_controls = ARRAY_SIZE(cv181xdac_controls),
+	.read = cv181xdac_reg_read,
+	.write = cv181xdac_reg_write,
+};
+
+static const struct file_operations dac_fops = {
+	.owner = THIS_MODULE,
+	.open = dac_open,
+	.release = dac_close,
+	.unlocked_ioctl = dac_ioctl,
+	.compat_ioctl = dac_ioctl,
+};
+
+static int dac_device_register(struct cv181xdac *dac)
+{
+	struct miscdevice *miscdev = &dac->miscdev;
+	int ret;
+
+	miscdev->minor = MISC_DYNAMIC_MINOR;
+	miscdev->name = "cvitekadac";
+	miscdev->fops = &dac_fops;
+	miscdev->parent = NULL;
+
+	ret = misc_register(miscdev);
+	if (ret) {
+		pr_err("dac: failed to register misc device.\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int cv181xdac_probe(struct platform_device *pdev)
+{
+	struct cv181xdac *dac;
+	struct resource *res;
+	int ret;
+	enum of_gpio_flags flags;
+
+	mute_pin_l =  -EINVAL;
+	mute_pin_r =  -EINVAL;
+
+	dev_info(&pdev->dev, "cvitekadac_probe\n");
+
+	dac = devm_kzalloc(&pdev->dev, sizeof(*dac), GFP_KERNEL);
+	if (!dac)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dac->dac_base = devm_ioremap_resource(&pdev->dev, res);
+	dev_dbg(&pdev->dev, "cvitekadac_probe get dac_base=0x%p\n", dac->dac_base);
+	if (IS_ERR(dac->dac_base))
+		return PTR_ERR(dac->dac_base);
+
+	dev_set_drvdata(&pdev->dev, dac);
+	dac->dev = &pdev->dev;
+
+	ret = dac_device_register(dac);
+	if (ret < 0) {
+		pr_err("dac: register device error\n");
+		return ret;
+	}
+
+	mute_pin_l = of_get_named_gpio_flags(pdev->dev.of_node,
+		"mute-gpio-l", 0, &flags);
+	mute_pin_r = of_get_named_gpio_flags(pdev->dev.of_node,
+		"mute-gpio-r", 0, &flags);
+
+	if (!gpio_is_valid(mute_pin_l)) {
+		pr_err("cvitekadac_probe gpio_is_valid mute_pin_l\n");
+		mute_pin_l =  -EINVAL;
+	} else {
+		gpio_request(mute_pin_l, "mute_pin_l");
+		gpio_direction_output(mute_pin_l, 1);
+		gpio_set_value(mute_pin_l, 0);
+	}
+
+	if (!gpio_is_valid(mute_pin_r)) {
+		pr_err("cvitekadac_probe gpio_is_valid mute_pin_r\n");
+		mute_pin_r =  -EINVAL;
+	} else {
+		gpio_request(mute_pin_r, "mute_pin_r");
+		gpio_direction_output(mute_pin_r, 1);
+		gpio_set_value(mute_pin_r, 0);
+	}
+	return devm_snd_soc_register_component(&pdev->dev, &soc_component_dev_cv181xdac,
+					  &cv181xdac_dai, 1);
+}
+
+static int cv181xdac_remove(struct platform_device *pdev)
+{
+	muteAmp(true);
+	dev_dbg(&pdev->dev, "cvitekadac_remove\n");
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id cvitek_dac_of_match[] = {
+	{ .compatible = "cvitek,cv182xadac", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, cvitek_dac_of_match);
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+static int cv181xdac_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct cv181xdac *dac = platform_get_drvdata(pdev);
+
+	muteAmp(true);
+	if (!dac->reg_ctx) {
+		dac->reg_ctx = devm_kzalloc(dac->dev, sizeof(struct cv181xdac_context), GFP_KERNEL);
+		if (!dac->reg_ctx)
+			return -ENOMEM;
+	}
+
+	dac->reg_ctx->ctl0 = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0);
+	dac->reg_ctx->ctl1 = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL1);
+	dac->reg_ctx->afe0 = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE0);
+	dac->reg_ctx->afe1 = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1);
+	dac->reg_ctx->ana0 = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA0);
+	dac->reg_ctx->ana1 = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA1);
+	dac->reg_ctx->ana2 = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+
+	return 0;
+}
+
+static int cv181xdac_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct cv181xdac *dac = platform_get_drvdata(pdev);
+
+	muteAmp(false);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0, dac->reg_ctx->ctl0);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL1, dac->reg_ctx->ctl1);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE0, dac->reg_ctx->afe0);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1, dac->reg_ctx->afe1);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA0, dac->reg_ctx->ana0);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA1, dac->reg_ctx->ana1);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2, dac->reg_ctx->ana2);
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(cv181xdac_pm_ops, cv181xdac_suspend,
+			 cv181xdac_resume);
+#endif
+
+static struct platform_driver cv181xdac_platform_driver = {
+	.probe		= cv181xdac_probe,
+	.remove		= cv181xdac_remove,
+	.driver		= {
+		.name	= "cvitekadac",
+		.of_match_table = of_match_ptr(cvitek_dac_of_match),
+#ifdef CONFIG_PM_SLEEP
+		.pm	= &cv181xdac_pm_ops,
+#endif
+	},
+};
+module_platform_driver(cv181xdac_platform_driver);
+
+MODULE_DESCRIPTION("ASoC CVITEK cvitekaDAC driver");
+MODULE_AUTHOR("Ethan Chen <ethan.chen@wisecore.com.tw>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:cvitekadac");
diff --git a/sound/soc/cvitek/cv182x_cv182xadc.c b/sound/soc/cvitek/cv182x_cv182xadc.c
new file mode 100644
index 000000000000..cd3d0b8441ee
--- /dev/null
+++ b/sound/soc/cvitek/cv182x_cv182xadc.c
@@ -0,0 +1,288 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Machine driver for CVITEK ADC on CVITEK CV182X
+ *
+ * Copyright 2019 CVITEK
+ *
+ * Author: EthanChen
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <linux/io.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+#include "../codecs/cv182xadac.h"
+#include <linux/version.h>
+
+bool proc_ai_not_allocted = true;
+
+static int cv182x_adc_vol_list[25] = {
+	ADC_VOL_GAIN_0,
+	ADC_VOL_GAIN_1,
+	ADC_VOL_GAIN_2,
+	ADC_VOL_GAIN_3,
+	ADC_VOL_GAIN_4,
+	ADC_VOL_GAIN_5,
+	ADC_VOL_GAIN_6,
+	ADC_VOL_GAIN_7,
+	ADC_VOL_GAIN_8,
+	ADC_VOL_GAIN_9,
+	ADC_VOL_GAIN_10,
+	ADC_VOL_GAIN_11,
+	ADC_VOL_GAIN_12,
+	ADC_VOL_GAIN_13,
+	ADC_VOL_GAIN_14,
+	ADC_VOL_GAIN_15,
+	ADC_VOL_GAIN_16,
+	ADC_VOL_GAIN_17,
+	ADC_VOL_GAIN_18,
+	ADC_VOL_GAIN_19,
+	ADC_VOL_GAIN_20,
+	ADC_VOL_GAIN_21,
+	ADC_VOL_GAIN_22,
+	ADC_VOL_GAIN_23,
+	ADC_VOL_GAIN_24
+};
+
+static int cv182x_adc_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	return 0;
+}
+
+static int cv182x_adc_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+	return 0;
+}
+static struct snd_soc_ops cv182x_adc_ops = {
+	.hw_params = cv182x_adc_hw_params,
+};
+
+static struct snd_soc_dai_link_component cv182x_adc_cpus = {
+	.name = "4100000.i2s",
+	.dai_name = "4100000.i2s",
+
+};
+
+static struct snd_soc_dai_link_component cv182x_adc_codecs = {
+	.name = "300a100.adc",
+	.dai_name = "cv182xadc",
+
+};
+
+static struct snd_soc_dai_link_component cv182x_adc_platform = {
+	.name = "4100000.i2s",
+	.dai_name = "4100000.i2s",
+
+};
+
+static struct snd_soc_dai_link cv182x_adc_dai = {
+	.name = "cv182x-i2s-adc",
+	.stream_name = "cv182x-adc",
+	.cpus = &cv182x_adc_cpus,
+	.num_cpus = 1,
+	.codecs = &cv182x_adc_codecs,
+	.num_codecs = 1,
+	.platforms = &cv182x_adc_platform,
+	.num_platforms = 1,
+	.ops = &cv182x_adc_ops,
+	.init = cv182x_adc_codec_init,
+	.dai_fmt = SND_SOC_DAIFMT_I2S
+	| SND_SOC_DAIFMT_IB_NF
+	| SND_SOC_DAIFMT_CBM_CFM,
+	.capture_only = 1,
+};
+
+static struct snd_soc_card cv182x_adc = {
+	//.owner = THIS_MODULE,
+	.name = "cv182x-i2s-adc",
+	.dai_link = &cv182x_adc_dai,
+	.num_links = 1,
+
+};
+
+
+static const struct of_device_id cvi_audio_match_ids[] = {
+	{
+		.compatible = "cvitek,cv182x-adc",
+		//.data = (void *) &cv182x_adc_dai,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, cvi_audio_match_ids);
+
+static int cv182x_adc_proc_show(struct seq_file *m, void *v)
+{
+	void __iomem *i2s0;
+	void __iomem *adc;
+	void __iomem *audio_pll;
+	void __iomem *sdma_pll;
+	u32 audio_freq;
+	u32 val1, val2, val3;
+	u32 temp1, temp2;
+
+	i2s0 = ioremap(0x04100000, 0x100);
+	adc = ioremap(0x0300A100, 0x100);
+	audio_pll = ioremap(0x3002854, 0x10);
+	sdma_pll = ioremap(0x3002004, 0x10);
+	if (readl(audio_pll) == 0x179EDCFA)
+		audio_freq = 22579200;
+	else
+		audio_freq = 24576000;
+
+
+	seq_puts(m, "\n------------- CVI AI ATTRIBUTE -------------\n");
+	seq_puts(m, "AiDev    Workmode    SampleRate    BitWidth\n");
+	val1 = (readl(i2s0) >> 1) & 0x1;
+	//samplerate = audio_freq/(mclk_div * CIC_mask * 64 * cofe(4))
+	val2 = audio_freq / ((readl(i2s0 + 0x64) & 0x0000ffff)*((readl(adc + AUDIO_PHY_RXADC_CTRL1) & 0x1) + 1)*64*4);
+	val3 = ((readl(i2s0 + 0x10) >> 1) & 0x3) * 16;
+	seq_printf(m, "  %d       %s        %6d        %2d\n", 0, val1 == 0 ? "slave" : "master", val2, val3);
+	seq_puts(m, "\n");
+	seq_puts(m, "-------------  CVI AI STATUS   -------------\n");
+
+	val1 = (readl(i2s0 + 0x18));
+	seq_printf(m, "I2S0 is %s\n", val1 == 1 ? "on" : "off");
+	seq_puts(m, "\n");
+	val1 = (readl(sdma_pll) & 0x00000002) >> 1;
+	seq_printf(m, "SDMA clk is %s\n", val1 == 1 ? "on" : "off");
+	seq_puts(m, "\n");
+
+	val1 = (readl(adc + AUDIO_PHY_RXADC_CTRL0) &
+		(AUDIO_PHY_REG_RXADC_EN_MASK | AUDIO_PHY_REG_I2S_TX_EN_MASK));
+	seq_printf(m, "ADC is %s (%d)\n", val1 == 3 ? "on" : "off", val1);
+	seq_puts(m, "\n");
+
+	val1 = (readl(adc + AUDIO_PHY_RXADC_ANA2) & AUDIO_PHY_REG_MUTEL_RXPGA_MASK);
+	val2 = (readl(adc + AUDIO_PHY_RXADC_ANA2) & AUDIO_PHY_REG_MUTER_RXPGA_MASK) >> 1;
+	seq_puts(m, "L-Mute   R-Mute\n");
+	seq_printf(m, "  %s       %s\n", val1 == 1 ? "yes" : "no", val2 == 1 ? "yes" : "no");
+	seq_puts(m, "\n");
+
+	val1 = (readl(adc + AUDIO_PHY_RXADC_ANA0) & 0xffff);
+	val2 = (readl(adc + AUDIO_PHY_RXADC_ANA0) & 0xffff0000) >> 16;
+
+	for (temp1 = 0; temp1 < 25; temp1++) {
+		if (val1 == cv182x_adc_vol_list[temp1])
+			break;
+	}
+	for (temp2 = 0; temp2 < 25; temp2++) {
+		if (val2 == cv182x_adc_vol_list[temp2])
+			break;
+	}
+
+	seq_puts(m, "L-Vol           R-Vol\n");
+	seq_printf(m, "  %d              %d\n", temp1, temp2);
+	seq_puts(m, "\n");
+
+
+
+	iounmap(i2s0);
+	iounmap(adc);
+	iounmap(audio_pll);
+	iounmap(sdma_pll);
+	return 0;
+}
+
+static int seq_cv182x_adc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, cv182x_adc_proc_show, PDE_DATA(inode));
+}
+
+static const struct proc_ops cv182x_adc_proc_ops = {
+	.proc_read	= seq_read,
+	.proc_open	= seq_cv182x_adc_open,
+	.proc_release	= single_release,
+};
+
+
+static int cv182x_adc_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card;
+	struct device_node *np = pdev->dev.of_node;
+	struct proc_dir_entry *proc_ai;
+
+
+	dev_info(&pdev->dev, "%s, dev name=%s\n", __func__, dev_name(&pdev->dev));
+	card = &cv182x_adc;
+
+	if (np) {
+
+		of_property_read_string(np, "cvi,card_name", &card->name);
+		card->dev = &pdev->dev;
+
+		if (!proc_audio_dir) {
+			proc_audio_dir = proc_mkdir("audio_debug", NULL);
+			if (!proc_audio_dir)
+				dev_err(&pdev->dev, "Error creating audio_debug proc folder entry\n");
+		}
+
+		if (proc_audio_dir && (proc_ai_not_allocted == true)) {
+			proc_ai = proc_create_data("cv182x_adc", 0444, proc_audio_dir, &cv182x_adc_proc_ops, np);
+			if (!proc_ai)
+				dev_err(&pdev->dev, "Create cv182x_adc proc failed!\n");
+			else
+				proc_ai_not_allocted = false;
+		}
+
+		platform_set_drvdata(pdev, card);
+		dev_info(&pdev->dev, "%s start devm_snd_soc_register_card\n", __func__);
+		return devm_snd_soc_register_card(&pdev->dev, card);
+	}
+	return 0;
+
+}
+
+#ifdef CONFIG_PM
+int cv182x_cv182xadc_suspend(struct device *dev)
+{
+	return 0;
+}
+
+int cv182x_cv182xadc_resume(struct device *dev)
+{
+	return 0;
+}
+
+int cv182x_cv182xadc_poweroff(struct device *dev)
+{
+	return 0;
+}
+
+#else
+#define cv182x_cv182xadc_suspend	NULL
+#define cv182x_cv182xadc_resume		NULL
+#define cv182x_cv182xadc_poweroff	NULL
+#endif
+
+const struct dev_pm_ops cv182x_cv182xadc_pm_ops = {
+	.suspend = cv182x_cv182xadc_suspend,
+	.resume = cv182x_cv182xadc_resume,
+	.freeze = cv182x_cv182xadc_suspend,
+	.thaw = cv182x_cv182xadc_resume,
+	.poweroff = cv182x_cv182xadc_poweroff,
+	.restore = cv182x_cv182xadc_resume,
+};
+
+static struct platform_driver cv182x_adc_driver = {
+	.driver = {
+		.name = "cv182x-adc",
+		.pm = &cv182x_cv182xadc_pm_ops,
+		.of_match_table = cvi_audio_match_ids,
+	},
+	.probe = cv182x_adc_probe,
+};
+
+module_platform_driver(cv182x_adc_driver);
+
+MODULE_AUTHOR("EthanChen");
+MODULE_DESCRIPTION("ALSA SoC cv182x adc driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:cv182x-adc");
diff --git a/sound/soc/cvitek/cv182x_cv182xdac.c b/sound/soc/cvitek/cv182x_cv182xdac.c
new file mode 100644
index 000000000000..78febc6d59f2
--- /dev/null
+++ b/sound/soc/cvitek/cv182x_cv182xdac.c
@@ -0,0 +1,244 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Machine driver for CVITEK DAC on CVITEK CV182X
+ *
+ * Copyright 2019 CVITEK
+ *
+ * Author: EthanChen
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <linux/io.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+#include "../codecs/cv182xadac.h"
+#include <linux/version.h>
+
+bool proc_ao_not_allocted = true;
+
+static int cv182x_dac_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	return 0;
+}
+
+static int cv182x_dac_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+	return 0;
+}
+
+static struct snd_soc_ops cv182x_dac_ops = {
+	.hw_params = cv182x_dac_hw_params,
+};
+
+static struct snd_soc_dai_link_component cv182x_dac_cpus = {
+	.name = "4130000.i2s",
+	.dai_name = "4130000.i2s",
+
+};
+
+static struct snd_soc_dai_link_component cv182x_dac_codecs = {
+	.name = "300a000.dac",
+	.dai_name = "cv182xdac",
+
+};
+
+static struct snd_soc_dai_link_component cv182x_dac_platform = {
+	.name = "4130000.i2s",
+	.dai_name = "4130000.i2s",
+
+};
+static struct snd_soc_dai_link cv182x_dac_dai = {
+	.name = "cv182x-i2s-dac",
+	.stream_name = "cv182x-dac",
+	.cpus = &cv182x_dac_cpus,
+	.num_cpus = 1,
+	.codecs = &cv182x_dac_codecs,
+	.num_codecs = 1,
+	.platforms = &cv182x_dac_platform,
+	.num_platforms = 1,
+	.ops = &cv182x_dac_ops,
+	.init = cv182x_dac_codec_init,
+	.dai_fmt = SND_SOC_DAIFMT_I2S
+	| SND_SOC_DAIFMT_IB_IF
+	| SND_SOC_DAIFMT_CBS_CFS,
+	.playback_only = 1,
+};
+
+
+static struct snd_soc_card cv182x_dac = {
+	.owner = THIS_MODULE,
+	.dai_link = &cv182x_dac_dai,
+	.num_links = 1,
+
+};
+
+
+static int cv182x_dac_proc_show(struct seq_file *m, void *v)
+{
+
+	void __iomem *i2s3;
+	void __iomem *dac;
+	void __iomem *audio_pll;
+	void __iomem *sdma_pll;
+	u32 audio_freq;
+	u32 val1, val2, val3;
+
+	i2s3 = ioremap(0x04130000, 0x100);
+	dac = ioremap(0x0300A000, 0x100);
+	audio_pll = ioremap(0x3002854, 0x10);
+	sdma_pll = ioremap(0x3002004, 0x10);
+	if (readl(audio_pll) == 0x179EDCFA)
+		audio_freq = 22579200;
+	else
+		audio_freq = 24576000;
+
+
+	seq_puts(m, "\n------------- CVI AO ATTRIBUTE -------------\n");
+	seq_puts(m, "AiDev    Workmode    SampleRate    BitWidth\n");
+	val1 = (readl(i2s3) >> 1) & 0x1;
+	//samplerate = audio_freq/(mclk_div * CIC_mask * 64 * cofe(4))
+	val2 = audio_freq / ((readl(i2s3 + 0x64) & 0x0000ffff)*((readl(dac + AUDIO_PHY_TXDAC_CTRL1) & 0x1) + 1)*64*4);
+	val3 = ((readl(i2s3 + 0x10) >> 1) & 0x3) * 16;
+	seq_printf(m, "  %d       %s        %6d        %2d\n", 1, val1 == 0 ? "slave" : "master", val2, val3);
+	seq_puts(m, "\n");
+	seq_puts(m, "-------------  CVI AO STATUS   -------------\n");
+	val1 = (readl(i2s3 + 0x18));
+	seq_printf(m, "I2S3 is %s\n", val1 == 1 ? "on" : "off");
+	seq_puts(m, "\n");
+
+	val1 = (readl(sdma_pll) & 0x00000002) >> 1;
+	seq_printf(m, "SDMA clk is %s\n", val1 == 1 ? "on" : "off");
+
+	val1 = (readl(dac + AUDIO_PHY_TXDAC_CTRL0)
+		& (AUDIO_PHY_REG_TXDAC_EN_MASK | AUDIO_PHY_REG_I2S_RX_EN_MASK));
+	seq_printf(m, "DAC is %s (%d)\n", val1 == 3 ? "on" : "off", val1);
+
+	val2 = (readl(dac + AUDIO_PHY_TXDAC_ANA2) & AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_MASK) >> 16;
+	val3 = (readl(dac + AUDIO_PHY_TXDAC_ANA2) & AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_MASK) >> 17;
+	seq_puts(m, "L-Mute   R-Mute\n");
+	seq_printf(m, "  %s       %s\n", val2 == 1 ? "yes" : "no", val3 == 1 ? "yes" : "no");
+	seq_puts(m, "\n");
+
+	val2 = ((readl(dac + AUDIO_PHY_TXDAC_AFE1) & AUDIO_PHY_REG_TXDAC_GAIN_UB_0_MASK) + 1) / 16;
+	val3 = (((readl(dac + AUDIO_PHY_TXDAC_AFE1) & AUDIO_PHY_REG_TXDAC_GAIN_UB_1_MASK) >> 16) + 1) / 16;
+	seq_puts(m, "L-Vol           R-Vol\n");
+	seq_printf(m, "  %d             %d\n", val2, val3);
+	seq_puts(m, "\n");
+
+	iounmap(i2s3);
+	iounmap(dac);
+	iounmap(audio_pll);
+	iounmap(sdma_pll);
+	return 0;
+}
+
+static int seq_cv182x_dac_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, cv182x_dac_proc_show, PDE_DATA(inode));
+}
+
+static const struct proc_ops cv182x_dac_proc_ops = {
+	.proc_read	= seq_read,
+	.proc_open	= seq_cv182x_dac_open,
+	.proc_release	= single_release,
+};
+
+static const struct of_device_id cvi_audio_match_ids[] = {
+	{
+		.compatible = "cvitek,cv182x-dac",
+		//.data = (void *) &cv182x_dac_dai,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, cvi_audio_match_ids);
+
+static int cv182x_dac_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card;
+	struct device_node *np = pdev->dev.of_node;
+	struct proc_dir_entry *proc_ao;
+
+	dev_info(&pdev->dev, "%s, dev name=%s\n", __func__, dev_name(&pdev->dev));
+
+	/* Ethan add, set pinmux by hard code temporary */
+	card = &cv182x_dac;
+
+	if (np) {
+
+		of_property_read_string(np, "cvi,card_name", &card->name);
+		card->dev = &pdev->dev;
+
+		if (!proc_audio_dir) {
+			proc_audio_dir = proc_mkdir("audio_debug", NULL);
+			if (!proc_audio_dir)
+				dev_err(&pdev->dev, "Error creating audio_debug proc folder entry\n");
+		}
+
+		if (proc_audio_dir && (proc_ao_not_allocted == true)) {
+			proc_ao = proc_create_data("cv182x_dac", 0444, proc_audio_dir, &cv182x_dac_proc_ops, np);
+			if (!proc_ao)
+				dev_err(&pdev->dev, "Create cv182x_dac proc failed!\n");
+			proc_ao_not_allocted = false;
+		}
+
+		platform_set_drvdata(pdev, card);
+		return devm_snd_soc_register_card(&pdev->dev, card);
+	}
+	return 0;
+
+}
+
+#ifdef CONFIG_PM
+int cv182x_cv182xdac_suspend(struct device *dev)
+{
+	return 0;
+}
+
+int cv182x_cv182xdac_resume(struct device *dev)
+{
+	return 0;
+}
+
+int cv182x_cv182xdac_poweroff(struct device *dev)
+{
+	return 0;
+}
+
+#else
+#define cv182x_cv182xdac_suspend	NULL
+#define cv182x_cv182xdac_resume		NULL
+#define cv182x_cv182xdac_poweroff	NULL
+#endif
+
+const struct dev_pm_ops cv182x_cv182xdac_pm_ops = {
+	.suspend = cv182x_cv182xdac_suspend,
+	.resume = cv182x_cv182xdac_resume,
+	.freeze = cv182x_cv182xdac_suspend,
+	.thaw = cv182x_cv182xdac_resume,
+	.poweroff = cv182x_cv182xdac_poweroff,
+	.restore = cv182x_cv182xdac_resume,
+};
+
+static struct platform_driver cv182x_dac_driver = {
+	.driver = {
+		.name = "cv182x-dac",
+		.pm = &cv182x_cv182xdac_pm_ops,
+		.of_match_table = cvi_audio_match_ids,
+	},
+	.probe = cv182x_dac_probe,
+};
+
+module_platform_driver(cv182x_dac_driver);
+
+MODULE_AUTHOR("EthanChen");
+MODULE_DESCRIPTION("ALSA SoC cv182x dac driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:cv182x-dac");
diff --git a/sound/soc/cvitek/cv182x_cv182xpdm.c b/sound/soc/cvitek/cv182x_cv182xpdm.c
new file mode 100644
index 000000000000..e2107970770c
--- /dev/null
+++ b/sound/soc/cvitek/cv182x_cv182xpdm.c
@@ -0,0 +1,99 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Machine driver for CVITEK PDM on CVITEK CV182X
+ *
+ * Copyright 2019 CVITEK
+ *
+ * Author: EthanChen
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <linux/io.h>
+#include "cv1835pdm.h"
+
+static int cv182x_pdm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	return 0;
+}
+
+static int cv182x_pdm_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+	return 0;
+}
+static struct snd_soc_ops cv182x_pdm_ops = {
+	.hw_params = cv182x_pdm_hw_params,
+};
+
+static struct snd_soc_dai_link cv182x_pdm_dai = {
+	.name = "cv182x-i2s-pdm",
+	.stream_name = "cv182x-pdm",
+	.cpu_dai_name = "4110000.i2s",
+	.codec_dai_name = "cv1835pdm",
+	.platform_name = "4110000.i2s",
+	.codec_name = "41d0c00.pdm",
+	.ops = &cv182x_pdm_ops,
+	.init = cv182x_pdm_codec_init,
+	.dai_fmt = SND_SOC_DAIFMT_I2S
+	| SND_SOC_DAIFMT_IB_NF
+	| SND_SOC_DAIFMT_CBM_CFM,
+};
+
+static struct snd_soc_card cv182x_pdm = {
+	.owner = THIS_MODULE,
+	.dai_link = &cv182x_pdm_dai,
+	.num_links = 1,
+
+};
+
+
+static const struct of_device_id cvi_audio_match_ids[] = {
+	{
+		.compatible = "cvitek,cv182x-pdm",
+		//.data = (void *) &cv182x_pdm_dai,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, cvi_audio_match_ids);
+
+static int cv182x_pdm_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card;
+	struct device_node *np = pdev->dev.of_node;
+
+	dev_info(&pdev->dev, "%s, dev name=%s\n", __func__, dev_name(&pdev->dev));
+
+	card = &cv182x_pdm;
+
+	if (np) {
+
+		of_property_read_string(np, "cvi,card_name", &card->name);
+		card->dev = &pdev->dev;
+		platform_set_drvdata(pdev, card);
+		return devm_snd_soc_register_card(&pdev->dev, card);
+	}
+	return 0;
+
+}
+
+static struct platform_driver cv182x_pdm_driver = {
+	.driver = {
+		.name = "cv182x-pdm",
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = cvi_audio_match_ids,
+	},
+	.probe = cv182x_pdm_probe,
+};
+
+module_platform_driver(cv182x_pdm_driver);
+
+MODULE_AUTHOR("EthanChen");
+MODULE_DESCRIPTION("ALSA SoC cv182x pdm driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:cv182x-pdm");
diff --git a/sound/soc/cvitek/cv182xadc.c b/sound/soc/cvitek/cv182xadc.c
new file mode 100644
index 000000000000..c838097d64e9
--- /dev/null
+++ b/sound/soc/cvitek/cv182xadc.c
@@ -0,0 +1,937 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * CVITEK CV1835 ADC driver
+ *
+ * Copyright 2020 CVITEK Inc.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/pm.h>
+#include <linux/mutex.h>
+#include <linux/miscdevice.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/control.h>
+#include "cv1835_ioctl.h"
+#include "../codecs/cv182xadac.h"
+#include "cv1835_i2s_subsys.h"
+
+static DEFINE_MUTEX(cv182xadc_mutex);
+
+static int adc_vol_list[25] = {
+	ADC_VOL_GAIN_0,
+	ADC_VOL_GAIN_1,
+	ADC_VOL_GAIN_2,
+	ADC_VOL_GAIN_3,
+	ADC_VOL_GAIN_4,
+	ADC_VOL_GAIN_5,
+	ADC_VOL_GAIN_6,
+	ADC_VOL_GAIN_7,
+	ADC_VOL_GAIN_8,
+	ADC_VOL_GAIN_9,
+	ADC_VOL_GAIN_10,
+	ADC_VOL_GAIN_11,
+	ADC_VOL_GAIN_12,
+	ADC_VOL_GAIN_13,
+	ADC_VOL_GAIN_14,
+	ADC_VOL_GAIN_15,
+	ADC_VOL_GAIN_16,
+	ADC_VOL_GAIN_17,
+	ADC_VOL_GAIN_18,
+	ADC_VOL_GAIN_19,
+	ADC_VOL_GAIN_20,
+	ADC_VOL_GAIN_21,
+	ADC_VOL_GAIN_22,
+	ADC_VOL_GAIN_23,
+	ADC_VOL_GAIN_24
+};
+
+u32 old_adc_voll;
+u32 old_adc_volr;
+
+static int adc_open(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&cv182xadc_mutex))
+		return -EINTR;
+	mutex_unlock(&cv182xadc_mutex);
+	pr_debug("%s\n", __func__);
+	return 0;
+}
+
+static int adc_close(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&cv182xadc_mutex))
+		return -EINTR;
+	mutex_unlock(&cv182xadc_mutex);
+	pr_debug("%s\n", __func__);
+	return 0;
+}
+
+static inline void adc_write_reg(void __iomem *io_base, int reg, u32 val)
+{
+	writel(val, io_base + reg);
+}
+
+static inline u32 adc_read_reg(void __iomem *io_base, int reg)
+{
+	return readl(io_base + reg);
+}
+
+static void cv182xadc_clk_on(struct cv182xadc *adc)
+{
+
+	u32 clk_ctrl0;
+
+	mutex_lock(&cv182xadc_mutex);
+
+	clk_ctrl0 = readl(adc->mclk_source + CVI_I2S_CLK_CTRL0);
+
+	if (!(clk_ctrl0 & CVI_I2S_AU_EN_MASK)) {
+		dev_info(adc->dev, "turn I2S3 aud_en on\n");
+		clk_ctrl0 |= CVI_I2S_AU_EN;
+	}
+
+	if (!(clk_ctrl0 & CVI_I2S_MCLK_OUT_EN_MASK)) {
+		dev_info(adc->dev, "turn I2S3 mclk_out_en on\n");
+		clk_ctrl0 |= CVI_I2S_MCLK_OUT_EN;
+	}
+
+	writel(clk_ctrl0, adc->mclk_source + CVI_I2S_CLK_CTRL0);
+	dev_info(adc->dev, "%s, I2S3 clk_ctrl0 = 0x%x\n", __func__, readl(adc->mclk_source + CVI_I2S_CLK_CTRL0));
+
+	mutex_unlock(&cv182xadc_mutex);
+}
+
+static void cv182xadc_set_mclk(struct cv182xadc *adc, u32 rate)
+{
+
+	u32 clk_ctrl1, audio_clk;
+
+	mutex_lock(&cv182xadc_mutex);
+
+	clk_ctrl1 = readl(adc->mclk_source + CVI_I2S_CLK_CTRL1) & ~CVI_I2S_MCLK_MASK;
+
+	dev_dbg(adc->dev, "%s, I2S3 ctrl1=0x%x\n", __func__, clk_ctrl1);
+
+	switch (rate) {
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+		audio_clk = 22579200;
+		break;
+	case 8000:
+	case 12000:
+	case 16000:
+	case 24000:
+	case 32000:
+	case 48000:
+	case 96000:
+	case 192000:
+		audio_clk = 24576000;
+		break;
+	default:
+		dev_err(adc->dev, "Warning!!! this sample rate is not supported\n");
+		return;
+	}
+
+	dev_dbg(adc->dev, "Audio system clk=%d, sample rate=%d\n", audio_clk, rate);
+	cv1835_set_mclk(audio_clk);
+
+	/* cv182x internal adc codec need dynamic MCLK frequency input */
+	switch (rate) {
+	case 8000:
+		clk_ctrl1 |= CVI_I2S_MCLK_DIV(6);
+		break;
+	case 11025:
+		clk_ctrl1 |= CVI_I2S_MCLK_DIV(4);
+		break;
+	case 16000:
+	case 32000:
+		clk_ctrl1 |= CVI_I2S_MCLK_DIV(3);
+		break;
+	case 22050:
+	case 44100:
+	case 48000:
+		clk_ctrl1 |= CVI_I2S_MCLK_DIV(2);
+		break;
+	default:
+		dev_err(adc->dev, "%s doesn't support this sample rate\n", __func__);
+		break;
+	}
+	writel(clk_ctrl1, adc->mclk_source + CVI_I2S_CLK_CTRL1);
+	dev_dbg(adc->dev, "%s, I2S3 clk_ctrl1 = 0x%x\n", __func__, readl(adc->mclk_source + CVI_I2S_CLK_CTRL1));
+	mutex_unlock(&cv182xadc_mutex);
+}
+
+static void cv182xadc_clk_off(struct cv182xadc *adc)
+{
+	u32 i2s_en;
+	u32 clk_ctrl0;
+
+	mutex_lock(&cv182xadc_mutex);
+
+	i2s_en = readl(adc->mclk_source + CVI_I2S_EN);
+	clk_ctrl0 = readl(adc->mclk_source + CVI_I2S_CLK_CTRL0);
+
+	if (!i2s_en) {
+		if ((clk_ctrl0 & CVI_I2S_AU_EN_MASK)) {
+			dev_info(adc->dev, "turn I2S3 aud_en off\n");
+			clk_ctrl0 &= CVI_I2S_AU_OFF;
+		}
+	}
+
+	if (!(clk_ctrl0 & CVI_I2S_MCLK_OUT_EN_MASK)) {
+		dev_info(adc->dev, "turn I2S3 mclk_out_en on\n");
+		clk_ctrl0 &= CVI_I2S_MCLK_OUT_OFF;
+	}
+
+	writel(clk_ctrl0, adc->mclk_source + CVI_I2S_CLK_CTRL0);
+	dev_info(adc->dev, "%s, I2S3 clk_ctrl0 = 0x%x\n", __func__, readl(adc->mclk_source + CVI_I2S_CLK_CTRL0));
+
+	mutex_unlock(&cv182xadc_mutex);
+}
+
+static int cv182xadc_set_dai_fmt(struct snd_soc_dai *dai,
+				 unsigned int fmt)
+{
+
+	struct cv182xadc *adc = snd_soc_dai_get_drvdata(dai);
+
+	if (!adc->dev)
+		dev_err(adc->dev, "dev is NULL\n");
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		dev_dbg(adc->dev, "Set ADC to MASTER mode\n");
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		dev_err(adc->dev, "Cannot set DAC to SLAVE mode, only support MASTER mode\n");
+		break;
+	default:
+		dev_err(adc->dev, "Cannot support this role mode\n");
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_IF:
+		dev_dbg(adc->dev, "set codec to NB_IF\n");
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		dev_dbg(adc->dev, "set codec to IB_NF\n");
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		dev_dbg(adc->dev, "set codec to IB_IF\n");
+		break;
+	case SND_SOC_DAIFMT_NB_NF:
+		dev_dbg(adc->dev, "set codec to NB_NF\n");
+		break;
+	default:
+		dev_err(adc->dev, "Cannot support this format\n");
+		break;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		dev_dbg(adc->dev, "set codec to I2S mode\n");
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		dev_dbg(adc->dev, "set codec to LEFT-JUSTIFY mode\n");
+		break;
+	default:
+		dev_err(adc->dev, "Cannot support this mode\n");
+		break;
+	}
+	return 0;
+}
+
+static int cv182xadc_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *params,
+			       struct snd_soc_dai *dai)
+{
+	struct cv182xadc *adc = snd_soc_dai_get_drvdata(dai);
+	int rate;
+	u32 ctrl1 = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL1) & ~AUDIO_PHY_REG_RXADC_CIC_OPT_MASK;
+	u32 ana3 = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA3) & ~AUDIO_PHY_REG_CTUNE_RXADC_MASK;
+	u32 ana0;
+	u32 spare0 = adc_read_reg(adc->adc_base, AUDIO_PHY_SPARE_0) & ~AUDIO_ADC_SCK_DIV_MASK;
+	void __iomem *dac;
+
+	/* ECO function, register naming is not corrected, use ioremap to access register of DAC */
+	dac = ioremap(0x0300A000, 0x30);
+	ana0 = readl(dac + AUDIO_PHY_TXDAC_ANA0) & ~AUDIO_PHY_REG_ADDI_TXDAC_MASK;
+
+	rate = params_rate(params);
+	if (rate >= 8000 && rate <= 48000) {
+		dev_info(adc->dev, "%s, set rate to %d\n", __func__, rate);
+		cv182xadc_set_mclk(adc, rate);
+
+		switch (rate) {
+		case 8000:
+			ctrl1 |= RXADC_CIC_DS_128;
+			ana3 |= RXADC_CTUNE_MCLK_4096;
+			ana0 |= ADDI_TXDAC_GAIN_RATIO_2_5;
+			spare0 |= SPARE_SCK_DIV(8); /* 4096 / 8 / 32 / 2 (if CIC is 128 need divide 2 in addition)*/
+			break;
+		case 11025:
+			ctrl1 |= RXADC_CIC_DS_128;
+			ana3 |= RXADC_CTUNE_MCLK_5644;
+			ana0 |= ADDI_TXDAC_GAIN_RATIO_2_5;
+			spare0 |= SPARE_SCK_DIV(8); /* 5644 / 11.025 / 32 / 2 */
+			break;
+		case 16000:
+			ctrl1 |= RXADC_CIC_DS_128;
+			ana3 |= RXADC_CTUNE_MCLK_8192;
+			ana0 |= ADDI_TXDAC_GAIN_RATIO_2_5;
+			spare0 |= SPARE_SCK_DIV(8); /* 8192 / 16 / 32 / 2 */
+			break;
+		case 22050:
+			ctrl1 |= RXADC_CIC_DS_128;
+			ana3 |= RXADC_CTUNE_MCLK_11298;
+			ana0 &= ADDI_TXDAC_GAIN_RATIO_1;
+			spare0 |= SPARE_SCK_DIV(8); /* 11298 / 22.05 / 32 / 2 */
+			break;
+		case 32000:
+			ctrl1 &= RXADC_CIC_DS_64;
+			ana3 |= RXADC_CTUNE_MCLK_8192;
+			ana0 &= ADDI_TXDAC_GAIN_RATIO_1;
+			spare0 |= SPARE_SCK_DIV(4); /* 8192 / 32 / 32 / 2 */
+			break;
+		case 44100:
+			ctrl1 &= RXADC_CIC_DS_64;
+			ana3 |= RXADC_CTUNE_MCLK_11298;
+			ana0 &= ADDI_TXDAC_GAIN_RATIO_1;
+			spare0 |= SPARE_SCK_DIV(4); /* 11298 / 44.1 / 32 / 2 */
+			break;
+		case 48000:
+			ctrl1 &= RXADC_CIC_DS_64;
+			ana3 |= RXADC_CTUNE_MCLK_12288;
+			ana0 &= ADDI_TXDAC_GAIN_RATIO_1;
+			spare0 |= SPARE_SCK_DIV(4); /* 12288 / 48 / 32 / 2 */
+			break;
+		default:
+			ctrl1 |= RXADC_CIC_DS_128;
+			ana3 |= RXADC_CTUNE_MCLK_8192;
+			ana0 |= ADDI_TXDAC_GAIN_RATIO_2_5;
+			spare0 |= SPARE_SCK_DIV(8); /* 8192 / 16 / 32 / 2 */
+			dev_dbg(adc->dev, "%s, unsupported sample rate. Set with default 16KHz\n", __func__);
+			break;
+		}
+
+		adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL1, ctrl1);
+		adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA3, ana3);
+		adc_write_reg(adc->adc_base, AUDIO_PHY_SPARE_0, spare0);
+		writel(ana0, dac + AUDIO_PHY_TXDAC_ANA0);
+		iounmap(dac);
+	} else {
+		dev_err(adc->dev, "%s, unsupported sample rate\n", __func__);
+		return 0;
+	}
+
+	if (params_width(params) != 16) {
+		dev_err(adc->dev, "Only support I2S channel width with 16 bits\n");
+		dev_err(adc->dev, "Set I2S channel width with 16bits\n");
+		return 0;
+	}
+	return 0;
+}
+
+static int cv182xadc_startup(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *dai)
+{
+	struct cv182xadc *adc = snd_soc_dai_get_drvdata(dai);
+
+	dev_dbg(adc->dev, "%s\n", __func__);
+	cv182xadc_clk_on(adc);
+
+	return 0;
+}
+
+static void cv182xadc_on(struct cv182xadc *adc)
+{
+
+	u32 val = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+
+	dev_info(adc->dev, "%s, before rxadc reg val=0x%08x\n",
+		 __func__, adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0));
+
+	if ((val & AUDIO_PHY_REG_RXADC_EN_ON) | (val & AUDIO_PHY_REG_I2S_TX_EN_ON))
+		dev_info(adc->dev, "ADC or I2S TX already switched ON!!, val=0x%08x\n", val);
+
+	val |= AUDIO_PHY_REG_RXADC_EN_ON | AUDIO_PHY_REG_I2S_TX_EN_ON;
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, val);
+
+	dev_info(adc->dev, "%s, after rxadc reg val=0x%08x\n",
+		 __func__, adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0));
+
+}
+
+static void cv182xadc_off(struct cv182xadc *adc)
+{
+
+	u32 val = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+
+	val &= AUDIO_PHY_REG_RXADC_EN_OFF & AUDIO_PHY_REG_I2S_TX_EN_OFF;
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, val);
+
+	dev_dbg(adc->dev, "%s, after rxadc reg val=0x%08x\n",
+		__func__, adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0));
+
+}
+
+static void cv182xadc_shutdown(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct cv182xadc *adc = snd_soc_dai_get_drvdata(dai);
+
+	dev_dbg(adc->dev, "%s\n", __func__);
+	cv182x_reset_adc();
+	cv182xadc_clk_off(adc);
+}
+
+static int cv182xadc_trigger(struct snd_pcm_substream *substream,
+			     int cmd, struct snd_soc_dai *dai)
+{
+	struct cv182xadc *adc = snd_soc_dai_get_drvdata(dai);
+	int ret = 0;
+
+	dev_dbg(adc->dev, "%s, cmd=%d\n", __func__, cmd);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		cv182xadc_on(adc);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		cv182xadc_off(adc);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static struct cv182xadc *file_adc_dev(struct file *file)
+{
+	return container_of(file->private_data, struct cv182xadc, miscdev);
+}
+
+
+static long adc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+
+	unsigned int __user *argp = (unsigned int __user *)arg;
+	struct cv182xadc *adc = file_adc_dev(file);
+	struct cvi_vol_ctrl vol;
+	u32 val, val2;
+	u32 temp;
+
+	if (argp != NULL) {
+		if (!copy_from_user(&val, argp, sizeof(val))) {
+			if (mutex_lock_interruptible(&cv182xadc_mutex)) {
+				pr_debug("cv182xadc: signal arrives while waiting for lock\n");
+				return -EINTR;
+			}
+		} else
+			return -EFAULT;
+	}
+
+	pr_debug("%s, received cmd=%u, val=%d\n", __func__, cmd, val);
+
+	switch (cmd) {
+	case ACODEC_SOFT_RESET_CTRL:
+		cv182x_reset_adc();
+		break;
+
+	case ACODEC_SET_INPUT_VOL:
+		pr_debug("adc: ACODEC_SET_INPUT_VOL\n");
+		if ((val < 0) | (val > 24))
+			pr_err("Only support range 0 [0dB] ~ 24 [48dB]\n");
+		else if (val == 0) {
+			/* set mute */
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2)
+			       | AUDIO_PHY_REG_MUTEL_ON
+			       | AUDIO_PHY_REG_MUTER_ON;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2, temp);
+			temp = (adc_vol_list[val] | (adc_vol_list[val] << 16));
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0, temp);
+		} else {
+			val2 = (adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & AUDIO_PHY_REG_ADC_VOLL_MASK);
+			for (temp = 0; temp < 25; temp++) {
+				if (val2 == adc_vol_list[temp])
+					break;
+			}
+			if (temp == 0) {
+				/* unmute */
+				temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2)
+				       & AUDIO_PHY_REG_MUTEL_OFF
+				       & AUDIO_PHY_REG_MUTEL_OFF;
+				adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2, temp);
+			}
+			temp = (adc_vol_list[val] | (adc_vol_list[val] << 16));
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0, temp);
+		}
+		break;
+
+	case ACODEC_GET_INPUT_VOL:
+		pr_debug("adc: ACODEC_GET_INPUT_VOL\n");
+		val = (adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & AUDIO_PHY_REG_ADC_VOLL_MASK);
+		for (temp = 0; temp < 25; temp++) {
+			if (val == adc_vol_list[temp])
+				break;
+		}
+		if (temp == 25)
+			pr_info("adc: cannot find, out of range\n");
+
+		if (copy_to_user(argp, &temp, sizeof(temp)))
+			pr_err("adc, failed to return input vol\n");
+		break;
+
+	case ACODEC_SET_I2S1_FS:
+		pr_info("adc: ACODEC_SET_I2S1_FS is not support\n");
+		break;
+
+	case ACODEC_SET_MIXER_MIC:
+		pr_info("ACODEC_SET_MIXER_MIC is not support\n");
+		break;
+	case ACODEC_SET_GAIN_MICL:
+		pr_debug("adc: ACODEC_SET_GAIN_MICL\n");
+		if ((val < 0) | (val > 24))
+			pr_err("Only support range 0 [0dB] ~ 24 [48dB]\n");
+		else {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & ~AUDIO_PHY_REG_ADC_VOLL_MASK;
+			temp |= adc_vol_list[val];
+			old_adc_voll = val;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0, temp);
+		}
+		break;
+	case ACODEC_SET_GAIN_MICR:
+		pr_debug("adc: ACODEC_SET_GAIN_MICR\n");
+		if ((val < 0) | (val > 24))
+			pr_err("Only support range 0 [0dB] ~ 24 [48dB]\n");
+		else {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & ~AUDIO_PHY_REG_ADC_VOLR_MASK;
+			temp |= (adc_vol_list[val] << 16);
+			old_adc_volr = val;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0, temp);
+		}
+		break;
+
+	case ACODEC_SET_ADCL_VOL:
+
+		if (copy_from_user(&vol, argp, sizeof(vol))) {
+			if (mutex_is_locked(&cv182xadc_mutex))
+				mutex_unlock(&cv182xadc_mutex);
+
+			return -EFAULT;
+		}
+
+		pr_info("adc: ACODEC_SET_ADCL_VOL to %d, mute=%d\n", vol.vol_ctrl, vol.vol_ctrl_mute);
+
+		if (vol.vol_ctrl_mute == 1) {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) | AUDIO_PHY_REG_MUTEL_ON;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2, temp);
+		} else if ((vol.vol_ctrl < 0) | (vol.vol_ctrl > 24))
+			pr_err("adc-L: Only support range 0 [0dB] ~ 24 [48dB]\n");
+		else {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & ~AUDIO_PHY_REG_ADC_VOLL_MASK;
+			temp |= adc_vol_list[val];
+			old_adc_voll = val;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0, temp);
+
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) & AUDIO_PHY_REG_MUTEL_OFF;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2, temp);
+		}
+
+		break;
+
+	case ACODEC_SET_ADCR_VOL:
+		if (copy_from_user(&vol, argp, sizeof(vol))) {
+			if (mutex_is_locked(&cv182xadc_mutex))
+				mutex_unlock(&cv182xadc_mutex);
+
+			return -EFAULT;
+		}
+
+		pr_debug("adc: ACODEC_SET_ADCR_VOL to %d, mute=%d\n", vol.vol_ctrl, vol.vol_ctrl_mute);
+
+		if (vol.vol_ctrl_mute == 1) {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) | AUDIO_PHY_REG_MUTER_ON;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2, temp);
+		} else if ((vol.vol_ctrl < 0) | (vol.vol_ctrl > 24))
+			pr_err("adc-R: Only support range 0 [0dB] ~ 24 [48dB]\n");
+		else {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & ~AUDIO_PHY_REG_ADC_VOLR_MASK;
+			temp |= (adc_vol_list[val] << 16);
+			old_adc_volr = val;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0, temp);
+
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) & AUDIO_PHY_REG_MUTER_OFF;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2, temp);
+		}
+		break;
+	case ACODEC_SET_MICL_MUTE:
+		pr_debug("adc: ACODEC_SET_MICL_MUTE\n");
+		if (val == 0)
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) & AUDIO_PHY_REG_MUTEL_OFF;
+		else
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) | AUDIO_PHY_REG_MUTEL_ON;
+
+		adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2, temp);
+		break;
+	case ACODEC_SET_MICR_MUTE:
+		pr_debug("adc: ACODEC_SET_MICR_MUTE\n");
+		if (val == 0)
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) & AUDIO_PHY_REG_MUTER_OFF;
+		else
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) | AUDIO_PHY_REG_MUTER_ON;
+
+		adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2, temp);
+		break;
+
+	case ACODEC_GET_GAIN_MICL:
+		pr_debug("adc: ACODEC_GET_GAIN_MICL\n");
+		val = (adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & AUDIO_PHY_REG_ADC_VOLL_MASK);
+
+		for (temp = 0; temp < 25; temp++) {
+			if (val == adc_vol_list[temp])
+				break;
+		}
+
+		if (copy_to_user(argp, &temp, sizeof(temp)))
+			pr_err("failed to return MICL gain\n");
+		break;
+	case ACODEC_GET_GAIN_MICR:
+		pr_debug("adc: ACODEC_GET_GAIN_MICR\n");
+		val = (adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & AUDIO_PHY_REG_ADC_VOLR_MASK) >> 16;
+
+		for (temp = 0; temp < 25; temp++) {
+			if (val == adc_vol_list[temp])
+				break;
+		}
+		if (copy_to_user(argp, &temp, sizeof(temp)))
+			pr_err("failed to return MICR gain\n");
+		break;
+
+	case ACODEC_GET_ADCL_VOL:
+		pr_debug("adc: ACODEC_GET_ADCL_VOL\n");
+
+		val = (adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & AUDIO_PHY_REG_ADC_VOLL_MASK);
+		for (temp = 0; temp < 25; temp++) {
+			if (val == adc_vol_list[temp])
+				break;
+		}
+		vol.vol_ctrl = temp;
+		vol.vol_ctrl_mute = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) & AUDIO_PHY_REG_MUTEL_RXPGA_MASK;
+
+		if (copy_to_user(argp, &vol, sizeof(vol)))
+			pr_err("failed to return ADCL vol\n");
+
+		break;
+	case ACODEC_GET_ADCR_VOL:
+		pr_debug("adc: ACODEC_GET_ADCR_VOL\n");
+
+		val = (adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0) & AUDIO_PHY_REG_ADC_VOLR_MASK) >> 16;
+		for (temp = 0; temp < 25; temp++) {
+			if (val == adc_vol_list[temp])
+				break;
+		}
+		vol.vol_ctrl = temp;
+		vol.vol_ctrl_mute = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2) & AUDIO_PHY_REG_MUTER_RXPGA_MASK;
+
+		if (copy_to_user(argp, &vol, sizeof(vol)))
+			pr_err("failed to return ADCR vol\n");
+
+		break;
+
+	case ACODEC_SET_PD_ADCL:
+		pr_debug("adc: ACODEC_SET_PD_ADCL, val=%d\n", val);
+		if (val == 0) {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+			temp |= AUDIO_PHY_REG_RXADC_EN_ON | AUDIO_PHY_REG_I2S_TX_EN_ON;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, temp);
+		} else {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+			temp &= AUDIO_PHY_REG_RXADC_EN_OFF & AUDIO_PHY_REG_I2S_TX_EN_OFF;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, temp);
+		}
+		break;
+	case ACODEC_SET_PD_ADCR:
+		pr_debug("adc: ACODEC_SET_PD_ADCR, val=%d\n", val);
+		if (val == 0) {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+			temp |= AUDIO_PHY_REG_RXADC_EN_ON | AUDIO_PHY_REG_I2S_TX_EN_ON;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, temp);
+		} else {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+			temp &= AUDIO_PHY_REG_RXADC_EN_OFF & AUDIO_PHY_REG_I2S_TX_EN_OFF;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, temp);
+		}
+		break;
+
+	case ACODEC_SET_PD_LINEINL:
+		pr_debug("adc: ACODEC_SET_PD_LINEINL, val=%d\n", val);
+		if (val == 0) {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+			temp |= AUDIO_PHY_REG_RXADC_EN_ON | AUDIO_PHY_REG_I2S_TX_EN_ON;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, temp);
+		} else {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+			temp &= AUDIO_PHY_REG_RXADC_EN_OFF & AUDIO_PHY_REG_I2S_TX_EN_OFF;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, temp);
+		}
+		break;
+	case ACODEC_SET_PD_LINEINR:
+		pr_debug("adc: ACODEC_SET_PD_LINEINR, val=%d\n", val);
+		if (val == 0) {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+			temp |= AUDIO_PHY_REG_RXADC_EN_ON | AUDIO_PHY_REG_I2S_TX_EN_ON;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, temp);
+		} else {
+			temp = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+			temp &= AUDIO_PHY_REG_RXADC_EN_OFF & AUDIO_PHY_REG_I2S_TX_EN_OFF;
+			adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, temp);
+		}
+		break;
+	case ACODEC_SET_ADC_HP_FILTER:
+		pr_info("adc: ACODEC_SET_ADC_HP_FILTER is not support\n");
+		break;
+	default:
+		pr_info("%s, received unsupport cmd=%u\n", __func__, cmd);
+		break;
+	}
+
+	if (mutex_is_locked(&cv182xadc_mutex))
+		mutex_unlock(&cv182xadc_mutex);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops cv182xadc_dai_ops = {
+	.hw_params	= cv182xadc_hw_params,
+	.set_fmt	= cv182xadc_set_dai_fmt,
+	.startup	= cv182xadc_startup,
+	.shutdown	= cv182xadc_shutdown,
+	.trigger	= cv182xadc_trigger,
+};
+
+static struct snd_soc_dai_driver cv182xadc_dai = {
+	.name		= "cv182xadc",
+	.capture	= {
+		.stream_name	= "Capture",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates = SNDRV_PCM_RATE_8000_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.ops		= &cv182xadc_dai_ops,
+};
+
+static const struct snd_kcontrol_new cv182xadc_controls[] = {
+	SOC_DOUBLE("ADC Power", AUDIO_PHY_RXADC_CTRL0, 0, 1, 1, 0),
+	SOC_DOUBLE("ADC Capture Volume", AUDIO_PHY_RXADC_ANA0, 0, 16, 24, 0),
+	SOC_DOUBLE("ADC Capture Mute", AUDIO_PHY_RXADC_ANA2, 0, 1, 1, 0),
+};
+
+unsigned int cv182xadc_reg_read(struct snd_soc_component *codec, unsigned int reg)
+{
+	int ret, idx;
+	struct cv182xadc *adc = dev_get_drvdata(codec->dev);
+
+	ret = adc_read_reg(adc->adc_base, reg);
+	if (reg == AUDIO_PHY_RXADC_ANA0) {
+		for (idx = 0; idx < 25; idx++)
+			if ((ret & 0xffff) == adc_vol_list[idx])
+				break;
+		dev_info(adc->dev, "ADC get Vol, reg:%d,ret:%#x, idx=%d.\n", reg, ret, idx);
+		ret = idx;
+	}
+	dev_dbg(adc->dev, "%s reg:%d,ret:%#x.\n", __func__, reg, ret);
+
+	return ret;
+}
+
+int cv182xadc_reg_write(struct snd_soc_component *codec, unsigned int reg, unsigned int value)
+{
+	struct cv182xadc *adc = dev_get_drvdata(codec->dev);
+	u32 temp_val;
+
+	if (reg == AUDIO_PHY_RXADC_ANA0) {
+		temp_val = adc_vol_list[value];
+		dev_info(adc->dev, "Set ADC Vol, get input val=%d, output val=0x%x\n", value, temp_val);
+		value = (temp_val << 16) | temp_val;
+	}
+
+	adc_write_reg(adc->adc_base, reg, value);
+	dev_dbg(adc->dev, "%s reg:%d,value:%#x.\n", __func__, reg, value);
+
+	return 0;
+}
+
+static const struct snd_soc_component_driver soc_component_dev_cv182xadc = {
+	.controls = cv182xadc_controls,
+	.num_controls = ARRAY_SIZE(cv182xadc_controls),
+	.read = cv182xadc_reg_read,
+	.write = cv182xadc_reg_write,
+};
+
+static const struct file_operations adc_fops = {
+	.owner = THIS_MODULE,
+	.open = adc_open,
+	.release = adc_close,
+	.unlocked_ioctl = adc_ioctl,
+	.compat_ioctl = adc_ioctl,
+};
+
+static int adc_device_register(struct cv182xadc *adc)
+{
+	struct miscdevice *miscdev = &adc->miscdev;
+	int ret;
+
+	miscdev->minor = MISC_DYNAMIC_MINOR;
+	miscdev->name = "cv182xadc";
+	miscdev->fops = &adc_fops;
+	miscdev->parent = NULL;
+
+	ret = misc_register(miscdev);
+	if (ret) {
+		pr_err("adc: failed to register misc device.\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int cv182xadc_probe(struct platform_device *pdev)
+{
+	struct cv182xadc *adc;
+	struct resource *res;
+	u32 mclk_source_addr = 0x0;
+	u32 ctrl1;
+	int ret;
+
+	dev_info(&pdev->dev, "%s\n", __func__);
+
+	adc = devm_kzalloc(&pdev->dev, sizeof(*adc), GFP_KERNEL);
+	if (!adc)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	adc->adc_base = devm_ioremap_resource(&pdev->dev, res);
+	dev_dbg(&pdev->dev, "%s get adc_base=0x%p\n", __func__, adc->adc_base);
+	if (IS_ERR(adc->adc_base))
+		return PTR_ERR(adc->adc_base);
+
+	dev_set_drvdata(&pdev->dev, adc);
+	adc->dev = &pdev->dev;
+
+	ret = adc_device_register(adc);
+	if (ret < 0) {
+		pr_err("adc: register device error\n");
+		return ret;
+	}
+
+	of_property_read_u32(pdev->dev.of_node, "clk_source", &mclk_source_addr);
+
+	if (mclk_source_addr)
+		adc->mclk_source = ioremap(mclk_source_addr, 0x100);
+	else
+		dev_err(&pdev->dev, "get MCLK source failed !!\n");
+
+	/* set default input vol gain to maxmum 48dB, vol range is 0~24 */
+	ctrl1 = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL1);
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL1, ctrl1 | AUDIO_ADC_IGR_INIT_EN);
+	pr_info("%s start devm_snd_soc_register_component\n", __func__);
+	return devm_snd_soc_register_component(&pdev->dev, &soc_component_dev_cv182xadc,
+					       &cv182xadc_dai, 1);
+}
+
+static int cv182xadc_remove(struct platform_device *pdev)
+{
+	struct cv182xadc *adc = dev_get_drvdata(&pdev->dev);
+
+	dev_dbg(&pdev->dev, "%s\n", __func__);
+	iounmap(adc->mclk_source);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id cvitek_adc_of_match[] = {
+	{ .compatible = "cvitek,cv182xadc", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, cvitek_adc_of_match);
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+static int cv182xadc_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct cv182xadc *adc = platform_get_drvdata(pdev);
+
+	if (!adc->reg_ctx) {
+		adc->reg_ctx = devm_kzalloc(adc->dev, sizeof(struct cv182xadc_context), GFP_KERNEL);
+		if (!adc->reg_ctx)
+			return -ENOMEM;
+	}
+
+	adc->reg_ctx->ctl0 = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0);
+	adc->reg_ctx->ctl1 = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL1);
+	adc->reg_ctx->status = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_STATUS);
+	adc->reg_ctx->ana0 = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0);
+	adc->reg_ctx->ana2 = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2);
+	adc->reg_ctx->ana3 = adc_read_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA3);
+
+	return 0;
+}
+
+static int cv182xadc_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct cv182xadc *adc = platform_get_drvdata(pdev);
+
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL0, adc->reg_ctx->ctl0);
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_CTRL1, adc->reg_ctx->ctl1);
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_STATUS, adc->reg_ctx->status);
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA0, adc->reg_ctx->ana0);
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA2, adc->reg_ctx->ana2);
+	adc_write_reg(adc->adc_base, AUDIO_PHY_RXADC_ANA3, adc->reg_ctx->ana3);
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(cv182xadc_pm_ops, cv182xadc_suspend,
+			 cv182xadc_resume);
+#endif
+
+
+static struct platform_driver cv182xadc_platform_driver = {
+	.probe		= cv182xadc_probe,
+	.remove		= cv182xadc_remove,
+	.driver		= {
+		.name	= "cv182xadc",
+		.of_match_table = of_match_ptr(cvitek_adc_of_match),
+#ifdef CONFIG_PM_SLEEP
+		.pm	= &cv182xadc_pm_ops,
+#endif
+	},
+};
+module_platform_driver(cv182xadc_platform_driver);
+
+MODULE_DESCRIPTION("ASoC CVITEK CV182xADC driver");
+MODULE_AUTHOR("Ethan Chen <ethan.chen@wisecore.com.tw>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:cv182xadc");
diff --git a/sound/soc/cvitek/cv182xdac.c b/sound/soc/cvitek/cv182xdac.c
new file mode 100644
index 000000000000..5721e5ddb18c
--- /dev/null
+++ b/sound/soc/cvitek/cv182xdac.c
@@ -0,0 +1,715 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * CVITEK CV182X DAC driver
+ *
+ * Copyright 2020 CVITEK Inc.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/pm.h>
+#include <linux/mutex.h>
+#include <linux/miscdevice.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/control.h>
+#include "cv1835_ioctl.h"
+#include "../codecs/cv182xadac.h"
+#include "cv1835_i2s_subsys.h"
+#include <linux/gpio.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/of_gpio.h>
+
+static DEFINE_MUTEX(cv182xdac_mutex);
+int mute_pin_l; // 495
+int mute_pin_r; // 510
+
+
+void muteAmp(bool enable)
+{
+	if (enable) {
+		if (mute_pin_l != -EINVAL) {
+			gpio_set_value(mute_pin_l, 0);
+		}
+		if (mute_pin_r != -EINVAL) {
+			gpio_set_value(mute_pin_r, 0);
+		}
+	} else {
+		if (mute_pin_l != -EINVAL) {
+			gpio_set_value(mute_pin_l, 1);
+		}
+		if (mute_pin_r != -EINVAL) {
+			gpio_set_value(mute_pin_r, 1);
+		}
+	}
+}
+
+static inline void dac_write_reg(void __iomem *io_base, int reg, u32 val)
+{
+	writel(val, io_base + reg);
+}
+
+static inline u32 dac_read_reg(void __iomem *io_base, int reg)
+{
+	return readl(io_base + reg);
+}
+
+static int dac_open(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&cv182xdac_mutex))
+		return -EINTR;
+	mutex_unlock(&cv182xdac_mutex);
+	pr_debug("%s\n", __func__);
+	return 0;
+}
+
+static int dac_close(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&cv182xdac_mutex))
+		return -EINTR;
+	mutex_unlock(&cv182xdac_mutex);
+	pr_debug("%s\n", __func__);
+	return 0;
+}
+
+
+static int cv182xdac_set_dai_fmt(struct snd_soc_dai *dai,
+				 unsigned int fmt)
+{
+
+	struct cv182xdac *dac = snd_soc_dai_get_drvdata(dai);
+
+	if (!dac->dev)
+		dev_err(dac->dev, "dev is NULL\n");
+
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		dev_err(dac->dev, "Cannot set DAC to MASTER mode\n");
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		dev_dbg(dac->dev, "Set DAC to SLAVE mode\n");
+		break;
+	default:
+		dev_err(dac->dev, "Cannot support this role mode\n");
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		dev_dbg(dac->dev, "set codec to NB_NF\n");
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		dev_dbg(dac->dev, "set codec to IB_NF\n");
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		dev_dbg(dac->dev, "set codec to IB_IF\n");
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		dev_dbg(dac->dev, "set codec to NB_IF\n");
+		break;
+	default:
+		dev_err(dac->dev, "Cannot support this format\n");
+		break;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		dev_dbg(dac->dev, "set codec to I2S mode\n");
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		dev_dbg(dac->dev, "set codec to LEFT-JUSTIFY mode\n");
+		break;
+	default:
+		dev_err(dac->dev, "Cannot support this mode\n");
+		break;
+	}
+	return 0;
+}
+
+static int cv182xdac_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *params,
+			       struct snd_soc_dai *dai)
+{
+	struct cv182xdac *dac = snd_soc_dai_get_drvdata(dai);
+	int rate;
+	u32 ctrl1 = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL1) & ~AUDIO_PHY_REG_TXDAC_CIC_OPT_MASK;
+	u32 tick = 0;
+	u32 chan_nr = 0;
+	u32 ana2 = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+
+	chan_nr = params_channels(params);
+
+	switch (chan_nr) {
+	case 1:
+		//ana2 |= AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_ON; /* turn R-channel off */
+		ana2 &= AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_OFF; /* turn R-channel on */
+		dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2, ana2);
+		break;
+	default:
+		ana2 &= AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_OFF; /* turn R-channel on */
+		dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2, ana2);
+		break;
+	}
+
+
+	rate = params_rate(params);
+	if (rate >= 8000 && rate <= 48000) {
+		dev_dbg(dac->dev, "%s, set rate to %d\n", __func__, rate);
+
+		switch (rate) {
+		case 8000:
+			ctrl1 |= TXDAC_CIC_DS_128;
+			tick = ((2 * 4096) / 1000) + 1; /* (2 msec * MCLK frequecy) / 1s ) + 1 */
+			break;
+		case 11025:
+			ctrl1 |= TXDAC_CIC_DS_128;
+			tick = ((2 * 4096) / 1000) + 1;
+			break;
+		case 16000:
+			ctrl1 |= TXDAC_CIC_DS_128;
+			tick = ((2 * 4096) / 1000) + 1;
+			break;
+		case 22050:
+			ctrl1 |= TXDAC_CIC_DS_128;
+			tick = ((2 * 4096) / 1000) + 1;
+			break;
+		case 32000:
+			ctrl1 &= TXDAC_CIC_DS_64;
+			tick = ((2 * 4096) / 1000) + 1;
+			break;
+		case 44100:
+			ctrl1 &= TXDAC_CIC_DS_64;
+			tick = ((2 * 4096) / 1000) + 1;
+			break;
+		case 48000:
+			ctrl1 &= TXDAC_CIC_DS_64;
+			tick = ((2 * 4096) / 1000) + 1;
+			break;
+		default:
+			ctrl1 |= TXDAC_CIC_DS_128;
+			tick = ((2 * 4096) / 1000) + 1;
+			dev_dbg(dac->dev, "%s, set sample rate with default 16KHz\n", __func__);
+			break;
+		}
+	} else {
+		dev_err(dac->dev, "%s, unsupported sample rate\n", __func__);
+		return 0;
+	}
+	dev_dbg(dac->dev, "%s, ctrl1=0x%x\n", __func__, ctrl1);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL1, ctrl1);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE0, tick);
+
+	return 0;
+}
+
+static int cv182xdac_startup(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static void cv182xdac_on(struct cv182xdac *dac)
+{
+
+	u32 val = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0);
+
+	dev_dbg(dac->dev, "%s, before ctrl0_reg val=0x%08x\n",	__func__, val);
+
+	if ((val & AUDIO_PHY_REG_TXDAC_EN_ON) | (val & AUDIO_PHY_REG_I2S_RX_EN_ON))
+		dev_info(dac->dev, "DAC already switched ON!!, val=0x%08x\n", val);
+
+	val |= AUDIO_PHY_REG_TXDAC_EN_ON | AUDIO_PHY_REG_I2S_RX_EN_ON;
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0, val);
+
+	dev_dbg(dac->dev, "%s, after ctrl0_reg val=0x%08x\n",
+		__func__, dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0));
+
+}
+
+static void cv182xdac_off(struct cv182xdac *dac)
+{
+	u32 val = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0);
+
+	dev_dbg(dac->dev, "%s, before ctrl_reg val=0x%08x\n",
+		__func__, dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0));
+
+	val &= AUDIO_PHY_REG_TXDAC_EN_OFF & AUDIO_PHY_REG_I2S_RX_EN_OFF;
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0, val);
+
+	dev_dbg(dac->dev, "%s, after ctrl_reg val=0x%08x\n",
+		__func__, dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0));
+}
+
+static void cv182xdac_shutdown(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct cv182xdac *dac = snd_soc_dai_get_drvdata(dai);
+
+	dev_dbg(dac->dev, "%s\n", __func__);
+	muteAmp(true);
+	cv182x_reset_dac();
+}
+
+static int cv182xdac_trigger(struct snd_pcm_substream *substream,
+			     int cmd, struct snd_soc_dai *dai)
+{
+	struct cv182xdac *dac = snd_soc_dai_get_drvdata(dai);
+	int ret = 0;
+
+	dev_dbg(dac->dev, "%s, cmd=%d\n", __func__, cmd);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		snd_pcm_stream_unlock_irq(substream);
+		cv182xdac_on(dac);
+		muteAmp(false);
+		snd_pcm_stream_lock_irq(substream);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		snd_pcm_stream_unlock_irq(substream);
+		muteAmp(true);
+		cv182xdac_off(dac);
+		snd_pcm_stream_lock_irq(substream);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static struct cv182xdac *file_dac_dev(struct file *file)
+{
+	return container_of(file->private_data, struct cv182xdac, miscdev);
+}
+
+static long dac_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+
+	unsigned int __user *argp = (unsigned int __user *)arg;
+	struct cv182xdac *dac = file_dac_dev(file);
+	struct cvi_vol_ctrl vol;
+	u32 val;
+	u32 temp;
+
+	if (argp != NULL) {
+		if (!copy_from_user(&val, argp, sizeof(val))) {
+			if (mutex_lock_interruptible(&cv182xdac_mutex)) {
+				pr_debug("cv182xdac: signal arrives while waiting for lock\n");
+				return -EINTR;
+			}
+		} else
+			return -EFAULT;
+	}
+
+	switch (cmd) {
+	case ACODEC_SOFT_RESET_CTRL:
+		cv182x_reset_dac();
+		break;
+
+	case ACODEC_SET_OUTPUT_VOL:
+		pr_debug("dac: ACODEC_SET_OUTPUT_VOL with val=%d\n", val);
+
+		if ((val < 0) | (val > 32))
+			pr_err("Only support range 0 [mute] ~ 32 [maximum]\n");
+		else {
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1)
+			       & ~(AUDIO_PHY_REG_TXDAC_GAIN_UB_0_MASK | AUDIO_PHY_REG_TXDAC_GAIN_UB_1_MASK);
+			temp |= DAC_VOL_L(val) | DAC_VOL_R(val);
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1, temp);
+		}
+		break;
+
+	case ACODEC_GET_OUTPUT_VOL:
+		pr_debug("dac: ACODEC_GET_OUTPUT_VOL\n");
+		temp = ((dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1)
+			 & AUDIO_PHY_REG_TXDAC_GAIN_UB_0_MASK) + 1) / CV182x_DAC_VOL_STEP;
+		pr_debug("dac: return val=%d\n", temp);
+		if (copy_to_user(argp, &temp, sizeof(temp)))
+			pr_err("dac, failed to return output vol\n");
+		break;
+
+	case ACODEC_SET_I2S1_FS:
+		pr_debug("dac: ACODEC_SET_I2S1_FS is not support\n");
+		break;
+
+	case ACODEC_SET_DACL_VOL:
+		pr_debug("dac: ACODEC_SET_DACL_VOL\n");
+		if (copy_from_user(&vol, argp, sizeof(vol))) {
+			if (mutex_is_locked(&cv182xdac_mutex))
+				mutex_unlock(&cv182xdac_mutex);
+
+			return -EFAULT;
+		}
+		if (vol.vol_ctrl_mute == 1) {
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+			temp |= AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_ON;
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2, temp);
+		} else if ((vol.vol_ctrl < 0) | (vol.vol_ctrl > 32))
+			pr_err("dac-L: Only support range 0 [mute] ~ 32 [maximum]\n");
+		else {
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1) & ~AUDIO_PHY_REG_TXDAC_GAIN_UB_0_MASK;
+			temp |= DAC_VOL_L(vol.vol_ctrl);
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1, temp);
+
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+			temp &= AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_OFF;
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2, temp);
+		}
+		break;
+
+	case ACODEC_SET_DACR_VOL:
+		pr_debug("dac: ACODEC_SET_DACR_VOL\n");
+		if (copy_from_user(&vol, argp, sizeof(vol)))
+			return -EFAULT;
+
+		if (vol.vol_ctrl_mute == 1) {
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+			temp |= AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_ON;
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2, temp);
+		} else if ((vol.vol_ctrl < 0) | (vol.vol_ctrl > 32))
+			pr_err("dac-L: Only support range 0 [mute] ~ 32 [maximum]\n");
+		else {
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1) & ~AUDIO_PHY_REG_TXDAC_GAIN_UB_1_MASK;
+			temp |= DAC_VOL_R(vol.vol_ctrl);
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1, temp);
+
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+			temp &= AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_OFF;
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2, temp);
+		}
+		break;
+
+	case ACODEC_SET_DACL_MUTE:
+		pr_debug("dac: ACODEC_SET_DACL_MUTE, val=%d\n", val);
+		temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+		if (val == 0)
+			temp &= AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_OFF;
+		else
+			temp |= AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_ON;
+
+		dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2, temp);
+		break;
+	case ACODEC_SET_DACR_MUTE:
+		pr_debug("dac: ACODEC_SET_DACR_MUTE, val=%d\n", val);
+		temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+		if (val == 0)
+			temp &= AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_OFF;
+		else
+			temp |= AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_ON;
+		dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2, temp);
+		break;
+
+	case ACODEC_GET_DACL_VOL:
+		pr_debug("dac: ACODEC_GET_DACL_VOL\n");
+		temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+		if (temp & AUDIO_PHY_REG_DA_DEML_TXDAC_OW_EN_MASK) {
+			vol.vol_ctrl = 0;
+			vol.vol_ctrl_mute = 1;
+		} else {
+			temp = ((dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1)
+				 & AUDIO_PHY_REG_TXDAC_GAIN_UB_0_MASK) + 1) / CV182x_DAC_VOL_STEP;
+			vol.vol_ctrl = temp;
+			vol.vol_ctrl_mute = 0;
+		}
+		if (copy_to_user(argp, &vol, sizeof(vol)))
+			pr_err("failed to return DACL vol\n");
+		break;
+	case ACODEC_GET_DACR_VOL:
+		temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+		pr_debug("dac: ACODEC_GET_DACR_VOL, txdac_ana2=0x%x\n", temp);
+		if (temp & AUDIO_PHY_REG_DA_DEMR_TXDAC_OW_EN_MASK) {
+			vol.vol_ctrl = 0;
+			vol.vol_ctrl_mute = 1;
+		} else {
+			temp = (((dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1)
+				  & AUDIO_PHY_REG_TXDAC_GAIN_UB_1_MASK) >> 16) + 1) / CV182x_DAC_VOL_STEP;
+			vol.vol_ctrl = temp;
+			vol.vol_ctrl_mute = 0;
+		}
+		if (copy_to_user(argp, &vol, sizeof(vol)))
+			pr_err("failed to return DACR vol\n");
+		break;
+
+	case ACODEC_SET_PD_DACL:
+		pr_debug("dac: ACODEC_SET_PD_DACL, val=%d\n", val);
+		if (val == 0) {
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0);
+			temp &= AUDIO_PHY_REG_TXDAC_EN_ON | AUDIO_PHY_REG_I2S_RX_EN_ON;
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0, temp);
+		} else {
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0);
+			temp &= AUDIO_PHY_REG_TXDAC_EN_OFF & AUDIO_PHY_REG_I2S_RX_EN_OFF;
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0, temp);
+		}
+		break;
+	case ACODEC_SET_PD_DACR:
+		pr_debug("dac: ACODEC_SET_PD_DACR, val=%d\n", val);
+		if (val == 0) {
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0);
+			temp &= AUDIO_PHY_REG_TXDAC_EN_ON | AUDIO_PHY_REG_I2S_RX_EN_ON;
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0, temp);
+		} else {
+			temp = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0);
+			temp &= AUDIO_PHY_REG_TXDAC_EN_OFF & AUDIO_PHY_REG_I2S_RX_EN_OFF;
+			dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0, temp);
+		}
+		break;
+	case ACODEC_SET_DAC_DE_EMPHASIS:
+		pr_info("dac: ACODEC_SET_DAC_DE_EMPHASIS is not support\n");
+		break;
+	default:
+		pr_info("%s, received unsupported cmd=%u\n", __func__, cmd);
+		break;
+	}
+
+	if (mutex_is_locked(&cv182xdac_mutex))
+		mutex_unlock(&cv182xdac_mutex);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops cv182xdac_dai_ops = {
+	.hw_params	= cv182xdac_hw_params,
+	.set_fmt	= cv182xdac_set_dai_fmt,
+	.startup	= cv182xdac_startup,
+	.shutdown	= cv182xdac_shutdown,
+	.trigger	= cv182xdac_trigger,
+};
+
+static struct snd_soc_dai_driver cv182xdac_dai = {
+	.name		= "cv182xdac",
+	.playback	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates = SNDRV_PCM_RATE_8000_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.ops		= &cv182xdac_dai_ops,
+};
+
+static const struct snd_kcontrol_new cv182xdac_controls[] = {
+	SOC_DOUBLE("DAC Playback Power Up/Down", AUDIO_PHY_TXDAC_CTRL0, 1, 0, 1, 1),
+	SOC_DOUBLE("DAC Playback Volume", AUDIO_PHY_TXDAC_AFE1, 0, 16, 32, 1),
+	SOC_DOUBLE("DAC Playback MUTE", AUDIO_PHY_TXDAC_ANA2, 16, 17, 1, 0),
+};
+
+unsigned int cv182xdac_reg_read(struct snd_soc_component *codec, unsigned int reg)
+{
+	struct cv182xdac *dac = dev_get_drvdata(codec->dev);
+	int ret;
+	u32 temp_val = 0;
+
+	ret = dac_read_reg(dac->dac_base, reg);
+
+	if (reg == AUDIO_PHY_TXDAC_AFE1) {
+		temp_val = ((ret & 0x000001ff) + 1) / 16;
+		dev_info(dac->dev, "Get DAC Vol reg:%d,ret:0x%x temp_val=%d.\n", reg, ret, temp_val);
+		ret = temp_val;
+	}
+
+	dev_info(dac->dev, "%s reg:%d,ret:%#x.\n", __func__, reg, ret);
+
+	return ret;
+}
+
+int cv182xdac_reg_write(struct snd_soc_component *codec, unsigned int reg, unsigned int value)
+{
+	struct cv182xdac *dac = dev_get_drvdata(codec->dev);
+	u32 temp_val;
+
+	if (reg == AUDIO_PHY_TXDAC_AFE1) {
+		temp_val = ((value & 0x000001ff) * 16) - 1;
+		dev_info(dac->dev, "Set DAC Vol, get input val=%d, output val=%d\n", value, temp_val);
+		value = (temp_val << 16) | temp_val;
+	}
+
+	dac_write_reg(dac->dac_base, reg, value);
+	dev_info(dac->dev, "%s reg:%d,value:%#x.\n", __func__, reg, value);
+
+	return 0;
+}
+
+static const struct snd_soc_component_driver soc_component_dev_cv182xdac = {
+	.controls = cv182xdac_controls,
+	.num_controls = ARRAY_SIZE(cv182xdac_controls),
+	.read = cv182xdac_reg_read,
+	.write = cv182xdac_reg_write,
+};
+
+static const struct file_operations dac_fops = {
+	.owner = THIS_MODULE,
+	.open = dac_open,
+	.release = dac_close,
+	.unlocked_ioctl = dac_ioctl,
+	.compat_ioctl = dac_ioctl,
+};
+
+static int dac_device_register(struct cv182xdac *dac)
+{
+	struct miscdevice *miscdev = &dac->miscdev;
+	int ret;
+
+	miscdev->minor = MISC_DYNAMIC_MINOR;
+	miscdev->name = "cv182xdac";
+	miscdev->fops = &dac_fops;
+	miscdev->parent = NULL;
+
+	ret = misc_register(miscdev);
+	if (ret) {
+		pr_err("dac: failed to register misc device.\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int cv182xdac_probe(struct platform_device *pdev)
+{
+	struct cv182xdac *dac;
+	struct resource *res;
+	int ret;
+	enum of_gpio_flags flags;
+
+	mute_pin_l =  -EINVAL;
+	mute_pin_r =  -EINVAL;
+
+	dev_info(&pdev->dev, "%s\n", __func__);
+
+	dac = devm_kzalloc(&pdev->dev, sizeof(*dac), GFP_KERNEL);
+	if (!dac)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dac->dac_base = devm_ioremap_resource(&pdev->dev, res);
+	dev_dbg(&pdev->dev, "%s get dac_base=0x%p\n", __func__, dac->dac_base);
+	if (IS_ERR(dac->dac_base))
+		return PTR_ERR(dac->dac_base);
+
+	dev_set_drvdata(&pdev->dev, dac);
+	dac->dev = &pdev->dev;
+
+	ret = dac_device_register(dac);
+	if (ret < 0) {
+		pr_err("dac: register device error\n");
+		return ret;
+	}
+
+	mute_pin_l = of_get_named_gpio_flags(pdev->dev.of_node,
+					     "mute-gpio-l", 0, &flags);
+	mute_pin_r = of_get_named_gpio_flags(pdev->dev.of_node,
+					     "mute-gpio-r", 0, &flags);
+	// printk("mute_pin_l =%d, mute_pin_r=%d\n", mute_pin_l ,mute_pin_r);
+
+	if (!gpio_is_valid(mute_pin_l)) {
+		pr_info("%s mute_pin_l %d is not availabel(QFN is not need)\n", __func__, mute_pin_l);
+		mute_pin_l =  -EINVAL;
+	} else {
+		gpio_request(mute_pin_l, "mute_pin_l");
+		gpio_direction_output(mute_pin_l, 1);
+		gpio_set_value(mute_pin_l, 0);
+	}
+
+	if (!gpio_is_valid(mute_pin_r)) {
+		pr_info("%s mute_pin_r %d is not availabel\n", __func__, mute_pin_r);
+		mute_pin_r =  -EINVAL;
+	} else {
+		gpio_request(mute_pin_r, "mute_pin_r");
+		gpio_direction_output(mute_pin_r, 1);
+		gpio_set_value(mute_pin_r, 0);
+	}
+	return devm_snd_soc_register_component(&pdev->dev, &soc_component_dev_cv182xdac,
+					       &cv182xdac_dai, 1);
+}
+
+static int cv182xdac_remove(struct platform_device *pdev)
+{
+	muteAmp(true);
+	dev_dbg(&pdev->dev, "%s\n", __func__);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id cvitek_dac_of_match[] = {
+	{ .compatible = "cvitek,cv182xdac", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, cvitek_dac_of_match);
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+static int cv182xdac_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct cv182xdac *dac = platform_get_drvdata(pdev);
+
+	muteAmp(true);
+	if (!dac->reg_ctx) {
+		dac->reg_ctx = devm_kzalloc(dac->dev, sizeof(struct cv182xdac_context), GFP_KERNEL);
+		if (!dac->reg_ctx)
+			return -ENOMEM;
+	}
+
+	dac->reg_ctx->ctl0 = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0);
+	dac->reg_ctx->ctl1 = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL1);
+	dac->reg_ctx->afe0 = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE0);
+	dac->reg_ctx->afe1 = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1);
+	dac->reg_ctx->ana0 = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA0);
+	dac->reg_ctx->ana1 = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA1);
+	dac->reg_ctx->ana2 = dac_read_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2);
+
+	return 0;
+}
+
+static int cv182xdac_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct cv182xdac *dac = platform_get_drvdata(pdev);
+
+	muteAmp(false);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL0, dac->reg_ctx->ctl0);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_CTRL1, dac->reg_ctx->ctl1);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE0, dac->reg_ctx->afe0);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_AFE1, dac->reg_ctx->afe1);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA0, dac->reg_ctx->ana0);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA1, dac->reg_ctx->ana1);
+	dac_write_reg(dac->dac_base, AUDIO_PHY_TXDAC_ANA2, dac->reg_ctx->ana2);
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(cv182xdac_pm_ops, cv182xdac_suspend,
+			 cv182xdac_resume);
+#endif
+
+static struct platform_driver cv182xdac_platform_driver = {
+	.probe		= cv182xdac_probe,
+	.remove		= cv182xdac_remove,
+	.driver		= {
+		.name	= "cv182xdac",
+		.of_match_table = of_match_ptr(cvitek_dac_of_match),
+#ifdef CONFIG_PM_SLEEP
+		.pm	= &cv182xdac_pm_ops,
+#endif
+	},
+};
+module_platform_driver(cv182xdac_platform_driver);
+
+MODULE_DESCRIPTION("ASoC CVITEK CV182XDAC driver");
+MODULE_AUTHOR("Ethan Chen <ethan.chen@wisecore.com.tw>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:cv182xdac");
diff --git a/sound/soc/cvitek/cv1835_adau1372.c b/sound/soc/cvitek/cv1835_adau1372.c
new file mode 100644
index 000000000000..427fe9e65b7a
--- /dev/null
+++ b/sound/soc/cvitek/cv1835_adau1372.c
@@ -0,0 +1,209 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Machine driver for EVAL-ADAU1372 on CVITEK CV1835
+ *
+ * Copyright 2019 CVITEK
+ *
+ * Author: EthanChen
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <linux/io.h>
+#include "../codecs/adau1372.h"
+
+u16 tdm_slot_no = 2;
+
+static const struct snd_soc_dapm_widget cv1835_adau1372_dapm_widgets[] = {
+	SND_SOC_DAPM_LINE("Line In0", NULL),
+	SND_SOC_DAPM_LINE("Line In1", NULL),
+	SND_SOC_DAPM_LINE("Line In2", NULL),
+	SND_SOC_DAPM_LINE("Line In3", NULL),
+	SND_SOC_DAPM_HP("Earpiece", NULL),
+};
+
+static const struct snd_soc_dapm_route cv1835_adau1372_dapm_routes[] = {
+	{ "AIN0", NULL, "Line In0" },
+	{ "AIN1", NULL, "Line In1" },
+	{ "AIN2", NULL, "Line In2" },
+	{ "AIN3", NULL, "Line In3" },
+
+	{ "Earpiece", NULL, "HPOUTL" },
+	{ "Earpiece", NULL, "HPOUTR" },
+};
+
+static int cv1835_adau1372_hw_params(struct snd_pcm_substream *substream,
+				     struct snd_pcm_hw_params *params)
+{
+	return 0;
+}
+
+static int cv1835_adau1372_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	u32 ret;
+
+	/* Only need to set slot number while mode is TDM/PDM, otherwise default slot number is 2 */
+	if (tdm_slot_no != 2) {
+		ret = snd_soc_dai_set_tdm_slot(codec_dai, 0x0F, 0x0F, tdm_slot_no, 32);
+
+		if (ret < 0)
+			return ret;
+
+		ret = snd_soc_dai_set_tdm_slot(cpu_dai, 0x0F, 0x0F, tdm_slot_no, 32);
+
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+static struct snd_soc_ops cv1835_adau1372_ops = {
+	.hw_params = cv1835_adau1372_hw_params,
+};
+
+static struct snd_soc_dai_link cv1835_adau1372_dai[] = {
+	{
+		.ops = &cv1835_adau1372_ops,
+		.init = cv1835_adau1372_codec_init,
+	},
+#if defined(CONFIG_SND_SOC_CV1835_CONCURRENT_I2S)
+	{
+		.ops = &cv1835_adau1372_ops,
+		.init = cv1835_adau1372_codec_init,
+	},
+#endif
+};
+
+
+static struct snd_soc_card cv1835_adau1372 = {
+	.owner = THIS_MODULE,
+	.dai_link = cv1835_adau1372_dai,
+	.num_links = ARRAY_SIZE(cv1835_adau1372_dai),
+
+	.dapm_widgets		= cv1835_adau1372_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(cv1835_adau1372_dapm_widgets),
+	.dapm_routes		= cv1835_adau1372_dapm_routes,
+	.num_dapm_routes	= ARRAY_SIZE(cv1835_adau1372_dapm_routes),
+};
+
+static const struct of_device_id cvi_audio_match_ids[] = {
+	{
+		.compatible = "cvitek,cv1835-adau1372",
+		//.data = (void *) &cv1835_adau1372_dai,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, cvi_audio_match_ids);
+
+
+
+static int cv1835_adau1372_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card;
+	struct device_node *np = pdev->dev.of_node, *dai;
+	const char *mode;
+	const char *fmt;
+	const char *role;
+	u8 idx = 0;
+	u32	slot_no;
+
+	dev_info(&pdev->dev, "%s, dev name=%s\n", __func__, dev_name(&pdev->dev));
+
+	card = &cv1835_adau1372;
+
+	if (np) {
+
+		of_property_read_string(np, "cvi,card_name", &card->name);
+		of_property_read_u32(np, "cvi,slot_no", &slot_no);
+		of_property_read_string(np, "cvi,mode", &mode);
+		of_property_read_string(np, "cvi,fmt", &fmt);
+
+		for_each_child_of_node(np, dai) {
+			of_property_read_string(dai, "cvi,dai_name", &card->dai_link[idx].name);
+			of_property_read_string(dai, "cvi,stream_name", &card->dai_link[idx].stream_name);
+			of_property_read_string(dai, "cvi,cpu_dai_name", &card->dai_link[idx].cpu_dai_name);
+
+			of_property_read_string(dai, "cvi,codec_dai_name", &card->dai_link[idx].codec_dai_name);
+			of_property_read_string(dai, "cvi,platform_name", &card->dai_link[idx].platform_name);
+			of_property_read_string(dai, "cvi,codec_name", &card->dai_link[idx].codec_name);
+
+			card->dev = &pdev->dev;
+
+			of_property_read_string(dai, "cvi,role", &role);
+
+			if (!strcmp(mode, "I2S"))
+				card->dai_link[idx].dai_fmt = SND_SOC_DAIFMT_I2S;
+			else if (!strcmp(mode, "LEFT_J"))
+				card->dai_link[idx].dai_fmt = SND_SOC_DAIFMT_LEFT_J;
+			else if (!strcmp(mode, "RIGHT_J"))
+				card->dai_link[idx].dai_fmt = SND_SOC_DAIFMT_RIGHT_J;
+			else if (!strcmp(mode, "DSP_A"))
+				card->dai_link[idx].dai_fmt = SND_SOC_DAIFMT_DSP_A; /* PCM and TDM belong to it */
+			else if (!strcmp(mode, "DSP_B"))
+				card->dai_link[idx].dai_fmt = SND_SOC_DAIFMT_DSP_B; /* PCM and TDM belong to it */
+			else if (!strcmp(mode, "PDM"))
+				card->dai_link[idx].dai_fmt = SND_SOC_DAIFMT_PDM;
+			else
+				dev_err(&pdev->dev, "%s, not support this mode\n", __func__);
+
+			if ((!strcmp(mode, "I2S")) || (!strcmp(mode, "LEFT_J")) || (!strcmp(mode, "RIGHT_J"))) {
+				if (!strcmp(fmt, "IBNF"))
+					card->dai_link[idx].dai_fmt |= SND_SOC_DAIFMT_IB_NF;
+				else if (!strcmp(fmt, "IBIF"))
+					card->dai_link[idx].dai_fmt |= SND_SOC_DAIFMT_IB_IF;
+				else if (!strcmp(fmt, "NBNF"))
+					card->dai_link[idx].dai_fmt |= SND_SOC_DAIFMT_NB_NF;
+				else if (!strcmp(fmt, "NBIF"))
+					card->dai_link[idx].dai_fmt |= SND_SOC_DAIFMT_NB_IF;
+				else
+					dev_err(&pdev->dev, "%s, not support this sample format\n", __func__);
+			} else
+				card->dai_link[idx].dai_fmt |= SND_SOC_DAIFMT_NB_IF;
+			/* DSP_A, DSP_B and PDM(TDM) use NB_IF format */
+
+			if (!strcmp(role, "master"))
+				card->dai_link[idx].dai_fmt |= SND_SOC_DAIFMT_CBS_CFS;
+			else if (!strcmp(role, "slave"))
+				card->dai_link[idx].dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;
+			else
+				dev_err(&pdev->dev, "%s, not support this role\n", __func__);
+
+
+			if (!strcmp(mode, "PDM"))
+				tdm_slot_no = slot_no; /* tdm_slot_no is only valid when mode is TDM/PDM */
+			else if (slot_no != 2)
+				dev_err(&pdev->dev, "Wrong solt number setting in %s mode\n", mode);
+
+			dev_info(&pdev->dev, "%s, set DAI fmt to 0x%08x\n", __func__, card->dai_link[idx].dai_fmt);
+			idx++;
+		}
+
+		platform_set_drvdata(pdev, card);
+		return devm_snd_soc_register_card(&pdev->dev, card);
+	}
+	return 0;
+
+}
+
+static struct platform_driver cv1835_adau1372_driver = {
+	.driver = {
+		.name = "cv1835-adau1372",
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = cvi_audio_match_ids,
+	},
+	.probe = cv1835_adau1372_probe,
+};
+
+module_platform_driver(cv1835_adau1372_driver);
+
+MODULE_AUTHOR("EthanChen");
+MODULE_DESCRIPTION("ALSA SoC cv1835 adau1372 driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:cv1835-adau1372");
diff --git a/sound/soc/cvitek/cv1835_cv1835adc.c b/sound/soc/cvitek/cv1835_cv1835adc.c
new file mode 100644
index 000000000000..66cf5294fb4d
--- /dev/null
+++ b/sound/soc/cvitek/cv1835_cv1835adc.c
@@ -0,0 +1,197 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Machine driver for CVITEK ADC on CVITEK CV1835
+ *
+ * Copyright 2019 CVITEK
+ *
+ * Author: EthanChen
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <linux/io.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+#include "../codecs/cv1835adc.h"
+
+bool proc_ai_not_allocted = true;
+
+static int cv1835_adc_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	return 0;
+}
+
+static int cv1835_adc_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+	return 0;
+}
+static struct snd_soc_ops cv1835_adc_ops = {
+	.hw_params = cv1835_adc_hw_params,
+};
+
+static struct snd_soc_dai_link cv1835_adc_dai = {
+	.name = "cv1835-i2s-adc",
+	.stream_name = "cv1835-adc",
+	.cpu_dai_name = "4100000.i2s",
+	.codec_dai_name = "cv1835adc",
+	.platform_name = "4100000.i2s",
+	.codec_name = "300a000.adc",
+	.ops = &cv1835_adc_ops,
+	.init = cv1835_adc_codec_init,
+	.dai_fmt = SND_SOC_DAIFMT_LEFT_J
+	| SND_SOC_DAIFMT_NB_IF
+	| SND_SOC_DAIFMT_CBM_CFM,
+};
+
+
+static struct snd_soc_card cv1835_adc = {
+	.owner = THIS_MODULE,
+	.dai_link = &cv1835_adc_dai,
+	.num_links = 1,
+
+};
+
+
+static const struct of_device_id cvi_audio_match_ids[] = {
+	{
+		.compatible = "cvitek,cv1835-adc",
+		//.data = (void *) &cv1835_adc_dai,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, cvi_audio_match_ids);
+
+static int cv183x_adc_proc_show(struct seq_file *m, void *v)
+{
+	void __iomem *i2s0;
+	void __iomem *adc;
+	void __iomem *audio_pll;
+	void __iomem *sdma_pll;
+	u32 audio_freq;
+	u32 val1, val2, val3;
+
+	i2s0 = ioremap(0x04100000, 0x100);
+	adc = ioremap(0x0300A000, 0x100);
+	audio_pll = ioremap(0x3002854, 0x10);
+	sdma_pll = ioremap(0x3002004, 0x10);
+	if (readl(audio_pll) == 0x179EDCFA)
+		audio_freq = 22579200;
+	else
+		audio_freq = 24576000;
+
+
+	seq_puts(m, "\n------------- CVI AI ATTRIBUTE -------------\n");
+	seq_puts(m, "AiDev    Workmode    SampleRate    BitWidth\n");
+	val1 = (readl(i2s0) >> 1) & 0x1;
+	val2 = audio_freq / ((readl(i2s0 + 0x64) >> 16) * ((readl(i2s0 + 0x4) & 0x000001ff) + 1));
+	val3 = ((readl(i2s0 + 0x10) >> 1) & 0x3) * 16;
+	seq_printf(m, "  %d       %s        %6d        %2d\n", 0, val1 == 0 ? "slave" : "master", val2, val3);
+	seq_puts(m, "\n");
+	seq_puts(m, "-------------  CVI AI STATUS   -------------\n");
+
+	val1 = (readl(i2s0 + 0x18));
+	seq_printf(m, "I2S0 is %s\n", val1 == 1 ? "on" : "off");
+	seq_puts(m, "\n");
+	val1 = (readl(sdma_pll) & 0x00000002) >> 1;
+	seq_printf(m, "SDMA clk is %s\n", val1 == 1 ? "on" : "off");
+	seq_puts(m, "\n");
+
+	val1 = (readl(adc + 0x4) & 0x00000004) >> 2;
+	val2 = (readl(adc + 0x4) & 0x00000008) >> 3;
+	seq_puts(m, "L-Power       R-Power\n");
+	seq_printf(m, "  %s          %s\n", val1 == 1 ? "on" : "off",
+		   val2 == 1 ? "on" : "off");
+	seq_puts(m, "\n");
+
+	val1 = (readl(adc) & 0x07000000) >> 24;
+	val2 = (readl(adc) & 0x00070000) >> 16;
+	seq_puts(m, "L-Mute   R-Mute      L-Vol           R-Vol\n");
+	seq_printf(m, "  %s       %s          %d              %d\n", val1 == 7 ? "yes" : "no", val2 == 7 ? "yes" : "no",
+		   (7 - val1), (7 - val2));
+	seq_puts(m, "\n");
+
+	val1 = (readl(adc + 0x4) & 0x00000080) >> 7;
+	val2 = (readl(adc + 0x4) & 0x00000040) >> 6;
+	val3 = (readl(adc + 0x20) & 0x00000001);
+	seq_puts(m, "L-HighPass       R-HighPass    AGC\n");
+	seq_printf(m, "  %s          %s       %s\n", val1 == 1 ? "enable" : "disable",
+		   val2 == 1 ? "enable" : "disable", val3 == 1 ? "enable" : "disable");
+	seq_puts(m, "\n");
+
+	iounmap(i2s0);
+	iounmap(adc);
+	iounmap(audio_pll);
+	iounmap(sdma_pll);
+	return 0;
+}
+
+static int seq_cv183x_adc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, cv183x_adc_proc_show, PDE_DATA(inode));
+}
+static const struct file_operations cv183x_adc_proc_ops = {
+	.owner  = THIS_MODULE,
+	.open = seq_cv183x_adc_open,
+	.read = seq_read,
+	.release = single_release,
+};
+
+static int cv1835_adc_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card;
+	struct device_node *np = pdev->dev.of_node;
+	struct proc_dir_entry *proc_ai;
+
+
+	dev_dbg(&pdev->dev, "%s, dev name=%s\n", __func__, dev_name(&pdev->dev));
+
+	card = &cv1835_adc;
+
+	if (np) {
+
+		of_property_read_string(np, "cvi,card_name", &card->name);
+		card->dev = &pdev->dev;
+
+		if (!proc_audio_dir) {
+			proc_audio_dir = proc_mkdir("audio_debug", NULL);
+			if (!proc_audio_dir)
+				dev_err(&pdev->dev, "Error creating audio_debug proc folder entry\n");
+		}
+
+		if (proc_audio_dir && (proc_ai_not_allocted == true)) {
+			proc_ai = proc_create_data("cv183x_adc", 0444, proc_audio_dir, &cv183x_adc_proc_ops, np);
+			if (!proc_ai)
+				dev_err(&pdev->dev, "Create cv183x_adc proc failed!\n");
+			else
+				proc_ai_not_allocted = false;
+		}
+
+		platform_set_drvdata(pdev, card);
+		return devm_snd_soc_register_card(&pdev->dev, card);
+	}
+	return 0;
+
+}
+
+static struct platform_driver cv1835_adc_driver = {
+	.driver = {
+		.name = "cv1835-adc",
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = cvi_audio_match_ids,
+	},
+	.probe = cv1835_adc_probe,
+};
+
+module_platform_driver(cv1835_adc_driver);
+
+MODULE_AUTHOR("EthanChen");
+MODULE_DESCRIPTION("ALSA SoC cv1835 adc driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:cv1835-adc");
diff --git a/sound/soc/cvitek/cv1835_cv1835dac.c b/sound/soc/cvitek/cv1835_cv1835dac.c
new file mode 100644
index 000000000000..48e331685159
--- /dev/null
+++ b/sound/soc/cvitek/cv1835_cv1835dac.c
@@ -0,0 +1,186 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Machine driver for CVITEK DAC on CVITEK CV1835
+ *
+ * Copyright 2019 CVITEK
+ *
+ * Author: EthanChen
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <linux/io.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+#include "../codecs/cv1835dac.h"
+
+bool proc_ao_not_allocted = true;
+
+static int cv1835_dac_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	return 0;
+}
+
+static int cv1835_dac_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+	return 0;
+}
+static struct snd_soc_ops cv1835_dac_ops = {
+	.hw_params = cv1835_dac_hw_params,
+};
+
+static struct snd_soc_dai_link cv1835_dac_dai = {
+	.name = "cv1835-i2s-dac",
+	.stream_name = "cv1835-dac",
+	.cpu_dai_name = "4130000.i2s",
+	.codec_dai_name = "cv1835dac",
+	.platform_name = "4130000.i2s",
+	.codec_name = "300a400.dac",
+	.ops = &cv1835_dac_ops,
+	.init = cv1835_dac_codec_init,
+	.dai_fmt = SND_SOC_DAIFMT_I2S
+	| SND_SOC_DAIFMT_IB_NF
+	| SND_SOC_DAIFMT_CBS_CFS,
+};
+
+
+static struct snd_soc_card cv1835_dac = {
+	.owner = THIS_MODULE,
+	.dai_link = &cv1835_dac_dai,
+	.num_links = 1,
+
+};
+
+
+static int cv183x_dac_proc_show(struct seq_file *m, void *v)
+{
+
+	void __iomem *i2s3;
+	void __iomem *dac;
+	void __iomem *audio_pll;
+	void __iomem *sdma_pll;
+	u32 audio_freq;
+	u32 val1, val2, val3;
+
+	i2s3 = ioremap(0x04130000, 0x100);
+	dac = ioremap(0x0300A400, 0x100);
+	audio_pll = ioremap(0x3002854, 0x10);
+	sdma_pll = ioremap(0x3002004, 0x10);
+	if (readl(audio_pll) == 0x179EDCFA)
+		audio_freq = 22579200;
+	else
+		audio_freq = 24576000;
+
+
+	seq_puts(m, "\n------------- CVI AO ATTRIBUTE -------------\n");
+	seq_puts(m, "AiDev    Workmode    SampleRate    BitWidth\n");
+	val1 = (readl(i2s3) >> 1) & 0x1;
+	val2 = audio_freq / ((readl(i2s3 + 0x64) >> 16) * ((readl(i2s3 + 0x4) & 0x000001ff) + 1));
+	val3 = ((readl(i2s3 + 0x10) >> 1) & 0x3) * 16;
+	seq_printf(m, "  %d       %s        %6d        %2d\n", 1, val1 == 0 ? "slave" : "master", val2, val3);
+	seq_puts(m, "\n");
+	seq_puts(m, "-------------  CVI AO STATUS   -------------\n");
+	val1 = (readl(i2s3 + 0x18));
+	seq_printf(m, "I2S3 is %s\n", val1 == 1 ? "on" : "off");
+	seq_puts(m, "\n");
+
+	val1 = (readl(sdma_pll) & 0x00000002) >> 1;
+	seq_printf(m, "SDMA clk is %s\n", val1 == 1 ? "on" : "off");
+
+	val1 = (readl(dac + 0x4) & 0x2) >> 1;
+	val2 = (readl(dac + 0x4) & 0x1);
+	val3 = (readl(dac + 0x4) & 0x0000f000) >> 12;
+	seq_puts(m, "L-Mute   R-Mute      L-Vol           R-Vol\n");
+	seq_printf(m, "  %s       %s        %d              %d\n", val1 == 1 ? "yes" : "no", val2 == 1 ? "yes" : "no",
+		   (15 - val3), (15 - val3));
+	seq_puts(m, "\n");
+	val1 = (readl(dac + 0x4) & 0x00000008) >> 3;
+	seq_puts(m, "De-emphasis\n");
+	seq_printf(m, "  %s\n", val1 == 0 ? "enable" : "disable");
+	seq_puts(m, "\n");
+
+	iounmap(i2s3);
+	iounmap(dac);
+	iounmap(audio_pll);
+	iounmap(sdma_pll);
+	return 0;
+}
+
+static int seq_cv183x_dac_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, cv183x_dac_proc_show, PDE_DATA(inode));
+}
+static const struct file_operations cv183x_dac_proc_ops = {
+	.owner  = THIS_MODULE,
+	.open = seq_cv183x_dac_open,
+	.read = seq_read,
+	.release = single_release,
+};
+
+static const struct of_device_id cvi_audio_match_ids[] = {
+	{
+		.compatible = "cvitek,cv1835-dac",
+		//.data = (void *) &cv1835_dac_dai,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, cvi_audio_match_ids);
+
+static int cv1835_dac_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card;
+	struct device_node *np = pdev->dev.of_node;
+	struct proc_dir_entry *proc_ao;
+
+	dev_dbg(&pdev->dev, "%s, dev name=%s\n", __func__, dev_name(&pdev->dev));
+
+	/* Ethan add, set pinmux by hard code temporary */
+	card = &cv1835_dac;
+
+	if (np) {
+
+		of_property_read_string(np, "cvi,card_name", &card->name);
+		card->dev = &pdev->dev;
+
+		if (!proc_audio_dir) {
+			proc_audio_dir = proc_mkdir("audio_debug", NULL);
+			if (!proc_audio_dir)
+				dev_err(&pdev->dev, "Error creating audio_debug proc folder entry\n");
+		}
+
+		if (proc_audio_dir && (proc_ao_not_allocted == true)) {
+			proc_ao = proc_create_data("cv183x_dac", 0444, proc_audio_dir, &cv183x_dac_proc_ops, np);
+			if (!proc_ao)
+				dev_err(&pdev->dev, "Create cv183x_dac proc failed!\n");
+			proc_ao_not_allocted = false;
+		}
+
+		platform_set_drvdata(pdev, card);
+		return devm_snd_soc_register_card(&pdev->dev, card);
+	}
+	return 0;
+
+}
+
+static struct platform_driver cv1835_dac_driver = {
+	.driver = {
+		.name = "cv1835-dac",
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = cvi_audio_match_ids,
+	},
+	.probe = cv1835_dac_probe,
+};
+
+module_platform_driver(cv1835_dac_driver);
+
+MODULE_AUTHOR("EthanChen");
+MODULE_DESCRIPTION("ALSA SoC cv1835 dac driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:cv1835-dac");
diff --git a/sound/soc/cvitek/cv1835_cv1835pdm.c b/sound/soc/cvitek/cv1835_cv1835pdm.c
new file mode 100644
index 000000000000..dec0d6bb9c56
--- /dev/null
+++ b/sound/soc/cvitek/cv1835_cv1835pdm.c
@@ -0,0 +1,100 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Machine driver for CVITEK PDM on CVITEK CV1835
+ *
+ * Copyright 2019 CVITEK
+ *
+ * Author: EthanChen
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <linux/io.h>
+#include "cv1835pdm.h"
+
+static int cv1835_pdm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	return 0;
+}
+
+static int cv1835_pdm_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+	return 0;
+}
+static struct snd_soc_ops cv1835_pdm_ops = {
+	.hw_params = cv1835_pdm_hw_params,
+};
+
+static struct snd_soc_dai_link cv1835_pdm_dai = {
+	.name = "cv1835-i2s-1",
+	.stream_name = "cv1835-pdm",
+	.cpu_dai_name = "4110000.i2s",
+	.codec_dai_name = "cv1835pdm",
+	.platform_name = "4110000.i2s",
+	.codec_name = "41d0c00.pdm",
+	.ops = &cv1835_pdm_ops,
+	.init = cv1835_pdm_codec_init,
+	.dai_fmt = SND_SOC_DAIFMT_I2S
+	| SND_SOC_DAIFMT_IB_NF
+	| SND_SOC_DAIFMT_CBM_CFM,
+};
+
+
+static struct snd_soc_card cv1835_pdm = {
+	.owner = THIS_MODULE,
+	.dai_link = &cv1835_pdm_dai,
+	.num_links = 1,
+
+};
+
+
+static const struct of_device_id cvi_audio_match_ids[] = {
+	{
+		.compatible = "cvitek,cv1835-pdm",
+		//.data = (void *) &cv1835_pdm_dai,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, cvi_audio_match_ids);
+
+static int cv1835_pdm_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card;
+	struct device_node *np = pdev->dev.of_node;
+
+	dev_info(&pdev->dev, "%s, dev name=%s\n", __func__, dev_name(&pdev->dev));
+
+	card = &cv1835_pdm;
+
+	if (np) {
+
+		of_property_read_string(np, "cvi,card_name", &card->name);
+		card->dev = &pdev->dev;
+		platform_set_drvdata(pdev, card);
+		return devm_snd_soc_register_card(&pdev->dev, card);
+	}
+	return 0;
+
+}
+
+static struct platform_driver cv1835_pdm_driver = {
+	.driver = {
+		.name = "cv1835-pdm",
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = cvi_audio_match_ids,
+	},
+	.probe = cv1835_pdm_probe,
+};
+
+module_platform_driver(cv1835_pdm_driver);
+
+MODULE_AUTHOR("EthanChen");
+MODULE_DESCRIPTION("ALSA SoC cv1835 pdm driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:cv1835-pdm");
diff --git a/sound/soc/cvitek/cv1835_dummy_codec.c b/sound/soc/cvitek/cv1835_dummy_codec.c
new file mode 100644
index 000000000000..8a32b5e7b2b1
--- /dev/null
+++ b/sound/soc/cvitek/cv1835_dummy_codec.c
@@ -0,0 +1,160 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Audio Dummy driver on CVITEK CV1835
+ *
+ * Copyright 2021 CVITEK
+ *
+ * Author: RuiLong
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+
+u16 tdm_slot_no2 = 2;
+
+static int cv1835_dummy_hw_params(struct snd_pcm_substream *substream,
+				  struct snd_pcm_hw_params *params)
+{
+	return 0;
+}
+
+static struct snd_soc_ops cv1835_dummy_ops = {
+	.hw_params = cv1835_dummy_hw_params,
+};
+
+static struct snd_soc_dai_link cv1835_dummy_dai[] = {
+	{
+		.ops = &cv1835_dummy_ops,
+	},
+#if defined(CONFIG_SND_SOC_CV1835_CONCURRENT_I2S)
+	{
+		.ops = &cv1835_dummy_ops,
+	},
+#endif
+};
+
+static struct snd_soc_card cv1835_dummy = {
+	.owner = THIS_MODULE,
+	.dai_link = cv1835_dummy_dai,
+	.num_links = ARRAY_SIZE(cv1835_dummy_dai),
+};
+
+static const struct of_device_id cvi_dummy_match_ids[] = {
+	{
+		.compatible = "cvitek,cv1835-dummy-card",
+	},
+};
+MODULE_DEVICE_TABLE(of, cvi_dummy_match_ids);
+
+
+
+static int cv1835_dummy_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card;
+	struct device_node *np = pdev->dev.of_node, *dai;
+	const char *mode;
+	const char *fmt;
+	const char *role;
+	u8 idx = 0;
+	u32	slot_no;
+
+	dev_info(&pdev->dev, "%s dev name=%s\n",  __func__, dev_name(&pdev->dev));
+	card = &cv1835_dummy;
+
+	if (np) {
+
+		of_property_read_string(np, "cvi,card_name", &card->name);
+		of_property_read_u32(np, "cvi,slot_no", &slot_no);
+		of_property_read_string(np, "cvi,mode", &mode);
+		of_property_read_string(np, "cvi,fmt", &fmt);
+
+		for_each_child_of_node(np, dai) {
+			of_property_read_string(dai, "cvi,dai_name", &card->dai_link[idx].name);
+			of_property_read_string(dai, "cvi,stream_name", &card->dai_link[idx].stream_name);
+			of_property_read_string(dai, "cvi,cpu_dai_name", &card->dai_link[idx].cpu_dai_name);
+
+			of_property_read_string(dai, "cvi,codec_dai_name", &card->dai_link[idx].codec_dai_name);
+			of_property_read_string(dai, "cvi,platform_name", &card->dai_link[idx].platform_name);
+			of_property_read_string(dai, "cvi,codec_name", &card->dai_link[idx].codec_name);
+
+			card->dev = &pdev->dev;
+
+			of_property_read_string(dai, "cvi,role", &role);
+
+			if (!strcmp(mode, "I2S"))
+				card->dai_link[idx].dai_fmt = SND_SOC_DAIFMT_I2S;
+			else if (!strcmp(mode, "LEFT_J"))
+				card->dai_link[idx].dai_fmt = SND_SOC_DAIFMT_LEFT_J;
+			else if (!strcmp(mode, "RIGHT_J"))
+				card->dai_link[idx].dai_fmt = SND_SOC_DAIFMT_RIGHT_J;
+			else if (!strcmp(mode, "DSP_A"))
+				card->dai_link[idx].dai_fmt = SND_SOC_DAIFMT_DSP_A; /* PCM and TDM belong to it */
+			else if (!strcmp(mode, "DSP_B"))
+				card->dai_link[idx].dai_fmt = SND_SOC_DAIFMT_DSP_B; /* PCM and TDM belong to it */
+			else if (!strcmp(mode, "PDM"))
+				card->dai_link[idx].dai_fmt = SND_SOC_DAIFMT_PDM;
+			else
+				dev_err(&pdev->dev, "%s, not support this mode\n", __func__);
+
+			if ((!strcmp(mode, "I2S")) || (!strcmp(mode, "LEFT_J")) || (!strcmp(mode, "RIGHT_J"))) {
+				if (!strcmp(fmt, "IBNF"))
+					card->dai_link[idx].dai_fmt |= SND_SOC_DAIFMT_IB_NF;
+				else if (!strcmp(fmt, "IBIF"))
+					card->dai_link[idx].dai_fmt |= SND_SOC_DAIFMT_IB_IF;
+				else if (!strcmp(fmt, "NBNF"))
+					card->dai_link[idx].dai_fmt |= SND_SOC_DAIFMT_NB_NF;
+				else if (!strcmp(fmt, "NBIF"))
+					card->dai_link[idx].dai_fmt |= SND_SOC_DAIFMT_NB_IF;
+				else
+					dev_err(&pdev->dev, "%s, not support this sample format\n", __func__);
+			} else
+				card->dai_link[idx].dai_fmt |= SND_SOC_DAIFMT_NB_IF;
+			/* DSP_A, DSP_B and PDM(TDM) use NB_IF format */
+
+			if (!strcmp(role, "master"))
+				card->dai_link[idx].dai_fmt |= SND_SOC_DAIFMT_CBS_CFS;
+			else if (!strcmp(role, "slave"))
+				card->dai_link[idx].dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;
+			else
+				dev_err(&pdev->dev, "%s, not support this role\n", __func__);
+
+
+			if (!strcmp(mode, "PDM"))
+				tdm_slot_no2 = slot_no; /* tdm_slot_no is only valid when mode is TDM/PDM */
+			else if (slot_no != 2)
+				dev_err(&pdev->dev, "Wrong solt number setting in %s mode\n", mode);
+
+			dev_info(&pdev->dev, "%s, set DAI fmt to 0x%08x\n", __func__, card->dai_link[idx].dai_fmt);
+			idx++;
+		}
+
+		platform_set_drvdata(pdev, card);
+		return devm_snd_soc_register_card(&pdev->dev, card);
+	}
+	return 0;
+
+}
+
+static struct platform_driver cv1835_dummy_driver = {
+	.driver = {
+		.name = "cv1835-dummy",
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = cvi_dummy_match_ids,
+	},
+	.probe = cv1835_dummy_probe,
+};
+
+module_platform_driver(cv1835_dummy_driver);
+
+MODULE_AUTHOR("RuiLong.Chen <ruilong.chen@cvitek.com>");
+MODULE_DESCRIPTION("ALSA SoC cv1835 dummy driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:cv1835-dummy");
+
diff --git a/sound/soc/cvitek/cv1835_i2s.c b/sound/soc/cvitek/cv1835_i2s.c
new file mode 100644
index 000000000000..09bd0dc833ad
--- /dev/null
+++ b/sound/soc/cvitek/cv1835_i2s.c
@@ -0,0 +1,1353 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * I2S driver on CVITEK CV1835
+ *
+ * Copyright 2018 CVITEK
+ *
+ * Author: EthanChen
+ *
+ */
+
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/pm_runtime.h>
+#include <sound/cv1835_i2s.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+#include "local.h"
+#include "cv1835_i2s_subsys.h"
+#include <linux/version.h>
+
+struct proc_dir_entry *proc_audio_dir;
+static int cvi_i2s_suspend(struct snd_soc_dai *dai);
+static int cvi_i2s_resume(struct snd_soc_dai *dai);
+
+static inline void i2s_write_reg(void __iomem *io_base, int reg, u32 val)
+{
+	writel(val, io_base + reg);
+}
+
+static inline u32 i2s_read_reg(void __iomem *io_base, int reg)
+{
+	return readl(io_base + reg);
+}
+
+static inline void i2s_clear_irqs(struct cvi_i2s_dev *dev, u32 stream)
+{
+	u32 irq = i2s_read_reg(dev->i2s_base, I2S_INT);
+
+	/* I2S_INT is write 1 clear */
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		i2s_write_reg(dev->i2s_base, I2S_INT,
+			      irq & (I2S_INT_TXDA | I2S_INT_TXFO | I2S_INT_TXFU
+				     | I2S_INT_TXDA_RAW | I2S_INT_TXFO_RAW | I2S_INT_TXFU_RAW));
+	else
+		i2s_write_reg(dev->i2s_base, I2S_INT,
+			      irq & (I2S_INT_RXDA | I2S_INT_RXFO | I2S_INT_RXFU
+				     | I2S_INT_RXDA_RAW | I2S_INT_RXFO_RAW | I2S_INT_RXFU_RAW));
+}
+
+static inline void i2s_disable_irqs(struct cvi_i2s_dev *dev, u32 stream)
+{
+	u32 irq = i2s_read_reg(dev->i2s_base, I2S_INT_EN);
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		i2s_write_reg(dev->i2s_base, I2S_INT_EN, irq & ~(I2S_INT_TXDA | I2S_INT_TXFO | I2S_INT_TXFU));
+	else
+		i2s_write_reg(dev->i2s_base, I2S_INT_EN, irq & ~(I2S_INT_RXDA | I2S_INT_RXFO | I2S_INT_RXFU));
+}
+
+static inline void i2s_enable_irqs(struct cvi_i2s_dev *dev, u32 stream)
+{
+	u32 irq = i2s_read_reg(dev->i2s_base, I2S_INT_EN);
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		i2s_write_reg(dev->i2s_base, I2S_INT_EN, irq | I2S_INT_TXFO | I2S_INT_TXFU);
+	else
+		i2s_write_reg(dev->i2s_base, I2S_INT_EN, irq | I2S_INT_RXFO | I2S_INT_RXFU);
+
+}
+
+static void i2s_fifo_reset(struct cvi_i2s_dev *dev, u32 stream)
+{
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		i2s_write_reg(dev->i2s_base, FIFO_RESET, TX_FIFO_RESET_PULL_UP);
+		i2s_write_reg(dev->i2s_base, FIFO_RESET, TX_FIFO_RESET_PULL_DOWN);
+	} else { /* reset RX*/
+		i2s_write_reg(dev->i2s_base, FIFO_RESET, RX_FIFO_RESET_PULL_UP);
+		i2s_write_reg(dev->i2s_base, FIFO_RESET, RX_FIFO_RESET_PULL_DOWN);
+	}
+}
+
+#define I2S_RETRY_COUNT 30000
+static void i2s_reset(struct cvi_i2s_dev *dev, u32 stream)
+{
+	u32 retry = 0;
+
+	dev_dbg(dev->dev, "blk_mode=0x%08x, clk_ctrl=0x%08x, i2s_enable=0x%08x\n",
+		i2s_read_reg(dev->i2s_base, BLK_MODE_SETTING),
+		i2s_read_reg(dev->i2s_base, I2S_CLK_CTRL0),
+		i2s_read_reg(dev->i2s_base, I2S_ENABLE));
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		i2s_write_reg(dev->i2s_base, I2S_RESET, I2S_RESET_TX_PULL_UP);
+
+		while (!((i2s_read_reg(dev->i2s_base, TX_STATUS) & RESET_TX_SCLK) >> 23)) {
+			if ((retry++) > I2S_RETRY_COUNT)
+				break;
+		}
+
+		if (retry > I2S_RETRY_COUNT)
+			dev_err(dev->dev, "WARNING!!! I2S TX RESET failed\n");
+
+		i2s_write_reg(dev->i2s_base, I2S_RESET, I2S_RESET_TX_PULL_DOWN);
+
+	} else { /* reset RX*/
+		i2s_write_reg(dev->i2s_base, I2S_RESET, I2S_RESET_RX_PULL_UP);
+
+		while (!((i2s_read_reg(dev->i2s_base, RX_STATUS) & RESET_RX_SCLK) >> 23)) {
+			if ((retry++) > I2S_RETRY_COUNT)
+				break;
+		}
+
+		if (retry > I2S_RETRY_COUNT)
+			dev_err(dev->dev, "WARNING!!! I2S RX RESET failed\n");
+
+		i2s_write_reg(dev->i2s_base, I2S_RESET, I2S_RESET_TX_PULL_DOWN);
+	}
+}
+
+static irqreturn_t i2s_irq_handler(int irq, void *dev_id)
+{
+	struct cvi_i2s_dev *dev = dev_id;
+	u32 val = 0;
+
+	val = i2s_read_reg(dev->i2s_base, I2S_INT);
+
+	if (dev->active >= 1) { /* If I2S is really active */
+		if (val & (I2S_INT_RXFO | I2S_INT_RXFU)) {
+			dev_dbg(dev->dev, "WARNING!!! I2S RX FIFO exception occur int_status=0x%x\n", val);
+			i2s_write_reg(dev->i2s_base, I2S_ENABLE, I2S_OFF);
+			i2s_write_reg(dev->i2s_base, I2S_CLK_CTRL0,
+				      (i2s_read_reg(dev->i2s_base, I2S_CLK_CTRL0) | AUD_ENABLE));
+			i2s_fifo_reset(dev, SNDRV_PCM_STREAM_CAPTURE);
+			i2s_reset(dev, SNDRV_PCM_STREAM_CAPTURE);
+			i2s_write_reg(dev->i2s_base, I2S_ENABLE, I2S_ON);
+		} else if (val & (I2S_INT_TXFO | I2S_INT_TXFU)) {
+			dev_dbg(dev->dev, "WARNING!!! I2S TX FIFO exception occur int_status=0x%x\n", val);
+			i2s_write_reg(dev->i2s_base, I2S_ENABLE, I2S_OFF);
+			i2s_write_reg(dev->i2s_base, I2S_CLK_CTRL0,
+				      (i2s_read_reg(dev->i2s_base, I2S_CLK_CTRL0) | AUD_ENABLE));
+			i2s_fifo_reset(dev, SNDRV_PCM_STREAM_PLAYBACK);
+			i2s_reset(dev, SNDRV_PCM_STREAM_PLAYBACK);
+			i2s_write_reg(dev->i2s_base, I2S_ENABLE, I2S_ON);
+		}
+	}
+
+	i2s_clear_irqs(dev, SNDRV_PCM_STREAM_PLAYBACK);
+	i2s_clear_irqs(dev, SNDRV_PCM_STREAM_CAPTURE);
+
+	return IRQ_HANDLED;
+}
+
+static void i2s_start(struct cvi_i2s_dev *dev,
+		      struct snd_pcm_substream *substream)
+{
+
+	u32 i2s_enable = i2s_read_reg(dev->i2s_base, I2S_ENABLE);
+	u32 clk_ctrl = i2s_read_reg(dev->i2s_base, I2S_CLK_CTRL0);
+	u32 blk_mode_setting = i2s_read_reg(dev->i2s_base, BLK_MODE_SETTING);
+
+	if (!strcmp(substream->pcm->card->shortname, "cvi_adc") ||
+		!strcmp(substream->pcm->card->shortname, "cv182x_adc") ||
+		!strcmp(substream->pcm->card->shortname, "cv182xa_adc")) {
+		if ((clk_ctrl & AUD_ENABLE) != AUD_ENABLE)
+			i2s_write_reg(dev->i2s_base, I2S_CLK_CTRL0, clk_ctrl | AUD_ENABLE);
+	} else {
+		if (((blk_mode_setting & ROLE_MASK) == MASTER_MODE) && ((clk_ctrl & AUD_ENABLE) != AUD_ENABLE))
+			i2s_write_reg(dev->i2s_base, I2S_CLK_CTRL0, clk_ctrl | AUD_ENABLE);
+	}
+
+	i2s_fifo_reset(dev, substream->stream);
+
+	i2s_reset(dev, substream->stream);
+	i2s_clear_irqs(dev, substream->stream);
+	i2s_enable_irqs(dev, substream->stream);
+
+	if (i2s_enable == I2S_OFF) {
+		//i2s_subsys_switch(dev->dev_id, I2S_ON);
+		i2s_write_reg(dev->i2s_base, I2S_ENABLE, I2S_ON);
+		udelay(10);
+
+	} else
+		dev_err(dev->dev, "WARNING!!!  I2S SHOULD NOT be in ON state\n");
+
+	dev_dbg(dev->dev,
+		"blk_mode=0x%08x, clk_ctrl=0x%08x, int_en=0x%08x, frame_setting=0x%08x, slot_setting=0x%08x, data_format=0x%08x\n",
+		i2s_read_reg(dev->i2s_base, BLK_MODE_SETTING),
+		i2s_read_reg(dev->i2s_base, I2S_CLK_CTRL0),
+		i2s_read_reg(dev->i2s_base, I2S_INT_EN),
+		i2s_read_reg(dev->i2s_base, FRAME_SETTING),
+		i2s_read_reg(dev->i2s_base, SLOT_SETTING1),
+		i2s_read_reg(dev->i2s_base, DATA_FORMAT));
+}
+
+static void i2s_stop(struct cvi_i2s_dev *dev,
+		     struct snd_pcm_substream *substream)
+{
+	u32 i2s_enable = i2s_read_reg(dev->i2s_base, I2S_ENABLE);
+	/* Don't to disalbe AUD_ENABLE due to external codec still need MCLK to do configuration */
+	/* Don't to disalbe AUD_ENABLE due to external codec still need MCLK to do configuration */
+
+	i2s_disable_irqs(dev, substream->stream);
+
+	if (dev->mclk_out == false) {
+		u32 blk_mode_setting = i2s_read_reg(dev->i2s_base, BLK_MODE_SETTING);
+		u32 clk_ctrl = i2s_read_reg(dev->i2s_base, I2S_CLK_CTRL0);
+
+		if (((blk_mode_setting & ROLE_MASK) == MASTER_MODE) && ((clk_ctrl & AUD_ENABLE) == AUD_ENABLE))	{
+			dev_dbg(dev->dev, "Disable aud_en\n");
+			i2s_write_reg(dev->i2s_base, I2S_CLK_CTRL0, clk_ctrl & ~(AUD_ENABLE));
+		}
+	}
+
+	if (i2s_enable == I2S_ON) {
+		//i2s_subsys_switch(dev->dev_id, I2S_OFF);
+		i2s_write_reg(dev->i2s_base, I2S_ENABLE, I2S_OFF);
+		i2s_fifo_reset(dev, substream->stream);
+	} else
+		dev_err(dev->dev, "WARNING!!! I2S SHOULD NOT be in OFF state\n");
+}
+
+static int cvi_i2s_dai_probe(struct snd_soc_dai *cpu_dai)
+{
+	struct cvi_i2s_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
+
+	dev_dbg(cpu_dai->dev, "%s start *cpu_dai = %p name = %s\n", __func__, cpu_dai, cpu_dai->name);
+	cpu_dai->playback_dma_data = &dev->play_dma_data;
+	cpu_dai->capture_dma_data = &dev->capture_dma_data;
+
+	if (cpu_dai->playback_dma_data == NULL) {
+		dev_err(cpu_dai->dev, "%s playback_dma_data == NULL\n", __func__);
+	}
+
+	if (cpu_dai->capture_dma_data == NULL) {
+		dev_err(cpu_dai->dev, "%s capture_dma_data == NULL\n", __func__);
+	}
+
+	dev_dbg(cpu_dai->dev, "%s end cpu_dai->playback_dma_data = %p\n", __func__, cpu_dai->playback_dma_data);
+
+	return 0;
+
+}
+
+
+static int cvi_i2s_startup(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *cpu_dai)
+{
+	struct cvi_i2s_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
+	union cvi_i2s_snd_dma_data *dma_data = NULL;
+
+	dev_dbg(dev->dev, "%s start *cpu_dai = %p name = %s\n", __func__, cpu_dai, cpu_dai->name);
+	if (!(dev->capability & CVI_I2S_RECORD) &&
+	    (substream->stream == SNDRV_PCM_STREAM_CAPTURE)) {
+		dev_dbg(dev->dev, "%s return -EINVAL;\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!(dev->capability & CVI_I2S_PLAY) &&
+	    (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)) {
+		dev_dbg(dev->dev, "%s return -EINVAL; 2\n", __func__);
+		return -EINVAL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_data = &dev->play_dma_data;
+	else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		dma_data = &dev->capture_dma_data;
+	if (dma_data == NULL) {
+		dev_dbg(dev->dev, "%s dma_data == NULL\n", __func__);
+	}
+
+	dev_dbg(dev->dev, "%s start *dma_data = %p\n", __func__, dma_data);
+	snd_soc_dai_set_dma_data(cpu_dai, substream, (void *)dma_data);
+	dev_dbg(dev->dev, "%s end cpu_dai->playback_dma_data = %p\n",
+		__func__, cpu_dai->playback_dma_data);
+	return 0;
+}
+
+static void cvi_i2s_config(struct cvi_i2s_dev *dev, int stream)
+{
+	u32 blk_mode_setting = i2s_read_reg(dev->i2s_base, BLK_MODE_SETTING) & ~(DMA_MODE_MASK);
+
+	/* Configure to USE HW DMA*/
+	i2s_write_reg(dev->i2s_base, BLK_MODE_SETTING, blk_mode_setting | HW_DMA_MODE);
+
+	/* Configure FIFO thresholds */
+	i2s_write_reg(dev->i2s_base, FIFO_THRESHOLD,
+		      RX_FIFO_THRESHOLD(7) | TX_FIFO_THRESHOLD(7) | TX_FIFO_HIGH_THRESHOLD(31));
+
+}
+
+static int cvi_i2s_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct cvi_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+	struct i2s_clk_config_data *config = &dev->config;
+	u32 frame_setting = i2s_read_reg(dev->i2s_base, FRAME_SETTING) & ~(FRAME_LENGTH_MASK | FS_ACT_LENGTH_MASK);
+	u32 slot_setting1 = i2s_read_reg(dev->i2s_base, SLOT_SETTING1) & ~(SLOT_SIZE_MASK | DATA_SIZE_MASK);
+	u32 clk_ctrl1 = 0;
+	u32 data_format = i2s_read_reg(dev->i2s_base, DATA_FORMAT) & ~(WORD_LENGTH_MASK | SKIP_TX_INACT_SLOT_MASK);
+	u32 audio_clk = 0;
+	u32 mclk_div = 0;
+	u32 bclk_div = 0;
+
+	config->chan_nr = params_channels(params);
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+	case SNDRV_PCM_FORMAT_U16_LE:
+		config->data_size = 16;
+		dev->wss = WSS_16_CLKCYCLE;
+		switch (dev->mode) {
+		case SND_SOC_DAIFMT_I2S:
+		case SND_SOC_DAIFMT_RIGHT_J:
+		case SND_SOC_DAIFMT_LEFT_J:
+		case SND_SOC_DAIFMT_PDM:
+			if (!strcmp(substream->pcm->card->shortname, "cvi_dac")) {
+				frame_setting |= FRAME_LENGTH(64) | FS_ACT_LENGTH(32);
+				dev->wss = WSS_32_CLKCYCLE;
+			} else if (!strcmp(substream->pcm->card->shortname, "cv182x_adc") ||
+				!strcmp(substream->pcm->card->shortname, "cv182x_dac") ||
+				!strcmp(substream->pcm->card->shortname, "cv182xa_adc") ||
+				!strcmp(substream->pcm->card->shortname, "cv182xa_dac")) {
+				if (!strcmp(substream->pcm->card->shortname, "cv182x_dac") ||
+					!strcmp(substream->pcm->card->shortname, "cv182xa_dac")) {
+					/* For cv182x and cv182xa DAC codec, while playing with mono audio data,
+					 * need to assume there are 2 channels but skip 1. Thus, need
+					 * to set frame length as 32, slot_num as 2, slot_en as 1 and
+					 * skip tx inactivate slot. I2S will duplucate 16 bits into
+					 * another skiped channel
+					 */
+					switch (config->chan_nr) {
+					case 1:
+						frame_setting |= FRAME_LENGTH(32) | FS_ACT_LENGTH(16);
+						break;
+					case 2:
+					default:
+						frame_setting |= FRAME_LENGTH(16) | FS_ACT_LENGTH(16);
+						break;
+					}
+				} else
+					frame_setting |= FRAME_LENGTH(16) | FS_ACT_LENGTH(16);
+			} else
+				frame_setting |= FRAME_LENGTH(32) | FS_ACT_LENGTH(16);
+
+			break;
+		case SND_SOC_DAIFMT_DSP_A:
+		case SND_SOC_DAIFMT_DSP_B:
+			frame_setting |= FRAME_LENGTH(config->data_size * config->chan_nr) | FS_ACT_LENGTH(1);
+			break;
+		}
+		//i2s_write_reg(dev->i2s_base, SLOT_SETTING1, slot_setting1 | SLOT_SIZE(16) | DATA_SIZE(16));
+		if (!strcmp(substream->pcm->card->shortname, "cvi_dac"))
+			slot_setting1 |= SLOT_SIZE(32) | DATA_SIZE(16);
+		else
+			slot_setting1 |= SLOT_SIZE(16) | DATA_SIZE(16);
+		break;
+
+	case SNDRV_PCM_FORMAT_S24_LE:
+	case SNDRV_PCM_FORMAT_U24_LE:
+	case SNDRV_PCM_FORMAT_S24_3LE:
+	case SNDRV_PCM_FORMAT_U24_3LE:
+		if (!strcmp(substream->pcm->card->shortname, "cv182x_adc") ||
+			!strcmp(substream->pcm->card->shortname, "cv182x_dac") ||
+			!strcmp(substream->pcm->card->shortname, "cv182xa_adc") ||
+			!strcmp(substream->pcm->card->shortname, "cv182xa_dac")) {
+			dev_err(dev->dev, "24 bit resolution is not supported\n");
+			return -EINVAL;
+		}
+
+		config->data_size = 24;
+		dev->wss = WSS_32_CLKCYCLE;
+		switch (dev->mode) {
+		case SND_SOC_DAIFMT_I2S:
+		case SND_SOC_DAIFMT_RIGHT_J:
+		case SND_SOC_DAIFMT_LEFT_J:
+		case SND_SOC_DAIFMT_PDM:
+			frame_setting |= FRAME_LENGTH(64) | FS_ACT_LENGTH(32);
+			break;
+		case SND_SOC_DAIFMT_DSP_A:
+		case SND_SOC_DAIFMT_DSP_B:
+			frame_setting |= FRAME_LENGTH(config->data_size * config->chan_nr) | FS_ACT_LENGTH(1);
+			break;
+		}
+		//i2s_write_reg(dev->i2s_base, SLOT_SETTING1, slot_setting1 | SLOT_SIZE(32) | DATA_SIZE(24));
+		slot_setting1 |= SLOT_SIZE(32) | DATA_SIZE(24);
+		break;
+
+	case SNDRV_PCM_FORMAT_S32_LE:
+	case SNDRV_PCM_FORMAT_U32_LE:
+		if (!strcmp(substream->pcm->card->shortname, "cv182x_adc") ||
+			!strcmp(substream->pcm->card->shortname, "cv182x_dac") ||
+			!strcmp(substream->pcm->card->shortname, "cv182xa_adc") ||
+			!strcmp(substream->pcm->card->shortname, "cv182xa_dac")
+			) {
+			dev_err(dev->dev, "32 bit resolution is not supported\n");
+			return -EINVAL;
+		}
+		config->data_size = 32;
+		dev->wss = WSS_32_CLKCYCLE;
+		switch (dev->mode) {
+		case SND_SOC_DAIFMT_I2S:
+		case SND_SOC_DAIFMT_RIGHT_J:
+		case SND_SOC_DAIFMT_LEFT_J:
+		case SND_SOC_DAIFMT_PDM:
+			frame_setting |= FRAME_LENGTH(64) | FS_ACT_LENGTH(32);
+			break;
+		case SND_SOC_DAIFMT_DSP_A:
+		case SND_SOC_DAIFMT_DSP_B:
+			frame_setting |= FRAME_LENGTH(config->data_size * config->chan_nr) | FS_ACT_LENGTH(1);
+			break;
+		}
+		//i2s_write_reg(dev->i2s_base, SLOT_SETTING1, slot_setting1 | SLOT_SIZE(32) | DATA_SIZE(32));
+		slot_setting1 |= SLOT_SIZE(32) | DATA_SIZE(32);
+		break;
+
+	default:
+		dev_err(dev->dev, "CVI-i2s: unsupported PCM fmt\n");
+		return -EINVAL;
+	}
+	i2s_write_reg(dev->i2s_base, SLOT_SETTING1, slot_setting1);
+	i2s_write_reg(dev->i2s_base, FRAME_SETTING, frame_setting);
+
+#if defined(CONFIG_SND_SOC_CV1835_CONCURRENT_I2S)
+	if ((dev->dev_id != 0) && (dev->dev_id != 3) && (dev->dev_id != i2s_subsys_query_master()))
+		i2s_set_master_frame_setting(frame_setting);
+#endif
+
+	slot_setting1 &= ~SLOT_NUM_MASK;
+	dev_dbg(dev->dev, "CVI-i2s: set slot number=%d\n",	config->chan_nr);
+	switch (config->chan_nr) {
+	case EIGHT_CHANNEL_SUPPORT:
+		slot_setting1 |= SLOT_NUM(8);
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING1, slot_setting1);
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING2, 0xff); /* enable slot 0-7 for TDM */
+		break;
+	case SIX_CHANNEL_SUPPORT:
+		slot_setting1 |= SLOT_NUM(6);
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING1, slot_setting1);
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING2, 0x3f); /* enable slot 0-5 for TDM */
+		break;
+	case FOUR_CHANNEL_SUPPORT:
+		slot_setting1 |= SLOT_NUM(4);
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING1, slot_setting1);
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING2, 0x0f); /* enable slot 0-3 for TDM */
+		break;
+	case TWO_CHANNEL_SUPPORT:
+		slot_setting1 |= SLOT_NUM(2);
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING1, slot_setting1);
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING2, 0x03); /* enable slot 0-1 for TDM */
+		break;
+	case ONE_CHANNEL_SUPPORT:
+		if (!strcmp(substream->pcm->card->shortname, "cv182x_dac") ||
+			!strcmp(substream->pcm->card->shortname, "cv182xa_dac")) {
+			slot_setting1 |= SLOT_NUM(2);
+			data_format |= SKIP_TX_INACT_SLOT;
+		} else
+			slot_setting1 |= SLOT_NUM(1);
+
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING1, slot_setting1);
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING2, 0x01); /* enable slot 0-3 for TDM */
+		break;
+	default:
+		dev_err(dev->dev, "channel not supported\n");
+		return -EINVAL;
+	}
+
+	cvi_i2s_config(dev, substream->stream); /* Config use HW DMA and FIFO threshold here */
+
+	config->sample_rate = params_rate(params);
+	//audio_clk = clk_get_rate(dev->clk);
+	/* set audio_clk depends on audio format */
+	switch (config->sample_rate) {
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+		audio_clk = CVI_22579_MHZ;
+		break;
+	case 8000:
+	case 16000:
+	case 32000:
+		if (!strcmp(substream->pcm->card->shortname, "cv182xa_adc") ||
+			!strcmp(substream->pcm->card->shortname, "cv182xa_dac"))
+			audio_clk = CVI_16384_MHZ;
+		else
+			audio_clk = CVI_24576_MHZ;
+		break;
+	case 12000:
+	case 24000:
+	case 48000:
+	case 96000:
+	case 192000:
+		audio_clk = CVI_24576_MHZ;
+		break;
+	default:
+		dev_err(dev->dev, "Warning!!! this sample rate is not supported\n");
+		return -1;
+	}
+
+	if (strcmp(substream->pcm->card->shortname, "cv182x_adc")) {
+		/* cv182x adc doesnot need to set apll*/
+		dev_info(dev->dev, "Audio system clk=%d, sample rate=%d\n", audio_clk, config->sample_rate);
+		cv1835_set_mclk(audio_clk);
+	}
+
+	if (!strcmp(substream->pcm->card->shortname, "cvi_adc")) {
+		/* cv183x internal adc codec need dynamic MCLK frequency input */
+		int div = 1;
+
+		switch (config->sample_rate) {
+		case 8000:
+		case 11025:
+		case 12000:
+			div = audio_clk / (1024 * config->sample_rate);
+			clk_ctrl1 |= MCLK_DIV(div);
+			break;
+		case 16000:
+		case 22050:
+		case 24000:
+			div = audio_clk / (512 * config->sample_rate);
+			clk_ctrl1 |= MCLK_DIV(div);
+			break;
+		case 32000:
+		case 44100:
+		case 48000:
+			div = audio_clk / (256 * config->sample_rate);
+			clk_ctrl1 |= MCLK_DIV(div);
+			break;
+		}
+	} else if (!strcmp(substream->pcm->card->shortname, "cv182x_adc") ||
+			!strcmp(substream->pcm->card->shortname, "cv182x_dac")) {
+		/* cv182x internal adc codec need dynamic MCLK frequency input */
+
+		dev_info(dev->dev, "%s set MCLK\n", __func__);
+		switch (config->sample_rate) {
+		case 8000:
+			clk_ctrl1 |= MCLK_DIV(6);
+			mclk_div = 6;
+			break;
+		case 11025:
+			clk_ctrl1 |= MCLK_DIV(4);
+			mclk_div = 4;
+			break;
+		case 16000:
+		case 32000:
+			clk_ctrl1 |= MCLK_DIV(3);
+			mclk_div = 3;
+			break;
+		case 22050:
+		case 44100:
+		case 48000:
+			clk_ctrl1 |= MCLK_DIV(2);
+			mclk_div = 2;
+			break;
+		default:
+			dev_err(dev->dev, "%s doesn't support this sample rate\n", __func__);
+			break;
+		}
+	} else if (!strcmp(substream->pcm->card->shortname, "cv182xa_adc") ||
+			!strcmp(substream->pcm->card->shortname, "cv182xa_dac")) {
+		/* cv182xa internal adc codec need dynamic MCLK frequency input */
+
+		switch (config->sample_rate) {
+		case 8000:
+		case 16000:
+		case 32000:
+			/* apll is 16.384Mhz, no need to divide */
+			clk_ctrl1 |= MCLK_DIV(1);
+			mclk_div = 1;
+			break;
+		case 11025:
+		case 22050:
+		case 44100:
+		case 48000:
+			clk_ctrl1 |= MCLK_DIV(2);
+			mclk_div = 2;
+			break;
+		default:
+			dev_err(dev->dev, "%s doesn't support this sample rate\n", __func__);
+			break;
+		}
+	} else {
+		if ((audio_clk == CVI_24576_MHZ) || (audio_clk == CVI_22579_MHZ))
+			clk_ctrl1 |= MCLK_DIV(2);
+		else
+			dev_err(dev->dev, "Get unexpected audio system clk=%d\n", audio_clk);
+	}
+
+	/* Configure I2S word length,  bclk_div and sync_div here*/
+	switch (dev->wss) {
+	case (WSS_32_CLKCYCLE):
+#if defined(CONFIG_ARCH_CV183X_ASIC)
+		bclk_div = (audio_clk / 1000) / (WSS_32_CLKCYCLE * (config->sample_rate / 1000));
+#else
+		bclk_div = (audio_clk / 1000) / (WSS_32_CLKCYCLE * (config->sample_rate / 1000) * mclk_div);
+#endif
+		if (!strcmp(substream->pcm->card->shortname, "cvi_dac")) {
+			switch (config->data_size) {
+			case 32:
+			case 24:
+				data_format |= WORD_LEN_32;
+				break;
+			case 16:
+				data_format |= WORD_LEN_16;
+				break;
+			}
+		} else
+			data_format |= WORD_LEN_32;
+		break;
+	case (WSS_24_CLKCYCLE):
+#if defined(CONFIG_ARCH_CV183X_ASIC)
+		bclk_div = (audio_clk / 1000) / (WSS_32_CLKCYCLE * (config->sample_rate / 1000));
+#else
+		bclk_div = (audio_clk / 1000) / (WSS_32_CLKCYCLE * (config->sample_rate / 1000) * mclk_div);
+#endif
+		data_format |= WORD_LEN_32;
+		break;
+	case (WSS_16_CLKCYCLE):
+#if defined(CONFIG_ARCH_CV183X_ASIC)
+			bclk_div = (audio_clk / 1000) / (WSS_16_CLKCYCLE * (config->sample_rate / 1000));
+#else
+			bclk_div = (audio_clk / 1000) / (WSS_16_CLKCYCLE * (config->sample_rate / 1000) * mclk_div);
+#endif
+		data_format |= WORD_LEN_16;
+		break;
+	default:
+		dev_err(dev->dev, "resolution not supported\n");
+	}
+
+	/* Configure word length */
+	i2s_write_reg(dev->i2s_base, DATA_FORMAT, data_format);
+
+	clk_ctrl1 |= BCLK_DIV(bclk_div);
+	dev_dbg(dev->dev, "Set clock ctrl1=0x%08x\n", clk_ctrl1);
+	i2s_write_reg(dev->i2s_base, I2S_CLK_CTRL1, clk_ctrl1);
+
+#if defined(CONFIG_SND_SOC_CV1835_CONCURRENT_I2S)
+	if ((dev->dev_id != 0) && (dev->dev_id != 3) && (dev->dev_id != i2s_subsys_query_master()))
+		i2s_set_master_clk(clk_ctrl1);
+#endif
+
+	dev_dbg(dev->dev, "frame_setting=0x%08x, slot_setting1=0x%08x, clk_ctrl1=0x%08x, data_format=0x%08x\n",
+		i2s_read_reg(dev->i2s_base, FRAME_SETTING),
+		i2s_read_reg(dev->i2s_base, SLOT_SETTING1),
+		i2s_read_reg(dev->i2s_base, I2S_CLK_CTRL1),
+		i2s_read_reg(dev->i2s_base, DATA_FORMAT));
+
+	return 0;
+}
+
+static void cvi_i2s_shutdown(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *dai)
+{
+	pr_info("%s not start *dai = %p, *dai->playback_dma_data = %p\n", __func__, dai, dai->playback_dma_data);
+	//snd_soc_dai_set_dma_data(dai, substream, NULL);
+}
+
+static int cvi_i2s_prepare(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *dai)
+{
+	struct cvi_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	u32 blk_mode_setting = (i2s_read_reg(dev->i2s_base, BLK_MODE_SETTING) & ~(TXRX_MODE_MASK));
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		blk_mode_setting |= TX_MODE;
+	else
+		blk_mode_setting |= RX_MODE;
+
+	i2s_write_reg(dev->i2s_base, BLK_MODE_SETTING, blk_mode_setting);
+
+	return 0;
+}
+
+static int cvi_i2s_trigger(struct snd_pcm_substream *substream,
+			   int cmd, struct snd_soc_dai *dai)
+{
+	struct cvi_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		snd_pcm_stream_unlock_irq(substream);
+		dev->active++;
+#if defined(CONFIG_SND_SOC_CV1835_CONCURRENT_I2S)
+		if ((dev->dev_id != 0) && (dev->dev_id != 3) && (dev->dev_id != i2s_subsys_query_master())) {
+			dev_dbg(dev->dev, "enable master clk generation\n");
+			i2s_master_clk_switch_on(true);
+		}
+#endif
+
+		cvi_i2s_resume(dai);
+		i2s_start(dev, substream);
+		snd_pcm_stream_lock_irq(substream);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+//		snd_pcm_stream_unlock_irq(substream);
+		dev->active--;
+		i2s_stop(dev, substream);
+#if defined(CONFIG_SND_SOC_CV1835_CONCURRENT_I2S)
+		if ((dev->dev_id != 0) && (dev->dev_id != 3) && (dev->dev_id != i2s_subsys_query_master())) {
+			dev_dbg(dev->dev, "disable master clk generation\n");
+			i2s_master_clk_switch_on(false);
+		}
+#endif
+
+		cvi_i2s_suspend(dai);
+
+//		snd_pcm_stream_lock_irq(substream);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int cvi_i2s_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	struct cvi_i2s_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 blk_mode_setting = i2s_read_reg(dev->i2s_base, BLK_MODE_SETTING) & ~(SAMPLE_EDGE_MASK | ROLE_MASK);
+	u32 frame_setting = i2s_read_reg(dev->i2s_base, FRAME_SETTING) &
+			    ~(FS_POLARITY_MASK | FS_OFFSET_MASK | FS_IDEF_MASK | FS_ACT_LENGTH_MASK);
+	u32 slot_setting1 = i2s_read_reg(dev->i2s_base, SLOT_SETTING1);/* & ~(SLOT_NUM_MASK);*/
+	//int role = MASTER_MODE;
+
+	int ret = 0;
+
+	dev_dbg(dev->dev, "%s, fmt=0x%08x\n", __func__, fmt);
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM: /* Set codec to Master mode, so I2S IP need to be Slave mode */
+		blk_mode_setting |= SLAVE_MODE;
+		dev->role = SLAVE_MODE;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS: /* Set codec to Slave mode, so I2S IP need to be Master mode */
+		blk_mode_setting |= MASTER_MODE;
+		dev->role = MASTER_MODE;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+	case SND_SOC_DAIFMT_CBS_CFM:
+		ret = -EINVAL;
+		break;
+	default:
+		dev_dbg(dev->dev, "cvitek : Invalid master/slave format\n");
+		ret = -EINVAL;
+		break;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		dev->sample_edge = FMT_NB_NF;
+		blk_mode_setting |= RX_SAMPLE_EDGE_N | TX_SAMPLE_EDGE_P | FS_SAMPLE_EDGE_P;
+		frame_setting |= FS_ACT_LOW;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		dev->sample_edge = FMT_NB_IF;
+		blk_mode_setting |= RX_SAMPLE_EDGE_N | TX_SAMPLE_EDGE_P | FS_SAMPLE_EDGE_P;
+		frame_setting |= FS_ACT_HIGH;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		dev->sample_edge = FMT_IB_NF;
+		blk_mode_setting |= RX_SAMPLE_EDGE_P | TX_SAMPLE_EDGE_N | FS_SAMPLE_EDGE_N;
+		frame_setting |= FS_ACT_LOW;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		dev->sample_edge = FMT_IB_IF;
+		blk_mode_setting |= RX_SAMPLE_EDGE_P | TX_SAMPLE_EDGE_N | FS_SAMPLE_EDGE_N;
+		frame_setting |= FS_ACT_HIGH;
+		break;
+	default:
+		dev_dbg(dev->dev, "cvitek : Invalid frame format\n");
+		ret = -EINVAL;
+		break;
+	}
+
+	i2s_write_reg(dev->i2s_base, BLK_MODE_SETTING, blk_mode_setting);
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+	case SND_SOC_DAIFMT_PDM:
+		dev->mode = SND_SOC_DAIFMT_I2S;
+		frame_setting |= FS_OFFSET_1_BIT | FS_IDEF_FRAME_SYNC
+				 | FS_ACT_LENGTH(((frame_setting & FRAME_LENGTH_MASK) + 1) / 2);
+		i2s_write_reg(dev->i2s_base, FRAME_SETTING, frame_setting);
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		dev->mode = SND_SOC_DAIFMT_RIGHT_J;
+		frame_setting |= NO_FS_OFFSET | FS_IDEF_FRAME_SYNC
+				 | FS_ACT_LENGTH(((frame_setting & FRAME_LENGTH_MASK) + 1) / 2);
+		i2s_write_reg(dev->i2s_base, FRAME_SETTING, frame_setting);
+
+		slot_setting1 &= ~(FB_OFFSET_MASK);
+		slot_setting1 |= FB_OFFSET((((frame_setting & FS_ACT_LENGTH_MASK) >> 16)
+					    - ((slot_setting1 & DATA_SIZE_MASK) >> 16)));
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING1, slot_setting1);
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		dev->mode = SND_SOC_DAIFMT_LEFT_J;
+		frame_setting |= NO_FS_OFFSET | FS_IDEF_FRAME_SYNC
+				 | FS_ACT_LENGTH(((frame_setting & FRAME_LENGTH_MASK) + 1) / 2);
+		i2s_write_reg(dev->i2s_base, FRAME_SETTING, frame_setting);
+		break;
+
+	case SND_SOC_DAIFMT_DSP_A:
+		dev->mode = SND_SOC_DAIFMT_DSP_A;
+		frame_setting |= FS_OFFSET_1_BIT | FS_IDEF_FRAME_SYNC | FS_ACT_LENGTH(1);
+		i2s_write_reg(dev->i2s_base, FRAME_SETTING, frame_setting);
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		dev->mode = SND_SOC_DAIFMT_DSP_B;
+		frame_setting |= NO_FS_OFFSET | FS_IDEF_FRAME_SYNC | FS_ACT_LENGTH(1);
+		i2s_write_reg(dev->i2s_base, FRAME_SETTING, frame_setting);
+		break;
+	default:
+		dev_dbg(dev->dev, "cvitek : Invalid I2S mode\n");
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int cvi_i2s_set_tdm_slot(struct snd_soc_dai *cpu_dai, unsigned int tx_mask,
+				unsigned int rx_mask, int slots, int width)
+{
+	struct cvi_i2s_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
+	u32 slot_setting1 = i2s_read_reg(dev->i2s_base, SLOT_SETTING1) & ~(SLOT_NUM_MASK);
+
+	/* Mode other than PDM/TDM mode*/
+	if (slots == 0) {
+		/* The other settings dont matter in I2S mode */
+		return 0;
+	}
+
+	/* We have 16 channels anything outside that is not supported */
+	if ((tx_mask & ~0xffff) != 0 || (rx_mask & ~0xffff) != 0)
+		return -EINVAL;
+
+	switch (width) {
+	case 16:
+		break;
+	case 32:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (slots) {
+	case EIGHT_CHANNEL_SUPPORT:
+		slot_setting1 |= SLOT_NUM(8);
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING1, slot_setting1);
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING2, 0x00ff); /* enable slot 0-7 for TDM */
+		break;
+	case SIX_CHANNEL_SUPPORT:
+		slot_setting1 |= SLOT_NUM(6);
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING1, slot_setting1);
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING2, 0x003f); /* enable slot 0-5 for TDM */
+		break;
+	case FOUR_CHANNEL_SUPPORT:
+		slot_setting1 |= SLOT_NUM(4);
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING1, slot_setting1);
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING2, 0x000f); /* enable slot 0-3 for TDM */
+		break;
+	case TWO_CHANNEL_SUPPORT:
+		slot_setting1 |= SLOT_NUM(2);
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING1, slot_setting1);
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING2, 0x0003); /* enable slot 0-1 for TDM */
+		break;
+	case ONE_CHANNEL_SUPPORT:
+		slot_setting1 |= SLOT_NUM(1);
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING1, slot_setting1);
+		i2s_write_reg(dev->i2s_base, SLOT_SETTING2, 0x0001); /* enable slot 0-3 for TDM */
+		break;
+	default:
+		dev_err(dev->dev, "slot number not supported\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_dai_ops cvi_i2s_dai_ops = {
+	.startup	= cvi_i2s_startup,
+	.shutdown	= cvi_i2s_shutdown,
+	.hw_params	= cvi_i2s_hw_params,
+	.prepare	= cvi_i2s_prepare,
+	.trigger	= cvi_i2s_trigger,
+	.set_fmt	= cvi_i2s_set_fmt,
+	.set_tdm_slot = cvi_i2s_set_tdm_slot,
+};
+
+static const struct snd_soc_component_driver cvi_i2s_component = {
+	.name		= "cvitek-i2s",
+};
+
+#ifdef CONFIG_PM
+static int cvi_i2s_runtime_suspend(struct device *dev)
+{
+	struct cvi_i2s_dev *cvi_dev = dev_get_drvdata(dev);
+
+	if (cvi_dev->capability & CVI_I2S_MASTER)
+		clk_disable(cvi_dev->clk);
+	return 0;
+}
+
+static int cvi_i2s_runtime_resume(struct device *dev)
+{
+	struct cvi_i2s_dev *cvi_dev = dev_get_drvdata(dev);
+
+	if (cvi_dev->capability & CVI_I2S_MASTER)
+		clk_enable(cvi_dev->clk);
+	return 0;
+}
+#endif
+
+static int cvi_i2s_suspend(struct snd_soc_dai *dai)
+{
+	struct cvi_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	if (dev->capability & CVI_I2S_MASTER)
+		clk_disable(dev->clk);
+	return 0;
+}
+
+static int cvi_i2s_resume(struct snd_soc_dai *dai)
+{
+	struct cvi_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	if (dev->capability & CVI_I2S_MASTER)
+		clk_enable(dev->clk);
+
+	return 0;
+}
+
+static int cvi_configure_dai(struct cvi_i2s_dev *dev,
+			     struct snd_soc_dai_driver *cvi_i2s_dai,
+			     unsigned int rates)
+{
+
+	struct device_node *np = dev->dev->of_node;
+	const char *capability;
+
+	if (of_property_read_string(np, "capability", &capability) < 0)
+		return -EINVAL;
+
+
+	if ((!strcmp(capability, "tx")) || (!strcmp(capability, "txrx"))) {
+		dev_dbg(dev->dev, "CV: playback support\n");
+		cvi_i2s_dai->playback.channels_min = 1;
+		cvi_i2s_dai->playback.channels_max = 8;
+		cvi_i2s_dai->playback.formats = SNDRV_PCM_FMTBIT_S32_LE
+						| SNDRV_PCM_FMTBIT_S24_LE
+						| SNDRV_PCM_FORMAT_S24_3LE
+						| SNDRV_PCM_FMTBIT_U24_LE
+						| SNDRV_PCM_FORMAT_U24_3LE
+						| SNDRV_PCM_FMTBIT_S16_LE;
+		cvi_i2s_dai->playback.rates = rates;
+	} else {
+		/* this device doesn't have playback capability */
+		dev_dbg(dev->dev, "CV: playback not support\n");
+		cvi_i2s_dai->playback.channels_min = 0;
+		cvi_i2s_dai->playback.channels_max = 0;
+	}
+
+	if ((!strcmp(capability, "rx")) || (!strcmp(capability, "txrx"))) {
+		dev_dbg(dev->dev, "CV: capature support\n");
+		cvi_i2s_dai->capture.channels_min = 1;
+		cvi_i2s_dai->capture.channels_max = 8;
+		cvi_i2s_dai->capture.formats = SNDRV_PCM_FMTBIT_S32_LE
+					       | SNDRV_PCM_FMTBIT_S24_LE
+					       | SNDRV_PCM_FMTBIT_S16_LE;
+		cvi_i2s_dai->capture.rates = rates;
+	} else {
+		/* this device doesn't have capature capability */
+		dev_dbg(dev->dev, "CV: capature not support\n");
+		cvi_i2s_dai->capture.channels_min = 0;
+		cvi_i2s_dai->capture.channels_max = 0;
+	}
+
+	dev_dbg(dev->dev, "CV: i2s master/slave mode supported\n");
+	dev->capability |= CVI_I2S_MASTER | CVI_I2S_SLAVE;
+
+	dev->fifo_th = I2STDM_FIFO_DEPTH / 2;
+	return 0;
+}
+
+static int cvi_configure_dai_by_dt(struct cvi_i2s_dev *dev,
+				   struct snd_soc_dai_driver *cvi_i2s_dai,
+				   struct resource *res)
+{
+	int ret;
+	struct device_node *np = dev->dev->of_node;
+
+	dev_dbg(dev->dev, "%s start\n", __func__);
+	ret = cvi_configure_dai(dev, cvi_i2s_dai, SNDRV_PCM_RATE_8000_192000);
+	if (ret < 0)
+		return ret;
+
+	/* Set TX parameters */
+	if (of_property_match_string(np, "dma-names", "tx") >= 0) {
+		dev_dbg(dev->dev, "%s dma-names  tx\n", __func__);
+		dev->capability |= CVI_I2S_PLAY;
+		dev->play_dma_data.dt.addr = res->start + TX_WR_PORT_CH0;
+		dev->play_dma_data.dt.addr_width = 4;
+		dev->play_dma_data.dt.fifo_size = I2STDM_FIFO_DEPTH * I2STDM_FIFO_WIDTH;
+		dev->play_dma_data.dt.maxburst = 8;
+	}
+
+	/* Set RX parameters */
+	if (of_property_match_string(np, "dma-names", "rx") >= 0) {
+		dev_dbg(dev->dev, "%s dma-names  rx\n", __func__);
+		dev->capability |= CVI_I2S_RECORD;
+		dev->capture_dma_data.dt.addr = res->start + RX_RD_PORT_CH0;
+		dev->capture_dma_data.dt.addr_width = 4;
+		dev->capture_dma_data.dt.fifo_size = I2STDM_FIFO_DEPTH * I2STDM_FIFO_WIDTH;
+		dev->capture_dma_data.dt.maxburst = 8;
+	}
+
+	return 0;
+
+}
+
+static int i2s_proc_show(struct seq_file *m, void *v)
+{
+	struct cvi_i2s_dev *dev = m->private;
+
+	if (i2s_read_reg(dev->i2s_base, I2S_ENABLE))
+		seq_printf(m, "\ni2s%d is enabled\n", dev->dev_id);
+	else
+		seq_printf(m, "\ni2s%d is disabled\n", dev->dev_id);
+
+	seq_printf(m, "\n===== Dump I2S%d register status =====\n", dev->dev_id);
+
+	seq_printf(m, "\nblk_mode=0x%08x,          clk_ctrl=0x%08x,          int_en=0x%08x\n",
+		   i2s_read_reg(dev->i2s_base, BLK_MODE_SETTING),
+		   i2s_read_reg(dev->i2s_base, I2S_CLK_CTRL0),
+		   i2s_read_reg(dev->i2s_base, I2S_INT_EN));
+
+	seq_printf(m, "\nframe_setting=0x%08x,     slot_setting=0x%08x,      data_format=0x%08x\n",
+		   i2s_read_reg(dev->i2s_base, FRAME_SETTING),
+		   i2s_read_reg(dev->i2s_base, SLOT_SETTING1),
+		   i2s_read_reg(dev->i2s_base, DATA_FORMAT));
+
+	seq_printf(m, "\ni2s_int=0x%08x,           rx_status=0x%08x,         tx_status=0x%08x\n",
+		   i2s_read_reg(dev->i2s_base, I2S_INT),
+		   i2s_read_reg(dev->i2s_base, RX_STATUS),
+		   i2s_read_reg(dev->i2s_base, TX_STATUS));
+
+	seq_printf(m, "\ndma_req=0x%08x,           dma_ack=0x%08x\n",
+		   i2s_read_reg(dev->i2s_base, DMA_REQ_COUNT),
+		   i2s_read_reg(dev->i2s_base, DMA_ACK_COUNT));
+
+	seq_printf(m, "\nclk_ctrl0=0x%08x,         clk_ctrl1=0x%08x\n",
+		   i2s_read_reg(dev->i2s_base, I2S_CLK_CTRL0),
+		   i2s_read_reg(dev->i2s_base, I2S_CLK_CTRL1));
+
+	return 0;
+}
+
+static int seq_i2s_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, i2s_proc_show, PDE_DATA(inode));
+}
+
+static const struct proc_ops i2s_proc_ops = {
+	.proc_read	= seq_read,
+	.proc_open	= seq_i2s_open,
+	.proc_release	= single_release,
+};
+
+
+static int cvi_i2s_probe(struct platform_device *pdev)
+{
+	const struct i2s_platform_data *pdata = pdev->dev.platform_data;
+	struct cvi_i2s_dev *dev;
+	struct resource *res;
+	int ret, irq;
+	struct snd_soc_dai_driver *cvi_i2s_dai;
+	const char *clk_id;
+	unsigned int val;
+	struct proc_dir_entry *proc_i2s;
+	char *i2s_dev_name;
+	const char *mclk_out;
+
+	dev_info(&pdev->dev, "%s\n", __func__);
+
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	cvi_i2s_dai = devm_kzalloc(&pdev->dev, sizeof(*cvi_i2s_dai), GFP_KERNEL);
+	if (!cvi_i2s_dai)
+		return -ENOMEM;
+
+	cvi_i2s_dai->ops = &cvi_i2s_dai_ops;
+	cvi_i2s_dai->name = "cvi_i2s_probe";
+
+	//for kernel version witch is less than 5.10.4
+	//cvi_i2s_dai->suspend = cvi_i2s_suspend;
+	//cvi_i2s_dai->resume = cvi_i2s_resume;
+
+	cvi_i2s_dai->probe = cvi_i2s_dai_probe;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dev->i2s_base = devm_ioremap_resource(&pdev->dev, res);
+	dev_dbg(&pdev->dev, "I2S get i2s_base=0x%p\n", dev->i2s_base);
+	if (IS_ERR(dev->i2s_base))
+		return PTR_ERR(dev->i2s_base);
+
+	dev->dev = &pdev->dev;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq >= 0) {
+		dev_dbg(&pdev->dev, "I2S get IRQ=0x%x\n", irq);
+		ret = devm_request_irq(&pdev->dev, irq, i2s_irq_handler, 0,
+				       pdev->name, dev);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "failed to request irq\n");
+			return ret;
+		}
+	}
+
+	if (pdata) {
+		dev->capability = pdata->cap;
+		clk_id = NULL;
+		dev->quirks = pdata->quirks;
+	} else {
+		clk_id = "i2sclk";
+		ret = cvi_configure_dai_by_dt(dev, cvi_i2s_dai, res);
+		device_property_read_u32(&pdev->dev, "dev-id",
+					 &dev->dev_id);
+		dev->clk = devm_clk_get(&pdev->dev, clk_id);
+	}
+	if (ret < 0)
+		return ret;
+
+	if (dev->capability & CVI_I2S_MASTER) {
+		if (pdata) {
+			dev->i2s_clk_cfg = pdata->i2s_clk_cfg;
+			if (!dev->i2s_clk_cfg) {
+				dev_err(&pdev->dev, "no clock configure method\n");
+				return -ENODEV;
+			}
+		}
+		dev->clk = devm_clk_get(&pdev->dev, clk_id);
+
+		if (IS_ERR(dev->clk))
+			return PTR_ERR(dev->clk);
+
+		ret = clk_prepare_enable(dev->clk);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "I2S clock prepare failed\n");
+			return ret;
+		}
+	}
+
+	device_property_read_string(&pdev->dev, "mclk_out", &mclk_out);
+
+	if (!strcmp(mclk_out, "true"))
+		dev->mclk_out = true;
+	else
+		dev->mclk_out = false;
+
+	val = i2s_read_reg(dev->i2s_base, I2S_CLK_CTRL0);
+	val &= ~(AUD_CLK_SOURCE_MASK);
+	val &= ~(BCLK_OUT_FORCE_EN); /* blck_out output after transmission start */
+#if defined(CONFIG_SND_SOC_CV1835_USE_AUDIO_PLL)
+	if (dev->mclk_out == true)
+		i2s_write_reg(dev->i2s_base, I2S_CLK_CTRL0, val | AUD_CLK_FROM_PLL | MCLK_OUT_EN | AUD_ENABLE);
+	/* Turn aud_en on due to external codec might need MCLK to do register initialization */
+	else
+		i2s_write_reg(dev->i2s_base, I2S_CLK_CTRL0, val | AUD_CLK_FROM_PLL);
+#else
+	i2s_write_reg(dev->i2s_base, I2S_CLK_CTRL0, val | AUD_CLK_FROM_MCLK_IN);
+#endif
+
+	dev_set_drvdata(&pdev->dev, dev);
+	ret = devm_snd_soc_register_component(&pdev->dev, &cvi_i2s_component,
+					      cvi_i2s_dai, 1);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "not able to register dai\n");
+		goto err_clk_disable;
+	}
+
+	if (!pdata) {
+		ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
+
+		if (ret == -EPROBE_DEFER) {
+			dev_err(&pdev->dev,
+				"failed to register PCM, deferring probe\n");
+			return ret;
+		} else if (ret) {
+			dev_err(&pdev->dev,
+				"Could not register DMA PCM: %d\n"
+				"falling back to PIO mode\n", ret);
+			ret = cvi_pcm_register(pdev);
+			if (ret) {
+				dev_err(&pdev->dev,
+					"Could not register PIO PCM: %d\n",
+					ret);
+				goto err_clk_disable;
+			}
+		}
+	}
+	if (!proc_audio_dir) {
+		proc_audio_dir = proc_mkdir("audio_debug", NULL);
+		if (!proc_audio_dir)
+			dev_err(&pdev->dev, "Error creating audio_debug proc folder entry\n");
+	}
+
+	if (proc_audio_dir) {
+		i2s_dev_name = devm_kasprintf(&pdev->dev, GFP_KERNEL, "i2s%d", dev->dev_id);
+		proc_i2s = proc_create_data(i2s_dev_name, 0664, proc_audio_dir, &i2s_proc_ops, dev);
+		if (!proc_i2s)
+			dev_err(&pdev->dev, "Create i2s%d status proc failed!\n", dev->dev_id);
+		devm_kfree(&pdev->dev, i2s_dev_name);
+	}
+
+	pm_runtime_enable(&pdev->dev);
+
+	return 0;
+
+err_clk_disable:
+	if (dev->capability & CVI_I2S_MASTER)
+		clk_disable_unprepare(dev->clk);
+	return ret;
+}
+
+static int cvi_i2s_remove(struct platform_device *pdev)
+{
+	struct cvi_i2s_dev *dev = dev_get_drvdata(&pdev->dev);
+
+	if (dev->capability & CVI_I2S_MASTER)
+		clk_disable_unprepare(dev->clk);
+
+	pm_runtime_disable(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id cvi_i2s_of_match[] = {
+	{ .compatible = "cvitek,cv1835-i2s", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, cvi_i2s_of_match);
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+static int cvi_i2s_pm_suspend(struct device *dev)
+{
+	struct cvi_i2s_dev *i2s_dev = dev_get_drvdata(dev);
+
+	if (!i2s_dev->reg_ctx) {
+		i2s_dev->reg_ctx = devm_kzalloc(i2s_dev->dev, sizeof(struct cvi_i2s_reg_context), GFP_KERNEL);
+		if (!i2s_dev->reg_ctx)
+			return -ENOMEM;
+	}
+
+	i2s_dev->reg_ctx->blk_setting = i2s_read_reg(i2s_dev->i2s_base, BLK_MODE_SETTING);
+	i2s_dev->reg_ctx->frame_setting = i2s_read_reg(i2s_dev->i2s_base, FRAME_SETTING);
+	i2s_dev->reg_ctx->slot_setting1 = i2s_read_reg(i2s_dev->i2s_base, SLOT_SETTING1);
+	i2s_dev->reg_ctx->slot_setting2 = i2s_read_reg(i2s_dev->i2s_base, SLOT_SETTING2);
+	i2s_dev->reg_ctx->data_format = i2s_read_reg(i2s_dev->i2s_base, DATA_FORMAT);
+	i2s_dev->reg_ctx->blk_cfg = i2s_read_reg(i2s_dev->i2s_base, BLK_CFG);
+	i2s_dev->reg_ctx->i2s_en = i2s_read_reg(i2s_dev->i2s_base, I2S_ENABLE);
+	i2s_dev->reg_ctx->i2s_int_en = i2s_read_reg(i2s_dev->i2s_base, I2S_INT_EN);
+	i2s_dev->reg_ctx->fifo_threshold = i2s_read_reg(i2s_dev->i2s_base, FIFO_THRESHOLD);
+	i2s_dev->reg_ctx->i2s_lrck_master = i2s_read_reg(i2s_dev->i2s_base, I2S_LRCK_MASTER);
+	i2s_dev->reg_ctx->i2s_clk_ctl0 = i2s_read_reg(i2s_dev->i2s_base, I2S_CLK_CTRL0);
+	i2s_dev->reg_ctx->i2c_clk_ctl1 = i2s_read_reg(i2s_dev->i2s_base, I2S_CLK_CTRL1);
+	i2s_dev->reg_ctx->i2s_pcm_synth = i2s_read_reg(i2s_dev->i2s_base, I2S_PCM_SYNTH);
+
+	if (i2s_dev->capability & CVI_I2S_MASTER)
+		clk_disable(i2s_dev->clk);
+
+	return 0;
+}
+
+static int cvi_i2s_pm_resume(struct device *dev)
+{
+	struct cvi_i2s_dev *i2s_dev = dev_get_drvdata(dev);
+
+	if (i2s_dev->capability & CVI_I2S_MASTER)
+		clk_enable(i2s_dev->clk);
+
+	i2s_write_reg(i2s_dev->i2s_base, BLK_MODE_SETTING, i2s_dev->reg_ctx->blk_setting);
+	i2s_write_reg(i2s_dev->i2s_base, FRAME_SETTING, i2s_dev->reg_ctx->frame_setting);
+	i2s_write_reg(i2s_dev->i2s_base, SLOT_SETTING1, i2s_dev->reg_ctx->slot_setting1);
+	i2s_write_reg(i2s_dev->i2s_base, SLOT_SETTING2, i2s_dev->reg_ctx->slot_setting2);
+	i2s_write_reg(i2s_dev->i2s_base, DATA_FORMAT, i2s_dev->reg_ctx->data_format);
+	i2s_write_reg(i2s_dev->i2s_base, BLK_CFG, i2s_dev->reg_ctx->blk_cfg);
+	i2s_write_reg(i2s_dev->i2s_base, I2S_ENABLE, i2s_dev->reg_ctx->i2s_en);
+	i2s_write_reg(i2s_dev->i2s_base, I2S_INT_EN, i2s_dev->reg_ctx->i2s_int_en);
+	i2s_write_reg(i2s_dev->i2s_base, FIFO_THRESHOLD, i2s_dev->reg_ctx->fifo_threshold);
+	i2s_write_reg(i2s_dev->i2s_base, I2S_LRCK_MASTER, i2s_dev->reg_ctx->i2s_lrck_master);
+	i2s_write_reg(i2s_dev->i2s_base, I2S_CLK_CTRL0, i2s_dev->reg_ctx->i2s_clk_ctl0);
+	i2s_write_reg(i2s_dev->i2s_base, I2S_CLK_CTRL1, i2s_dev->reg_ctx->i2c_clk_ctl1);
+	i2s_write_reg(i2s_dev->i2s_base, I2S_PCM_SYNTH, i2s_dev->reg_ctx->i2s_pcm_synth);
+
+	return 0;
+}
+
+#else
+#define cvi_i2s_pm_suspend	NULL
+#define cvi_i2s_pm_resume	NULL
+#endif
+
+#ifdef CONFIG_PM
+static const struct dev_pm_ops cvi_pm_ops = {
+	SET_RUNTIME_PM_OPS(cvi_i2s_runtime_suspend, cvi_i2s_runtime_resume, NULL)
+#ifdef CONFIG_PM_SLEEP
+	SET_SYSTEM_SLEEP_PM_OPS(cvi_i2s_pm_suspend, cvi_i2s_pm_resume)
+#endif
+};
+#endif
+
+static struct platform_driver cvi_i2s_driver = {
+	.probe		= cvi_i2s_probe,
+	.remove		= cvi_i2s_remove,
+	.driver		= {
+		.name	= "cvitek-i2s",
+		.of_match_table = of_match_ptr(cvi_i2s_of_match),
+#ifdef CONFIG_PM
+		.pm = &cvi_pm_ops,
+#endif
+	},
+};
+
+module_platform_driver(cvi_i2s_driver);
+
+MODULE_AUTHOR("EthanChen <ethan.chen@wisecore.com.tw>");
+MODULE_DESCRIPTION("CVITEK I2S SoC Interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:CVITEK_I2S");
diff --git a/sound/soc/cvitek/cv1835_i2s_subsys.c b/sound/soc/cvitek/cv1835_i2s_subsys.c
new file mode 100644
index 000000000000..9c0f5da479c7
--- /dev/null
+++ b/sound/soc/cvitek/cv1835_i2s_subsys.c
@@ -0,0 +1,350 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include "cv1835_i2s_subsys.h"
+
+struct cvi_i2s_subsys_dev *dev;
+void __iomem *master_reg;
+u32 current_freq;
+
+u32 i2s_subsys_query_master(void)
+{
+	return dev->master_id;
+}
+
+bool i2s_master_is_on(void)
+{
+	return readl(master_reg + I2S_ENABLE_REG);
+}
+
+void i2s_set_master_clk(u32 clk_ctrl1)
+{
+	if (i2s_master_is_on()) {
+		if (clk_ctrl1 != readl(master_reg + I2S_CLK_CTRL1_REG))
+			dev_err(dev->dev, "Master I2S is already enabled, cannot set with different bclk\n");
+		return;
+	}
+
+	writel(clk_ctrl1, master_reg + I2S_CLK_CTRL1_REG);
+}
+
+void i2s_set_master_frame_setting(u32 frame_format)
+{
+	if (i2s_master_is_on()) {
+		if (frame_format != readl(master_reg + I2S_FRAME_SETTING_REG))
+			dev_err(dev->dev, "Master I2S is already enabled, cannot set with different format\n");
+		return;
+	}
+
+	writel(frame_format, master_reg + I2S_FRAME_SETTING_REG);
+}
+
+void i2s_master_clk_switch_on(bool on)
+{
+	u32 clk_ctrl0 = readl(master_reg + I2S_CLK_CTRL0_REG);
+
+	if (i2s_master_is_on())
+		return;
+
+	if (on) {
+		writel(clk_ctrl0 | 0x140, master_reg + I2S_CLK_CTRL0_REG);
+		writel(0x1, master_reg + I2S_LCRK_MASTER_REG);
+	} else {
+		writel(0x0, master_reg + I2S_LCRK_MASTER_REG);
+		writel(clk_ctrl0 & 0x0bf, master_reg + I2S_CLK_CTRL0_REG);
+	}
+
+}
+
+void cv1835_set_mclk(u32 freq)
+{
+	struct clk *clk_a0pll;
+	struct clk *clk_sdma_aud0;
+	struct clk *clk_sdma_aud1;
+	struct clk *clk_sdma_aud2;
+	struct clk *clk_sdma_aud3;
+#ifdef CONFIG_ARCH_CV183X_ASIC
+	void __iomem *gp_reg3 = ioremap(0x0300008c, 4);
+	u32 chip_id = readl(gp_reg3);
+#endif
+
+	if (current_freq != freq)
+		current_freq = freq;
+	else
+		return;
+
+	clk_a0pll = devm_clk_get(dev->dev, "clk_a0pll");
+	if (IS_ERR(clk_a0pll)) {
+		dev_err(dev->dev, "Get clk_a0pll failed\n");
+		return;
+	}
+
+	clk_sdma_aud0 = devm_clk_get(dev->dev, "clk_sdma_aud0");
+	if (IS_ERR(clk_sdma_aud0)) {
+		dev_err(dev->dev, "Get clk_sdma_aud0 failed\n");
+		return;
+	}
+
+	clk_sdma_aud1 = devm_clk_get(dev->dev, "clk_sdma_aud1");
+	if (IS_ERR(clk_sdma_aud1)) {
+		dev_err(dev->dev, "Get clk_sdma_aud1 failed\n");
+		return;
+	}
+
+	clk_sdma_aud2 = devm_clk_get(dev->dev, "clk_sdma_aud2");
+	if (IS_ERR(clk_sdma_aud2)) {
+		dev_err(dev->dev, "Get clk_sdma_aud2 failed\n");
+		return;
+	}
+
+	clk_sdma_aud3 = devm_clk_get(dev->dev, "clk_sdma_aud3");
+	if (IS_ERR(clk_sdma_aud3)) {
+		dev_err(dev->dev, "Get clk_sdma_aud3 failed\n");
+		return;
+	}
+
+	switch (freq) {
+	case CVI_16384_MHZ:
+#ifdef CONFIG_ARCH_CV183X_ASIC
+		if (chip_id != 0x1838) {
+			dev_info(dev->dev, "Set clk_a0pll to 406425600\n");
+			clk_set_rate(clk_a0pll, 406425600);
+		}
+#endif
+		dev_info(dev->dev, "Set clk_sdma_aud0~3 to 16384000\n");
+		clk_set_rate(clk_sdma_aud0, 16384000);
+		clk_set_rate(clk_sdma_aud1, 16384000);
+		clk_set_rate(clk_sdma_aud2, 16384000);
+		clk_set_rate(clk_sdma_aud3, 16384000);
+		break;
+	case CVI_22579_MHZ:
+#ifdef CONFIG_ARCH_CV183X_ASIC
+		if (chip_id != 0x1838) {
+			dev_info(dev->dev, "Set clk_a0pll to 406425600\n");
+			clk_set_rate(clk_a0pll, 406425600);
+		}
+#endif
+		dev_info(dev->dev, "Set clk_sdma_aud0~3 to 22579200\n");
+		clk_set_rate(clk_sdma_aud0, 22579200);
+		clk_set_rate(clk_sdma_aud1, 22579200);
+		clk_set_rate(clk_sdma_aud2, 22579200);
+		clk_set_rate(clk_sdma_aud3, 22579200);
+		break;
+	case CVI_24576_MHZ:
+#ifdef CONFIG_ARCH_CV183X_ASIC
+		if (chip_id != 0x1838) {
+			dev_info(dev->dev, "Set clk_a0pll to 417792000\n");
+			clk_set_rate(clk_a0pll, 417792000);
+		}
+#endif
+		dev_info(dev->dev, "Set clk_sdma_aud0~3 to 24576000\n");
+		clk_set_rate(clk_sdma_aud0, 24576000);
+		clk_set_rate(clk_sdma_aud1, 24576000);
+		clk_set_rate(clk_sdma_aud2, 24576000);
+		clk_set_rate(clk_sdma_aud3, 24576000);
+		break;
+	default:
+		dev_info(dev->dev, "Unrecognised freq\n");
+		break;
+	}
+
+#ifdef CONFIG_ARCH_CV183X_ASIC
+	iounmap(gp_reg3);
+#endif
+}
+
+static int i2s_subsys_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct clk *i2sclk;
+	const char *clk_id;
+	u32 audio_clk;
+
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dev->subsys_base = devm_ioremap_resource(&pdev->dev, res);
+	dev_dbg(&pdev->dev, "I2S get i2s_subsys_base=0x%p\n", dev->subsys_base);
+	if (IS_ERR(dev->subsys_base))
+		return PTR_ERR(dev->subsys_base);
+	dev->dev = &pdev->dev;
+
+#if defined(CONFIG_SND_SOC_CV1835_CONCURRENT_I2S)
+	device_property_read_u32(&pdev->dev, "master_base", &dev->master_base);
+	dev_dbg(dev->dev, "master base is 0x%x\n", dev->master_base);
+
+	switch (dev->master_base) {
+	case 0x4110000:
+		dev->master_id = 1;
+		break;
+	case 0x4120000:
+		dev->master_id = 2;
+		break;
+	default:
+		dev_err(dev->dev, "master base is not correct!! plz set I2S1 or I2S2\n");
+	}
+#endif
+
+	master_reg = ioremap(dev->master_base, 0x100);
+	if (!master_reg)
+		dev_err(dev->dev, "%s FAILED!!\n", __func__);
+
+	clk_id = "i2sclk";
+	i2sclk = devm_clk_get(&pdev->dev, clk_id);
+	if (IS_ERR(i2sclk))
+		return PTR_ERR(i2sclk);
+
+	audio_clk = clk_get_rate(i2sclk);
+	pr_info("get audio clk=%d\n", audio_clk);
+	cv1835_set_mclk(audio_clk);
+
+#if (!defined(CONFIG_SND_SOC_CV1835_CONCURRENT_I2S) && !defined(CONFIG_SND_SOC_CV1835PDM))
+	/* normal operation, use I2S1 as TX and RX */
+	writel(0x7654, dev->subsys_base + SCLK_IN_SEL);
+	writel(0x7654, dev->subsys_base + FS_IN_SEL);
+	writel(0x7654, dev->subsys_base + SDI_IN_SEL);
+	writel(0x7654, dev->subsys_base + SDO_OUT_SEL);
+	writel(0x0000, dev->subsys_base + MULTI_SYNC);
+	writel(0x0000, dev->subsys_base + BCLK_OEN_SEL);
+
+#elif defined(CONFIG_SND_SOC_CV1835_CONCURRENT_I2S)
+	writel(0x7114, dev->subsys_base + SCLK_IN_SEL);
+	writel(0x7114, dev->subsys_base + FS_IN_SEL);
+	writel(0x7554, dev->subsys_base + SDI_IN_SEL);
+	writel(0x7664, dev->subsys_base + SDO_OUT_SEL);
+	writel(0x0000, dev->subsys_base + MULTI_SYNC);
+	writel(0x0000, dev->subsys_base + BCLK_OEN_SEL);
+
+#elif defined(CONFIG_SND_SOC_CV1835PDM)
+	writel(0x7614, dev->subsys_base + SCLK_IN_SEL);
+	writel(0x7214, dev->subsys_base + FS_IN_SEL);
+	writel(0x7614, dev->subsys_base + SDI_IN_SEL);
+	writel(0x7604, dev->subsys_base + SDO_OUT_SEL);
+	writel(0x0000, dev->subsys_base + MULTI_SYNC);
+#if defined(CONFIG_ARCH_CV182X)
+	writel(0x0404, dev->subsys_base + BCLK_OEN_SEL);
+#else
+	writel(0x0202, dev->subsys_base + BCLK_OEN_SEL);
+#endif
+	writel(0x0002, dev->subsys_base + AUDIO_PDM_CTRL);
+
+#endif
+
+	return 0;
+}
+
+#define CV182X_DAC_RESET	0xF7FFFFFF
+#define CV182X_ADC_RESET	0xDFFFFFFF
+#define CV182XA_DAC_RESET	0xF7FFFFFF
+#define CV182XA_ADC_RESET	0xDFFFFFFF
+
+/* while cv182x codecs transfer CIC between 64 and 128, need to reset codec first */
+void cv182x_reset_dac(void)
+{
+	void __iomem *reset_reg = ioremap(0x03003008, 4);
+
+	writel((readl(reset_reg) & CV182X_DAC_RESET), reset_reg);
+	writel((readl(reset_reg) | ~CV182X_DAC_RESET), reset_reg);
+	iounmap(reset_reg);
+}
+
+void cv182x_reset_adc(void)
+{
+	void __iomem *reset_reg = ioremap(0x03003008, 4);
+
+	writel((readl(reset_reg) & CV182X_ADC_RESET), reset_reg);
+	writel((readl(reset_reg) | ~CV182X_ADC_RESET), reset_reg);
+	iounmap(reset_reg);
+}
+
+void cv182xa_reset_dac(void)
+{
+	void __iomem *reset_reg = ioremap(0x03003008, 4);
+
+	writel((readl(reset_reg) & CV182XA_DAC_RESET), reset_reg);
+	writel((readl(reset_reg) | ~CV182XA_DAC_RESET), reset_reg);
+	iounmap(reset_reg);
+}
+
+void cv182xa_reset_adc(void)
+{
+	void __iomem *reset_reg = ioremap(0x03003008, 4);
+
+	writel((readl(reset_reg) & CV182XA_ADC_RESET), reset_reg);
+	writel((readl(reset_reg) | ~CV182XA_ADC_RESET), reset_reg);
+	iounmap(reset_reg);
+}
+
+static const struct of_device_id i2s_subsys_id_match[] = {
+	{
+		.compatible = "cvitek,i2s_tdm_subsys",
+	},
+	{},
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int i2s_subsys_suspend_late(struct device *t_dev)
+{
+	if (!dev->reg_ctx) {
+		dev->reg_ctx = devm_kzalloc(dev->dev, sizeof(struct subsys_reg_context), GFP_KERNEL);
+		if (!dev->reg_ctx)
+			return -ENOMEM;
+	}
+
+	dev->reg_ctx->sclk_in_sel = readl(dev->subsys_base + SCLK_IN_SEL);
+	dev->reg_ctx->fs_in_sel = readl(dev->subsys_base + FS_IN_SEL);
+	dev->reg_ctx->sdi_in_sel = readl(dev->subsys_base + SDI_IN_SEL);
+	dev->reg_ctx->sdo_out_sel = readl(dev->subsys_base + SDO_OUT_SEL);
+	dev->reg_ctx->multi_sync = readl(dev->subsys_base + MULTI_SYNC);
+	dev->reg_ctx->bclk_oen_sel = readl(dev->subsys_base + BCLK_OEN_SEL);
+	dev->reg_ctx->pdm_ctrl = readl(dev->subsys_base + AUDIO_PDM_CTRL);
+	return 0;
+}
+
+static int i2s_subsys_resume_early(struct device *t_dev)
+{
+	writel(dev->reg_ctx->sclk_in_sel, dev->subsys_base + SCLK_IN_SEL);
+	writel(dev->reg_ctx->fs_in_sel, dev->subsys_base + FS_IN_SEL);
+	writel(dev->reg_ctx->sdi_in_sel, dev->subsys_base + SDI_IN_SEL);
+	writel(dev->reg_ctx->sdo_out_sel, dev->subsys_base + SDO_OUT_SEL);
+	writel(dev->reg_ctx->multi_sync, dev->subsys_base + MULTI_SYNC);
+	writel(dev->reg_ctx->bclk_oen_sel, dev->subsys_base + BCLK_OEN_SEL);
+	writel(dev->reg_ctx->pdm_ctrl, dev->subsys_base + AUDIO_PDM_CTRL);
+
+	return 0;
+}
+#else
+#define i2s_subsys_suspend_late	NULL
+#define i2s_subsys_resume_early	NULL
+#endif /* CONFIG_PM_SLEEP */
+
+static const struct dev_pm_ops i2s_subsys_pm_ops = {
+	SET_LATE_SYSTEM_SLEEP_PM_OPS(i2s_subsys_suspend_late, i2s_subsys_resume_early)
+};
+
+static struct platform_driver i2s_subsys_driver = {
+	.driver = {
+		.name = "cvitek-i2s-subsys",
+		.owner = THIS_MODULE,
+		.pm = &i2s_subsys_pm_ops,
+		.of_match_table = of_match_ptr(i2s_subsys_id_match),
+	},
+	.probe = i2s_subsys_probe,
+};
+
+static int __init i2s_subsys_init(void)
+{
+	return platform_driver_register(&i2s_subsys_driver);
+}
+
+arch_initcall(i2s_subsys_init);
diff --git a/sound/soc/cvitek/cv1835_i2s_subsys.h b/sound/soc/cvitek/cv1835_i2s_subsys.h
new file mode 100644
index 000000000000..bc3c811cb2eb
--- /dev/null
+++ b/sound/soc/cvitek/cv1835_i2s_subsys.h
@@ -0,0 +1,77 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#ifndef _CV1835_I2S_SUBSYS_H_
+#define _CV1835_I2S_SUBSYS_H_
+
+#define SUBSYS_I2S0     (0x1 << 0)
+#define SUBSYS_I2S1     (0x1 << 1)
+#define SUBSYS_I2S2     (0x1 << 2)
+#define SUBSYS_I2S3     (0x1 << 3)
+
+#define SCLK_IN_SEL				0x00
+#define FS_IN_SEL				0x04
+#define SDI_IN_SEL				0x08
+#define SDO_OUT_SEL				0x0C
+#define MULTI_SYNC				0x20
+#define BCLK_OEN_SEL			0x30
+#define BCLK_OUT_CTRL			0x34
+#define AUDIO_PDM_CTRL			0x40
+#define AUDIO_PHY_BYPASS1		0x50
+#define AUDIO_PHY_BYPASS2		0x54
+#define SYS_CLK_CTRL			0x70
+#define I2S0_MASTER_CLK_CTRL0	0x80
+#define I2S0_MASTER_CLK_CTRL1	0x84
+#define I2S1_MASTER_CLK_CTRL0	0x90
+#define I2S1_MASTER_CLK_CTRL1	0x94
+#define I2S2_MASTER_CLK_CTRL0	0xA0
+#define I2S2_MASTER_CLK_CTRL1	0xA4
+#define I2S3_MASTER_CLK_CTRL0	0xB0
+#define I2S3_MASTER_CLK_CTRL1	0xB4
+#define SYS_LRCK_CTRL			0xC0
+
+#define I2S_FRAME_SETTING_REG	0x04
+#define I2S_ENABLE_REG			0x18
+#define I2S_LCRK_MASTER_REG		0x2C
+#define I2S_CLK_CTRL0_REG		0x60
+#define I2S_CLK_CTRL1_REG		0x64
+#define I2S_RESET_REG			0x1C
+#define I2S_TX_STATUS_REG		0x48
+
+#ifdef CONFIG_PM_SLEEP
+struct subsys_reg_context {
+	u32 sclk_in_sel;
+	u32 fs_in_sel;
+	u32 sdi_in_sel;
+	u32 sdo_out_sel;
+	u32 multi_sync;
+	u32 bclk_oen_sel;
+	u32 pdm_ctrl;
+};
+#endif
+
+struct cvi_i2s_subsys_dev {
+	void __iomem *subsys_base;
+	struct device *dev;
+	u32 master_id;
+	u32 master_base;
+#ifdef CONFIG_PM_SLEEP
+	struct subsys_reg_context *reg_ctx;
+#endif
+};
+
+#define	CVI_16384_MHZ	16384000   /* 16.384 Mhz */
+#define	CVI_22579_MHZ	22579200   /* 22.5792 Mhz */
+#define	CVI_24576_MHZ	24576000   /* 24.576 Mhz */
+
+u32 i2s_subsys_query_master(void);
+void i2s_master_clk_switch_on(bool on);
+void i2s_set_master_clk(u32 clk_ctrl1);
+void i2s_set_master_frame_setting(u32 frame_format);
+void cv1835_set_mclk(u32 freq);
+void cv182x_reset_dac(void);
+void cv182x_reset_adc(void);
+void cv182xa_reset_dac(void);
+void cv182xa_reset_adc(void);
+
+#endif
diff --git a/sound/soc/cvitek/cv1835_ioctl.h b/sound/soc/cvitek/cv1835_ioctl.h
new file mode 100644
index 000000000000..30275a2a8fc8
--- /dev/null
+++ b/sound/soc/cvitek/cv1835_ioctl.h
@@ -0,0 +1,125 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#ifndef __CV1835_IOCTL_H__
+#define __CV1835_IOCTL_H__
+
+enum cv1835_codec_fs {
+	ACODEC_FS_8000  =   0x1,
+	ACODEC_FS_11025 =   0x2,
+	ACODEC_FS_12000 =   0x3,
+	ACODEC_FS_16000 =   0x4,
+	ACODEC_FS_22050 =   0x5,
+	ACODEC_FS_24000 =   0x6,
+	ACODEC_FS_32000 =   0x7,
+	ACODEC_FS_44100 =   0x8,
+	ACODEC_FS_48000 =   0x9,
+	ACODEC_FS_64000 =   0xa,
+	ACODEC_FS_96000 =   0xb,
+	ACODEC_FS_192000 =  0xc,
+};
+
+enum cv1835_mixer {
+	CVI_MIXER_LINEIN = 0x0,
+	CVI_MIXER_MIC_IN = 0x1,
+};
+
+enum cv1835_codec_cmd {
+	CVI_SOFT_RESET_CTRL = 0x0,
+
+	CVI_SET_INPUT_VOL,
+	CVI_SET_OUTPUT_VOL,
+	CVI_GET_INPUT_VOL,
+	CVI_GET_OUTPUT_VOL,
+
+	CVI_SET_I2S1_FS,
+	CVI_SET_MIXER_MIC,
+	CVI_SEL_DAC_CLK, /* not support */
+	CVI_SEL_ADC_CLK, /* not support */
+	CVI_SEL_ANA_MCLK, /* not support */
+	CVI_SET_GAIN_MICL,
+	CVI_SET_GAIN_MICR,
+	CVI_SET_DACL_VOL,
+	CVI_SET_DACR_VOL,
+	CVI_SET_ADCL_VOL,
+	CVI_SET_ADCR_VOL,
+	CVI_SET_MICL_MUTE,
+	CVI_SET_MICR_MUTE,
+	CVI_SET_DACL_MUTE,
+	CVI_SET_DACR_MUTE,
+	CVI_BOOSTL_ENABLE, /* not support */
+	CVI_BOOSTR_ENABLE, /* not support */
+
+	CVI_GET_GAIN_MICL,
+	CVI_GET_GAIN_MICR,
+	CVI_GET_DACL_VOL,
+	CVI_GET_DACR_VOL,
+	CVI_GET_ADCL_VOL,
+	CVI_GET_ADCR_VOL,
+
+	CVI_SET_PD_DACL,
+	CVI_SET_PD_DACR,
+	CVI_SET_PD_ADCL,
+	CVI_SET_PD_ADCR,
+	CVI_SET_PD_LINEINL,
+	CVI_SET_PD_LINEINR,
+
+	CVI_SET_DAC_DE_EMPHASIS,
+	CVI_SET_ADC_HP_FILTER,
+
+	CVI_SET_I2S1_DATAWIDTH, /* not support */
+
+	CVI_DACL_SEL_TRACK, /* not support */
+	CVI_DACR_SEL_TRACK, /* not support */
+	CVI_ADCL_SEL_TRACK, /* not support */
+	CVI_ADCR_SEL_TRACK, /* not support */
+};
+
+struct cvi_vol_ctrl {
+	/* volume control, adc range: 0x00~0x1f, 0x17F:mute. dac range: 0x00~0x0f, 0x0f:mute */
+	unsigned int vol_ctrl;
+	/* adc/dac mute control, 1:mute, 0:unmute */
+	unsigned int vol_ctrl_mute;
+};
+
+#define ACODEC_SOFT_RESET_CTRL _IO('A', CVI_SOFT_RESET_CTRL)
+
+#define ACODEC_SET_INPUT_VOL _IOWR('A', CVI_SET_INPUT_VOL, unsigned int)
+#define ACODEC_SET_OUTPUT_VOL _IOWR('A', CVI_SET_OUTPUT_VOL, unsigned int)
+#define ACODEC_GET_INPUT_VOL _IOWR('A', CVI_GET_INPUT_VOL, unsigned int)
+#define ACODEC_GET_OUTPUT_VOL _IOWR('A', CVI_GET_OUTPUT_VOL, unsigned int)
+
+#define ACODEC_SET_I2S1_FS _IOWR('A', CVI_SET_I2S1_FS, unsigned int)
+#define ACODEC_SET_MIXER_MIC _IOWR('A', CVI_SET_MIXER_MIC, unsigned int)
+#define ACODEC_SET_GAIN_MICL _IOWR('A', CVI_SET_GAIN_MICL, unsigned int)
+#define ACODEC_SET_GAIN_MICR _IOWR('A', CVI_SET_GAIN_MICR, unsigned int)
+#define ACODEC_SET_DACL_VOL _IOWR('A', CVI_SET_DACL_VOL, struct cvi_vol_ctrl)
+#define ACODEC_SET_DACR_VOL _IOWR('A', CVI_SET_DACR_VOL, struct cvi_vol_ctrl)
+#define ACODEC_SET_ADCL_VOL _IOWR('A', CVI_SET_ADCL_VOL, struct cvi_vol_ctrl)
+#define ACODEC_SET_ADCR_VOL _IOWR('A', CVI_SET_ADCR_VOL, struct cvi_vol_ctrl)
+
+#define ACODEC_SET_MICL_MUTE _IOWR('A', CVI_SET_MICL_MUTE, unsigned int)
+#define ACODEC_SET_MICR_MUTE _IOWR('A', CVI_SET_MICR_MUTE, unsigned int)
+#define ACODEC_SET_DACL_MUTE _IOWR('A', CVI_SET_DACL_MUTE, unsigned int)
+#define ACODEC_SET_DACR_MUTE _IOWR('A', CVI_SET_DACR_MUTE, unsigned int)
+
+
+#define ACODEC_GET_GAIN_MICL _IOWR('A', CVI_GET_GAIN_MICL, unsigned int)
+#define ACODEC_GET_GAIN_MICR _IOWR('A', CVI_GET_GAIN_MICR, unsigned int)
+#define ACODEC_GET_DACL_VOL _IOWR('A', CVI_GET_DACL_VOL, struct cvi_vol_ctrl)
+#define ACODEC_GET_DACR_VOL _IOWR('A', CVI_GET_DACR_VOL, struct cvi_vol_ctrl)
+#define ACODEC_GET_ADCL_VOL _IOWR('A', CVI_GET_ADCL_VOL, struct cvi_vol_ctrl)
+#define ACODEC_GET_ADCR_VOL _IOWR('A', CVI_GET_ADCR_VOL, struct cvi_vol_ctrl)
+
+
+#define ACODEC_SET_PD_DACL _IOWR('A', CVI_SET_PD_DACL, unsigned int)
+#define ACODEC_SET_PD_DACR _IOWR('A', CVI_SET_PD_DACR, unsigned int)
+#define ACODEC_SET_PD_ADCL _IOWR('A', CVI_SET_PD_ADCL, unsigned int)
+#define ACODEC_SET_PD_ADCR _IOWR('A', CVI_SET_PD_ADCR, unsigned int)
+#define ACODEC_SET_PD_LINEINL _IOWR('A', CVI_SET_PD_LINEINL, unsigned int)
+#define ACODEC_SET_PD_LINEINR _IOWR('A', CVI_SET_PD_LINEINR, unsigned int)
+
+#define ACODEC_SET_DAC_DE_EMPHASIS _IOWR('A', CVI_SET_DAC_DE_EMPHASIS, unsigned int)
+#define ACODEC_SET_ADC_HP_FILTER _IOWR('A', CVI_SET_ADC_HP_FILTER, unsigned int)
+
+#endif  /* __CV1835_IOCTL_H__ */
diff --git a/sound/soc/cvitek/cv1835_lt9611.c b/sound/soc/cvitek/cv1835_lt9611.c
new file mode 100644
index 000000000000..0fcc3007dfa6
--- /dev/null
+++ b/sound/soc/cvitek/cv1835_lt9611.c
@@ -0,0 +1,99 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * lt9611 codec
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <linux/io.h>
+#include <linux/proc_fs.h>
+
+static int cv1835_lt9611_hw_params(struct snd_pcm_substream *substream,
+				   struct snd_pcm_hw_params *params)
+{
+//    printk("%s\n", __func__);
+	return 0;
+}
+
+static int cv1835_lt9611_codec_init(struct snd_soc_pcm_runtime *rtd)
+{
+//    printk("%s\n", __func__);
+	return 0;
+}
+static struct snd_soc_ops cv1835_lt9611_ops = {
+	.hw_params = cv1835_lt9611_hw_params,
+};
+
+static struct snd_soc_dai_link cv1835_lt9611_dai = {
+	.name = "cv1835-lt9611",
+	.stream_name = "cv1835-lt9611",
+	.codec_dai_name = "lt9611dai",
+	.codec_name = "lt9611",
+	.ops = &cv1835_lt9611_ops,
+	.init = cv1835_lt9611_codec_init,
+	.dai_fmt = SND_SOC_DAIFMT_I2S
+	| SND_SOC_DAIFMT_IB_NF
+	| SND_SOC_DAIFMT_CBS_CFS,
+};
+
+static struct snd_soc_card cv1835_lt9611 = {
+	.owner = THIS_MODULE,
+	.dai_link = &cv1835_lt9611_dai,
+	.num_links = 1,
+};
+
+static const struct of_device_id cvi_lt9611_audio_match_ids[] = {
+	{
+		.compatible = "cvitek,cv1835-lt9611",
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, cvi_lt9611_audio_match_ids);
+
+static int cv1835_lt9611_probe(struct platform_device *pdev)
+{
+	struct snd_soc_card *card;
+	struct device_node *np = pdev->dev.of_node;
+
+	//dev_dbg(&pdev->dev, "%s, dev name=%s\n", __func__, dev_name(&pdev->dev));
+//	printk("%s, dev name=%s\n", __func__, dev_name(&pdev->dev));
+
+	/* Ethan add, set pinmux by hard code temporary */
+	card = &cv1835_lt9611;
+
+	if (np) {
+
+		of_property_read_string(np, "cvi,card_name", &card->name);
+		card->dev = &pdev->dev;
+
+		of_property_read_string(np, "cvi,cpu_dai_name", &card->dai_link[0].cpu_dai_name);
+		of_property_read_string(np, "cvi,platform_name", &card->dai_link[0].platform_name);
+
+		platform_set_drvdata(pdev, card);
+		return devm_snd_soc_register_card(&pdev->dev, card);
+	}
+
+	return 0;
+}
+
+static struct platform_driver cv1835_lt9611_driver = {
+	.driver = {
+		.name = "cv1835-lt9611",
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = cvi_lt9611_audio_match_ids,
+	},
+	.probe = cv1835_lt9611_probe,
+};
+
+module_platform_driver(cv1835_lt9611_driver);
+
+MODULE_AUTHOR("EthanChen");
+MODULE_DESCRIPTION("lt9611 driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:cv1835-lt9611");
+
diff --git a/sound/soc/cvitek/cv1835adc.c b/sound/soc/cvitek/cv1835adc.c
new file mode 100644
index 000000000000..ce999f6933db
--- /dev/null
+++ b/sound/soc/cvitek/cv1835adc.c
@@ -0,0 +1,794 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * CVITEK CV1835 ADC driver
+ *
+ * Copyright 2020 CVITEK Inc.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/pm.h>
+#include <linux/mutex.h>
+#include <linux/miscdevice.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/control.h>
+#include "cv1835_ioctl.h"
+#include "../codecs/cv1835adc.h"
+
+static DEFINE_MUTEX(adc_mutex);
+
+u32 old_gsell_mic;
+u32 old_gselr_mic;
+
+static int adc_open(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&adc_mutex))
+		return -EINTR;
+	mutex_unlock(&adc_mutex);
+	pr_debug("%s\n", __func__);
+	return 0;
+}
+
+static int adc_close(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&adc_mutex))
+		return -EINTR;
+	mutex_unlock(&adc_mutex);
+	pr_debug("%s\n", __func__);
+	return 0;
+}
+
+static inline void adc_write_reg(void __iomem *io_base, int reg, u32 val)
+{
+	writel(val, io_base + reg);
+}
+
+static inline u32 adc_read_reg(void __iomem *io_base, int reg)
+{
+	return readl(io_base + reg);
+}
+
+static int cv1835adc_set_dai_fmt(struct snd_soc_dai *dai,
+				 unsigned int fmt)
+{
+
+	struct cvi1835adc *adc = snd_soc_dai_get_drvdata(dai);
+
+	if (!adc->dev)
+		dev_err(adc->dev, "dev is NULL\n");
+
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		dev_dbg(adc->dev, "Set ADC to MASTER mode\n");
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		dev_err(adc->dev, "Cannot set DAC to SLAVE mode, only support MASTER mode\n");
+		break;
+	default:
+		dev_err(adc->dev, "Cannot support this role mode\n");
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_IF:
+		dev_dbg(adc->dev, "set codec to NB_IF\n");
+		break;
+	default:
+		dev_err(adc->dev, "Cannot suuport this format\n");
+		break;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_LEFT_J:
+		dev_dbg(adc->dev, "set codec to LEFT-JUSTIFY mode\n");
+		break;
+	default:
+		dev_err(adc->dev, "Cannot support this mode\n");
+		break;
+	}
+	return 0;
+}
+
+static int cv1835adc_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *params,
+			       struct snd_soc_dai *dai)
+{
+
+	struct cvi1835adc *adc = snd_soc_dai_get_drvdata(dai);
+	int rate;
+
+	rate = params_rate(params);
+	if (rate >= 8000 && rate <= 48000) {
+		dev_dbg(adc->dev, "%s, set rate to %d\n", __func__, rate);
+
+		switch (rate) {
+		case 8000:
+		case 11025:
+		case 12000:
+			adc_write_reg(adc->adc_base, CVI_ADC_FS_SEL_REG, CVI_ADC_RATIO_1024);
+			break;
+		case 16000:
+		case 22050:
+		case 24000:
+			adc_write_reg(adc->adc_base, CVI_ADC_FS_SEL_REG, CVI_ADC_RATIO_512);
+			break;
+		case 32000:
+		case 44100:
+		case 48000:
+			adc_write_reg(adc->adc_base, CVI_ADC_FS_SEL_REG, CVI_ADC_RATIO_256);
+			break;
+		default:
+			adc_write_reg(adc->adc_base, CVI_ADC_FS_SEL_REG, CVI_ADC_RATIO_512);
+			dev_dbg(adc->dev, "%s, set sample rate with default 16KHz\n", __func__);
+			break;
+		}
+	} else {
+		adc_write_reg(adc->adc_base, CVI_ADC_FS_SEL_REG, CVI_ADC_RATIO_512);
+		dev_err(adc->dev, "Rate: %d Hz is not supported\n", rate);
+		dev_err(adc->dev, "%s, set sample rate with default 16KHz\n", __func__);
+		return 0;
+	}
+
+	if (params_width(params) != 16) {
+		dev_err(adc->dev, "Only support I2S channel width with 16 bits\n");
+		dev_err(adc->dev, "Set I2S channel width with 16bits\n");
+		return 0;
+	}
+
+	return 0;
+}
+
+static int cv1835adc_startup(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *dai)
+{
+	struct cvi1835adc *adc = snd_soc_dai_get_drvdata(dai);
+
+	dev_dbg(adc->dev, "%s\n", __func__);
+
+	return 0;
+}
+
+static void cv1835adc_on(struct cvi1835adc *adc)
+{
+	u32 val = adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG);
+
+	dev_dbg(adc->dev, "%s, before ctrl_reg val=0x%08x\n", __func__, adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG));
+
+	if ((val & CVI_ADC_ENADR_NORMAL) | (val & CVI_ADC_ENADL_NORMAL))
+		dev_info(adc->dev, "ADL or ADR already switched ON!!, val=0x%08x\n", val);
+
+	val |= CVI_ADC_ENADR_NORMAL | CVI_ADC_ENADL_NORMAL | CVI_ADC_VERF_NORMAL;
+	adc_write_reg(adc->adc_base, CVI_ADC_CTRL_REG, val);
+
+	dev_dbg(adc->dev, "%s, after ctrl_reg val=0x%08x\n", __func__, adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG));
+}
+
+static void cv1835adc_off(struct cvi1835adc *adc)
+{
+
+	u32 val = adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG);
+
+	val &= CVI_ADC_ENADR_POWER_DOWN & CVI_ADC_ENADL_POWER_DOWN & CVI_ADC_VREF_POWER_DOWN;
+	adc_write_reg(adc->adc_base, CVI_ADC_CTRL_REG, val);
+	dev_dbg(adc->dev, "%s, after ctrl_reg val=0x%08x\n", __func__, adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG));
+
+}
+
+static void cv1835adc_shutdown(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct cvi1835adc *adc = snd_soc_dai_get_drvdata(dai);
+
+	dev_dbg(adc->dev, "%s, before ctrl_reg val=0x%08x\n", __func__, adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG));
+
+}
+
+static int cv1835adc_trigger(struct snd_pcm_substream *substream,
+			     int cmd, struct snd_soc_dai *dai)
+{
+	struct cvi1835adc *adc = snd_soc_dai_get_drvdata(dai);
+	int ret = 0;
+
+	dev_dbg(adc->dev, "%s, cmd=%d\n", __func__, cmd);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		cv1835adc_on(adc);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		cv1835adc_off(adc);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static struct cvi1835adc *file_adc_dev(struct file *file)
+{
+	return container_of(file->private_data, struct cvi1835adc, miscdev);
+}
+
+
+static long adc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	unsigned int __user *argp = (unsigned int __user *)arg;
+	struct cvi1835adc *adc = file_adc_dev(file);
+	struct cvi_vol_ctrl vol;
+	u32 val;
+	u32 temp;
+	u32 input_type;
+
+	if (argp != NULL) {
+		if (!copy_from_user(&val, argp, sizeof(val))) {
+			if (mutex_lock_interruptible(&adc_mutex)) {
+				pr_debug("cv1835adc: signal arrives while waiting for lock\n");
+				return -EINTR;
+			}
+		} else
+			return -EFAULT;
+	}
+
+	pr_debug("%s, received cmd=%u, val=%d\n", __func__, cmd, val);
+
+	switch (cmd) {
+	case ACODEC_SOFT_RESET_CTRL:
+		pr_debug("adc: reset\n");
+		break;
+	case ACODEC_SET_INPUT_VOL:
+		pr_debug("adc: ACODEC_SET_INPUT_VOL\n");
+		input_type = (adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG) & CVI_ADC_INSELL_MIC) >> 1;
+		switch (input_type) {
+		case 0: /* line in */
+			if ((val < 0) | (val > 31))
+				pr_err("Only support range 31 [6dB] ~ 0 [mute]\n");
+			else {
+				val = 31 - val; /* invert 31 to 0, 0 to 31, vise versa */
+				temp = adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG)
+				       & CVI_ADC_GSELR_MASK
+				       & CVI_ADC_GSELL_MASK;
+
+				temp |= CVI_ADC_GSELR(val) | CVI_ADC_GSELL(val);
+				adc_write_reg(adc->adc_base, CVI_ADC_GSEL_REG, temp);
+			}
+			break;
+		case 1: /* mic in */
+			if ((val < 0) | (val > 7))
+				pr_err("Only support range 7 [40dB] ~ 0 [mute]\n");
+			else {
+				val = 31 - val; /* invert 31 to 0, 0 to 31, vise versa */
+				temp = adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG)
+				       & CVI_ADC_GSELR_MIC_MASK
+				       & CVI_ADC_GSELL_MIC_MASK;
+
+				temp |= CVI_ADC_GSELR_MIC(val) | CVI_ADC_GSELL_MIC(val);
+				adc_write_reg(adc->adc_base, CVI_ADC_GSEL_REG, temp);
+			}
+			break;
+		}
+		break;
+	case ACODEC_GET_INPUT_VOL:
+		pr_debug("adc: ACODEC_GET_INPUT_VOL\n");
+		input_type = (adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG) & CVI_ADC_INSELL_MIC) >> 1;
+		switch (input_type) {
+		case 0: /* line in */
+			temp = (adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & ~CVI_ADC_GSELL_MASK) >> 8;
+			temp = 31 - temp;
+			if (copy_to_user(argp, &temp, sizeof(temp)))
+				pr_err("adc, failed to return input vol\n");
+			break;
+		case 1: /* MIC in */
+			temp = (adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & ~CVI_ADC_GSELL_MIC_MASK) >> 24;
+			temp = 7 - temp;
+			if (copy_to_user(argp, &temp, sizeof(temp)))
+				pr_err("adc, failed to return input vol\n");
+			break;
+		}
+		break;
+	case ACODEC_SET_I2S1_FS:
+		pr_debug("adc: ACODEC_SET_I2S1_FS\n");
+		switch (val) {
+		case ACODEC_FS_8000:
+		case ACODEC_FS_12000:
+			adc_write_reg(adc->adc_base, CVI_ADC_FS_SEL_REG, CVI_ADC_RATIO_1024);
+			break;
+		case ACODEC_FS_16000:
+		case ACODEC_FS_24000:
+			adc_write_reg(adc->adc_base, CVI_ADC_FS_SEL_REG, CVI_ADC_RATIO_512);
+			break;
+		case ACODEC_FS_32000:
+		case ACODEC_FS_48000:
+			adc_write_reg(adc->adc_base, CVI_ADC_FS_SEL_REG, CVI_ADC_RATIO_256);
+			break;
+		default:
+			pr_debug("Not support this FS setting\n");
+			break;
+		}
+		break;
+	case ACODEC_SET_MIXER_MIC:
+		temp = adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG) & CVI_ADC_INSELL_LINE & CVI_ADC_INSELR_LINE;
+		if (val == CVI_MIXER_LINEIN) /* input from linein */
+			adc_write_reg(adc->adc_base, CVI_ADC_CTRL_REG, temp);
+		else if (val == CVI_MIXER_MIC_IN) /* input from MIC */
+			adc_write_reg(adc->adc_base, CVI_ADC_CTRL_REG, temp | CVI_ADC_INSELL_MIC | CVI_ADC_INSELR_MIC);
+		else
+			pr_err("Not support this kind of input\n");
+		break;
+	case ACODEC_SET_GAIN_MICL:
+		pr_debug("adc: ACODEC_SET_GAIN_MICL\n");
+		if ((val < 0) | (val > 7))
+			pr_err("Only support range 7 [40dB] ~ 0 [mute]\n");
+		else {
+			val = 7 - val;
+			temp = adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & CVI_ADC_GSELL_MIC_MASK;
+			temp |= CVI_ADC_GSELL_MIC(val);
+			old_gsell_mic = val;
+			adc_write_reg(adc->adc_base, CVI_ADC_GSEL_REG, temp);
+		}
+		break;
+	case ACODEC_SET_GAIN_MICR:
+		pr_debug("adc: ACODEC_SET_GAIN_MICR\n");
+		if ((val < 0) | (val > 7))
+			pr_err("Only support range 7 [40dB] ~ 0 [mute]\n");
+		else {
+			val = 7 - val;
+			temp = adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & CVI_ADC_GSELR_MIC_MASK;
+			temp |= CVI_ADC_GSELR_MIC(val);
+			old_gselr_mic = val;
+			adc_write_reg(adc->adc_base, CVI_ADC_GSEL_REG, temp);
+		}
+		break;
+	case ACODEC_SET_ADCL_VOL:
+
+		if (copy_from_user(&vol, argp, sizeof(vol))) {
+			if (mutex_is_locked(&adc_mutex))
+				mutex_unlock(&adc_mutex);
+
+			return -EFAULT;
+		}
+
+		pr_debug("adc: ACODEC_SET_ADCL_VOL to %d, mute=%d\n", vol.vol_ctrl, vol.vol_ctrl_mute);
+
+		input_type = (adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG) & CVI_ADC_INSELL_MIC) >> 1;
+
+		switch (input_type) {
+		case 0: /* use linein */
+			if (vol.vol_ctrl_mute == 1) {
+				temp = adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & CVI_ADC_GSELL_MASK;
+				temp |= CVI_ADC_GSELL(31);
+				adc_write_reg(adc->adc_base, CVI_ADC_GSEL_REG, temp);
+			} else if ((vol.vol_ctrl < 0) | (vol.vol_ctrl > 31))
+				pr_err("adc-R: Only support range 31 [6dB] ~ 0 [mute]\n");
+			else {
+				vol.vol_ctrl = 31 - vol.vol_ctrl;
+				temp = adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & CVI_ADC_GSELL_MASK;
+				temp |= CVI_ADC_GSELL(vol.vol_ctrl);
+				adc_write_reg(adc->adc_base, CVI_ADC_GSEL_REG, temp);
+			}
+			break;
+		case 1: /* use MIC */
+			if (vol.vol_ctrl_mute == 1) {
+				temp = adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & CVI_ADC_GSELL_MIC_MASK;
+				temp |= CVI_ADC_GSELL_MIC(7);
+				adc_write_reg(adc->adc_base, CVI_ADC_GSEL_REG, temp);
+			} else if ((vol.vol_ctrl < 0) | (vol.vol_ctrl > 7))
+				pr_err("adc-R: Only support range 7 [40dB] ~ 0 [mute]\n");
+			else {
+				vol.vol_ctrl = 7 - vol.vol_ctrl;
+				temp = adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & CVI_ADC_GSELL_MIC_MASK;
+				temp |= CVI_ADC_GSELL_MIC(vol.vol_ctrl);
+				adc_write_reg(adc->adc_base, CVI_ADC_GSEL_REG, temp);
+			}
+			break;
+		}
+		break;
+	case ACODEC_SET_ADCR_VOL:
+		if (copy_from_user(&vol, argp, sizeof(vol))) {
+			if (mutex_is_locked(&adc_mutex))
+				mutex_unlock(&adc_mutex);
+
+			return -EFAULT;
+		}
+
+		pr_debug("adc: ACODEC_SET_ADCR_VOL to %d, mute=%d\n", vol.vol_ctrl, vol.vol_ctrl_mute);
+
+		input_type = (adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG) & CVI_ADC_INSELR_MIC);
+
+		switch (input_type) {
+		case 0: /* use linein */
+			if (vol.vol_ctrl_mute == 1) {
+				temp = adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & CVI_ADC_GSELR_MASK;
+				temp |= CVI_ADC_GSELR(31);
+				adc_write_reg(adc->adc_base, CVI_ADC_GSEL_REG, temp);
+			} else if ((vol.vol_ctrl < 0) | (vol.vol_ctrl > 31))
+				pr_err("adc-R: Only support range 31 [6dB] ~ 0 [mute]\n");
+			else {
+				vol.vol_ctrl = 31 - vol.vol_ctrl;
+				temp = adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & CVI_ADC_GSELR_MASK;
+				temp |= CVI_ADC_GSELR(vol.vol_ctrl);
+				adc_write_reg(adc->adc_base, CVI_ADC_GSEL_REG, temp);
+			}
+			break;
+		case 1: /* use MIC */
+			if (vol.vol_ctrl_mute == 1) {
+				temp = adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & CVI_ADC_GSELR_MIC_MASK;
+				temp |= CVI_ADC_GSELR_MIC(7);
+				adc_write_reg(adc->adc_base, CVI_ADC_GSEL_REG, temp);
+			} else if ((vol.vol_ctrl < 0) | (vol.vol_ctrl > 7))
+				pr_err("adc-R: Only support range 7 [40dB] ~ 0 [mute]\n");
+			else {
+				vol.vol_ctrl = 7 - vol.vol_ctrl;
+				temp = adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & CVI_ADC_GSELR_MIC_MASK;
+				temp |= CVI_ADC_GSELR_MIC(vol.vol_ctrl);
+				adc_write_reg(adc->adc_base, CVI_ADC_GSEL_REG, temp);
+			}
+			break;
+		}
+		break;
+	case ACODEC_SET_MICL_MUTE:
+		pr_debug("adc: ACODEC_SET_MICL_MUTE\n");
+		if (val == 0) {
+			temp = adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & CVI_ADC_GSELL_MIC_MASK;
+			if (old_gsell_mic == 7)
+				temp |= CVI_ADC_GSELL_MIC(6);
+			else
+				temp |= CVI_ADC_GSELL_MIC(old_gsell_mic);
+		} else {
+			old_gsell_mic = (adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & ~CVI_ADC_GSELL_MIC_MASK) >> 24;
+			temp |= CVI_ADC_GSELL_MIC(7);
+		}
+		adc_write_reg(adc->adc_base, CVI_ADC_GSEL_REG, temp);
+		break;
+	case ACODEC_SET_MICR_MUTE:
+		pr_debug("adc: ACODEC_SET_MICR_MUTE\n");
+		if (val == 0) {
+			temp = adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & CVI_ADC_GSELR_MIC_MASK;
+			if (old_gselr_mic == 7)
+				temp |= CVI_ADC_GSELR_MIC(6);
+			else
+				temp |= CVI_ADC_GSELR_MIC(old_gselr_mic);
+		} else {
+			old_gselr_mic = (adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & ~CVI_ADC_GSELR_MIC_MASK) >> 16;
+			temp |= CVI_ADC_GSELR_MIC(7);
+		}
+		adc_write_reg(adc->adc_base, CVI_ADC_GSEL_REG, temp);
+		break;
+	case ACODEC_GET_GAIN_MICL:
+		pr_debug("adc: ACODEC_GET_GAIN_MICL\n");
+		temp = (adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & ~CVI_ADC_GSELL_MIC_MASK) >> 24;
+		temp = 7 - temp;
+		if (copy_to_user(argp, &temp, sizeof(temp)))
+			pr_err("failed to return MICL gain\n");
+		break;
+	case ACODEC_GET_GAIN_MICR:
+		pr_debug("adc: ACODEC_GET_GAIN_MICR\n");
+		temp = (adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & ~CVI_ADC_GSELR_MIC_MASK) >> 16;
+		temp = 7 - temp;
+		if (copy_to_user(argp, &temp, sizeof(temp)))
+			pr_err("failed to return MICR gain\n");
+		break;
+	case ACODEC_GET_ADCL_VOL:
+		pr_debug("adc: ACODEC_GET_ADCL_VOL\n");
+
+		input_type = (adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG) & CVI_ADC_INSELL_MIC) >> 1;
+
+		switch (input_type) {
+		case 0: /* line in */
+			temp = (adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & ~CVI_ADC_GSELL_MASK) >> 8;
+			if (temp == 31)
+				vol.vol_ctrl_mute = 1;
+			else
+				vol.vol_ctrl_mute = 0;
+
+			vol.vol_ctrl = 31 - temp;
+			break;
+		case 1: /* MIC in */
+			temp = (adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & ~CVI_ADC_GSELL_MIC_MASK) >> 24;
+			if (temp == 7)
+				vol.vol_ctrl_mute = 1;
+			else
+				vol.vol_ctrl_mute = 0;
+
+			vol.vol_ctrl = 7 - temp;
+			break;
+		}
+
+		if (copy_to_user(argp, &vol, sizeof(vol)))
+			pr_err("failed to return ADCL vol\n");
+
+		break;
+	case ACODEC_GET_ADCR_VOL:
+		pr_debug("adc: ACODEC_GET_ADCR_VOL\n");
+
+		input_type = (adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG) & CVI_ADC_INSELR_MIC);
+
+		switch (input_type) {
+		case 0: /* line in */
+			temp = (adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & ~CVI_ADC_GSELR_MASK) >> 0;
+			if (temp == 31)
+				vol.vol_ctrl_mute = 1;
+			else
+				vol.vol_ctrl_mute = 0;
+
+			vol.vol_ctrl = 31 - temp;
+			break;
+		case 1: /* MIC in */
+			temp = (adc_read_reg(adc->adc_base, CVI_ADC_GSEL_REG) & ~CVI_ADC_GSELR_MIC_MASK) >> 16;
+			if (temp == 7)
+				vol.vol_ctrl_mute = 1;
+			else
+				vol.vol_ctrl_mute = 0;
+
+			vol.vol_ctrl = 7 - temp;
+			break;
+		}
+
+		if (copy_to_user(argp, &vol, sizeof(vol)))
+			pr_err("failed to return ADCR vol\n");
+
+		break;
+	case ACODEC_SET_PD_ADCL:
+		pr_debug("adc: ACODEC_SET_PD_ADCL, val=%d\n", val);
+		if (val == 0) {
+			temp = adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG);
+			temp |= CVI_ADC_ENADL_NORMAL;
+			adc_write_reg(adc->adc_base, CVI_ADC_CTRL_REG, temp);
+		} else {
+			temp = adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG);
+			temp &= CVI_ADC_ENADL_POWER_DOWN;
+			adc_write_reg(adc->adc_base, CVI_ADC_CTRL_REG, temp);
+		}
+		break;
+	case ACODEC_SET_PD_ADCR:
+		pr_debug("adc: ACODEC_SET_PD_ADCR, val=%d\n", val);
+		if (val == 0) {
+			temp = adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG);
+			temp |= CVI_ADC_ENADR_NORMAL;
+			adc_write_reg(adc->adc_base, CVI_ADC_CTRL_REG, temp);
+		} else {
+			temp = adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG);
+			temp &= CVI_ADC_ENADR_POWER_DOWN;
+			adc_write_reg(adc->adc_base, CVI_ADC_CTRL_REG, temp);
+		}
+		break;
+	case ACODEC_SET_PD_LINEINL:
+		pr_debug("adc: ACODEC_SET_PD_LINEINL, val=%d\n", val);
+		if (val == 0) {
+			temp = adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG);
+			temp |= CVI_ADC_ENADL_NORMAL;
+			adc_write_reg(adc->adc_base, CVI_ADC_CTRL_REG, temp);
+		} else {
+			temp = adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG);
+			temp &= CVI_ADC_ENADL_POWER_DOWN;
+			adc_write_reg(adc->adc_base, CVI_ADC_CTRL_REG, temp);
+		}
+		break;
+	case ACODEC_SET_PD_LINEINR:
+		pr_debug("adc: ACODEC_SET_PD_LINEINR, val=%d\n", val);
+		if (val == 0) {
+			temp = adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG);
+			temp |= CVI_ADC_ENADR_NORMAL;
+			adc_write_reg(adc->adc_base, CVI_ADC_CTRL_REG, temp);
+		} else {
+			temp = adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG);
+			temp &= CVI_ADC_ENADR_POWER_DOWN;
+			adc_write_reg(adc->adc_base, CVI_ADC_CTRL_REG, temp);
+		}
+		break;
+	case ACODEC_SET_ADC_HP_FILTER:
+		pr_debug("adc: ACODEC_SET_ADC_HP_FILTER\n");
+		switch (val) {
+		case 0:
+			temp = adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG);
+			temp &= CVI_ADC_HPR_BYPASS & CVI_ADC_HPL_BYPASS;
+			adc_write_reg(adc->adc_base, CVI_ADC_CTRL_REG, temp);
+			break;
+		case 1:
+			temp = adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG);
+			temp |= CVI_ADC_HPR_ENABLE | CVI_ADC_HPL_ENABLE;
+			adc_write_reg(adc->adc_base, CVI_ADC_CTRL_REG, temp);
+			break;
+		default:
+			pr_info("Not support this val %d\n", val);
+			break;
+		}
+		break;
+	default:
+		pr_info("%s, received unsupport cmd=%u\n", __func__, cmd);
+		break;
+	}
+
+	if (mutex_is_locked(&adc_mutex))
+		mutex_unlock(&adc_mutex);
+
+	return 0;
+}
+static const struct snd_soc_dai_ops cv1835adc_dai_ops = {
+	.hw_params	= cv1835adc_hw_params,
+	.set_fmt	= cv1835adc_set_dai_fmt,
+	.startup	= cv1835adc_startup,
+	.shutdown	= cv1835adc_shutdown,
+	.trigger	= cv1835adc_trigger,
+};
+
+static struct snd_soc_dai_driver cv1835adc_dai = {
+	.name		= "cv1835adc",
+	.capture	= {
+		.stream_name	= "Capture",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.ops		= &cv1835adc_dai_ops,
+};
+
+static const char *const cv1835adc_input_text[] = {
+	"LineIn",
+	"MicIn",
+};
+
+static SOC_ENUM_SINGLE_DECL(cv1835adc_l_input_enum,
+			    CVI_ADC_CTRL_REG, 1, cv1835adc_input_text);
+
+static SOC_ENUM_SINGLE_DECL(cv1835adc_r_input_enum,
+			    CVI_ADC_CTRL_REG, 0, cv1835adc_input_text);
+
+static const struct snd_kcontrol_new cv1835adc_controls[] = {
+	SOC_DOUBLE("ADC Capture Line Volume", CVI_ADC_GSEL_REG, 0, 8, 31, 1),
+	SOC_DOUBLE("ADC Capture Mic Volume", CVI_ADC_GSEL_REG, 16, 24, 7, 1),
+	SOC_ENUM("ADC Capture L-Path", cv1835adc_l_input_enum),
+	SOC_ENUM("ADC Capture R-Path", cv1835adc_r_input_enum),
+	SOC_DOUBLE("ADC Capture High-Pass Filter", CVI_ADC_CTRL_REG, 7, 6, 1, 0),
+	SOC_SINGLE("ADC Capture DAGC", CVI_ADC_DAGC_CTRL_REG, 0, 1, 0),
+};
+
+unsigned int cv1835adc_reg_read(struct snd_soc_component *codec, unsigned int reg)
+{
+	int ret;
+	struct cvi1835adc *adc = dev_get_drvdata(codec->dev);
+
+	ret = adc_read_reg(adc->adc_base, reg);
+	dev_dbg(adc->dev, "%s reg:%d,ret:%#x.\n", __func__, reg, ret);
+
+	return ret;
+}
+
+int cv1835adc_reg_write(struct snd_soc_component *codec, unsigned int reg, unsigned int value)
+{
+	struct cvi1835adc *adc = dev_get_drvdata(codec->dev);
+
+	adc_write_reg(adc->adc_base, reg, value);
+
+	dev_dbg(adc->dev, "%s reg:%d,value:%#x.\n", __func__, reg, value);
+
+	return 0;
+}
+
+static const struct snd_soc_component_driver soc_component_dev_cv1835adc = {
+	.controls = cv1835adc_controls,
+	.num_controls = ARRAY_SIZE(cv1835adc_controls),
+	.read = cv1835adc_reg_read,
+	.write = cv1835adc_reg_write,
+};
+
+static const struct file_operations adc_fops = {
+	.owner = THIS_MODULE,
+	.open = adc_open,
+	.release = adc_close,
+	.unlocked_ioctl = adc_ioctl,
+	.compat_ioctl = adc_ioctl,
+};
+
+static int adc_device_register(struct cvi1835adc *adc)
+{
+	struct miscdevice *miscdev = &adc->miscdev;
+	int ret;
+
+	miscdev->minor = MISC_DYNAMIC_MINOR;
+	miscdev->name = "cv1835adc";
+	miscdev->fops = &adc_fops;
+	miscdev->parent = NULL;
+
+	ret = misc_register(miscdev);
+	if (ret) {
+		pr_err("adc: failed to register misc device.\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int cv1835adc_probe(struct platform_device *pdev)
+{
+	struct cvi1835adc *adc;
+	struct resource *res;
+	int ret, val;
+
+	dev_dbg(&pdev->dev, "%s\n", __func__);
+
+	adc = devm_kzalloc(&pdev->dev, sizeof(*adc), GFP_KERNEL);
+	if (!adc)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	adc->adc_base = devm_ioremap_resource(&pdev->dev, res);
+	dev_dbg(&pdev->dev, "%s get adc_base=0x%p\n", __func__, adc->adc_base);
+	if (IS_ERR(adc->adc_base))
+		return PTR_ERR(adc->adc_base);
+
+	dev_set_drvdata(&pdev->dev, adc);
+	adc->dev = &pdev->dev;
+
+	ret = adc_device_register(adc);
+	if (ret < 0) {
+		pr_err("adc: register device error\n");
+		return ret;
+	}
+
+	/* set default input is MIC in*/
+	val = adc_read_reg(adc->adc_base, CVI_ADC_CTRL_REG) | CVI_ADC_INSELL_MIC | CVI_ADC_INSELR_MIC;
+
+	val |= CVI_ADC_ZCD_ENABLE;
+
+	/* disable high pass to avoid pop noise while turn on ADC*/
+	//val &= CVI_ADC_HPL_BYPASS & CVI_ADC_HPR_BYPASS;
+
+	adc_write_reg(adc->adc_base, CVI_ADC_CTRL_REG, val);
+
+	/* set default MIC gain to 21 dB and LINE in gain to -1 dB*/
+	adc_write_reg(adc->adc_base, CVI_ADC_GSEL_REG, 0x03030606);
+
+	/* enable AGC */
+	val = adc_read_reg(adc->adc_base, CVI_ADC_DAGC_CTRL_REG) | CVI_ADC_DAGC_ENABLE;
+	adc_write_reg(adc->adc_base, CVI_ADC_DAGC_CTRL_REG, val);
+
+	adc_write_reg(adc->adc_base, CVI_ADC_TEST_MODE_REG, CVI_ADC_TM_NORMAL);
+
+	return devm_snd_soc_register_component(&pdev->dev, &soc_component_dev_cv1835adc,
+					       &cv1835adc_dai, 1);
+}
+
+static int cv1835adc_remove(struct platform_device *pdev)
+{
+	dev_dbg(&pdev->dev, "%s\n", __func__);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id cvitek_adc_of_match[] = {
+	{ .compatible = "cvitek,cv1835adc", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, cvitek_adc_of_match);
+#endif
+
+static struct platform_driver cv1835adc_platform_driver = {
+	.probe		= cv1835adc_probe,
+	.remove		= cv1835adc_remove,
+	.driver		= {
+		.name	= "cv1835adc",
+		.of_match_table = of_match_ptr(cvitek_adc_of_match),
+	},
+};
+module_platform_driver(cv1835adc_platform_driver);
+
+MODULE_DESCRIPTION("ASoC CVITEK CV1835PDM driver");
+MODULE_AUTHOR("Ethan Chen <ethan.chen@wisecore.com.tw>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:cv1835adc");
diff --git a/sound/soc/cvitek/cv1835dac.c b/sound/soc/cvitek/cv1835dac.c
new file mode 100644
index 000000000000..c1f390859f42
--- /dev/null
+++ b/sound/soc/cvitek/cv1835dac.c
@@ -0,0 +1,608 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * CVITEK CV1835 ADC driver
+ *
+ * Copyright 2020 CVITEK Inc.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/pm.h>
+#include <linux/mutex.h>
+#include <linux/miscdevice.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/control.h>
+#include "cv1835_ioctl.h"
+#include "../codecs/cv1835dac.h"
+
+static DEFINE_MUTEX(dac_mutex);
+
+static inline void dac_write_reg(void __iomem *io_base, int reg, u32 val)
+{
+	writel(val, io_base + reg);
+}
+
+static inline u32 dac_read_reg(void __iomem *io_base, int reg)
+{
+	return readl(io_base + reg);
+}
+
+bool cv1835dac_is_mute(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *dai = NULL;
+	struct cvi1835dac *dac = NULL;
+	u32 temp, vol, mute;
+
+	if (rtd == NULL)
+		return false;
+
+	dai = rtd->codec_dai;
+	dac = snd_soc_dai_get_drvdata(dai);
+
+	if (dac == NULL || dai == NULL)
+		return false;
+
+	temp = dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG);//
+	vol = (temp & ~CVI_DAC_S_MASK) >> 12;
+	vol = 15 - vol;
+	mute  = (CVI_DAC_DEMUTE_MODE == (temp & CVI_DAC_DEMUTE_MODE)) ? 0 : 1;
+	if (mute || !vol)
+		return true;
+
+	return false;
+}
+
+static int dac_open(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&dac_mutex))
+		return -EINTR;
+	mutex_unlock(&dac_mutex);
+	pr_debug("%s\n", __func__);
+	return 0;
+}
+
+static int dac_close(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&dac_mutex))
+		return -EINTR;
+	mutex_unlock(&dac_mutex);
+	pr_debug("%s\n", __func__);
+	return 0;
+}
+
+
+static int cv1835dac_set_dai_fmt(struct snd_soc_dai *dai,
+				 unsigned int fmt)
+{
+
+	struct cvi1835dac *dac = snd_soc_dai_get_drvdata(dai);
+
+	if (!dac->dev)
+		dev_err(dac->dev, "dev is NULL\n");
+
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		dev_err(dac->dev, "Cannot set ADC to MASTER mode\n");
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		dev_dbg(dac->dev, "Set DAC to SLAVE mode\n");
+		break;
+	default:
+		dev_err(dac->dev, "Cannot support this role mode\n");
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		dev_dbg(dac->dev, "set codec to NB_NF\n");
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		dev_dbg(dac->dev, "set codec to IB_NF\n");
+		break;
+	default:
+		dev_err(dac->dev, "Cannot support this format\n");
+		break;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		dev_dbg(dac->dev, "set codec to I2S mode\n");
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		dev_dbg(dac->dev, "set codec to LEFT-JUSTIFY mode\n");
+		break;
+	default:
+		dev_err(dac->dev, "Cannot support this mode\n");
+		break;
+	}
+	return 0;
+}
+
+static int cv1835dac_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *params,
+			       struct snd_soc_dai *dai)
+{
+
+	struct cvi1835dac *dac = snd_soc_dai_get_drvdata(dai);
+	int rate;
+
+	rate = params_rate(params);
+	if (rate >= 8000 && rate <= 192000) {
+		dev_dbg(dac->dev, "%s, set rate to %d\n", __func__, rate);
+
+		switch (rate) {
+		case 8000:
+		case 11025:
+		case 16000:
+		case 22050:
+			dac_write_reg(dac->dac_base, CVI_DAC_FS_REG, CVI_DAC_FS_16_32);
+			break;
+		case 32000:
+		case 44100:
+		case 48000:
+			dac_write_reg(dac->dac_base, CVI_DAC_FS_REG, CVI_DAC_FS_32_64);
+			break;
+		case 96000:
+			dac_write_reg(dac->dac_base, CVI_DAC_FS_REG, CVI_DAC_FS_64_128);
+			break;
+		case 192000:
+			dac_write_reg(dac->dac_base, CVI_DAC_FS_REG, CVI_DAC_FS_128_192);
+			break;
+		default:
+			dac_write_reg(dac->dac_base, CVI_DAC_FS_REG, CVI_DAC_FS_16_32);
+			dev_dbg(dac->dev, "%s, set sample rate with default 16KHz\n", __func__);
+			break;
+		}
+	} else {
+		dac_write_reg(dac->dac_base, CVI_DAC_FS_REG, CVI_DAC_FS_16_32);
+		dev_err(dac->dev, "Rate: %d is not supported\n", rate);
+		dev_err(dac->dev, "%s, set sample rate with default 16KHz\n", __func__);
+		return 0;
+	}
+
+	return 0;
+}
+
+static int cv1835dac_startup(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static void cv1835dac_on(struct cvi1835dac *dac)
+{
+	u32 val = dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG);
+
+	dev_dbg(dac->dev, "%s, before ctrl_reg val=0x%08x\n", __func__, dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG));
+	if (!((val & CVI_DAC_PWDAR_DOWN) && (val & CVI_DAC_PWDAL_DOWN)))
+		dev_info(dac->dev, "DAL or DAR already switched ON!!, val=0x%08x\n", val);
+
+	val &= CVI_DAC_PWDAL_NORMAL & CVI_DAC_PWDAR_NORMAL;
+	val |= CVI_DAC_EN_REF_ENABLE;
+	dac_write_reg(dac->dac_base, CVI_DAC_CTRL_REG, val);
+	msleep(500); /* In order to avoid pop noise */
+	dev_dbg(dac->dev, "%s, after ctrl_reg val=0x%08x\n", __func__, dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG));
+}
+
+static void cv1835dac_off(struct cvi1835dac *dac)
+{
+	u32 val = dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG);
+
+	dev_dbg(dac->dev, "%s, before ctrl_reg val=0x%08x\n", __func__, dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG));
+	val |= CVI_DAC_PWDAR_DOWN | CVI_DAC_PWDAL_DOWN;
+	//val &= CVI_DAC_EN_REF_DISABLE;
+
+	dac_write_reg(dac->dac_base, CVI_DAC_CTRL_REG, val);
+	dev_dbg(dac->dev, "%s, after ctrl_reg val=0x%08x\n", __func__, dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG));
+}
+
+static void cv1835dac_shutdown(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct cvi1835dac *dac = snd_soc_dai_get_drvdata(dai);
+
+	dev_dbg(dac->dev, "%s\n", __func__);
+}
+
+static int cv1835dac_trigger(struct snd_pcm_substream *substream,
+			     int cmd, struct snd_soc_dai *dai)
+{
+	struct cvi1835dac *dac = snd_soc_dai_get_drvdata(dai);
+	int ret = 0;
+
+	dev_dbg(dac->dev, "%s, cmd=%d\n", __func__, cmd);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		snd_pcm_stream_unlock_irq(substream);
+		cv1835dac_on(dac);
+		snd_pcm_stream_lock_irq(substream);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		snd_pcm_stream_unlock_irq(substream);
+		cv1835dac_off(dac);
+		snd_pcm_stream_lock_irq(substream);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static struct cvi1835dac *file_dac_dev(struct file *file)
+{
+	return container_of(file->private_data, struct cvi1835dac, miscdev);
+}
+
+static long dac_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	unsigned int __user *argp = (unsigned int __user *)arg;
+	struct cvi1835dac *dac = file_dac_dev(file);
+	struct cvi_vol_ctrl vol;
+	u32 val;
+	u32 temp;
+
+	if (argp != NULL) {
+		if (!copy_from_user(&val, argp, sizeof(val))) {
+			if (mutex_lock_interruptible(&dac_mutex)) {
+				pr_debug("cv1835dac: signal arrives while waiting for lock\n");
+				return -EINTR;
+			}
+		} else
+			return -EFAULT;
+	}
+
+	switch (cmd) {
+	case ACODEC_SOFT_RESET_CTRL:
+		pr_debug("dac: reset\n");
+		break;
+	case ACODEC_SET_OUTPUT_VOL:
+		pr_debug("dac: ACODEC_SET_OUTPUT_VOL with val=%d\n", val);
+
+		if ((val < 0) | (val > 15))
+			pr_err("Only support range 15 [0dB] ~ 0 [mute]\n");
+		else {
+			val = 15 - val;
+			temp = dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG) & CVI_DAC_S_MASK;
+			temp |= CVI_DAC_S(val);
+			dac_write_reg(dac->dac_base, CVI_DAC_CTRL_REG, temp);
+		}
+		break;
+	case ACODEC_GET_OUTPUT_VOL:
+		pr_debug("dac: ACODEC_GET_OUTPUT_VOL\n");
+		temp = (dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG) & ~CVI_DAC_S_MASK) >> 12;
+		temp = 15 - temp;
+		pr_debug("dac: return val=%d\n", temp);
+		if (copy_to_user(argp, &temp, sizeof(temp)))
+			pr_err("dac, failed to return output vol\n");
+		break;
+	case ACODEC_SET_I2S1_FS:
+		pr_debug("dac: ACODEC_SET_I2S1_FS with val=%d\n", val);
+		switch (val) {
+		case ACODEC_FS_8000:
+		case ACODEC_FS_16000:
+			dac_write_reg(dac->dac_base, CVI_DAC_FS_REG, CVI_DAC_FS_16_32);
+			break;
+		case ACODEC_FS_32000:
+		case ACODEC_FS_48000:
+			dac_write_reg(dac->dac_base, CVI_DAC_FS_REG, CVI_DAC_FS_32_64);
+			break;
+		case ACODEC_FS_96000:
+			dac_write_reg(dac->dac_base, CVI_DAC_FS_REG, CVI_DAC_FS_64_128);
+			break;
+		case ACODEC_FS_192000:
+			dac_write_reg(dac->dac_base, CVI_DAC_FS_REG, CVI_DAC_FS_128_192);
+			break;
+		default:
+			dac_write_reg(dac->dac_base, CVI_DAC_FS_REG, CVI_DAC_FS_16_32);
+			dev_dbg(dac->dev, "%s, set sample rate with default 16KHz\n", __func__);
+			break;
+		}
+		break;
+	case ACODEC_SET_DACL_VOL:
+		pr_debug("dac: ACODEC_SET_DACL_VOL\n");
+		if (copy_from_user(&vol, argp, sizeof(vol))) {
+			if (mutex_is_locked(&dac_mutex))
+				mutex_unlock(&dac_mutex);
+
+			return -EFAULT;
+		}
+		if (vol.vol_ctrl_mute == 1) {
+			temp = dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG);
+			temp &= CVI_DAC_MUTE_MODE;
+			dac_write_reg(dac->dac_base, CVI_DAC_CTRL_REG, temp);
+		} else if ((vol.vol_ctrl < 0) | (vol.vol_ctrl > 15))
+			pr_err("dac-L: Only support range 15 [0dB] ~ 0 [-22.5dB]\n");
+		else {
+			vol.vol_ctrl = 15 - vol.vol_ctrl;
+			temp = dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG) & CVI_DAC_S_MASK;
+			temp |= CVI_DAC_S(vol.vol_ctrl);
+			dac_write_reg(dac->dac_base, CVI_DAC_CTRL_REG, temp);
+		}
+		break;
+	case ACODEC_SET_DACR_VOL:
+		pr_debug("dac: ACODEC_SET_DACR_VOL\n");
+		if (copy_from_user(&vol, argp, sizeof(vol)))
+			return -EFAULT;
+
+		if (vol.vol_ctrl_mute == 1) {
+			temp = dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG);
+			temp &= CVI_DAC_MUTE_MODE;
+			dac_write_reg(dac->dac_base, CVI_DAC_CTRL_REG, temp);
+		} else if ((vol.vol_ctrl < 0) | (vol.vol_ctrl > 15))
+			pr_err("dac-L: Only support range 15 [0dB] ~ 0 [-22.5dB]\n");
+		else {
+			vol.vol_ctrl = 15 - vol.vol_ctrl;
+			temp = dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG) & CVI_DAC_S_MASK;
+			temp |= CVI_DAC_S(vol.vol_ctrl);
+			dac_write_reg(dac->dac_base, CVI_DAC_CTRL_REG, temp);
+		}
+		break;
+	case ACODEC_SET_DACL_MUTE:
+		pr_debug("dac: ACODEC_SET_DACL_MUTE, val=%d\n", val);
+		temp = dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG);
+		if (val == 0)
+			temp |= CVI_DAC_DEMUTE_MODE;
+		else
+			temp &= CVI_DAC_MUTE_MODE;
+		dac_write_reg(dac->dac_base, CVI_DAC_CTRL_REG, temp);
+		break;
+	case ACODEC_SET_DACR_MUTE:
+		pr_debug("dac: ACODEC_SET_DACR_MUTE, val=%d\n", val);
+		temp = dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG);
+		if (val == 0)
+			temp |= CVI_DAC_DEMUTE_MODE;
+		else
+			temp &= CVI_DAC_MUTE_MODE;
+		dac_write_reg(dac->dac_base, CVI_DAC_CTRL_REG, temp);
+		break;
+	case ACODEC_GET_DACL_VOL:
+		pr_debug("dac: ACODEC_GET_DACL_VOL\n");
+		temp = dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG);
+		if (!(temp & CVI_DAC_DEMUTE_MODE)) {
+			vol.vol_ctrl = 0;
+			vol.vol_ctrl_mute = 1;
+		} else {
+			temp = (dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG) & ~CVI_DAC_S_MASK) >> 12;
+			temp = 15 - temp;
+			vol.vol_ctrl = temp;
+			vol.vol_ctrl_mute = 0;
+		}
+		if (copy_to_user(argp, &vol, sizeof(vol)))
+			pr_err("failed to return DACL vol\n");
+		break;
+	case ACODEC_GET_DACR_VOL:
+		pr_debug("dac: ACODEC_GET_DACR_VOL\n");
+		temp = dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG);
+		if (!(temp & CVI_DAC_DEMUTE_MODE)) {
+			vol.vol_ctrl = 0;
+			vol.vol_ctrl_mute = 1;
+		} else {
+			temp = (dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG) & ~CVI_DAC_S_MASK) >> 12;
+			temp = 15 - temp;
+			vol.vol_ctrl = temp;
+			vol.vol_ctrl_mute = 0;
+		}
+		if (copy_to_user(argp, &vol, sizeof(vol)))
+			pr_err("failed to return DACR vol\n");
+		break;
+	case ACODEC_SET_PD_DACL:
+		pr_debug("dac: ACODEC_SET_PD_DACL, val=%d\n", val);
+		if (val == 0) {
+			temp = dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG);
+			temp &= CVI_DAC_PWDAL_NORMAL;
+			dac_write_reg(dac->dac_base, CVI_DAC_CTRL_REG, temp);
+		} else {
+			temp = dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG);
+			temp |= CVI_DAC_PWDAL_DOWN;
+			dac_write_reg(dac->dac_base, CVI_DAC_CTRL_REG, temp);
+		}
+		break;
+	case ACODEC_SET_PD_DACR:
+		pr_debug("dac: ACODEC_SET_PD_DACR, val=%d\n", val);
+		if (val == 0) {
+			temp = dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG);
+			temp &= CVI_DAC_PWDAR_NORMAL;
+			dac_write_reg(dac->dac_base, CVI_DAC_CTRL_REG, temp);
+		} else {
+			temp = dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG);
+			temp |= CVI_DAC_PWDAR_DOWN;
+			dac_write_reg(dac->dac_base, CVI_DAC_CTRL_REG, temp);
+		}
+		break;
+	case ACODEC_SET_DAC_DE_EMPHASIS:
+		pr_debug("dac: ACODEC_SET_DAC_DE_EMPHASIS, val=%d\n", val);
+		if (val == 1) {
+			temp = dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG);
+			temp &= CVI_DAC_DEN_ENABLE;
+			dac_write_reg(dac->dac_base, CVI_DAC_CTRL_REG, temp);
+		} else {
+			temp = dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG);
+			temp |= CVI_DAC_DEN_DISABLE;
+			dac_write_reg(dac->dac_base, CVI_DAC_CTRL_REG, temp);
+		}
+		break;
+	default:
+		pr_info("%s, received unsupported cmd=%u\n", __func__, cmd);
+		break;
+	}
+
+	if (mutex_is_locked(&dac_mutex))
+		mutex_unlock(&dac_mutex);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops cv1835dac_dai_ops = {
+	.hw_params	= cv1835dac_hw_params,
+	.set_fmt	= cv1835dac_set_dai_fmt,
+	.startup	= cv1835dac_startup,
+	.shutdown	= cv1835dac_shutdown,
+	.trigger	= cv1835dac_trigger,
+};
+
+static struct snd_soc_dai_driver cv1835dac_dai = {
+	.name		= "cv1835dac",
+	.playback	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = SNDRV_PCM_FMTBIT_S32_LE
+		| SNDRV_PCM_FMTBIT_S24_LE
+		| SNDRV_PCM_FMTBIT_S24_3LE
+		| SNDRV_PCM_FMTBIT_U24_LE
+		| SNDRV_PCM_FMTBIT_U24_3LE
+		| SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.ops		= &cv1835dac_dai_ops,
+};
+
+static const struct snd_kcontrol_new cv1835dac_controls[] = {
+	SOC_SINGLE_RANGE("DAC Playback Volume", CVI_DAC_CTRL_REG, 12, 0, 15, 1),
+	SOC_DOUBLE("DAC Playback MUTE", CVI_DAC_CTRL_REG, 8, 8, 3, 0),
+	SOC_DOUBLE("DAC Playback Power Up/Down", CVI_DAC_CTRL_REG, 1, 0, 1, 1),
+	SOC_SINGLE("DAC Playback De-emphasis", CVI_DAC_CTRL_REG, 3, 1, 1),
+};
+
+unsigned int cv1835dac_reg_read(struct snd_soc_component *codec, unsigned int reg)
+{
+	int ret;
+	struct cvi1835dac *dac = dev_get_drvdata(codec->dev);
+
+	ret = dac_read_reg(dac->dac_base, reg);
+	dev_dbg(dac->dev, "%s reg:%d,ret:%#x.\n", __func__, reg, ret);
+
+	return ret;
+}
+
+int cv1835dac_reg_write(struct snd_soc_component *codec, unsigned int reg, unsigned int value)
+{
+	struct cvi1835dac *dac = dev_get_drvdata(codec->dev);
+
+	dac_write_reg(dac->dac_base, reg, value);
+
+	dev_dbg(dac->dev, "%s reg:%d,value:%#x.\n", __func__, reg, value);
+
+	return 0;
+}
+
+static const struct snd_soc_component_driver soc_component_dev_cv1835dac = {
+	.controls = cv1835dac_controls,
+	.num_controls = ARRAY_SIZE(cv1835dac_controls),
+	.read = cv1835dac_reg_read,
+	.write = cv1835dac_reg_write,
+};
+
+static const struct file_operations dac_fops = {
+	.owner = THIS_MODULE,
+	.open = dac_open,
+	.release = dac_close,
+	.unlocked_ioctl = dac_ioctl,
+	.compat_ioctl = dac_ioctl,
+};
+
+static int dac_device_register(struct cvi1835dac *dac)
+{
+	struct miscdevice *miscdev = &dac->miscdev;
+	int ret;
+
+	miscdev->minor = MISC_DYNAMIC_MINOR;
+	miscdev->name = "cv1835dac";
+	miscdev->fops = &dac_fops;
+	miscdev->parent = NULL;
+
+	ret = misc_register(miscdev);
+	if (ret) {
+		pr_err("dac: failed to register misc device.\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int cv1835dac_probe(struct platform_device *pdev)
+{
+	struct cvi1835dac *dac;
+	struct resource *res;
+	int ret, val;
+
+	dev_dbg(&pdev->dev, "%s\n", __func__);
+
+	dac = devm_kzalloc(&pdev->dev, sizeof(*dac), GFP_KERNEL);
+	if (!dac)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dac->dac_base = devm_ioremap_resource(&pdev->dev, res);
+	dev_dbg(&pdev->dev, "%s get dac_base=0x%p\n", __func__, dac->dac_base);
+	if (IS_ERR(dac->dac_base))
+		return PTR_ERR(dac->dac_base);
+
+	dev_set_drvdata(&pdev->dev, dac);
+	dac->dev = &pdev->dev;
+
+	ret = dac_device_register(dac);
+	if (ret < 0) {
+		pr_err("dac: register device error\n");
+		return ret;
+	}
+
+	val = dac_read_reg(dac->dac_base, CVI_DAC_CTRL_REG);
+	val |= CVI_DAC_PWDAR_DOWN | CVI_DAC_PWDAL_DOWN | CVI_DAC_DEMUTE_MODE;
+	val &= CVI_DAC_EN_REF_DISABLE;
+
+	dac_write_reg(dac->dac_base, CVI_DAC_CTRL_REG, val);
+
+	dac_write_reg(dac->dac_base, CVI_DAC_AIO_DA_REG, CVI_DAV_AIO_2CH);
+
+	dac_write_reg(dac->dac_base, CVI_DAC_TEST_MODE_REG, CVI_DAC_TM_NORMAL);
+
+	return devm_snd_soc_register_component(&pdev->dev, &soc_component_dev_cv1835dac,
+					       &cv1835dac_dai, 1);
+}
+
+static int cv1835dac_remove(struct platform_device *pdev)
+{
+	dev_dbg(&pdev->dev, "%s\n", __func__);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id cvitek_dac_of_match[] = {
+	{ .compatible = "cvitek,cv1835dac", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, cvitek_dac_of_match);
+#endif
+
+static struct platform_driver cv1835dac_platform_driver = {
+	.probe		= cv1835dac_probe,
+	.remove		= cv1835dac_remove,
+	.driver		= {
+		.name	= "cv1835dac",
+		.of_match_table = of_match_ptr(cvitek_dac_of_match),
+	},
+};
+module_platform_driver(cv1835dac_platform_driver);
+
+MODULE_DESCRIPTION("ASoC CVITEK CV1835PDM driver");
+MODULE_AUTHOR("Ethan Chen <ethan.chen@wisecore.com.tw>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:cv1835dac");
diff --git a/sound/soc/cvitek/cv1835pdm.c b/sound/soc/cvitek/cv1835pdm.c
new file mode 100644
index 000000000000..3f7a55438d41
--- /dev/null
+++ b/sound/soc/cvitek/cv1835pdm.c
@@ -0,0 +1,267 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * CVITEK CV1835 PDM driver
+ *
+ * Copyright 2020 CVITEK Inc.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/pm.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include "cv1835pdm.h"
+
+static inline void pdm_write_reg(void __iomem *io_base, int reg, u32 val)
+{
+	writel(val, io_base + reg);
+}
+
+static inline u32 pdm_read_reg(void __iomem *io_base, int reg)
+{
+	return readl(io_base + reg);
+}
+
+static int cv1835pdm_set_dai_fmt(struct snd_soc_dai *dai,
+				 unsigned int fmt)
+{
+
+	struct cvi1835pdm *pdm = snd_soc_dai_get_drvdata(dai);
+
+	if (!pdm->dev)
+		dev_err(pdm->dev, "dev is NULL\n");
+
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		dev_dbg(pdm->dev, "set PDM to MASTER mode\n");
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		dev_err(pdm->dev, "Cannot set PDM to SLAVE mode\n");
+		return -EINVAL;
+	default:
+		dev_err(pdm->dev, "Cannot support this role mode\n");
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_IB_NF:
+		dev_dbg(pdm->dev, "set codec to IB_NF\n");
+		break;
+	default:
+		dev_err(pdm->dev, "Cannot suuport this format\n");
+		break;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		dev_dbg(pdm->dev, "set codec to I2S mode\n");
+		break;
+	default:
+		dev_err(pdm->dev, "Cannot support this mode\n");
+		break;
+	}
+	return 0;
+}
+
+static int cv1835pdm_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *params,
+			       struct snd_soc_dai *dai)
+{
+
+	struct cvi1835pdm *pdm = snd_soc_dai_get_drvdata(dai);
+	int pdm_setting = pdm_read_reg(pdm->pdm_base, PDM_SETTING_REG);
+	int i2s_setting = pdm_read_reg(pdm->pdm_base, I2S_SETTING_REG);
+	int rate;
+
+	rate = params_rate(params);
+	if (rate >= 8000 && rate <= 192000) {
+		dev_dbg(pdm->dev, "%s, set rate to %d\n", __func__, rate);
+
+		switch (rate) {
+		case 48000:
+			pdm_write_reg(pdm->pdm_base, PDM_SETTING_REG, (pdm_setting & PDM_CLK_DIV_MASK) | PDM_48K);
+			pdm_write_reg(pdm->pdm_base, I2S_SETTING_REG, (i2s_setting & I2S_CLK_DIV_MASK) | I2S_48K);
+			dev_dbg(pdm->dev, "%s, set sample rate with 48KHz\n", __func__);
+			break;
+		case 44100:
+			pdm_write_reg(pdm->pdm_base, PDM_SETTING_REG, (pdm_setting & PDM_CLK_DIV_MASK) | PDM_44_1K);
+			pdm_write_reg(pdm->pdm_base, I2S_SETTING_REG, (i2s_setting & I2S_CLK_DIV_MASK) | I2S_44_1K);
+			dev_dbg(pdm->dev, "%s, set sample rate with 44.1KHz\n", __func__);
+			break;
+		case 22050:
+			pdm_write_reg(pdm->pdm_base, PDM_SETTING_REG, (pdm_setting & PDM_CLK_DIV_MASK) | PDM_22_05K);
+			pdm_write_reg(pdm->pdm_base, I2S_SETTING_REG, (i2s_setting & I2S_CLK_DIV_MASK) | I2S_22_05K);
+			dev_dbg(pdm->dev, "%s, set sample rate with 22.05KHz\n", __func__);
+			break;
+		case 16000:
+			pdm_write_reg(pdm->pdm_base, PDM_SETTING_REG, (pdm_setting & PDM_CLK_DIV_MASK) | PDM_16K);
+			pdm_write_reg(pdm->pdm_base, I2S_SETTING_REG, (i2s_setting & I2S_CLK_DIV_MASK) | I2S_16K);
+			dev_dbg(pdm->dev, "%s, set sample rate with 16KHz\n", __func__);
+			break;
+		case 11025:
+			pdm_write_reg(pdm->pdm_base, PDM_SETTING_REG, (pdm_setting & PDM_CLK_DIV_MASK) | PDM_11_025K);
+			pdm_write_reg(pdm->pdm_base, I2S_SETTING_REG, (i2s_setting & I2S_CLK_DIV_MASK) | I2S_11_025K);
+			dev_dbg(pdm->dev, "%s, set sample rate with 11.025KHz\n", __func__);
+			break;
+		case 8000:
+			pdm_write_reg(pdm->pdm_base, PDM_SETTING_REG, (pdm_setting & PDM_CLK_DIV_MASK) | PDM_8K);
+			pdm_write_reg(pdm->pdm_base, I2S_SETTING_REG, (i2s_setting & I2S_CLK_DIV_MASK) | I2S_8K);
+			dev_dbg(pdm->dev, "%s, set sample rate with 8KHz\n", __func__);
+			break;
+		default:
+			pdm_write_reg(pdm->pdm_base, PDM_SETTING_REG, (pdm_setting & PDM_CLK_DIV_MASK) | PDM_8K);
+			pdm_write_reg(pdm->pdm_base, I2S_SETTING_REG, (i2s_setting & I2S_CLK_DIV_MASK) | I2S_8K);
+			dev_dbg(pdm->dev, "%s, set sample rate with default 48KHz\n", __func__);
+			break;
+		}
+	} else {
+		dev_err(pdm->dev, "Rate: %d is not supported\n", rate);
+		return -EINVAL;
+	}
+
+	i2s_setting = pdm_read_reg(pdm->pdm_base, I2S_SETTING_REG);
+	switch (params_width(params)) {
+	case 16:
+		pdm_write_reg(pdm->pdm_base, I2S_SETTING_REG,
+			      (i2s_setting & I2S_CHN_WIDTH_MASK) | I2S_CHN_WIDTH(I2S_CHN_WIDTH_16BIT));
+		break;
+	default:
+		dev_err(pdm->dev, "Cannot support this width %d\n", params_width(params));
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int cv1835pdm_startup(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *dai)
+{
+	struct cvi1835pdm *pdm = snd_soc_dai_get_drvdata(dai);
+
+	dev_dbg(pdm->dev, "%s\n", __func__);
+
+	return 0;
+}
+
+static void cv1835pdm_shutdown(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct cvi1835pdm *pdm = snd_soc_dai_get_drvdata(dai);
+
+	dev_dbg(pdm->dev, "%s\n", __func__);
+}
+
+static int cv1835pdm_trigger(struct snd_pcm_substream *substream,
+			     int cmd, struct snd_soc_dai *dai)
+{
+	struct cvi1835pdm *pdm = snd_soc_dai_get_drvdata(dai);
+	int ret = 0;
+
+	dev_dbg(pdm->dev, "%s, cmd=%d\n", __func__, cmd);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		pdm_write_reg(pdm->pdm_base, PDM_EN_REG, PDM_EN);
+		//i2s_start(dev, substream);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		pdm_write_reg(pdm->pdm_base, PDM_EN_REG, PDM_OFF);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static const struct snd_soc_dai_ops cv1835pdm_dai_ops = {
+	.hw_params	= cv1835pdm_hw_params,
+	.set_fmt	= cv1835pdm_set_dai_fmt,
+	.startup	= cv1835pdm_startup,
+	.shutdown	= cv1835pdm_shutdown,
+	.trigger	= cv1835pdm_trigger,
+};
+
+static struct snd_soc_dai_driver cv1835pdm_dai = {
+	.name		= "cv1835pdm",
+	.capture	= {
+		.stream_name	= "Capture",
+		.channels_min	= 2,
+		.channels_max	= 2,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = SNDRV_PCM_FMTBIT_S32_LE
+		| SNDRV_PCM_FMTBIT_S24_LE
+		| SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.ops		= &cv1835pdm_dai_ops,
+};
+
+static int cv1835pdm_component_probe(struct snd_soc_component *component)
+{
+	pr_info("%s\n", __func__);
+	return 0;
+}
+
+static const struct snd_soc_component_driver soc_component_dev_cv1835pdm = {
+	.probe = cv1835pdm_component_probe,
+};
+
+static int cv1835pdm_probe(struct platform_device *pdev)
+{
+	struct cvi1835pdm *pdm;
+	struct resource *res;
+
+	dev_info(&pdev->dev, "%s\n", __func__);
+
+	pdm = devm_kzalloc(&pdev->dev, sizeof(*pdm), GFP_KERNEL);
+	if (!pdm)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	pdm->pdm_base = devm_ioremap_resource(&pdev->dev, res);
+
+	if (IS_ERR(pdm->pdm_base))
+		return PTR_ERR(pdm->pdm_base);
+
+	dev_set_drvdata(&pdev->dev, pdm);
+	pdm->dev = &pdev->dev;
+
+	return devm_snd_soc_register_component(&pdev->dev, &soc_component_dev_cv1835pdm,
+					       &cv1835pdm_dai, 1);
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id cvitek_pdm_of_match[] = {
+	{ .compatible = "cvitek,cv1835pdm", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, cvitek_pdm_of_match);
+#endif
+
+static struct platform_driver cv1835pdm_platform_driver = {
+	.probe		= cv1835pdm_probe,
+	.driver		= {
+		.name	= "cv1835pdm",
+		.of_match_table = of_match_ptr(cvitek_pdm_of_match),
+	},
+};
+module_platform_driver(cv1835pdm_platform_driver);
+
+MODULE_DESCRIPTION("ASoC CVITEK CV1835PDM driver");
+MODULE_AUTHOR("Ethan Chen <ethan.chen@wisecore.com.tw>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:cv1835pdm");
diff --git a/sound/soc/cvitek/cv1835pdm.h b/sound/soc/cvitek/cv1835pdm.h
new file mode 100644
index 000000000000..81b3ed10a0a5
--- /dev/null
+++ b/sound/soc/cvitek/cv1835pdm.h
@@ -0,0 +1,61 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later
+ * PDM driver on CVITEK CV1835
+ *
+ * Copyright 2018 CVITEK
+ *
+ * Author: EthanChen
+ *
+ */
+
+#ifndef __CV1835PDM_H__
+#define __CV1835PDM_H__
+
+#include <linux/clk.h>
+
+/* register offset */
+#define PDM_EN_REG	        0x30
+#define PDM_EN				0x1
+#define PDM_OFF				0x0
+
+#define PDM_48K						3
+#define PDM_44_1K					3
+#define PDM_22_05K					7
+#define PDM_16K						11
+#define PDM_11_025K					15
+#define PDM_8K						23
+
+#define PDM_SETTING_REG		        0x34
+#define PDM_CLK_DIV_MASK    0xFFFFFFE0
+#define PDM_CLK_DIV(v)      (v << 0)
+#define PDM_CLK_INV         (0x1 << 15)
+#define PDM_DATA_CAP_MASK   0xFFC0FFFF
+#define PDM_DATA_CAP(v)     (v << 16)
+#define PDM_SEL_MASK        0xFEFFFFFF
+#define PDM_BOND_SEL_0      (0 << 24)
+#define PDM_BOND_SEL_1      (1 << 24)
+
+
+#define I2S_48K						7
+#define I2S_44_1K					7
+#define I2S_22_05K					15
+#define I2S_16K						23
+#define I2S_11_025K					31
+#define I2S_8K						47
+#define I2S_SETTING_REG		        0x38
+#define I2S_CLK_DIV_MASK            0xFFFFFF00
+#define I2S_CLK_DIV(v)              (v << 0)
+#define I2S_CHN_WIDTH_MASK          0xFFFFFCFF
+#define I2S_CHN_WIDTH_8BIT          0x0
+#define I2S_CHN_WIDTH_16BIT         0x1
+#define I2S_CHN_WIDTH_24BIT         0x2
+#define I2S_CHN_WIDTH_32BIT         0x3
+#define I2S_CHN_WIDTH(v)            (v << 8)
+
+
+struct cvi1835pdm {
+	void __iomem *pdm_base;
+	struct clk *clk;
+	struct device *dev;
+};
+
+#endif  /* __CV1835PDM_H__ */
diff --git a/sound/soc/cvitek/dummy_codec.c b/sound/soc/cvitek/dummy_codec.c
new file mode 100644
index 000000000000..dced5bf56212
--- /dev/null
+++ b/sound/soc/cvitek/dummy_codec.c
@@ -0,0 +1,153 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Audio Dummy driver on CVITEK CV1835
+ *
+ * Copyright 2021 CVITEK
+ *
+ * Author: RuiLong
+ *
+ */
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gcd.h>
+#include <linux/gpio/consumer.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pm.h>
+#include <linux/slab.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/tlv.h>
+#include <sound/soc.h>
+
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <linux/i2c.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <sound/soc.h>
+
+static bool initFlag;
+struct work_struct work;
+struct workqueue_struct *initWork;
+
+static void initWorkFuc(struct work_struct *work);
+
+static const struct snd_soc_component_driver dummy_component_driver = {
+
+};
+
+
+static int dummy_hw_params(struct snd_pcm_substream *substream,
+			   struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static const struct snd_soc_dai_ops dummy_dai_ops = {
+	.hw_params = dummy_hw_params,
+};
+
+#define DUMMY_FORMATS (SNDRV_PCM_FMTBIT_S16_LE \
+						|	SNDRV_PCM_FMTBIT_S24_LE \
+						|	SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct snd_soc_dai_driver dummy_dai_driver = {
+	.name = "dummy_codec-aif",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 8,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = DUMMY_FORMATS,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 8,
+		.rates = SNDRV_PCM_RATE_8000_192000,
+		.formats = DUMMY_FORMATS,
+	},
+	.ops = &dummy_dai_ops,
+	.symmetric_rates = 1,
+
+};
+
+static int dummy_codec_probe(struct platform_device *pdev)
+{
+	return devm_snd_soc_register_component(&pdev->dev, &dummy_component_driver,
+					       &dummy_dai_driver, 1);
+}
+
+
+static int dummy_codec_remove(struct platform_device *dev)
+{
+	return 0;
+}
+
+static void dummy_codec_release(struct device *dev)
+{
+	return 0;
+}
+
+
+
+static struct platform_driver cvitek_dummy_codec_driver = {
+	.driver = {
+		.name = "dummy_codec",
+	},
+	.probe = dummy_codec_probe,
+	.remove = dummy_codec_remove,
+};
+
+static struct platform_device cvitek_dummy_codec_dev = {
+	.name         = "dummy_codec",
+	.id       = -1,
+	.dev = {
+		.release = dummy_codec_release,
+	},
+};
+
+static void initWorkFuc(struct work_struct *work)
+{
+	char timeout = 0;
+
+	pr_info("dummy_codec %s\n", __func__);
+	if (!initFlag) {
+		platform_device_register(&cvitek_dummy_codec_dev);
+		platform_driver_register(&cvitek_dummy_codec_driver);
+		initFlag = true;
+	}
+}
+
+// register dummy coudec after internal codec register.
+static int dummy_codec_init(void)
+{
+	initFlag = false;
+	initWork = create_workqueue("initWork");
+	INIT_WORK(&work, initWorkFuc);
+	queue_work(initWork, &work);
+	return 0;
+}
+
+static void dummy_codec_exit(void)
+{
+	destroy_workqueue(initWork);
+	if (initFlag) {
+		platform_device_unregister(&cvitek_dummy_codec_dev);
+		platform_driver_unregister(&cvitek_dummy_codec_driver);
+	}
+	initFlag = false;
+}
+
+
+module_init(dummy_codec_init);
+module_exit(dummy_codec_exit);
+
+MODULE_DESCRIPTION("ASoC Dummy CODEC driver");
+MODULE_AUTHOR("RuiLong.Chen <ruilong.chen@cvitek.com>");
+MODULE_LICENSE("GPL v2");
+
diff --git a/sound/soc/cvitek/local.h b/sound/soc/cvitek/local.h
new file mode 100644
index 000000000000..1af206b12b7f
--- /dev/null
+++ b/sound/soc/cvitek/local.h
@@ -0,0 +1,275 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later
+ * I2S driver on CVITEK CV1835
+ *
+ * Copyright 2018 CVITEK
+ *
+ * Author: EthanChen
+ *
+ *
+ */
+
+#ifndef __CVITEK_LOCAL_H__
+#define __CVITEK_LOCAL_H__
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm.h>
+#include <sound/cv1835_i2s.h>
+
+#define I2S_MODE            0x0
+#define LJ_MODE             0x1
+#define RJ_MODE             0x2
+#define PCM_A_MODE          0x3
+#define PCM_B_MODE          0x4
+#define TDM_MODE            0x5
+
+#define I2STDM_FIFO_DEPTH	32 /* 32 items */
+#define I2STDM_FIFO_WIDTH	4 /* 32 bits */
+
+/* common register offset */
+#define BLK_MODE_SETTING	0x00
+#define FRAME_SETTING		0x04
+#define SLOT_SETTING1		0x08
+#define SLOT_SETTING2		0x0C
+#define DATA_FORMAT			0x10
+#define BLK_CFG				0x14
+#define I2S_ENABLE			0x18
+#define I2S_RESET			0x1C
+#define I2S_INT_EN			0x20
+#define I2S_INT				0x24
+#define FIFO_THRESHOLD		0x28
+#define I2S_LRCK_MASTER		0x2C
+#define FIFO_RESET			0x30
+#define RX_STATUS			0x40
+#define TX_STATUS			0x48
+#define DMA_REQ_COUNT		0x50
+#define DMA_ACK_COUNT		0x54
+#define I2S_CLK_CTRL0		0x60
+#define I2S_CLK_CTRL1		0x64
+#define I2S_PCM_SYNTH		0x68
+#define RX_RD_PORT_CH0		0x80
+#define RX_RD_PORT_CH1		0x84
+#define TX_WR_PORT_CH0		0xC0
+#define TX_WR_PORT_CH1		0xC4
+
+/* subsystem register offset */
+#define I2S_TDM_SCLK_IN_SEL	0x000
+#define I2S_TDM_FS_IN_SEL	0x004
+#define I2S_TDM_SDI_IN_SEL	0x008
+#define I2S_TDM_SDO_OUT_SEL	0x00C
+#define I2S_TDM_MULTI_SYNC	0x020
+#define I2S_BCLK_OEN_SEL	0x030
+
+
+/* define value of each configuration of register BLK_MODE_SETTING */
+#define RX_MODE	            (0x0 << 0)
+#define TX_MODE             (0x1 << 0)
+#define SLAVE_MODE	        (0x0 << 1)
+#define MASTER_MODE	        (0x1 << 1)
+#define RX_SAMPLE_EDGE_N    (0x0 << 2) /* Negative edge */
+#define RX_SAMPLE_EDGE_P    (0x1 << 2) /* Positive edge */
+#define TX_SAMPLE_EDGE_N    (0x0 << 3)
+#define TX_SAMPLE_EDGE_P    (0x1 << 3)
+#define FS_SAMPLE_EDGE_N    (0x0 << 4)
+#define FS_SAMPLE_EDGE_P    (0x1 << 4)
+#define FS_SAMPLE_RX_DELAY	(0x1 << 5)
+#define FS_SAMPLE_RX_NO_DELAY	(0x0 << 5)
+#define SW_MODE             (0x0 << 7)
+#define HW_DMA_MODE         (0x1 << 7)
+#define MULTI_I2S_SYNC      (0x1 << 8)
+#define TXRX_MODE_MASK      0x00000001
+#define ROLE_MASK           0x00000002
+#define SAMPLE_EDGE_MASK    0x0000001C
+#define FS_SAMPLE_RX_DELAY_MASK	0x00000020
+#define DMA_MODE_MASK       0x00000080
+#define MULTI_I2S_MODE_MASK 0x00000100
+
+/* define value of each configuration of register FRAME_SETTING */
+#define FS_POLARITY_MASK    0x00001000
+#define FS_OFFSET_MASK      0x00002000
+#define FS_IDEF_MASK        0x00004000
+#define FS_ACT_LENGTH_MASK  0x00FF0000
+#define FRAME_LENGTH_MASK   0x000001FF
+#define FRAME_LENGTH(l)     (((l-1) << 0) & FRAME_LENGTH_MASK) /* frame length between 0~511 = 1~512 bits */
+#define FS_ACT_LOW          (0x0 << 12)
+#define FS_ACT_HIGH         (0x1 << 12)
+#define NO_FS_OFFSET        (0x0 << 13)
+#define FS_OFFSET_1_BIT     (0x1 << 13)
+#define FS_IDEF_FRAME_SYNC	(0x0 << 14) /* frame sync*/
+#define FS_IDEF_CH_SYNC		(0x1 << 14) /* channel sync */
+#define FS_ACT_LENGTH(l)    (((l-1) << 16) & FS_ACT_LENGTH_MASK) /* frame active length between 0~255 = 1~256 bits*/
+
+
+/* define value of each configuration of register SLOT_SETTING1 */
+
+#define SLOT_NUM_MASK       0x0000000F
+#define SLOT_SIZE_MASK      0x00003F00
+#define DATA_SIZE_MASK      0x001F0000
+#define FB_OFFSET_MASK      0x1F000000
+#define SLOT_NUM(l)         (((l-1) << 0) & SLOT_NUM_MASK)
+#define SLOT_SIZE(l)        (((l-1) << 8) & SLOT_SIZE_MASK)
+#define DATA_SIZE(l)        (((l-1) << 16) & DATA_SIZE_MASK)
+#define FB_OFFSET(l)        ((l << 24) & FB_OFFSET_MASK)
+
+/* define value of each configuration of register DATA_FORMAT */
+#define WORD_LENGTH_MASK    (0x3 << 1)
+#define WORD_LEN_8          (0x0 << 1)
+#define WORD_LEN_16         (0x1 << 1)
+#define WORD_LEN_32         (0x2 << 1)
+#define SKIP_RX_INACT_SLOT_MASK (0x1 << 4)
+#define SKIP_RX_INACT_SLOT (0x1 << 4)
+#define SKIP_TX_INACT_SLOT_MASK (0x1 << 5)
+#define SKIP_TX_INACT_SLOT (0x1 << 5)
+
+/* define value of each configuration of register I2S_RESET */
+#define I2S_RESET_RX_PULL_UP 0x00000001
+#define I2S_RESET_RX_PULL_DOWN 0x00000000
+#define I2S_RESET_TX_PULL_UP 0x00000002
+#define I2S_RESET_TX_PULL_DOWN 0x00000000
+
+/* define value of each configuration of register I2S_INT_EN */
+#define I2S_INT_EN_ALL		0x00000077
+
+/* define value of each configuration of register I2S_INT */
+#define I2S_INT_RXDA		(0x1 << 0) /* RX FIFO data available interrupt status */
+#define I2S_INT_RXFO		(0x1 << 1) /* RX FIFO overflow interrupt status */
+#define I2S_INT_RXFU		(0x1 << 2) /* RX FIFO underflow interrupt status */
+#define I2S_INT_TXDA		(0x1 << 4) /* RX FIFO data available interrupt status */
+#define I2S_INT_TXFO		(0x1 << 5) /* RX FIFO overflow interrupt status */
+#define I2S_INT_TXFU		(0x1 << 6) /* RX FIFO underflow interrupt status */
+#define I2S_INT_RXDA_RAW	(0x1 << 8) /* RX FIFO data available interrupt raw status */
+#define I2S_INT_RXFO_RAW	(0x1 << 9) /* RX FIFO overflow interrupt raw status */
+#define I2S_INT_RXFU_RAW	(0x1 << 10) /* RX FIFO underflow interrupt raw status */
+#define I2S_INT_TXDA_RAW	(0x1 << 12) /* RX FIFO data available interrupt raw status */
+#define I2S_INT_TXFO_RAW	(0x1 << 13) /* RX FIFO overflow interrupt raw status */
+#define I2S_INT_TXFU_RAW	(0x1 << 14) /* RX FIFO underflow interrupt raw status */
+
+/* define value of each configuration of register FIFO_THRESHOLD */
+#define RX_FIFO_THRESHOLD_MASK  0x0000001F
+#define TX_FIFO_THRESHOLD_MASK  0x001F0000
+#define TX_FIFO_HIGH_THRESHOLD_MASK  0x1F000000
+#define RX_FIFO_THRESHOLD(v)    ((v << 0) & RX_FIFO_THRESHOLD_MASK)
+#define TX_FIFO_THRESHOLD(v)    ((v << 16) & TX_FIFO_THRESHOLD_MASK)
+#define TX_FIFO_HIGH_THRESHOLD(v)    ((v << 24) & TX_FIFO_HIGH_THRESHOLD_MASK)
+
+/* define value of each configuration of register FIFO_RESET */
+#define RX_FIFO_RESET_PULL_UP 0x00000001
+#define RX_FIFO_RESET_PULL_DOWN 0x00000000
+#define TX_FIFO_RESET_PULL_UP 0x00010000
+#define TX_FIFO_RESET_PULL_DOWN 0x00000000
+
+/* define value of each configuration of register RX_STATUS */
+#define RESET_RX_SCLK           0x00800000
+
+/* define value of each configuration of register TX_STATUS */
+#define RESET_TX_SCLK           0x00800000
+
+/* define value of each configuration of register CLK_CTRL0 */
+#define AUD_CLK_SOURCE_MASK     0x00000001
+#define AUD_SWITCH              0x00000100
+#define AUD_CLK_FROM_PLL        (0x0 << 0)
+#define AUD_CLK_FROM_MCLK_IN    (0x1 << 0)
+#define AUD_DISABLE             (0x0 << 8)
+#define AUD_ENABLE              (0x1 << 8)
+#define MCLK_OUT_EN		(0x1 << 7)
+#define BCLK_OUT_FORCE_EN	(0x1 << 6)
+
+/* define value of each configuration of register CLK_CTRL1 */
+#define MCLK_DIV(l)             ((l << 0) & 0x0000FFFF)
+#define BCLK_DIV(l)             ((l << 16) & 0xFFFF0000)
+
+
+#define FMT_IB_NF    0x0  /* sample at falling edge and sync polarity is active low*/
+#define FMT_IB_IF    0x1
+#define FMT_NB_NF    0x2
+#define FMT_NB_IF    0x3
+
+
+
+
+#define I2S_ON	0x1
+#define I2S_OFF 0x0
+
+/* I2S Tx Control */
+#define I2S_TX_ON	0x1
+#define I2S_TX_OFF	0x0
+
+/* I2S Rx Control */
+#define I2S_RX_ON	0x1
+#define I2S_RX_OFF	0x0
+
+#define WSS_16_CLKCYCLE   0x20
+#define WSS_24_CLKCYCLE   0x30
+#define WSS_32_CLKCYCLE   0x40
+#define WSS_256_CLKCYCLE  0x200
+
+
+
+union cvi_i2s_snd_dma_data {
+	struct i2s_dma_data pd;
+	struct snd_dmaengine_dai_dma_data dt;
+};
+
+#ifdef CONFIG_PM_SLEEP
+struct cvi_i2s_reg_context {
+	u32 blk_setting;
+	u32 frame_setting;
+	u32 slot_setting1;
+	u32 slot_setting2;
+	u32 data_format;
+	u32 blk_cfg;
+	u32 i2s_en;
+	u32 i2s_int_en;
+	u32 fifo_threshold;
+	u32 i2s_lrck_master;
+	u32 i2s_clk_ctl0;
+	u32 i2c_clk_ctl1;
+	u32 i2s_pcm_synth;
+};
+#endif
+
+struct cvi_i2s_dev {
+	void __iomem *i2s_base;
+	struct clk *clk;
+	int active;
+	unsigned int capability;
+	unsigned int quirks;
+	struct device *dev;
+	u32 wss;
+	u32 fifo_th;
+	u32 dev_id;
+	u8 mode;
+	u8 sample_edge;
+	u8 role;
+
+	/* data related to DMA transfers b/w i2s and DMAC */
+	union cvi_i2s_snd_dma_data play_dma_data;
+	union cvi_i2s_snd_dma_data capture_dma_data;
+	struct i2s_clk_config_data config;
+	int (*i2s_clk_cfg)(struct i2s_clk_config_data *config);
+
+	struct snd_pcm_substream __rcu *tx_substream;
+	unsigned int (*tx_fn)(struct cvi_i2s_dev *dev,
+			struct snd_pcm_runtime *runtime, unsigned int tx_ptr,
+			bool *period_elapsed);
+	unsigned int tx_ptr;
+	bool mclk_out;
+#ifdef CONFIG_PM_SLEEP
+	struct cvi_i2s_reg_context *reg_ctx;
+#endif
+};
+
+#if IS_ENABLED(CONFIG_SND_CV1835_PCM)
+void cvi_pcm_push_tx(struct cvi_i2s_dev *dev);
+int cvi_pcm_register(struct platform_device *pdev);
+#else
+void cvi_pcm_push_tx(struct cvi_i2s_dev *dev) { }
+int cvi_pcm_register(struct platform_device *pdev)
+{
+	return -EINVAL;
+}
+#endif
+
+#endif  /* __CVITEK_LOCAL_H__ */
-- 
2.39.2

